Train: 1001
Validation: 203
---
['x']
['x']
[PREMISE]:
All people who regularly drink coffee are dependent on caffeine.
People regularly drink coffee, or they don't want to be addicted to caffeine, or both.
No one who doesn't want to be addicted to caffeine is unaware that caffeine is a drug.
Rina is either a student who is unaware that caffeine is a drug, or she is not a student and is she aware that caffeine is a drug.
Rina  is either a student who is dependent on caffeine, or she is not a student and not dependent on caffeine.

[PREMISE (FOL)]:
∀x (DrinkRegularly(x, coffee) → IsDependentOn(x, caffeine))
∀x (DrinkRegularly(x, coffee)  ∨ (¬WantToBeAddictedTo(x, caffeine)))
∀x (¬WantToBeAddictedTo(x, caffeine) → ¬AwareThatDrug(x, caffeine))
¬(Student(rina) ⊕  ¬AwareThatDrug(rina, caffeine))
¬(IsDependentOn(rina, caffeine) ⊕ Student(rina))

[PREMISE (GK)]:
! [X] : (DrinkRegularly(X, coffee) => IsDependentOn(X, caffeine)).
! [X] : (DrinkRegularly(X, coffee)  | (-WantToBeAddictedTo(X, caffeine))).
! [X] : (-WantToBeAddictedTo(X, caffeine) => -AwareThatDrug(X, caffeine)).
-(Student(rina) <~>  -AwareThatDrug(rina, caffeine)).
-(IsDependentOn(rina, caffeine) <~> Student(rina)).

[CONCLUSION]:
Rina doesn't want to be addicted to caffeine or is unaware that caffeine is a drug.

[CONCLUSION (FOL)]:
¬WantToBeAddictedTo(rina, caffeine) ∨ (¬AwareThatDrug(rina, caffeine))

[CONCLUSION (GK)]:
-WantToBeAddictedTo(rina, caffeine) | (-AwareThatDrug(rina, caffeine)).


===

['x']
['x']
[PREMISE]:
All people who regularly drink coffee are dependent on caffeine.
People regularly drink coffee, or they don't want to be addicted to caffeine, or both.
No one who doesn't want to be addicted to caffeine is unaware that caffeine is a drug.
Rina is either a student who is unaware that caffeine is a drug, or she is not a student and is she aware that caffeine is a drug.
Rina  is either a student who is dependent on caffeine, or she is not a student and not dependent on caffeine.

[PREMISE (FOL)]:
∀x (DrinkRegularly(x, coffee) → IsDependentOn(x, caffeine))
∀x (DrinkRegularly(x, coffee)  ∨ (¬WantToBeAddictedTo(x, caffeine)))
∀x (¬WantToBeAddictedTo(x, caffeine) → ¬AwareThatDrug(x, caffeine))
¬(Student(rina) ⊕  ¬AwareThatDrug(rina, caffeine))
¬(IsDependentOn(rina, caffeine) ⊕ Student(rina))

[PREMISE (GK)]:
! [X] : (DrinkRegularly(X, coffee) => IsDependentOn(X, caffeine)).
! [X] : (DrinkRegularly(X, coffee)  | (-WantToBeAddictedTo(X, caffeine))).
! [X] : (-WantToBeAddictedTo(X, caffeine) => -AwareThatDrug(X, caffeine)).
-(Student(rina) <~>  -AwareThatDrug(rina, caffeine)).
-(IsDependentOn(rina, caffeine) <~> Student(rina)).

[CONCLUSION]:
Rina eith doesn't want to be addicted to caffeine or is unaware that caffeine is a drug.

[CONCLUSION (FOL)]:
¬WantToBeAddictedTo(rina, caffeine) ⊕ ¬AwareThatDrug(rina, caffeine)

[CONCLUSION (GK)]:
-WantToBeAddictedTo(rina, caffeine) <~> -AwareThatDrug(rina, caffeine).


===

['x']
['x']
[PREMISE]:
All people who regularly drink coffee are dependent on caffeine.
People regularly drink coffee, or they don't want to be addicted to caffeine, or both.
No one who doesn't want to be addicted to caffeine is unaware that caffeine is a drug.
Rina is either a student who is unaware that caffeine is a drug, or she is not a student and is she aware that caffeine is a drug.
Rina  is either a student who is dependent on caffeine, or she is not a student and not dependent on caffeine.

[PREMISE (FOL)]:
∀x (DrinkRegularly(x, coffee) → IsDependentOn(x, caffeine))
∀x (DrinkRegularly(x, coffee)  ∨ (¬WantToBeAddictedTo(x, caffeine)))
∀x (¬WantToBeAddictedTo(x, caffeine) → ¬AwareThatDrug(x, caffeine))
¬(Student(rina) ⊕  ¬AwareThatDrug(rina, caffeine))
¬(IsDependentOn(rina, caffeine) ⊕ Student(rina))

[PREMISE (GK)]:
! [X] : (DrinkRegularly(X, coffee) => IsDependentOn(X, caffeine)).
! [X] : (DrinkRegularly(X, coffee)  | (-WantToBeAddictedTo(X, caffeine))).
! [X] : (-WantToBeAddictedTo(X, caffeine) => -AwareThatDrug(X, caffeine)).
-(Student(rina) <~>  -AwareThatDrug(rina, caffeine)).
-(IsDependentOn(rina, caffeine) <~> Student(rina)).

[CONCLUSION]:
Rina either regularly drinks coffee or is unaware that caffeine is a drug.

[CONCLUSION (FOL)]:
DrinkRegularly(rina, coffee)  ⊕ IsUnawareThatCaffeineIsADrug(rina)

[CONCLUSION (GK)]:
DrinkRegularly(rina, coffee)  <~> IsUnawareThatCaffeineIsADrug(rina).


===

['x']
['x']
[PREMISE]:
All people who regularly drink coffee are dependent on caffeine.
People regularly drink coffee, or they don't want to be addicted to caffeine, or both.
No one who doesn't want to be addicted to caffeine is unaware that caffeine is a drug.
Rina is either a student who is unaware that caffeine is a drug, or she is not a student and is she aware that caffeine is a drug.
Rina  is either a student who is dependent on caffeine, or she is not a student and not dependent on caffeine.

[PREMISE (FOL)]:
∀x (DrinkRegularly(x, coffee) → IsDependentOn(x, caffeine))
∀x (DrinkRegularly(x, coffee)  ∨ (¬WantToBeAddictedTo(x, caffeine)))
∀x (¬WantToBeAddictedTo(x, caffeine) → ¬AwareThatDrug(x, caffeine))
¬(Student(rina) ⊕  ¬AwareThatDrug(rina, caffeine))
¬(IsDependentOn(rina, caffeine) ⊕ Student(rina))

[PREMISE (GK)]:
! [X] : (DrinkRegularly(X, coffee) => IsDependentOn(X, caffeine)).
! [X] : (DrinkRegularly(X, coffee)  | (-WantToBeAddictedTo(X, caffeine))).
! [X] : (-WantToBeAddictedTo(X, caffeine) => -AwareThatDrug(X, caffeine)).
-(Student(rina) <~>  -AwareThatDrug(rina, caffeine)).
-(IsDependentOn(rina, caffeine) <~> Student(rina)).

[CONCLUSION]:
If Rina either doesn't want to be addicted to caffeine and is unaware that caffeine is a drug, or neither doesn't want to be addicted to caffeine nor is unaware that caffeine is a drug, then Rina doesn't want to be addicted to caffeine and regularly drinks coffee.

[CONCLUSION (FOL)]:
(DoNotWantToBeAddictedToCaffeine(rina) ⊕ ¬AwareThatDrug(rina, caffeine)) → ¬(¬WantToBeAddictedTo(rina, caffeine) ∧ DrinkRegularly(rina, coffee))

[CONCLUSION (GK)]:
(DoNotWantToBeAddictedToCaffeine(rina) <~> -AwareThatDrug(rina, caffeine)) => -(-WantToBeAddictedTo(rina, caffeine) & DrinkRegularly(rina, coffee)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.
Any choral conductor is a musician.
Some musicians love music.
Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.

[PREMISE (FOL)]:
Czech(miroslav) ∧ ChoralConductor(miroslav) ∧ SpecializeInPerformanceOf(miroslav, renaissanceMusic) ∧ SpecializeInPerformanceOf(miroslav, baroqueMusic)
∀x (ChoralConductor(x) → Musician(x))
∃x ∃y ((Musician(x) → Love(x, music)) ∧ (¬(x=y) ∧ Musician(y) → Love(y, music)))
PublishedBook(miroslav, methodOfStudyingGregorianChant, yr1946)

[PREMISE (GK)]:
Czech(miroslav) & ChoralConductor(miroslav) & SpecializeInPerformanceOf(miroslav, renaissanceMusic) & SpecializeInPerformanceOf(miroslav, baroqueMusic).
! [X] : (ChoralConductor(X) => Musician(X)).
? [X] : ? [Y] : ((Musician(X) => Love(X, music)) & (-(X=Y) & Musician(Y) => Love(Y, music))).
PublishedBook(miroslav, methodOfStudyingGregorianChant, yr1946).

[CONCLUSION]:
Miroslav Venhoda loved music.

[CONCLUSION (FOL)]:
Love(miroslav, music)

[CONCLUSION (GK)]:
Love(miroslav, music).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.
Any choral conductor is a musician.
Some musicians love music.
Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.

[PREMISE (FOL)]:
Czech(miroslav) ∧ ChoralConductor(miroslav) ∧ SpecializeInPerformanceOf(miroslav, renaissanceMusic) ∧ SpecializeInPerformanceOf(miroslav, baroqueMusic)
∀x (ChoralConductor(x) → Musician(x))
∃x ∃y ((Musician(x) → Love(x, music)) ∧ (¬(x=y) ∧ Musician(y) → Love(y, music)))
PublishedBook(miroslav, methodOfStudyingGregorianChant, yr1946)

[PREMISE (GK)]:
Czech(miroslav) & ChoralConductor(miroslav) & SpecializeInPerformanceOf(miroslav, renaissanceMusic) & SpecializeInPerformanceOf(miroslav, baroqueMusic).
! [X] : (ChoralConductor(X) => Musician(X)).
? [X] : ? [Y] : ((Musician(X) => Love(X, music)) & (-(X=Y) & Musician(Y) => Love(Y, music))).
PublishedBook(miroslav, methodOfStudyingGregorianChant, yr1946).

[CONCLUSION]:
A Czech published a book in 1946.

[CONCLUSION (FOL)]:
∃x ∃y (Czech(x) ∧ PublishedBook(x, y, year1946))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Czech(X) & PublishedBook(X, Y, year1946)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.
Any choral conductor is a musician.
Some musicians love music.
Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.

[PREMISE (FOL)]:
Czech(miroslav) ∧ ChoralConductor(miroslav) ∧ SpecializeInPerformanceOf(miroslav, renaissanceMusic) ∧ SpecializeInPerformanceOf(miroslav, baroqueMusic)
∀x (ChoralConductor(x) → Musician(x))
∃x ∃y ((Musician(x) → Love(x, music)) ∧ (¬(x=y) ∧ Musician(y) → Love(y, music)))
PublishedBook(miroslav, methodOfStudyingGregorianChant, yr1946)

[PREMISE (GK)]:
Czech(miroslav) & ChoralConductor(miroslav) & SpecializeInPerformanceOf(miroslav, renaissanceMusic) & SpecializeInPerformanceOf(miroslav, baroqueMusic).
! [X] : (ChoralConductor(X) => Musician(X)).
? [X] : ? [Y] : ((Musician(X) => Love(X, music)) & (-(X=Y) & Musician(Y) => Love(Y, music))).
PublishedBook(miroslav, methodOfStudyingGregorianChant, yr1946).

[CONCLUSION]:
No choral conductor specialized in the performance of Renaissance.

[CONCLUSION (FOL)]:
∀x (ChoralConductor(x) → ¬SpecializeInPerformanceOf(x, renaissanceMusic))

[CONCLUSION (GK)]:
! [X] : (ChoralConductor(X) => -SpecializeInPerformanceOf(X, renaissanceMusic)).


===

['x']
['x']
[PREMISE]:
All eels are fish. 
No fish are plants. 
Everything displayed in the collection is either a plant or an animal.
All multicellular animals are not bacteria.
All animals displayed in the collection are multicellular.
A sea eel is displayed in the collection.
The sea eel is an eel or an animal or not a plant.

[PREMISE (FOL)]:
∀x (Eel(x) → Fish(x))
∀x (Fish(x) → ¬Plant(x))
∀x (DisplayedIn(x, collection) → Plant(x) ⊕ Animal(x))
∀x (Multicellular(x) → ¬Bacteria(x))
∀x (DisplayedIn(x, collection) ∧ Animal(x) → Multicellular(x))
DisplayedIn(seaEel, collection)
Eel(seaEel) ∨ Animal(seaEel) ∨ ¬Plant(seaEel)

[PREMISE (GK)]:
! [X] : (Eel(X) => Fish(X)).
! [X] : (Fish(X) => -Plant(X)).
! [X] : (DisplayedIn(X, collection) => Plant(X) <~> Animal(X)).
! [X] : (Multicellular(X) => -Bacteria(X)).
! [X] : (DisplayedIn(X, collection) & Animal(X) => Multicellular(X)).
DisplayedIn(seaEel, collection).
Eel(seaEel) | Animal(seaEel) | -Plant(seaEel).

[CONCLUSION]:
The sea eel is an eel.

[CONCLUSION (FOL)]:
Eel(seaEel)

[CONCLUSION (GK)]:
Eel(seaEel).


===

['x']
['x']
[PREMISE]:
All eels are fish. 
No fish are plants. 
Everything displayed in the collection is either a plant or an animal.
All multicellular animals are not bacteria.
All animals displayed in the collection are multicellular.
A sea eel is displayed in the collection.
The sea eel is an eel or an animal or not a plant.

[PREMISE (FOL)]:
∀x (Eel(x) → Fish(x))
∀x (Fish(x) → ¬Plant(x))
∀x (DisplayedIn(x, collection) → Plant(x) ⊕ Animal(x))
∀x (Multicellular(x) → ¬Bacteria(x))
∀x (DisplayedIn(x, collection) ∧ Animal(x) → Multicellular(x))
DisplayedIn(seaEel, collection)
Eel(seaEel) ∨ Animal(seaEel) ∨ ¬Plant(seaEel)

[PREMISE (GK)]:
! [X] : (Eel(X) => Fish(X)).
! [X] : (Fish(X) => -Plant(X)).
! [X] : (DisplayedIn(X, collection) => Plant(X) <~> Animal(X)).
! [X] : (Multicellular(X) => -Bacteria(X)).
! [X] : (DisplayedIn(X, collection) & Animal(X) => Multicellular(X)).
DisplayedIn(seaEel, collection).
Eel(seaEel) | Animal(seaEel) | -Plant(seaEel).

[CONCLUSION]:
The sea eel is bacteria.

[CONCLUSION (FOL)]:
Bacteria(seaEel)

[CONCLUSION (GK)]:
Bacteria(seaEel).


===

['x']
['x']
[PREMISE]:
All eels are fish. 
No fish are plants. 
Everything displayed in the collection is either a plant or an animal.
All multicellular animals are not bacteria.
All animals displayed in the collection are multicellular.
A sea eel is displayed in the collection.
The sea eel is an eel or an animal or not a plant.

[PREMISE (FOL)]:
∀x (Eel(x) → Fish(x))
∀x (Fish(x) → ¬Plant(x))
∀x (DisplayedIn(x, collection) → Plant(x) ⊕ Animal(x))
∀x (Multicellular(x) → ¬Bacteria(x))
∀x (DisplayedIn(x, collection) ∧ Animal(x) → Multicellular(x))
DisplayedIn(seaEel, collection)
Eel(seaEel) ∨ Animal(seaEel) ∨ ¬Plant(seaEel)

[PREMISE (GK)]:
! [X] : (Eel(X) => Fish(X)).
! [X] : (Fish(X) => -Plant(X)).
! [X] : (DisplayedIn(X, collection) => Plant(X) <~> Animal(X)).
! [X] : (Multicellular(X) => -Bacteria(X)).
! [X] : (DisplayedIn(X, collection) & Animal(X) => Multicellular(X)).
DisplayedIn(seaEel, collection).
Eel(seaEel) | Animal(seaEel) | -Plant(seaEel).

[CONCLUSION]:
The sea eel is multicellular or is bacteria.

[CONCLUSION (FOL)]:
Multicellular(seaEel) ∨ Bacteria(seaEel)

[CONCLUSION (GK)]:
Multicellular(seaEel) | Bacteria(seaEel).


===

[]
['x']
[PREMISE]:
The Blake McFall Company Building is a building added to the National Register of Historic Places in 1990.
The Emmet Building is a five-story building in Portland, Oregon.
The Emmet Building was built in 1915.
The Emmet Building is another name for the Blake McFall Company Building.
John works at the Emmet Building.

[PREMISE (FOL)]:
Building(blakeMcFallCompanyBuilding) ∧ AddedToIn(blakeMcFallCompanyBuilding, theNationalRegisterOfHistoricPlaces, year1990)
Building(emmetBuilding) ∧ Five-Story(emmetBuilding) ∧ LocatedIn(emmetBuilding, portland) ∧ LocatedIn(portland, oregon))
BuiltIn(emmetBuilding, year1915)
emmetBuiling=blakeMcFallCompanyBuilding
WorkAt(john, emmetBuilding)

[PREMISE (GK)]:
Building(blakeMcFallCompanyBuilding) & AddedToIn(blakeMcFallCompanyBuilding, theNationalRegisterOfHistoricPlaces, year1990).
Building(emmetBuilding) & Five-Story(emmetBuilding) & LocatedIn(emmetBuilding, portland) & LocatedIn(portland, oregon)).
BuiltIn(emmetBuilding, year1915).
emmetBuiling=blakeMcFallCompanyBuilding.
WorkAt(john, emmetBuilding).

[CONCLUSION]:
A five-story building is built in 1915.

[CONCLUSION (FOL)]:
∃x (Building(x) ∧ Five-Story(x) ∧ ConstructedIn(x, year1915))

[CONCLUSION (GK)]:
? [X] : (Building(X) & Five-Story(X) & ConstructedIn(X, year1915)).


===

[]
[]
[PREMISE]:
The Blake McFall Company Building is a building added to the National Register of Historic Places in 1990.
The Emmet Building is a five-story building in Portland, Oregon.
The Emmet Building was built in 1915.
The Emmet Building is another name for the Blake McFall Company Building.
John works at the Emmet Building.

[PREMISE (FOL)]:
Building(blakeMcFallCompanyBuilding) ∧ AddedToIn(blakeMcFallCompanyBuilding, theNationalRegisterOfHistoricPlaces, year1990)
Building(emmetBuilding) ∧ Five-Story(emmetBuilding) ∧ LocatedIn(emmetBuilding, portland) ∧ LocatedIn(portland, oregon))
BuiltIn(emmetBuilding, year1915)
emmetBuiling=blakeMcFallCompanyBuilding
WorkAt(john, emmetBuilding)

[PREMISE (GK)]:
Building(blakeMcFallCompanyBuilding) & AddedToIn(blakeMcFallCompanyBuilding, theNationalRegisterOfHistoricPlaces, year1990).
Building(emmetBuilding) & Five-Story(emmetBuilding) & LocatedIn(emmetBuilding, portland) & LocatedIn(portland, oregon)).
BuiltIn(emmetBuilding, year1915).
emmetBuiling=blakeMcFallCompanyBuilding.
WorkAt(john, emmetBuilding).

[CONCLUSION]:
The Blake McFall Company Building is located in Portland, Oregon.

[CONCLUSION (FOL)]:
LocatedIn(blakeMcFallCompanyBuilding, portland)

[CONCLUSION (GK)]:
LocatedIn(blakeMcFallCompanyBuilding, portland).


===

[]
[]
[PREMISE]:
The Blake McFall Company Building is a building added to the National Register of Historic Places in 1990.
The Emmet Building is a five-story building in Portland, Oregon.
The Emmet Building was built in 1915.
The Emmet Building is another name for the Blake McFall Company Building.
John works at the Emmet Building.

[PREMISE (FOL)]:
Building(blakeMcFallCompanyBuilding) ∧ AddedToIn(blakeMcFallCompanyBuilding, theNationalRegisterOfHistoricPlaces, year1990)
Building(emmetBuilding) ∧ Five-Story(emmetBuilding) ∧ LocatedIn(emmetBuilding, portland) ∧ LocatedIn(portland, oregon))
BuiltIn(emmetBuilding, year1915)
emmetBuiling=blakeMcFallCompanyBuilding
WorkAt(john, emmetBuilding)

[PREMISE (GK)]:
Building(blakeMcFallCompanyBuilding) & AddedToIn(blakeMcFallCompanyBuilding, theNationalRegisterOfHistoricPlaces, year1990).
Building(emmetBuilding) & Five-Story(emmetBuilding) & LocatedIn(emmetBuilding, portland) & LocatedIn(portland, oregon)).
BuiltIn(emmetBuilding, year1915).
emmetBuiling=blakeMcFallCompanyBuilding.
WorkAt(john, emmetBuilding).

[CONCLUSION]:
John started his current job in 1990.

[CONCLUSION (FOL)]:
StartCurrentJobIn(john, year1990)

[CONCLUSION (GK)]:
StartCurrentJobIn(john, year1990).


===

['x']
['x']
[PREMISE]:
William Dickinson was a British politician who sat in the House of Commons
William Dickinson attended Westminster school for high school and then the University of Edinburgh.
The University of Edinburgh is a university located in the United Kingdom.
William Dickinson supported the Portland Whigs.
People who supported the Portland Whigs did not get a seat in the Parliament.

[PREMISE (FOL)]:
British(williamDickinson) ∧ Politician(williamDickinson) ∧ SatIn(williamDickinson, houseOfCommons)
Attended(williamDickinson, westminsterSchool) ∧ Highschool(westminsterSchool) ∧ Attended(williamDickinson, universityOfEdinburgh)
University(universityOfEdinburgh) ∧ LocatedIn(universityOfEdinburgh, unitedKingdom)
Supported(williamDickinson, portlandWhigs)
∀x (Supported(x, portlandWhigs) → ¬SatIn(x, parliament))

[PREMISE (GK)]:
British(williamDickinson) & Politician(williamDickinson) & SatIn(williamDickinson, houseOfCommons).
Attended(williamDickinson, westminsterSchool) & Highschool(westminsterSchool) & Attended(williamDickinson, universityOfEdinburgh).
University(universityOfEdinburgh) & LocatedIn(universityOfEdinburgh, unitedKingdom).
Supported(williamDickinson, portlandWhigs).
! [X] : (Supported(X, portlandWhigs) => -SatIn(X, parliament)).

[CONCLUSION]:
William Dickinson did not get a seat in Parliament.

[CONCLUSION (FOL)]:
SatIn(williamDickinson, parliament)

[CONCLUSION (GK)]:
SatIn(williamDickinson, parliament).


===

['x']
['x', 'y']
[PREMISE]:
William Dickinson was a British politician who sat in the House of Commons
William Dickinson attended Westminster school for high school and then the University of Edinburgh.
The University of Edinburgh is a university located in the United Kingdom.
William Dickinson supported the Portland Whigs.
People who supported the Portland Whigs did not get a seat in the Parliament.

[PREMISE (FOL)]:
British(williamDickinson) ∧ Politician(williamDickinson) ∧ SatIn(williamDickinson, houseOfCommons)
Attended(williamDickinson, westminsterSchool) ∧ Highschool(westminsterSchool) ∧ Attended(williamDickinson, universityOfEdinburgh)
University(universityOfEdinburgh) ∧ LocatedIn(universityOfEdinburgh, unitedKingdom)
Supported(williamDickinson, portlandWhigs)
∀x (Supported(x, portlandWhigs) → ¬SatIn(x, parliament))

[PREMISE (GK)]:
British(williamDickinson) & Politician(williamDickinson) & SatIn(williamDickinson, houseOfCommons).
Attended(williamDickinson, westminsterSchool) & Highschool(westminsterSchool) & Attended(williamDickinson, universityOfEdinburgh).
University(universityOfEdinburgh) & LocatedIn(universityOfEdinburgh, unitedKingdom).
Supported(williamDickinson, portlandWhigs).
! [X] : (Supported(X, portlandWhigs) => -SatIn(X, parliament)).

[CONCLUSION]:
William Dickinson went to schools located in the United Kingdom for both high school and university.

[CONCLUSION (FOL)]:
∃x ∃y (Attended(williamDickinson, x) ∧ Highschool(x) ∧ LocatedIn(x, unitedKingdom) ∧ Attended(williamDickinson, y) ∧ University(y) ∧ LocatedIn(y, unitedKingdom))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Attended(williamDickinson, X) & Highschool(X) & LocatedIn(X, unitedKingdom) & Attended(williamDickinson, Y) & University(Y) & LocatedIn(Y, unitedKingdom)).


===

['x']
['x']
[PREMISE]:
William Dickinson was a British politician who sat in the House of Commons
William Dickinson attended Westminster school for high school and then the University of Edinburgh.
The University of Edinburgh is a university located in the United Kingdom.
William Dickinson supported the Portland Whigs.
People who supported the Portland Whigs did not get a seat in the Parliament.

[PREMISE (FOL)]:
British(williamDickinson) ∧ Politician(williamDickinson) ∧ SatIn(williamDickinson, houseOfCommons)
Attended(williamDickinson, westminsterSchool) ∧ Highschool(westminsterSchool) ∧ Attended(williamDickinson, universityOfEdinburgh)
University(universityOfEdinburgh) ∧ LocatedIn(universityOfEdinburgh, unitedKingdom)
Supported(williamDickinson, portlandWhigs)
∀x (Supported(x, portlandWhigs) → ¬SatIn(x, parliament))

[PREMISE (GK)]:
British(williamDickinson) & Politician(williamDickinson) & SatIn(williamDickinson, houseOfCommons).
Attended(williamDickinson, westminsterSchool) & Highschool(westminsterSchool) & Attended(williamDickinson, universityOfEdinburgh).
University(universityOfEdinburgh) & LocatedIn(universityOfEdinburgh, unitedKingdom).
Supported(williamDickinson, portlandWhigs).
! [X] : (Supported(X, portlandWhigs) => -SatIn(X, parliament)).

[CONCLUSION]:
William Dickinson attended university in the United Kingdom.

[CONCLUSION (FOL)]:
∃x (Attended(williamDickinson, x) ∧ University(x) ∧ LocatedIn(x, unitedKingdom))

[CONCLUSION (GK)]:
? [X] : (Attended(williamDickinson, X) & University(X) & LocatedIn(X, unitedKingdom)).


===

['x']
['x']
[PREMISE]:
William Dickinson was a British politician who sat in the House of Commons
William Dickinson attended Westminster school for high school and then the University of Edinburgh.
The University of Edinburgh is a university located in the United Kingdom.
William Dickinson supported the Portland Whigs.
People who supported the Portland Whigs did not get a seat in the Parliament.

[PREMISE (FOL)]:
British(williamDickinson) ∧ Politician(williamDickinson) ∧ SatIn(williamDickinson, houseOfCommons)
Attended(williamDickinson, westminsterSchool) ∧ Highschool(westminsterSchool) ∧ Attended(williamDickinson, universityOfEdinburgh)
University(universityOfEdinburgh) ∧ LocatedIn(universityOfEdinburgh, unitedKingdom)
Supported(williamDickinson, portlandWhigs)
∀x (Supported(x, portlandWhigs) → ¬SatIn(x, parliament))

[PREMISE (GK)]:
British(williamDickinson) & Politician(williamDickinson) & SatIn(williamDickinson, houseOfCommons).
Attended(williamDickinson, westminsterSchool) & Highschool(westminsterSchool) & Attended(williamDickinson, universityOfEdinburgh).
University(universityOfEdinburgh) & LocatedIn(universityOfEdinburgh, unitedKingdom).
Supported(williamDickinson, portlandWhigs).
! [X] : (Supported(X, portlandWhigs) => -SatIn(X, parliament)).

[CONCLUSION]:
William Dickinson sat in the House of Commons.

[CONCLUSION (FOL)]:
SatIn(williamDickinson, houseOfCommons)

[CONCLUSION (GK)]:
SatIn(williamDickinson, houseOfCommons).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
LanguageA is a universal language
If a universal language exists, then for every two people if they both know the same universal language they can communicate.
Katya cannot communicate with Danil.
Katya knows LanguageA. 

[PREMISE (FOL)]:
UniversalLanguage(languageA)
∀x ∀y (∃z (¬(x=y) ∧ Know(x, z) ∧ Know(y, z) ∧ UniversalLanguage(z)) → CanCommunicateWith(x, y) ∧ CanCommunicateWith(y, x))
¬CanCommunicateWith(katya, danil)
Know(katya, languageA)

[PREMISE (GK)]:
UniversalLanguage(languageA).
! [X] : ! [Y] : (? [Z] : (-(X=Y) & Know(X, Z) & Know(Y, Z) & UniversalLanguage(Z)) => CanCommunicateWith(X, Y) & CanCommunicateWith(Y, X)).
-CanCommunicateWith(katya, danil).
Know(katya, languageA).

[CONCLUSION]:
Danil knows LanguageA.

[CONCLUSION (FOL)]:
Know(danil, languageA)

[CONCLUSION (GK)]:
Know(danil, languageA).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All customers in James' family who subscribe to AMC A-List are eligible to watch three movies every week without any additional fees. 
Some of the customers in James' family go to the cinema every week.
Customers in James' family subscribe to AMC A-List or HBO service. 
Customers in James' family who prefer TV series will not watch TV series in cinemas.
All customers in James' family who subscribe to HBO services prefer TV series to movies. 
Lily is in James' family; she watches TV series in cinemas. 

[PREMISE (FOL)]:
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧ SubscribedTo(x, aMCAList)) →  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(x))
∃x ∃y (Customer(x) ∧ In(x, jameSFamily) ∧ GoToEveryWeek(x, cinema) ∧ (¬(x=y)) ∧ Customer(y) ∧ In(y, jameSFamily) ∧ GoToEveryWeek(y, cinema))
∀x (Customer(x) ∧ In(x, jameSFamily) ∧ (SubscribedTo(x, aMCAList) ∨ SubscribedTo(x, hBO)))
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧ Prefer(x, tVSeries)) → (¬WatchIn(x, tV, cinema)))
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧  SubscribedTo(x, hBO)) → Prefer(x, tVSeries))
Customer(lily) ∧ In(lily, jameSFamily ∧ WatchIn(lily, tV, cinema)

[PREMISE (GK)]:
! [X] : ((Customer(X) & In(X, jameSFamily) & SubscribedTo(X, aMCAList)) =>  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(X)).
? [X] : ? [Y] : (Customer(X) & In(X, jameSFamily) & GoToEveryWeek(X, cinema) & (-(X=Y)) & Customer(Y) & In(Y, jameSFamily) & GoToEveryWeek(Y, cinema)).
! [X] : (Customer(X) & In(X, jameSFamily) & (SubscribedTo(X, aMCAList) | SubscribedTo(X, hBO))).
! [X] : ((Customer(X) & In(X, jameSFamily) & Prefer(X, tVSeries)) => (-WatchIn(X, tV, cinema))).
! [X] : ((Customer(X) & In(X, jameSFamily) &  SubscribedTo(X, hBO)) => Prefer(X, tVSeries)).
Customer(lily) & In(lily, jameSFamily & WatchIn(lily, tV, cinema).

[CONCLUSION]:
Lily goes to cinemas every week.

[CONCLUSION (FOL)]:
GoToEveryWeek(lily, cinema)

[CONCLUSION (GK)]:
GoToEveryWeek(lily, cinema).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All customers in James' family who subscribe to AMC A-List are eligible to watch three movies every week without any additional fees. 
Some of the customers in James' family go to the cinema every week.
Customers in James' family subscribe to AMC A-List or HBO service. 
Customers in James' family who prefer TV series will not watch TV series in cinemas.
All customers in James' family who subscribe to HBO services prefer TV series to movies. 
Lily is in James' family; she watches TV series in cinemas. 

[PREMISE (FOL)]:
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧ SubscribedTo(x, aMCAList)) →  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(x))
∃x ∃y (Customer(x) ∧ In(x, jameSFamily) ∧ GoToEveryWeek(x, cinema) ∧ (¬(x=y)) ∧ Customer(y) ∧ In(y, jameSFamily) ∧ GoToEveryWeek(y, cinema))
∀x (Customer(x) ∧ In(x, jameSFamily) ∧ (SubscribedTo(x, aMCAList) ∨ SubscribedTo(x, hBO)))
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧ Prefer(x, tVSeries)) → (¬WatchIn(x, tV, cinema)))
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧  SubscribedTo(x, hBO)) → Prefer(x, tVSeries))
Customer(lily) ∧ In(lily, jameSFamily ∧ WatchIn(lily, tV, cinema)

[PREMISE (GK)]:
! [X] : ((Customer(X) & In(X, jameSFamily) & SubscribedTo(X, aMCAList)) =>  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(X)).
? [X] : ? [Y] : (Customer(X) & In(X, jameSFamily) & GoToEveryWeek(X, cinema) & (-(X=Y)) & Customer(Y) & In(Y, jameSFamily) & GoToEveryWeek(Y, cinema)).
! [X] : (Customer(X) & In(X, jameSFamily) & (SubscribedTo(X, aMCAList) | SubscribedTo(X, hBO))).
! [X] : ((Customer(X) & In(X, jameSFamily) & Prefer(X, tVSeries)) => (-WatchIn(X, tV, cinema))).
! [X] : ((Customer(X) & In(X, jameSFamily) &  SubscribedTo(X, hBO)) => Prefer(X, tVSeries)).
Customer(lily) & In(lily, jameSFamily & WatchIn(lily, tV, cinema).

[CONCLUSION]:
Lily does not go to cinemas every week.

[CONCLUSION (FOL)]:
¬GoToEveryWeek(lily, cinema)

[CONCLUSION (GK)]:
-GoToEveryWeek(lily, cinema).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All customers in James' family who subscribe to AMC A-List are eligible to watch three movies every week without any additional fees. 
Some of the customers in James' family go to the cinema every week.
Customers in James' family subscribe to AMC A-List or HBO service. 
Customers in James' family who prefer TV series will not watch TV series in cinemas.
All customers in James' family who subscribe to HBO services prefer TV series to movies. 
Lily is in James' family; she watches TV series in cinemas. 

[PREMISE (FOL)]:
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧ SubscribedTo(x, aMCAList)) →  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(x))
∃x ∃y (Customer(x) ∧ In(x, jameSFamily) ∧ GoToEveryWeek(x, cinema) ∧ (¬(x=y)) ∧ Customer(y) ∧ In(y, jameSFamily) ∧ GoToEveryWeek(y, cinema))
∀x (Customer(x) ∧ In(x, jameSFamily) ∧ (SubscribedTo(x, aMCAList) ∨ SubscribedTo(x, hBO)))
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧ Prefer(x, tVSeries)) → (¬WatchIn(x, tV, cinema)))
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧  SubscribedTo(x, hBO)) → Prefer(x, tVSeries))
Customer(lily) ∧ In(lily, jameSFamily ∧ WatchIn(lily, tV, cinema)

[PREMISE (GK)]:
! [X] : ((Customer(X) & In(X, jameSFamily) & SubscribedTo(X, aMCAList)) =>  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(X)).
? [X] : ? [Y] : (Customer(X) & In(X, jameSFamily) & GoToEveryWeek(X, cinema) & (-(X=Y)) & Customer(Y) & In(Y, jameSFamily) & GoToEveryWeek(Y, cinema)).
! [X] : (Customer(X) & In(X, jameSFamily) & (SubscribedTo(X, aMCAList) | SubscribedTo(X, hBO))).
! [X] : ((Customer(X) & In(X, jameSFamily) & Prefer(X, tVSeries)) => (-WatchIn(X, tV, cinema))).
! [X] : ((Customer(X) & In(X, jameSFamily) &  SubscribedTo(X, hBO)) => Prefer(X, tVSeries)).
Customer(lily) & In(lily, jameSFamily & WatchIn(lily, tV, cinema).

[CONCLUSION]:
Lily goes to cinemas every week or watches 3 movies every week without any additional fees.

[CONCLUSION (FOL)]:
GoToEveryWeek(lily, cinema) ∨ EligibleForThreeFreeMoviesWithoutAdditionalFees(lily)

[CONCLUSION (GK)]:
GoToEveryWeek(lily, cinema) | EligibleForThreeFreeMoviesWithoutAdditionalFees(lily).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All customers in James' family who subscribe to AMC A-List are eligible to watch three movies every week without any additional fees. 
Some of the customers in James' family go to the cinema every week.
Customers in James' family subscribe to AMC A-List or HBO service. 
Customers in James' family who prefer TV series will not watch TV series in cinemas.
All customers in James' family who subscribe to HBO services prefer TV series to movies. 
Lily is in James' family; she watches TV series in cinemas. 

[PREMISE (FOL)]:
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧ SubscribedTo(x, aMCAList)) →  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(x))
∃x ∃y (Customer(x) ∧ In(x, jameSFamily) ∧ GoToEveryWeek(x, cinema) ∧ (¬(x=y)) ∧ Customer(y) ∧ In(y, jameSFamily) ∧ GoToEveryWeek(y, cinema))
∀x (Customer(x) ∧ In(x, jameSFamily) ∧ (SubscribedTo(x, aMCAList) ∨ SubscribedTo(x, hBO)))
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧ Prefer(x, tVSeries)) → (¬WatchIn(x, tV, cinema)))
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧  SubscribedTo(x, hBO)) → Prefer(x, tVSeries))
Customer(lily) ∧ In(lily, jameSFamily ∧ WatchIn(lily, tV, cinema)

[PREMISE (GK)]:
! [X] : ((Customer(X) & In(X, jameSFamily) & SubscribedTo(X, aMCAList)) =>  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(X)).
? [X] : ? [Y] : (Customer(X) & In(X, jameSFamily) & GoToEveryWeek(X, cinema) & (-(X=Y)) & Customer(Y) & In(Y, jameSFamily) & GoToEveryWeek(Y, cinema)).
! [X] : (Customer(X) & In(X, jameSFamily) & (SubscribedTo(X, aMCAList) | SubscribedTo(X, hBO))).
! [X] : ((Customer(X) & In(X, jameSFamily) & Prefer(X, tVSeries)) => (-WatchIn(X, tV, cinema))).
! [X] : ((Customer(X) & In(X, jameSFamily) &  SubscribedTo(X, hBO)) => Prefer(X, tVSeries)).
Customer(lily) & In(lily, jameSFamily & WatchIn(lily, tV, cinema).

[CONCLUSION]:
If Lily does not both go to cinemas every week and subscribe to HBO service, then Lily is either available to watch 3 movies every week without any additional fees or she prefers TV more.

[CONCLUSION (FOL)]:
(GoToEveryWeek(lily, cinema) ∧ SubscribedTo(lily, hBO)) → (EligibleForThreeFreeMoviesEveryWeek(lily) ⊕ Prefer(lily, tVSeries))

[CONCLUSION (GK)]:
(GoToEveryWeek(lily, cinema) & SubscribedTo(lily, hBO)) => (EligibleForThreeFreeMoviesEveryWeek(lily) <~> Prefer(lily, tVSeries)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All customers in James' family who subscribe to AMC A-List are eligible to watch three movies every week without any additional fees. 
Some of the customers in James' family go to the cinema every week.
Customers in James' family subscribe to AMC A-List or HBO service. 
Customers in James' family who prefer TV series will not watch TV series in cinemas.
All customers in James' family who subscribe to HBO services prefer TV series to movies. 
Lily is in James' family; she watches TV series in cinemas. 

[PREMISE (FOL)]:
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧ SubscribedTo(x, aMCAList)) →  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(x))
∃x ∃y (Customer(x) ∧ In(x, jameSFamily) ∧ GoToEveryWeek(x, cinema) ∧ (¬(x=y)) ∧ Customer(y) ∧ In(y, jameSFamily) ∧ GoToEveryWeek(y, cinema))
∀x (Customer(x) ∧ In(x, jameSFamily) ∧ (SubscribedTo(x, aMCAList) ∨ SubscribedTo(x, hBO)))
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧ Prefer(x, tVSeries)) → (¬WatchIn(x, tV, cinema)))
∀x ((Customer(x) ∧ In(x, jameSFamily) ∧  SubscribedTo(x, hBO)) → Prefer(x, tVSeries))
Customer(lily) ∧ In(lily, jameSFamily ∧ WatchIn(lily, tV, cinema)

[PREMISE (GK)]:
! [X] : ((Customer(X) & In(X, jameSFamily) & SubscribedTo(X, aMCAList)) =>  EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(X)).
? [X] : ? [Y] : (Customer(X) & In(X, jameSFamily) & GoToEveryWeek(X, cinema) & (-(X=Y)) & Customer(Y) & In(Y, jameSFamily) & GoToEveryWeek(Y, cinema)).
! [X] : (Customer(X) & In(X, jameSFamily) & (SubscribedTo(X, aMCAList) | SubscribedTo(X, hBO))).
! [X] : ((Customer(X) & In(X, jameSFamily) & Prefer(X, tVSeries)) => (-WatchIn(X, tV, cinema))).
! [X] : ((Customer(X) & In(X, jameSFamily) &  SubscribedTo(X, hBO)) => Prefer(X, tVSeries)).
Customer(lily) & In(lily, jameSFamily & WatchIn(lily, tV, cinema).

[CONCLUSION]:
If Lily is available to watch 3 movies every week without any additional fees and she watches TV series in cinemas, then she goes to cinemas every week and prefers TV series more.

[CONCLUSION (FOL)]:
(EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(lily) ∧ WatchIn(lily, tV, cinema)) → (GoToEveryWeek(lily, cinema) ∧ Prefer(lily, tVSeries))

[CONCLUSION (GK)]:
(EligibleForThreeFreeMoviesEveryWeekWithoutAdditionalFees(lily) & WatchIn(lily, tV, cinema)) => (GoToEveryWeek(lily, cinema) & Prefer(lily, tVSeries)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
Real Madrid and Barcelona are both La Liga soccer teams.
Real Madrid received more points than Barcelona.
Neither Real Madrid nor Barcelona received more points from the games between them.

[PREMISE (FOL)]:
∀x ∀y (LaLigaSoccerTeam(x) ∧ LaLigaSoccerTeam(y) ∧ MorePoints(x, y) → RankHigherThan(x, y))
∀x ∀y (LaLigaSoccerTeam(x) ∧ LaLigaSoccerTeam(y) ∧ ¬MorePoints(x, y) ∧ ¬MorePoints(y, x) ∧ MorePointsInGameBetween(x, y) →  RankHigherThan(x, y))
LaLigaSoccerTeam(realMadrid) ∧ LaLigaSoccerTeam(barcelona)
MorePoints(realMadrid, barcelona)
¬MorePointsInGameBetween(realMadrid, barcelona) ∧ ¬MorePointsInGameBetween(barcelona, realMadrid)

[PREMISE (GK)]:
! [X] : ! [Y] : (LaLigaSoccerTeam(X) & LaLigaSoccerTeam(Y) & MorePoints(X, Y) => RankHigherThan(X, Y)).
! [X] : ! [Y] : (LaLigaSoccerTeam(X) & LaLigaSoccerTeam(Y) & -MorePoints(X, Y) & -MorePoints(Y, X) & MorePointsInGameBetween(X, Y) =>  RankHigherThan(X, Y)).
LaLigaSoccerTeam(realMadrid) & LaLigaSoccerTeam(barcelona).
MorePoints(realMadrid, barcelona).
-MorePointsInGameBetween(realMadrid, barcelona) & -MorePointsInGameBetween(barcelona, realMadrid).

[CONCLUSION]:
Real Madrid ranks higher than Barcelona.

[CONCLUSION (FOL)]:
RankHigherThan(realMadrid, barcelona)

[CONCLUSION (GK)]:
RankHigherThan(realMadrid, barcelona).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A La Liga soccer team ranks higher than another La Liga soccer team if it receives more points.
If there are two La Liga soccer teams and neither has more points than the other, then the team which receives more points from the games between the two teams ranks higher.
Real Madrid and Barcelona are both La Liga soccer teams.
Real Madrid received more points than Barcelona.
Neither Real Madrid nor Barcelona received more points from the games between them.

[PREMISE (FOL)]:
∀x ∀y (LaLigaSoccerTeam(x) ∧ LaLigaSoccerTeam(y) ∧ MorePoints(x, y) → RankHigherThan(x, y))
∀x ∀y (LaLigaSoccerTeam(x) ∧ LaLigaSoccerTeam(y) ∧ ¬MorePoints(x, y) ∧ ¬MorePoints(y, x) ∧ MorePointsInGameBetween(x, y) →  RankHigherThan(x, y))
LaLigaSoccerTeam(realMadrid) ∧ LaLigaSoccerTeam(barcelona)
MorePoints(realMadrid, barcelona)
¬MorePointsInGameBetween(realMadrid, barcelona) ∧ ¬MorePointsInGameBetween(barcelona, realMadrid)

[PREMISE (GK)]:
! [X] : ! [Y] : (LaLigaSoccerTeam(X) & LaLigaSoccerTeam(Y) & MorePoints(X, Y) => RankHigherThan(X, Y)).
! [X] : ! [Y] : (LaLigaSoccerTeam(X) & LaLigaSoccerTeam(Y) & -MorePoints(X, Y) & -MorePoints(Y, X) & MorePointsInGameBetween(X, Y) =>  RankHigherThan(X, Y)).
LaLigaSoccerTeam(realMadrid) & LaLigaSoccerTeam(barcelona).
MorePoints(realMadrid, barcelona).
-MorePointsInGameBetween(realMadrid, barcelona) & -MorePointsInGameBetween(barcelona, realMadrid).

[CONCLUSION]:
Barcelona ranks higher than Real Madrid.

[CONCLUSION (FOL)]:
RankHigherThan(barcelona, realMadrid)

[CONCLUSION (GK)]:
RankHigherThan(barcelona, realMadrid).


===

['x']
['x']
[PREMISE]:
Lawton Park is a neighborhood in Seattle. 
All citizens of Lawton Park use the zip code 98199. 
Tom is a citizen of Lawton Park.
Daniel uses the zip code 98199. 

[PREMISE (FOL)]:
NeighbourhoodIn(lawtonPark, seattle)
∀x (Residentof(x, lawtonPark) → UseZipCode(x, num98199))
ResidentOf(tom, lawtonPark)
UseZipCode(daniel, num98199)

[PREMISE (GK)]:
NeighbourhoodIn(lawtonPark, seattle).
! [X] : (Residentof(X, lawtonPark) => UseZipCode(X, num98199)).
ResidentOf(tom, lawtonPark).
UseZipCode(daniel, num98199).

[CONCLUSION]:
Tom uses the zip code 98199.

[CONCLUSION (FOL)]:
UseZipCode(tom, num98199)

[CONCLUSION (GK)]:
UseZipCode(tom, num98199).


===

['x']
['x']
[PREMISE]:
Lawton Park is a neighborhood in Seattle. 
All citizens of Lawton Park use the zip code 98199. 
Tom is a citizen of Lawton Park.
Daniel uses the zip code 98199. 

[PREMISE (FOL)]:
NeighbourhoodIn(lawtonPark, seattle)
∀x (Residentof(x, lawtonPark) → UseZipCode(x, num98199))
ResidentOf(tom, lawtonPark)
UseZipCode(daniel, num98199)

[PREMISE (GK)]:
NeighbourhoodIn(lawtonPark, seattle).
! [X] : (Residentof(X, lawtonPark) => UseZipCode(X, num98199)).
ResidentOf(tom, lawtonPark).
UseZipCode(daniel, num98199).

[CONCLUSION]:
Tom doesn't use the zip code 98199.

[CONCLUSION (FOL)]:
¬UseZipCode(tom, num98199)

[CONCLUSION (GK)]:
-UseZipCode(tom, num98199).


===

['x']
['x']
[PREMISE]:
Lawton Park is a neighborhood in Seattle. 
All citizens of Lawton Park use the zip code 98199. 
Tom is a citizen of Lawton Park.
Daniel uses the zip code 98199. 

[PREMISE (FOL)]:
NeighbourhoodIn(lawtonPark, seattle)
∀x (Residentof(x, lawtonPark) → UseZipCode(x, num98199))
ResidentOf(tom, lawtonPark)
UseZipCode(daniel, num98199)

[PREMISE (GK)]:
NeighbourhoodIn(lawtonPark, seattle).
! [X] : (Residentof(X, lawtonPark) => UseZipCode(X, num98199)).
ResidentOf(tom, lawtonPark).
UseZipCode(daniel, num98199).

[CONCLUSION]:
Tom is a citizen of Washington.

[CONCLUSION (FOL)]:
ResidentOf(tom, washington)

[CONCLUSION (GK)]:
ResidentOf(tom, washington).


===

['x']
['x']
[PREMISE]:
Lawton Park is a neighborhood in Seattle. 
All citizens of Lawton Park use the zip code 98199. 
Tom is a citizen of Lawton Park.
Daniel uses the zip code 98199. 

[PREMISE (FOL)]:
NeighbourhoodIn(lawtonPark, seattle)
∀x (Residentof(x, lawtonPark) → UseZipCode(x, num98199))
ResidentOf(tom, lawtonPark)
UseZipCode(daniel, num98199)

[PREMISE (GK)]:
NeighbourhoodIn(lawtonPark, seattle).
! [X] : (Residentof(X, lawtonPark) => UseZipCode(X, num98199)).
ResidentOf(tom, lawtonPark).
UseZipCode(daniel, num98199).

[CONCLUSION]:
Daniel is a citizen of Lawton Park.

[CONCLUSION (FOL)]:
ResidentOf(daniel, lawtonPark)

[CONCLUSION (GK)]:
ResidentOf(daniel, lawtonPark).


===

['x']
['x']
[PREMISE]:
If a legislator is found guilty of stealing government funds, they will be suspended from office.
Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.
Tiffany T. Alston was found guilty of stealing government funds in 2012.

[PREMISE (FOL)]:
∀x ((Legislator(x) ∧ StealsFunds(x)) → Suspended(x))
Legislator(tiffanyTAlston)
StealsFunds(tiffanyTAlston) ∧ StealsFundsInYr(tiffanyTAlston, yr2012)

[PREMISE (GK)]:
! [X] : ((Legislator(X) & StealsFunds(X)) => Suspended(X)).
Legislator(tiffanyTAlston).
StealsFunds(tiffanyTAlston) & StealsFundsInYr(tiffanyTAlston, yr2012).

[CONCLUSION]:
Tiffany T. Alston was suspended from the Maryland House of Delegates.

[CONCLUSION (FOL)]:
Suspended(tiffanyTAlston)

[CONCLUSION (GK)]:
Suspended(tiffanyTAlston).


===

['x']
['x']
[PREMISE]:
If a legislator is found guilty of stealing government funds, they will be suspended from office.
Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.
Tiffany T. Alston was found guilty of stealing government funds in 2012.

[PREMISE (FOL)]:
∀x ((Legislator(x) ∧ StealsFunds(x)) → Suspended(x))
Legislator(tiffanyTAlston)
StealsFunds(tiffanyTAlston) ∧ StealsFundsInYr(tiffanyTAlston, yr2012)

[PREMISE (GK)]:
! [X] : ((Legislator(X) & StealsFunds(X)) => Suspended(X)).
Legislator(tiffanyTAlston).
StealsFunds(tiffanyTAlston) & StealsFundsInYr(tiffanyTAlston, yr2012).

[CONCLUSION]:
Tiffany T. Alston was not suspended from the Maryland House of Delegates.

[CONCLUSION (FOL)]:
¬Suspended(tiffanyTAlston)

[CONCLUSION (GK)]:
-Suspended(tiffanyTAlston).


===

['x']
['x']
[PREMISE]:
If a legislator is found guilty of stealing government funds, they will be suspended from office.
Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.
Tiffany T. Alston was found guilty of stealing government funds in 2012.

[PREMISE (FOL)]:
∀x ((Legislator(x) ∧ StealsFunds(x)) → Suspended(x))
Legislator(tiffanyTAlston)
StealsFunds(tiffanyTAlston) ∧ StealsFundsInYr(tiffanyTAlston, yr2012)

[PREMISE (GK)]:
! [X] : ((Legislator(X) & StealsFunds(X)) => Suspended(X)).
Legislator(tiffanyTAlston).
StealsFunds(tiffanyTAlston) & StealsFundsInYr(tiffanyTAlston, yr2012).

[CONCLUSION]:
Tiffany T. Alston went to prison for stealing government funds.

[CONCLUSION (FOL)]:
Prison(tiffanyTAlston)

[CONCLUSION (GK)]:
Prison(tiffanyTAlston).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some fish stings people.
Stonefish is a fish.
Stonefish stings when stepped on. 
If a stonefish stings someone and they are not treated, it can cause death to them.
To treat stonefish stings, apply heat to the affected area or use an antivenom.

[PREMISE (FOL)]:
∃x ∃y (Fish(x) → Sting(x,y))
Fish(stonefish)
∀x (SteppedOnBy(stonefish, x) → Sting(stonefish, x))
∀x (Sting(stonefish, x) ∧ ¬Treated(x) → CauseDeathTo(stonefish, x))
∀x (Sting(stonefish, x) ∧ (ApplyHeatTo(x) ∨ UseAntivenomOn(x)) → Treated(x))

[PREMISE (GK)]:
? [X] : ? [Y] : (Fish(X) => Sting(X,Y)).
Fish(stonefish).
! [X] : (SteppedOnBy(stonefish, X) => Sting(stonefish, X)).
! [X] : (Sting(stonefish, X) & -Treated(X) => CauseDeathTo(stonefish, X)).
! [X] : (Sting(stonefish, X) & (ApplyHeatTo(X) | UseAntivenomOn(X)) => Treated(X)).

[CONCLUSION]:
If a stonefish stings you and you don’t use an antivenom, it can cause death to you.

[CONCLUSION (FOL)]:
∀x (Sting(stonefish, x) ∧ ¬UseAntivenomOn(x) → CauseDeathTo(stonefish, x))

[CONCLUSION (GK)]:
! [X] : (Sting(stonefish, X) & -UseAntivenomOn(X) => CauseDeathTo(stonefish, X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some fish stings people.
Stonefish is a fish.
Stonefish stings when stepped on. 
If a stonefish stings someone and they are not treated, it can cause death to them.
To treat stonefish stings, apply heat to the affected area or use an antivenom.

[PREMISE (FOL)]:
∃x ∃y (Fish(x) → Sting(x,y))
Fish(stonefish)
∀x (SteppedOnBy(stonefish, x) → Sting(stonefish, x))
∀x (Sting(stonefish, x) ∧ ¬Treated(x) → CauseDeathTo(stonefish, x))
∀x (Sting(stonefish, x) ∧ (ApplyHeatTo(x) ∨ UseAntivenomOn(x)) → Treated(x))

[PREMISE (GK)]:
? [X] : ? [Y] : (Fish(X) => Sting(X,Y)).
Fish(stonefish).
! [X] : (SteppedOnBy(stonefish, X) => Sting(stonefish, X)).
! [X] : (Sting(stonefish, X) & -Treated(X) => CauseDeathTo(stonefish, X)).
! [X] : (Sting(stonefish, X) & (ApplyHeatTo(X) | UseAntivenomOn(X)) => Treated(X)).

[CONCLUSION]:
Stings of some fish can cause death if not treated.

[CONCLUSION (FOL)]:
∃x ∃y (Fish(x) ∧ Sting(x, y) ∧ ¬Treated(y) → CauseDeathTo(x, y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Fish(X) & Sting(X, Y) & -Treated(Y) => CauseDeathTo(X, Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some fish stings people.
Stonefish is a fish.
Stonefish stings when stepped on. 
If a stonefish stings someone and they are not treated, it can cause death to them.
To treat stonefish stings, apply heat to the affected area or use an antivenom.

[PREMISE (FOL)]:
∃x ∃y (Fish(x) → Sting(x,y))
Fish(stonefish)
∀x (SteppedOnBy(stonefish, x) → Sting(stonefish, x))
∀x (Sting(stonefish, x) ∧ ¬Treated(x) → CauseDeathTo(stonefish, x))
∀x (Sting(stonefish, x) ∧ (ApplyHeatTo(x) ∨ UseAntivenomOn(x)) → Treated(x))

[PREMISE (GK)]:
? [X] : ? [Y] : (Fish(X) => Sting(X,Y)).
Fish(stonefish).
! [X] : (SteppedOnBy(stonefish, X) => Sting(stonefish, X)).
! [X] : (Sting(stonefish, X) & -Treated(X) => CauseDeathTo(stonefish, X)).
! [X] : (Sting(stonefish, X) & (ApplyHeatTo(X) | UseAntivenomOn(X)) => Treated(X)).

[CONCLUSION]:
If you step on a stonefish and apply heat to the affected area, it can cause death to you.

[CONCLUSION (FOL)]:
∀x (SteppedOnBy(stonefish, x) ∧ ApplyHeatTo(x)  → CauseDeathTo(stonefish, x))

[CONCLUSION (GK)]:
! [X] : (SteppedOnBy(stonefish, X) & ApplyHeatTo(X)  => CauseDeathTo(stonefish, X)).


===

['x']
['x']
[PREMISE]:
Some monitors made by LG have a type-c port.
Monitors that have a type-c port were not made before 2010.
All monitors in the library are made before 2010. 
The L-2021 monitor is either used in the library or has a type-c port.
The L-2021 monitor is either both produced before 2010 and made by LG, or neither is true.

[PREMISE (FOL)]:
∃x (Monitor(x) ∧ ProducedBy(x, lG) ∧ Have(x, typeCPort) ∧ (¬(x=y)) ∧ Monitor(y) ∧ ProducedBy(y, lG) ∧ Have(y, typeCPort))
∀x (Have(x, typeCPort) → ¬ProducedBefore(x, yr2010))
∀x ((Monitor(x) ∧ In(x, library)) → ProducedBefore(x, yr2010))
Monitor(l-2021) ∧ (In(l-2021, library) ⊕ Have(l-2021, typeCPort))
¬(ProducedBefore(l-2021, yr2010) ⊕ ProducedBy(l-2021, lG))

[PREMISE (GK)]:
? [X] : (Monitor(X) & ProducedBy(X, lG) & Have(X, typeCPort) & (-(X=y)) & Monitor(y) & ProducedBy(y, lG) & Have(y, typeCPort)).
! [X] : (Have(X, typeCPort) => -ProducedBefore(X, yr2010)).
! [X] : ((Monitor(X) & In(X, library)) => ProducedBefore(X, yr2010)).
Monitor(l-2021) & (In(l-2021, library) <~> Have(l-2021, typeCPort)).
-(ProducedBefore(l-2021, yr2010) <~> ProducedBy(l-2021, lG)).

[CONCLUSION]:
The monitor L-2021 is in the library.

[CONCLUSION (FOL)]:
In(l-2021, library)

[CONCLUSION (GK)]:
In(l-2021, library).


===

['x']
['x']
[PREMISE]:
Some monitors made by LG have a type-c port.
Monitors that have a type-c port were not made before 2010.
All monitors in the library are made before 2010. 
The L-2021 monitor is either used in the library or has a type-c port.
The L-2021 monitor is either both produced before 2010 and made by LG, or neither is true.

[PREMISE (FOL)]:
∃x (Monitor(x) ∧ ProducedBy(x, lG) ∧ Have(x, typeCPort) ∧ (¬(x=y)) ∧ Monitor(y) ∧ ProducedBy(y, lG) ∧ Have(y, typeCPort))
∀x (Have(x, typeCPort) → ¬ProducedBefore(x, yr2010))
∀x ((Monitor(x) ∧ In(x, library)) → ProducedBefore(x, yr2010))
Monitor(l-2021) ∧ (In(l-2021, library) ⊕ Have(l-2021, typeCPort))
¬(ProducedBefore(l-2021, yr2010) ⊕ ProducedBy(l-2021, lG))

[PREMISE (GK)]:
? [X] : (Monitor(X) & ProducedBy(X, lG) & Have(X, typeCPort) & (-(X=y)) & Monitor(y) & ProducedBy(y, lG) & Have(y, typeCPort)).
! [X] : (Have(X, typeCPort) => -ProducedBefore(X, yr2010)).
! [X] : ((Monitor(X) & In(X, library)) => ProducedBefore(X, yr2010)).
Monitor(l-2021) & (In(l-2021, library) <~> Have(l-2021, typeCPort)).
-(ProducedBefore(l-2021, yr2010) <~> ProducedBy(l-2021, lG)).

[CONCLUSION]:
The monitor L-2021 is either in the library or produced by LG.

[CONCLUSION (FOL)]:
In(l-2021, library) ⊕ ProducedBy(l-2021, lG)

[CONCLUSION (GK)]:
In(l-2021, library) <~> ProducedBy(l-2021, lG).


===

['x']
['x']
[PREMISE]:
Some monitors made by LG have a type-c port.
Monitors that have a type-c port were not made before 2010.
All monitors in the library are made before 2010. 
The L-2021 monitor is either used in the library or has a type-c port.
The L-2021 monitor is either both produced before 2010 and made by LG, or neither is true.

[PREMISE (FOL)]:
∃x (Monitor(x) ∧ ProducedBy(x, lG) ∧ Have(x, typeCPort) ∧ (¬(x=y)) ∧ Monitor(y) ∧ ProducedBy(y, lG) ∧ Have(y, typeCPort))
∀x (Have(x, typeCPort) → ¬ProducedBefore(x, yr2010))
∀x ((Monitor(x) ∧ In(x, library)) → ProducedBefore(x, yr2010))
Monitor(l-2021) ∧ (In(l-2021, library) ⊕ Have(l-2021, typeCPort))
¬(ProducedBefore(l-2021, yr2010) ⊕ ProducedBy(l-2021, lG))

[PREMISE (GK)]:
? [X] : (Monitor(X) & ProducedBy(X, lG) & Have(X, typeCPort) & (-(X=y)) & Monitor(y) & ProducedBy(y, lG) & Have(y, typeCPort)).
! [X] : (Have(X, typeCPort) => -ProducedBefore(X, yr2010)).
! [X] : ((Monitor(X) & In(X, library)) => ProducedBefore(X, yr2010)).
Monitor(l-2021) & (In(l-2021, library) <~> Have(l-2021, typeCPort)).
-(ProducedBefore(l-2021, yr2010) <~> ProducedBy(l-2021, lG)).

[CONCLUSION]:
The L-2021 monitor either has a type-c port or is produced by LG.

[CONCLUSION (FOL)]:
Have(l-2021, typeCPort) ⊕ ProducedBy(l-2021, lG)

[CONCLUSION (GK)]:
Have(l-2021, typeCPort) <~> ProducedBy(l-2021, lG).


===

['x']
['x']
[PREMISE]:
Some monitors made by LG have a type-c port.
Monitors that have a type-c port were not made before 2010.
All monitors in the library are made before 2010. 
The L-2021 monitor is either used in the library or has a type-c port.
The L-2021 monitor is either both produced before 2010 and made by LG, or neither is true.

[PREMISE (FOL)]:
∃x (Monitor(x) ∧ ProducedBy(x, lG) ∧ Have(x, typeCPort) ∧ (¬(x=y)) ∧ Monitor(y) ∧ ProducedBy(y, lG) ∧ Have(y, typeCPort))
∀x (Have(x, typeCPort) → ¬ProducedBefore(x, yr2010))
∀x ((Monitor(x) ∧ In(x, library)) → ProducedBefore(x, yr2010))
Monitor(l-2021) ∧ (In(l-2021, library) ⊕ Have(l-2021, typeCPort))
¬(ProducedBefore(l-2021, yr2010) ⊕ ProducedBy(l-2021, lG))

[PREMISE (GK)]:
? [X] : (Monitor(X) & ProducedBy(X, lG) & Have(X, typeCPort) & (-(X=y)) & Monitor(y) & ProducedBy(y, lG) & Have(y, typeCPort)).
! [X] : (Have(X, typeCPort) => -ProducedBefore(X, yr2010)).
! [X] : ((Monitor(X) & In(X, library)) => ProducedBefore(X, yr2010)).
Monitor(l-2021) & (In(l-2021, library) <~> Have(l-2021, typeCPort)).
-(ProducedBefore(l-2021, yr2010) <~> ProducedBy(l-2021, lG)).

[CONCLUSION]:
If the L-2021 monitor is either in the library and produced by LG, or neither in the library nor produced by LG,  then L-2021 neither has a type-c port nor is produced by LG.

[CONCLUSION (FOL)]:
¬(In(l-2021, library) ⊕ ProducedBy(l-2021, lG)) → (¬Have(x, typeCPort) ∧ ¬ProducedBy(x, lG))

[CONCLUSION (GK)]:
-(In(l-2021, library) <~> ProducedBy(l-2021, lG)) => (-Have(X, typeCPort) & -ProducedBy(X, lG)).


===

['x']
['x']
[PREMISE]:
Some monitors made by LG have a type-c port.
Monitors that have a type-c port were not made before 2010.
All monitors in the library are made before 2010. 
The L-2021 monitor is either used in the library or has a type-c port.
The L-2021 monitor is either both produced before 2010 and made by LG, or neither is true.

[PREMISE (FOL)]:
∃x (Monitor(x) ∧ ProducedBy(x, lG) ∧ Have(x, typeCPort) ∧ (¬(x=y)) ∧ Monitor(y) ∧ ProducedBy(y, lG) ∧ Have(y, typeCPort))
∀x (Have(x, typeCPort) → ¬ProducedBefore(x, yr2010))
∀x ((Monitor(x) ∧ In(x, library)) → ProducedBefore(x, yr2010))
Monitor(l-2021) ∧ (In(l-2021, library) ⊕ Have(l-2021, typeCPort))
¬(ProducedBefore(l-2021, yr2010) ⊕ ProducedBy(l-2021, lG))

[PREMISE (GK)]:
? [X] : (Monitor(X) & ProducedBy(X, lG) & Have(X, typeCPort) & (-(X=y)) & Monitor(y) & ProducedBy(y, lG) & Have(y, typeCPort)).
! [X] : (Have(X, typeCPort) => -ProducedBefore(X, yr2010)).
! [X] : ((Monitor(X) & In(X, library)) => ProducedBefore(X, yr2010)).
Monitor(l-2021) & (In(l-2021, library) <~> Have(l-2021, typeCPort)).
-(ProducedBefore(l-2021, yr2010) <~> ProducedBy(l-2021, lG)).

[CONCLUSION]:
If the monitor L-2021 is either produced by LG and produced before 2010 or neither produced by LG nor produced before 2010,  then L-2021 is either in the library or produced by LG.

[CONCLUSION (FOL)]:
¬(ProducedBefore(l-2021, year2010) ⊕ ProducedBy(l-2021, lG)) → (In(l-2021, library) ⊕ ProducedBy(l-2021, lG))

[CONCLUSION (GK)]:
-(ProducedBefore(l-2021, year2010) <~> ProducedBy(l-2021, lG)) => (In(l-2021, library) <~> ProducedBy(l-2021, lG)).


===

['x']
['x']
[PREMISE]:
Everything is either outside the solar system or in the solar system. 
Nothing outside the solar system has the Sun as its star.
Everything in the solar system is gravitationally bound by the Sun.
No planets gravitationally bound by the Sun are rogue planets. 
All orphan planets are rogue planets.
If PSO J318.5−22 is not both a rogue planet and a planet gravitationally bound by the Sun, then it is a rogue planet.

[PREMISE (FOL)]:
∀x (Outside(x, solarSystem) ⊕ In(x, solarSystem))
∀x (Outside(x, solarSystem) → ¬SunAs(x, star))
∀x (In(x, solarSystem) → BoundBy(x, sun, gravitationally))
∀x (Planet(x) ∧ BoundBy(x, sun, gravitationally) → ¬(Planet(x) ∧ Rogue(x)))
∀x (Planet(x) ∧ Orphan(x) → Planet(x) ∧ Rogue(x))
¬(Planet(pSOJ318.5-22) ∧ Rogue(pSOJ318.5-22) ∧ BoundBy(pSOJ318.5-22, sun, gravitationally)) → (Planet(pSOJ318.5-22) ∧ Rogue(pSOJ318.5-22))

[PREMISE (GK)]:
! [X] : (Outside(X, solarSystem) <~> In(X, solarSystem)).
! [X] : (Outside(X, solarSystem) => -SunAs(X, star)).
! [X] : (In(X, solarSystem) => BoundBy(X, sun, gravitationally)).
! [X] : (Planet(X) & BoundBy(X, sun, gravitationally) => -(Planet(X) & Rogue(X))).
! [X] : (Planet(X) & Orphan(X) => Planet(X) & Rogue(X)).
-(Planet(pSOJ318.5-22) & Rogue(pSOJ318.5-22) & BoundBy(pSOJ318.5-22, sun, gravitationally)) => (Planet(pSOJ318.5-22) & Rogue(pSOJ318.5-22)).

[CONCLUSION]:
PSO J318.5−22 is an orphan planet.

[CONCLUSION (FOL)]:
Planet(pSOJ318.5-22) ∧ Orphan(pSOJ318.5-22)

[CONCLUSION (GK)]:
Planet(pSOJ318.5-22) & Orphan(pSOJ318.5-22).


===

['x']
['x']
[PREMISE]:
Everything is either outside the solar system or in the solar system. 
Nothing outside the solar system has the Sun as its star.
Everything in the solar system is gravitationally bound by the Sun.
No planets gravitationally bound by the Sun are rogue planets. 
All orphan planets are rogue planets.
If PSO J318.5−22 is not both a rogue planet and a planet gravitationally bound by the Sun, then it is a rogue planet.

[PREMISE (FOL)]:
∀x (Outside(x, solarSystem) ⊕ In(x, solarSystem))
∀x (Outside(x, solarSystem) → ¬SunAs(x, star))
∀x (In(x, solarSystem) → BoundBy(x, sun, gravitationally))
∀x (Planet(x) ∧ BoundBy(x, sun, gravitationally) → ¬(Planet(x) ∧ Rogue(x)))
∀x (Planet(x) ∧ Orphan(x) → Planet(x) ∧ Rogue(x))
¬(Planet(pSOJ318.5-22) ∧ Rogue(pSOJ318.5-22) ∧ BoundBy(pSOJ318.5-22, sun, gravitationally)) → (Planet(pSOJ318.5-22) ∧ Rogue(pSOJ318.5-22))

[PREMISE (GK)]:
! [X] : (Outside(X, solarSystem) <~> In(X, solarSystem)).
! [X] : (Outside(X, solarSystem) => -SunAs(X, star)).
! [X] : (In(X, solarSystem) => BoundBy(X, sun, gravitationally)).
! [X] : (Planet(X) & BoundBy(X, sun, gravitationally) => -(Planet(X) & Rogue(X))).
! [X] : (Planet(X) & Orphan(X) => Planet(X) & Rogue(X)).
-(Planet(pSOJ318.5-22) & Rogue(pSOJ318.5-22) & BoundBy(pSOJ318.5-22, sun, gravitationally)) => (Planet(pSOJ318.5-22) & Rogue(pSOJ318.5-22)).

[CONCLUSION]:
PSO J318.5−22 is an orphan planet or it does not have the Sun as its star, or both.

[CONCLUSION (FOL)]:
(Planet(pSOJ318.5-22) ∧ Orphan(pSOJ318.5-22)) ∨ ¬SunAs(pSOJ318.5-22, star)

[CONCLUSION (GK)]:
(Planet(pSOJ318.5-22) & Orphan(pSOJ318.5-22)) | -SunAs(pSOJ318.5-22, star).


===

['x']
['x']
[PREMISE]:
Everything is either outside the solar system or in the solar system. 
Nothing outside the solar system has the Sun as its star.
Everything in the solar system is gravitationally bound by the Sun.
No planets gravitationally bound by the Sun are rogue planets. 
All orphan planets are rogue planets.
If PSO J318.5−22 is not both a rogue planet and a planet gravitationally bound by the Sun, then it is a rogue planet.

[PREMISE (FOL)]:
∀x (Outside(x, solarSystem) ⊕ In(x, solarSystem))
∀x (Outside(x, solarSystem) → ¬SunAs(x, star))
∀x (In(x, solarSystem) → BoundBy(x, sun, gravitationally))
∀x (Planet(x) ∧ BoundBy(x, sun, gravitationally) → ¬(Planet(x) ∧ Rogue(x)))
∀x (Planet(x) ∧ Orphan(x) → Planet(x) ∧ Rogue(x))
¬(Planet(pSOJ318.5-22) ∧ Rogue(pSOJ318.5-22) ∧ BoundBy(pSOJ318.5-22, sun, gravitationally)) → (Planet(pSOJ318.5-22) ∧ Rogue(pSOJ318.5-22))

[PREMISE (GK)]:
! [X] : (Outside(X, solarSystem) <~> In(X, solarSystem)).
! [X] : (Outside(X, solarSystem) => -SunAs(X, star)).
! [X] : (In(X, solarSystem) => BoundBy(X, sun, gravitationally)).
! [X] : (Planet(X) & BoundBy(X, sun, gravitationally) => -(Planet(X) & Rogue(X))).
! [X] : (Planet(X) & Orphan(X) => Planet(X) & Rogue(X)).
-(Planet(pSOJ318.5-22) & Rogue(pSOJ318.5-22) & BoundBy(pSOJ318.5-22, sun, gravitationally)) => (Planet(pSOJ318.5-22) & Rogue(pSOJ318.5-22)).

[CONCLUSION]:
If PSO J318.5−22 is an orphan planet or it does not have the Sun as the star, or both, then PSO J318.5−22 neither is an orphan planet nor does it have the Sun as the star.

[CONCLUSION (FOL)]:
(Planet(pSOJ318.5-22) ∧ Orphan(pSOJ318.5-22)) ∨ ¬SunAs(pSOJ318.5-22, star) → (¬(Planet(pSOJ318.5-22) ∧ Orphan(pSOJ318.5-22)) ∧ ¬SunAs(pSOJ318.5-22, star))

[CONCLUSION (GK)]:
(Planet(pSOJ318.5-22) & Orphan(pSOJ318.5-22)) | -SunAs(pSOJ318.5-22, star) => (-(Planet(pSOJ318.5-22) & Orphan(pSOJ318.5-22)) & -SunAs(pSOJ318.5-22, star)).


===

['x']
['x']
[PREMISE]:
Sam is doing a project.
A project is written either in C++ or Python.
If Sam does a project written in Python, he will not use a Mac.
Sam is using a Mac.
If Sam uses a Mac, he will play a song.
If a song is not titled "Perfect," Sam will never play it.

[PREMISE (FOL)]:
∃x (Project(x) ∧ Do(sam, x))
∀x (Project(x) → (WrittenIn(x, cplusplus) ⊕ WrittenIn(x, python)))
∀x (Project(x) ∧ WrittenIn(x, python) ∧ Do(sam, x) → ¬Use(sam, mac))
Use(sam, mac)
∃x (Use(sam, mac) ∧ Song(x) → Play(sam, x))
∀x (Song(x) ∧ Play(sam, x) → Titled(x, perfect))

[PREMISE (GK)]:
? [X] : (Project(X) & Do(sam, X)).
! [X] : (Project(X) => (WrittenIn(X, cplusplus) <~> WrittenIn(X, python))).
! [X] : (Project(X) & WrittenIn(X, python) & Do(sam, X) => -Use(sam, mac)).
Use(sam, mac).
? [X] : (Use(sam, mac) & Song(X) => Play(sam, X)).
! [X] : (Song(X) & Play(sam, X) => Titled(X, perfect)).

[CONCLUSION]:
The project Sam is doing is written in C++.

[CONCLUSION (FOL)]:
∀x (Project(x) ∧ Do(sam, x) ∧ WrittenIn(x, cplusplus))

[CONCLUSION (GK)]:
! [X] : (Project(X) & Do(sam, X) & WrittenIn(X, cplusplus)).


===

['x']
['x']
[PREMISE]:
Sam is doing a project.
A project is written either in C++ or Python.
If Sam does a project written in Python, he will not use a Mac.
Sam is using a Mac.
If Sam uses a Mac, he will play a song.
If a song is not titled "Perfect," Sam will never play it.

[PREMISE (FOL)]:
∃x (Project(x) ∧ Do(sam, x))
∀x (Project(x) → (WrittenIn(x, cplusplus) ⊕ WrittenIn(x, python)))
∀x (Project(x) ∧ WrittenIn(x, python) ∧ Do(sam, x) → ¬Use(sam, mac))
Use(sam, mac)
∃x (Use(sam, mac) ∧ Song(x) → Play(sam, x))
∀x (Song(x) ∧ Play(sam, x) → Titled(x, perfect))

[PREMISE (GK)]:
? [X] : (Project(X) & Do(sam, X)).
! [X] : (Project(X) => (WrittenIn(X, cplusplus) <~> WrittenIn(X, python))).
! [X] : (Project(X) & WrittenIn(X, python) & Do(sam, X) => -Use(sam, mac)).
Use(sam, mac).
? [X] : (Use(sam, mac) & Song(X) => Play(sam, X)).
! [X] : (Song(X) & Play(sam, X) => Titled(X, perfect)).

[CONCLUSION]:
The song Sam is playing is titled "Perfect".

[CONCLUSION (FOL)]:
∀x (Song(x) ∧ Play(sam, x) ∧ Titled(x, perfect))

[CONCLUSION (GK)]:
! [X] : (Song(X) & Play(sam, X) & Titled(X, perfect)).


===

['x']
['x']
[PREMISE]:
Sam is doing a project.
A project is written either in C++ or Python.
If Sam does a project written in Python, he will not use a Mac.
Sam is using a Mac.
If Sam uses a Mac, he will play a song.
If a song is not titled "Perfect," Sam will never play it.

[PREMISE (FOL)]:
∃x (Project(x) ∧ Do(sam, x))
∀x (Project(x) → (WrittenIn(x, cplusplus) ⊕ WrittenIn(x, python)))
∀x (Project(x) ∧ WrittenIn(x, python) ∧ Do(sam, x) → ¬Use(sam, mac))
Use(sam, mac)
∃x (Use(sam, mac) ∧ Song(x) → Play(sam, x))
∀x (Song(x) ∧ Play(sam, x) → Titled(x, perfect))

[PREMISE (GK)]:
? [X] : (Project(X) & Do(sam, X)).
! [X] : (Project(X) => (WrittenIn(X, cplusplus) <~> WrittenIn(X, python))).
! [X] : (Project(X) & WrittenIn(X, python) & Do(sam, X) => -Use(sam, mac)).
Use(sam, mac).
? [X] : (Use(sam, mac) & Song(X) => Play(sam, X)).
! [X] : (Song(X) & Play(sam, X) => Titled(X, perfect)).

[CONCLUSION]:
If a song is titled "Perfect", Sam will play it.

[CONCLUSION (FOL)]:
∀x (Titled(x, perfect) → Play(sam, x))

[CONCLUSION (GK)]:
! [X] : (Titled(X, perfect) => Play(sam, X)).


===

['x']
['x', 'y']
[PREMISE]:
All rabbits have fur
Some pets are rabbits.

[PREMISE (FOL)]:
∀x (Rabbit(x) → Have(x, fur))
∃x (Pet(x) ∧ Rabbit(x))

[PREMISE (GK)]:
! [X] : (Rabbit(X) => Have(X, fur)).
? [X] : (Pet(X) & Rabbit(X)).

[CONCLUSION]:
Some pets do not have fur.

[CONCLUSION (FOL)]:
∃x ∃y (Pet(x) ∧ Pet(y) ∧ ¬Have(x, fur) ∧ ¬Have(y, fur))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Pet(X) & Pet(Y) & -Have(X, fur) & -Have(Y, fur)).


===

['x']
['x']
[PREMISE]:
All social media applications containing chat features are software. 
All social media applications that allow users to send messages to each other have chat features. 
All social media applications have chat features or video features. 
All social media applications that have video features allow users to upload videos. 
All software that is social media applications are computer programs. 
All social media applications that have high engagement metrics are addictive. 
If a social media application is addictive, then it is not ideal for preteens. 
TikTok is a social media application, and it is not ideal for preteens. 

[PREMISE (FOL)]:
∀x (SocialMedia(x) ∧ Application(x) ∧ Contain(x, chatFeature) → Software(x))
∀x (SocialMedia(x) ∧ Application(x) ∧ AllowToSendTo(x, user, message) → Contain(x, chatFeature))
∀x (SocialMedia(x) ∧ Application(x) → Contain(x, chatFeature) ∨ Contain(x, videoFeature))
∀x (SocialMedia(x) ∧ Application(x) ∧ Contain(x, videoFeature) → Allow(x, user, uploadVideo))
∀x (SocialMedia(x) ∧ Application(x) ∧ Software(x) → ComputerProgram(x))
∀x (SocialMedia(x) ∧ Application(x) ∧Have(x, highEngagementMetric) → Addictive(x))
∀x (SocialMedia(x) ∧ Application(x) ∧ Addictive(x) → ¬IdealFor(x, preteen))
SocialMedia(tikTok) ∧ Application(tikTok) ∧ ¬IdealFor(tikTok, preteen)

[PREMISE (GK)]:
! [X] : (SocialMedia(X) & Application(X) & Contain(X, chatFeature) => Software(X)).
! [X] : (SocialMedia(X) & Application(X) & AllowToSendTo(X, user, message) => Contain(X, chatFeature)).
! [X] : (SocialMedia(X) & Application(X) => Contain(X, chatFeature) | Contain(X, videoFeature)).
! [X] : (SocialMedia(X) & Application(X) & Contain(X, videoFeature) => Allow(X, user, uploadVideo)).
! [X] : (SocialMedia(X) & Application(X) & Software(X) => ComputerProgram(X)).
! [X] : (SocialMedia(X) & Application(X) &Have(X, highEngagementMetric) => Addictive(X)).
! [X] : (SocialMedia(X) & Application(X) & Addictive(X) => -IdealFor(X, preteen)).
SocialMedia(tikTok) & Application(tikTok) & -IdealFor(tikTok, preteen).

[CONCLUSION]:
TikTok is a computer program.

[CONCLUSION (FOL)]:
ComputerProgram(tikTok)

[CONCLUSION (GK)]:
ComputerProgram(tikTok).


===

['x']
['x']
[PREMISE]:
All social media applications containing chat features are software. 
All social media applications that allow users to send messages to each other have chat features. 
All social media applications have chat features or video features. 
All social media applications that have video features allow users to upload videos. 
All software that is social media applications are computer programs. 
All social media applications that have high engagement metrics are addictive. 
If a social media application is addictive, then it is not ideal for preteens. 
TikTok is a social media application, and it is not ideal for preteens. 

[PREMISE (FOL)]:
∀x (SocialMedia(x) ∧ Application(x) ∧ Contain(x, chatFeature) → Software(x))
∀x (SocialMedia(x) ∧ Application(x) ∧ AllowToSendTo(x, user, message) → Contain(x, chatFeature))
∀x (SocialMedia(x) ∧ Application(x) → Contain(x, chatFeature) ∨ Contain(x, videoFeature))
∀x (SocialMedia(x) ∧ Application(x) ∧ Contain(x, videoFeature) → Allow(x, user, uploadVideo))
∀x (SocialMedia(x) ∧ Application(x) ∧ Software(x) → ComputerProgram(x))
∀x (SocialMedia(x) ∧ Application(x) ∧Have(x, highEngagementMetric) → Addictive(x))
∀x (SocialMedia(x) ∧ Application(x) ∧ Addictive(x) → ¬IdealFor(x, preteen))
SocialMedia(tikTok) ∧ Application(tikTok) ∧ ¬IdealFor(tikTok, preteen)

[PREMISE (GK)]:
! [X] : (SocialMedia(X) & Application(X) & Contain(X, chatFeature) => Software(X)).
! [X] : (SocialMedia(X) & Application(X) & AllowToSendTo(X, user, message) => Contain(X, chatFeature)).
! [X] : (SocialMedia(X) & Application(X) => Contain(X, chatFeature) | Contain(X, videoFeature)).
! [X] : (SocialMedia(X) & Application(X) & Contain(X, videoFeature) => Allow(X, user, uploadVideo)).
! [X] : (SocialMedia(X) & Application(X) & Software(X) => ComputerProgram(X)).
! [X] : (SocialMedia(X) & Application(X) &Have(X, highEngagementMetric) => Addictive(X)).
! [X] : (SocialMedia(X) & Application(X) & Addictive(X) => -IdealFor(X, preteen)).
SocialMedia(tikTok) & Application(tikTok) & -IdealFor(tikTok, preteen).

[CONCLUSION]:
TikTok is either ideal for preteens or a computer program.

[CONCLUSION (FOL)]:
IdealFor(tikTok, preteen) ⊕ ComputerProgram(tikTok)

[CONCLUSION (GK)]:
IdealFor(tikTok, preteen) <~> ComputerProgram(tikTok).


===

['x']
['x']
[PREMISE]:
All social media applications containing chat features are software. 
All social media applications that allow users to send messages to each other have chat features. 
All social media applications have chat features or video features. 
All social media applications that have video features allow users to upload videos. 
All software that is social media applications are computer programs. 
All social media applications that have high engagement metrics are addictive. 
If a social media application is addictive, then it is not ideal for preteens. 
TikTok is a social media application, and it is not ideal for preteens. 

[PREMISE (FOL)]:
∀x (SocialMedia(x) ∧ Application(x) ∧ Contain(x, chatFeature) → Software(x))
∀x (SocialMedia(x) ∧ Application(x) ∧ AllowToSendTo(x, user, message) → Contain(x, chatFeature))
∀x (SocialMedia(x) ∧ Application(x) → Contain(x, chatFeature) ∨ Contain(x, videoFeature))
∀x (SocialMedia(x) ∧ Application(x) ∧ Contain(x, videoFeature) → Allow(x, user, uploadVideo))
∀x (SocialMedia(x) ∧ Application(x) ∧ Software(x) → ComputerProgram(x))
∀x (SocialMedia(x) ∧ Application(x) ∧Have(x, highEngagementMetric) → Addictive(x))
∀x (SocialMedia(x) ∧ Application(x) ∧ Addictive(x) → ¬IdealFor(x, preteen))
SocialMedia(tikTok) ∧ Application(tikTok) ∧ ¬IdealFor(tikTok, preteen)

[PREMISE (GK)]:
! [X] : (SocialMedia(X) & Application(X) & Contain(X, chatFeature) => Software(X)).
! [X] : (SocialMedia(X) & Application(X) & AllowToSendTo(X, user, message) => Contain(X, chatFeature)).
! [X] : (SocialMedia(X) & Application(X) => Contain(X, chatFeature) | Contain(X, videoFeature)).
! [X] : (SocialMedia(X) & Application(X) & Contain(X, videoFeature) => Allow(X, user, uploadVideo)).
! [X] : (SocialMedia(X) & Application(X) & Software(X) => ComputerProgram(X)).
! [X] : (SocialMedia(X) & Application(X) &Have(X, highEngagementMetric) => Addictive(X)).
! [X] : (SocialMedia(X) & Application(X) & Addictive(X) => -IdealFor(X, preteen)).
SocialMedia(tikTok) & Application(tikTok) & -IdealFor(tikTok, preteen).

[CONCLUSION]:
TikTok is does not have chat features or it is not a computer program.

[CONCLUSION (FOL)]:
¬Contain(tikTok, chatFeature) ∨ ¬ComputerProgram(tikTok))

[CONCLUSION (GK)]:
-Contain(tikTok, chatFeature) | -ComputerProgram(tikTok)).


===

['x']
['x']
[PREMISE]:
All social media applications containing chat features are software. 
All social media applications that allow users to send messages to each other have chat features. 
All social media applications have chat features or video features. 
All social media applications that have video features allow users to upload videos. 
All software that is social media applications are computer programs. 
All social media applications that have high engagement metrics are addictive. 
If a social media application is addictive, then it is not ideal for preteens. 
TikTok is a social media application, and it is not ideal for preteens. 

[PREMISE (FOL)]:
∀x (SocialMedia(x) ∧ Application(x) ∧ Contain(x, chatFeature) → Software(x))
∀x (SocialMedia(x) ∧ Application(x) ∧ AllowToSendTo(x, user, message) → Contain(x, chatFeature))
∀x (SocialMedia(x) ∧ Application(x) → Contain(x, chatFeature) ∨ Contain(x, videoFeature))
∀x (SocialMedia(x) ∧ Application(x) ∧ Contain(x, videoFeature) → Allow(x, user, uploadVideo))
∀x (SocialMedia(x) ∧ Application(x) ∧ Software(x) → ComputerProgram(x))
∀x (SocialMedia(x) ∧ Application(x) ∧Have(x, highEngagementMetric) → Addictive(x))
∀x (SocialMedia(x) ∧ Application(x) ∧ Addictive(x) → ¬IdealFor(x, preteen))
SocialMedia(tikTok) ∧ Application(tikTok) ∧ ¬IdealFor(tikTok, preteen)

[PREMISE (GK)]:
! [X] : (SocialMedia(X) & Application(X) & Contain(X, chatFeature) => Software(X)).
! [X] : (SocialMedia(X) & Application(X) & AllowToSendTo(X, user, message) => Contain(X, chatFeature)).
! [X] : (SocialMedia(X) & Application(X) => Contain(X, chatFeature) | Contain(X, videoFeature)).
! [X] : (SocialMedia(X) & Application(X) & Contain(X, videoFeature) => Allow(X, user, uploadVideo)).
! [X] : (SocialMedia(X) & Application(X) & Software(X) => ComputerProgram(X)).
! [X] : (SocialMedia(X) & Application(X) &Have(X, highEngagementMetric) => Addictive(X)).
! [X] : (SocialMedia(X) & Application(X) & Addictive(X) => -IdealFor(X, preteen)).
SocialMedia(tikTok) & Application(tikTok) & -IdealFor(tikTok, preteen).

[CONCLUSION]:
TikTok either has chat features or is a computer program.

[CONCLUSION (FOL)]:
Contain(tikTok, chatFeature) ⊕ ComputerProgram(tikTok))

[CONCLUSION (GK)]:
Contain(tikTok, chatFeature) <~> ComputerProgram(tikTok)).


===

[]
['x']
[PREMISE]:
Ordinary is an unincorporated community.
Located within Elliot County, Ordinary is on Kentucky Route 32.
Ordinary is located northwest of Sandy Hook.

[PREMISE (FOL)]:
UnincorporatedCommunity(ordinary)
LocatedIn(ordinary, elliotCounty) ∧ On(ordinary, kentuckyRoute32)
LocatedNorthwestOf(ordinary, sandyHook)

[PREMISE (GK)]:
UnincorporatedCommunity(ordinary).
LocatedIn(ordinary, elliotCounty) & On(ordinary, kentuckyRoute32).
LocatedNorthwestOf(ordinary, sandyHook).

[CONCLUSION]:
There are no unincorporated communities along Kentucky Route 32.

[CONCLUSION (FOL)]:
∀x (On(x, kentuckyRoute32) → ¬UnincorporatedCommunity(x))

[CONCLUSION (GK)]:
! [X] : (On(X, kentuckyRoute32) => -UnincorporatedCommunity(X)).


===

[]
['x']
[PREMISE]:
Ordinary is an unincorporated community.
Located within Elliot County, Ordinary is on Kentucky Route 32.
Ordinary is located northwest of Sandy Hook.

[PREMISE (FOL)]:
UnincorporatedCommunity(ordinary)
LocatedIn(ordinary, elliotCounty) ∧ On(ordinary, kentuckyRoute32)
LocatedNorthwestOf(ordinary, sandyHook)

[PREMISE (GK)]:
UnincorporatedCommunity(ordinary).
LocatedIn(ordinary, elliotCounty) & On(ordinary, kentuckyRoute32).
LocatedNorthwestOf(ordinary, sandyHook).

[CONCLUSION]:
There is an unincorporated community located in Elliot County.

[CONCLUSION (FOL)]:
∃x (UnincorporatedCommunity(x) ∧ LocatedIn(x, elliotCounty))

[CONCLUSION (GK)]:
? [X] : (UnincorporatedCommunity(X) & LocatedIn(X, elliotCounty)).


===

['x']
['x']
[PREMISE]:
All young adults at the event like independence.
All college students at the event are young adults.
All Yale students at the event are college students.
Everyone at the event is a Yale student or a Harvard student.
All Harvard students at the event are diligent.
Susan is at the event, and if Susan is a Harvard student, then she is a young adult.
If Susan is a Yale student, then she does not like independence.

[PREMISE (FOL)]:
∀x (At(x, event) ∧ YoungAdult(x) → Like(x, independence))
∀x (At(x, event) ∧ CollegeStudent(x) → YoungAdult(x))
∀x (At(x, event) ∧ YaleStudent(x) → CollegeStudent(x))
∀x (At(x, event) → (YaleStudent(x) ⊕ HarvardStudent(x)))
∀x (At(x, event) ∧ HarvardStudent(x) → Diligent(x))
At(susan, event) ∧ (HarvardStudent(susan) → YoungAdult(susan))
YaleStudent(susan) → ¬Like(susan, independence)

[PREMISE (GK)]:
! [X] : (At(X, event) & YoungAdult(X) => Like(X, independence)).
! [X] : (At(X, event) & CollegeStudent(X) => YoungAdult(X)).
! [X] : (At(X, event) & YaleStudent(X) => CollegeStudent(X)).
! [X] : (At(X, event) => (YaleStudent(X) <~> HarvardStudent(X))).
! [X] : (At(X, event) & HarvardStudent(X) => Diligent(X)).
At(susan, event) & (HarvardStudent(susan) => YoungAdult(susan)).
YaleStudent(susan) => -Like(susan, independence).

[CONCLUSION]:
Susan is a college student.

[CONCLUSION (FOL)]:
CollegeStudent(susan)

[CONCLUSION (GK)]:
CollegeStudent(susan).


===

['x']
['x']
[PREMISE]:
All young adults at the event like independence.
All college students at the event are young adults.
All Yale students at the event are college students.
Everyone at the event is a Yale student or a Harvard student.
All Harvard students at the event are diligent.
Susan is at the event, and if Susan is a Harvard student, then she is a young adult.
If Susan is a Yale student, then she does not like independence.

[PREMISE (FOL)]:
∀x (At(x, event) ∧ YoungAdult(x) → Like(x, independence))
∀x (At(x, event) ∧ CollegeStudent(x) → YoungAdult(x))
∀x (At(x, event) ∧ YaleStudent(x) → CollegeStudent(x))
∀x (At(x, event) → (YaleStudent(x) ⊕ HarvardStudent(x)))
∀x (At(x, event) ∧ HarvardStudent(x) → Diligent(x))
At(susan, event) ∧ (HarvardStudent(susan) → YoungAdult(susan))
YaleStudent(susan) → ¬Like(susan, independence)

[PREMISE (GK)]:
! [X] : (At(X, event) & YoungAdult(X) => Like(X, independence)).
! [X] : (At(X, event) & CollegeStudent(X) => YoungAdult(X)).
! [X] : (At(X, event) & YaleStudent(X) => CollegeStudent(X)).
! [X] : (At(X, event) => (YaleStudent(X) <~> HarvardStudent(X))).
! [X] : (At(X, event) & HarvardStudent(X) => Diligent(X)).
At(susan, event) & (HarvardStudent(susan) => YoungAdult(susan)).
YaleStudent(susan) => -Like(susan, independence).

[CONCLUSION]:
Susan likes independence and is diligent.

[CONCLUSION (FOL)]:
Like(susan, independence) ∧ Diligent(susan)

[CONCLUSION (GK)]:
Like(susan, independence) & Diligent(susan).


===

['x']
['x']
[PREMISE]:
All young adults at the event like independence.
All college students at the event are young adults.
All Yale students at the event are college students.
Everyone at the event is a Yale student or a Harvard student.
All Harvard students at the event are diligent.
Susan is at the event, and if Susan is a Harvard student, then she is a young adult.
If Susan is a Yale student, then she does not like independence.

[PREMISE (FOL)]:
∀x (At(x, event) ∧ YoungAdult(x) → Like(x, independence))
∀x (At(x, event) ∧ CollegeStudent(x) → YoungAdult(x))
∀x (At(x, event) ∧ YaleStudent(x) → CollegeStudent(x))
∀x (At(x, event) → (YaleStudent(x) ⊕ HarvardStudent(x)))
∀x (At(x, event) ∧ HarvardStudent(x) → Diligent(x))
At(susan, event) ∧ (HarvardStudent(susan) → YoungAdult(susan))
YaleStudent(susan) → ¬Like(susan, independence)

[PREMISE (GK)]:
! [X] : (At(X, event) & YoungAdult(X) => Like(X, independence)).
! [X] : (At(X, event) & CollegeStudent(X) => YoungAdult(X)).
! [X] : (At(X, event) & YaleStudent(X) => CollegeStudent(X)).
! [X] : (At(X, event) => (YaleStudent(X) <~> HarvardStudent(X))).
! [X] : (At(X, event) & HarvardStudent(X) => Diligent(X)).
At(susan, event) & (HarvardStudent(susan) => YoungAdult(susan)).
YaleStudent(susan) => -Like(susan, independence).

[CONCLUSION]:
Susan is not both diligent and likes independence.

[CONCLUSION (FOL)]:
¬(Like(susan, independence) ∧ Diligent(susan))

[CONCLUSION (GK)]:
-(Like(susan, independence) & Diligent(susan)).


===

['x']
['x']
[PREMISE]:
Vic DiCara plays guitar and bass.
The only style of music Vic DiCara plays is punk music.
Vic DiCara played in the band Inside Out.

[PREMISE (FOL)]:
Play(vicDicara, guitar) ∧ Play(vicDicara, bass)
∀x (Music(vicDicara, x) → ¬(x=punk)))
Band(vicDicara, insideOut)

[PREMISE (GK)]:
Play(vicDicara, guitar) & Play(vicDicara, bass).
! [X] : (Music(vicDicara, X) => -(X=punk))).
Band(vicDicara, insideOut).

[CONCLUSION]:
Inside Out was a punk band.

[CONCLUSION (FOL)]:
Music(insideOut, punk)

[CONCLUSION (GK)]:
Music(insideOut, punk).


===

['x']
['x']
[PREMISE]:
Vic DiCara plays guitar and bass.
The only style of music Vic DiCara plays is punk music.
Vic DiCara played in the band Inside Out.

[PREMISE (FOL)]:
Play(vicDicara, guitar) ∧ Play(vicDicara, bass)
∀x (Music(vicDicara, x) → ¬(x=punk)))
Band(vicDicara, insideOut)

[PREMISE (GK)]:
Play(vicDicara, guitar) & Play(vicDicara, bass).
! [X] : (Music(vicDicara, X) => -(X=punk))).
Band(vicDicara, insideOut).

[CONCLUSION]:
A musician from Inside Out plays bass.

[CONCLUSION (FOL)]:
∃x (Band(x, insideOut) ∧ Play(x, bass))

[CONCLUSION (GK)]:
? [X] : (Band(X, insideOut) & Play(X, bass)).


===

['x']
['x']
[PREMISE]:
All professional athletes spend most of their time on sports.
All Olympic gold medal winners are professional athletes.
No full-time scientists spend the majority of their time on sports.
All Nobel physics laureates are full-time scientists.
Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.

[PREMISE (FOL)]:
∀x (ProfessionalAthlete(x) → SpendOn(x, mostOfTheirTime, sports))
∀x (OlympicGoldMedalWinner(x) → ProfessionalAthlete(x))
∀x (FullTimeScientist(x) → ¬SpendOn(x, mostOfTheirTime, sports))
∀x (NobelPhysicsLaureate(x) → FullTimeScientist(x))
SpendOn(amy, mostOfTheirTime, sports) ∨ OlympicGoldMedalWinner(amy)
¬NobelPhysicsLaureate(amy) → ¬OlympicGoldMedalWinner(amy)

[PREMISE (GK)]:
! [X] : (ProfessionalAthlete(X) => SpendOn(X, mostOfTheirTime, sports)).
! [X] : (OlympicGoldMedalWinner(X) => ProfessionalAthlete(X)).
! [X] : (FullTimeScientist(X) => -SpendOn(X, mostOfTheirTime, sports)).
! [X] : (NobelPhysicsLaureate(X) => FullTimeScientist(X)).
SpendOn(amy, mostOfTheirTime, sports) | OlympicGoldMedalWinner(amy).
-NobelPhysicsLaureate(amy) => -OlympicGoldMedalWinner(amy).

[CONCLUSION]:
Amy is a professional athlete.

[CONCLUSION (FOL)]:
ProfessionalAthlete(amy)

[CONCLUSION (GK)]:
ProfessionalAthlete(amy).


===

['x']
['x']
[PREMISE]:
All professional athletes spend most of their time on sports.
All Olympic gold medal winners are professional athletes.
No full-time scientists spend the majority of their time on sports.
All Nobel physics laureates are full-time scientists.
Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.

[PREMISE (FOL)]:
∀x (ProfessionalAthlete(x) → SpendOn(x, mostOfTheirTime, sports))
∀x (OlympicGoldMedalWinner(x) → ProfessionalAthlete(x))
∀x (FullTimeScientist(x) → ¬SpendOn(x, mostOfTheirTime, sports))
∀x (NobelPhysicsLaureate(x) → FullTimeScientist(x))
SpendOn(amy, mostOfTheirTime, sports) ∨ OlympicGoldMedalWinner(amy)
¬NobelPhysicsLaureate(amy) → ¬OlympicGoldMedalWinner(amy)

[PREMISE (GK)]:
! [X] : (ProfessionalAthlete(X) => SpendOn(X, mostOfTheirTime, sports)).
! [X] : (OlympicGoldMedalWinner(X) => ProfessionalAthlete(X)).
! [X] : (FullTimeScientist(X) => -SpendOn(X, mostOfTheirTime, sports)).
! [X] : (NobelPhysicsLaureate(X) => FullTimeScientist(X)).
SpendOn(amy, mostOfTheirTime, sports) | OlympicGoldMedalWinner(amy).
-NobelPhysicsLaureate(amy) => -OlympicGoldMedalWinner(amy).

[CONCLUSION]:
Amy is neither a full-time scientist nor an Olympic gold medal winner.

[CONCLUSION (FOL)]:
¬(FullTimeScientist(amy) ∨ OlympicGoldMedalWinner(amy))

[CONCLUSION (GK)]:
-(FullTimeScientist(amy) | OlympicGoldMedalWinner(amy)).


===

['x']
['x']
[PREMISE]:
All professional athletes spend most of their time on sports.
All Olympic gold medal winners are professional athletes.
No full-time scientists spend the majority of their time on sports.
All Nobel physics laureates are full-time scientists.
Amy spends the most time on sports, or Amy is an Olympic gold medal winner.
If Amy is not a Nobel physics laureate, then Amy is not an Olympic gold medal winner.

[PREMISE (FOL)]:
∀x (ProfessionalAthlete(x) → SpendOn(x, mostOfTheirTime, sports))
∀x (OlympicGoldMedalWinner(x) → ProfessionalAthlete(x))
∀x (FullTimeScientist(x) → ¬SpendOn(x, mostOfTheirTime, sports))
∀x (NobelPhysicsLaureate(x) → FullTimeScientist(x))
SpendOn(amy, mostOfTheirTime, sports) ∨ OlympicGoldMedalWinner(amy)
¬NobelPhysicsLaureate(amy) → ¬OlympicGoldMedalWinner(amy)

[PREMISE (GK)]:
! [X] : (ProfessionalAthlete(X) => SpendOn(X, mostOfTheirTime, sports)).
! [X] : (OlympicGoldMedalWinner(X) => ProfessionalAthlete(X)).
! [X] : (FullTimeScientist(X) => -SpendOn(X, mostOfTheirTime, sports)).
! [X] : (NobelPhysicsLaureate(X) => FullTimeScientist(X)).
SpendOn(amy, mostOfTheirTime, sports) | OlympicGoldMedalWinner(amy).
-NobelPhysicsLaureate(amy) => -OlympicGoldMedalWinner(amy).

[CONCLUSION]:
If Amy is not an Olympic gold medal winner, then Amy is a Nobel physics laureate.

[CONCLUSION (FOL)]:
¬OlympicGoldMedalWinner(amy) → NobelPhysicsLaureate(amy)

[CONCLUSION (GK)]:
-OlympicGoldMedalWinner(amy) => NobelPhysicsLaureate(amy).


===

['x']
['x']
[PREMISE]:
All red fruits that grow in Ben's yard contain some Vitamin C.
All apples that grow in Ben's yard are red fruits.
All fruits that grow in Ben's yard and contain some Vitamin C are healthy. 
No fruits that grow in Ben's yard and are healthy are on a warning list.
The cherries grow in Ben's yard.
If cherries are not apples and are not healthy, then they are red fruits.

[PREMISE (FOL)]:
∀x ((GrownIn(x, benSYard) ∧ RedFruit(x)) → Contain(x, vitaminC))
∀x (GrownIn(x, benSYard) ∧ Is(x, apple) → RedFruit(x))
∀x ((GrownIn(x, benSYard) ∧ Contain(x, vitaminC)) → healthy(x))
∀x ((GrownIn(x, benSYard) ∧ Healthy(x)) → ¬On(x, warningList))
GrownIn(cherry, benSYard)
¬(Healthy(cherry) ∧ Is(cherry, apple)) → RedFruit(cherry)


[PREMISE (GK)]:
! [X] : ((GrownIn(X, benSYard) & RedFruit(X)) => Contain(X, vitaminC)).
! [X] : (GrownIn(X, benSYard) & Is(X, apple) => RedFruit(X)).
! [X] : ((GrownIn(X, benSYard) & Contain(X, vitaminC)) => healthy(X)).
! [X] : ((GrownIn(X, benSYard) & Healthy(X)) => -On(X, warningList)).
GrownIn(cherry, benSYard).
-(Healthy(cherry) & Is(cherry, apple)) => RedFruit(cherry).
.

[CONCLUSION]:
The cherries are apples.

[CONCLUSION (FOL)]:
Is(cherry, apple)

[CONCLUSION (GK)]:
Is(cherry, apple).


===

['x']
['x']
[PREMISE]:
All red fruits that grow in Ben's yard contain some Vitamin C.
All apples that grow in Ben's yard are red fruits.
All fruits that grow in Ben's yard and contain some Vitamin C are healthy. 
No fruits that grow in Ben's yard and are healthy are on a warning list.
The cherries grow in Ben's yard.
If cherries are not apples and are not healthy, then they are red fruits.

[PREMISE (FOL)]:
∀x ((GrownIn(x, benSYard) ∧ RedFruit(x)) → Contain(x, vitaminC))
∀x (GrownIn(x, benSYard) ∧ Is(x, apple) → RedFruit(x))
∀x ((GrownIn(x, benSYard) ∧ Contain(x, vitaminC)) → healthy(x))
∀x ((GrownIn(x, benSYard) ∧ Healthy(x)) → ¬On(x, warningList))
GrownIn(cherry, benSYard)
¬(Healthy(cherry) ∧ Is(cherry, apple)) → RedFruit(cherry)


[PREMISE (GK)]:
! [X] : ((GrownIn(X, benSYard) & RedFruit(X)) => Contain(X, vitaminC)).
! [X] : (GrownIn(X, benSYard) & Is(X, apple) => RedFruit(X)).
! [X] : ((GrownIn(X, benSYard) & Contain(X, vitaminC)) => healthy(X)).
! [X] : ((GrownIn(X, benSYard) & Healthy(X)) => -On(X, warningList)).
GrownIn(cherry, benSYard).
-(Healthy(cherry) & Is(cherry, apple)) => RedFruit(cherry).
.

[CONCLUSION]:
The cherries either contain some amount of vitamin C or are on a warning list.

[CONCLUSION (FOL)]:
Contain(cherry, vitaminC) ⊕ On(cherry, warningList)

[CONCLUSION (GK)]:
Contain(cherry, vitaminC) <~> On(cherry, warningList).


===

['x']
['x']
[PREMISE]:
All red fruits that grow in Ben's yard contain some Vitamin C.
All apples that grow in Ben's yard are red fruits.
All fruits that grow in Ben's yard and contain some Vitamin C are healthy. 
No fruits that grow in Ben's yard and are healthy are on a warning list.
The cherries grow in Ben's yard.
If cherries are not apples and are not healthy, then they are red fruits.

[PREMISE (FOL)]:
∀x ((GrownIn(x, benSYard) ∧ RedFruit(x)) → Contain(x, vitaminC))
∀x (GrownIn(x, benSYard) ∧ Is(x, apple) → RedFruit(x))
∀x ((GrownIn(x, benSYard) ∧ Contain(x, vitaminC)) → healthy(x))
∀x ((GrownIn(x, benSYard) ∧ Healthy(x)) → ¬On(x, warningList))
GrownIn(cherry, benSYard)
¬(Healthy(cherry) ∧ Is(cherry, apple)) → RedFruit(cherry)


[PREMISE (GK)]:
! [X] : ((GrownIn(X, benSYard) & RedFruit(X)) => Contain(X, vitaminC)).
! [X] : (GrownIn(X, benSYard) & Is(X, apple) => RedFruit(X)).
! [X] : ((GrownIn(X, benSYard) & Contain(X, vitaminC)) => healthy(X)).
! [X] : ((GrownIn(X, benSYard) & Healthy(X)) => -On(X, warningList)).
GrownIn(cherry, benSYard).
-(Healthy(cherry) & Is(cherry, apple)) => RedFruit(cherry).
.

[CONCLUSION]:
The cherries are either on a warning list or are red.

[CONCLUSION (FOL)]:
On(cherry, warningList) ⊕ RedFruit(cherry)

[CONCLUSION (GK)]:
On(cherry, warningList) <~> RedFruit(cherry).


===

['x']
['x']
[PREMISE]:
All red fruits that grow in Ben's yard contain some Vitamin C.
All apples that grow in Ben's yard are red fruits.
All fruits that grow in Ben's yard and contain some Vitamin C are healthy. 
No fruits that grow in Ben's yard and are healthy are on a warning list.
The cherries grow in Ben's yard.
If cherries are not apples and are not healthy, then they are red fruits.

[PREMISE (FOL)]:
∀x ((GrownIn(x, benSYard) ∧ RedFruit(x)) → Contain(x, vitaminC))
∀x (GrownIn(x, benSYard) ∧ Is(x, apple) → RedFruit(x))
∀x ((GrownIn(x, benSYard) ∧ Contain(x, vitaminC)) → healthy(x))
∀x ((GrownIn(x, benSYard) ∧ Healthy(x)) → ¬On(x, warningList))
GrownIn(cherry, benSYard)
¬(Healthy(cherry) ∧ Is(cherry, apple)) → RedFruit(cherry)


[PREMISE (GK)]:
! [X] : ((GrownIn(X, benSYard) & RedFruit(X)) => Contain(X, vitaminC)).
! [X] : (GrownIn(X, benSYard) & Is(X, apple) => RedFruit(X)).
! [X] : ((GrownIn(X, benSYard) & Contain(X, vitaminC)) => healthy(X)).
! [X] : ((GrownIn(X, benSYard) & Healthy(X)) => -On(X, warningList)).
GrownIn(cherry, benSYard).
-(Healthy(cherry) & Is(cherry, apple)) => RedFruit(cherry).
.

[CONCLUSION]:
If the cherries are either healthy or are on a warning list, then they are not red.

[CONCLUSION (FOL)]:
BeneficialTo(cherry, people) ⊕ On(cherry, warningList))) → ¬RedFruit(cherry)

[CONCLUSION (GK)]:
BeneficialTo(cherry, people) <~> On(cherry, warningList))) => -RedFruit(cherry).


===

['x']
['x']
[PREMISE]:
All red fruits that grow in Ben's yard contain some Vitamin C.
All apples that grow in Ben's yard are red fruits.
All fruits that grow in Ben's yard and contain some Vitamin C are healthy. 
No fruits that grow in Ben's yard and are healthy are on a warning list.
The cherries grow in Ben's yard.
If cherries are not apples and are not healthy, then they are red fruits.

[PREMISE (FOL)]:
∀x ((GrownIn(x, benSYard) ∧ RedFruit(x)) → Contain(x, vitaminC))
∀x (GrownIn(x, benSYard) ∧ Is(x, apple) → RedFruit(x))
∀x ((GrownIn(x, benSYard) ∧ Contain(x, vitaminC)) → healthy(x))
∀x ((GrownIn(x, benSYard) ∧ Healthy(x)) → ¬On(x, warningList))
GrownIn(cherry, benSYard)
¬(Healthy(cherry) ∧ Is(cherry, apple)) → RedFruit(cherry)


[PREMISE (GK)]:
! [X] : ((GrownIn(X, benSYard) & RedFruit(X)) => Contain(X, vitaminC)).
! [X] : (GrownIn(X, benSYard) & Is(X, apple) => RedFruit(X)).
! [X] : ((GrownIn(X, benSYard) & Contain(X, vitaminC)) => healthy(X)).
! [X] : ((GrownIn(X, benSYard) & Healthy(X)) => -On(X, warningList)).
GrownIn(cherry, benSYard).
-(Healthy(cherry) & Is(cherry, apple)) => RedFruit(cherry).
.

[CONCLUSION]:
If the cherries are either on a warning list or are red, then they are not healthy and do not contain any amount of vitamin C.

[CONCLUSION (FOL)]:
On(cherry, warningList) ⊕ RedFruit(cherry)) → ¬(BeneficialTo(cherry, people) ∧ Contain(cherry, vitaminC)

[CONCLUSION (GK)]:
On(cherry, warningList) <~> RedFruit(cherry)) => -(BeneficialTo(cherry, people) & Contain(cherry, vitaminC).


===

['x']
['x']
[PREMISE]:
Everyone working at Meta has a high income. 
A person with a high income will not take a bus to their destination.
People will either take a bus or drive to their destination. 
Everyone who has a car will choose to drive to their destination. 
No students drive to their destination. 
James has a car or works at Meta.

[PREMISE (FOL)]:
∀x (WorkAt(x, meta) → HighIncome(x))
∀x (HighIncome(x) → ¬MeansToDestination(x, bus))
∀x (MeansToDestination(x, bus) ⊕ MeansToDestination(x, drive))
∀x (HaveCar(x) → MeansToDestination(x, drive))
∀x (Student(x) → ¬ MeansToDestination(x, drive))
HaveCar(james) ∨ WorkAt(james, meta)

[PREMISE (GK)]:
! [X] : (WorkAt(X, meta) => HighIncome(X)).
! [X] : (HighIncome(X) => -MeansToDestination(X, bus)).
! [X] : (MeansToDestination(X, bus) <~> MeansToDestination(X, drive)).
! [X] : (HaveCar(X) => MeansToDestination(X, drive)).
! [X] : (Student(X) => - MeansToDestination(X, drive)).
HaveCar(james) | WorkAt(james, meta).

[CONCLUSION]:
James has a high income.

[CONCLUSION (FOL)]:
HighIncome(james)

[CONCLUSION (GK)]:
HighIncome(james).


===

['x']
['x']
[PREMISE]:
Everyone working at Meta has a high income. 
A person with a high income will not take a bus to their destination.
People will either take a bus or drive to their destination. 
Everyone who has a car will choose to drive to their destination. 
No students drive to their destination. 
James has a car or works at Meta.

[PREMISE (FOL)]:
∀x (WorkAt(x, meta) → HighIncome(x))
∀x (HighIncome(x) → ¬MeansToDestination(x, bus))
∀x (MeansToDestination(x, bus) ⊕ MeansToDestination(x, drive))
∀x (HaveCar(x) → MeansToDestination(x, drive))
∀x (Student(x) → ¬ MeansToDestination(x, drive))
HaveCar(james) ∨ WorkAt(james, meta)

[PREMISE (GK)]:
! [X] : (WorkAt(X, meta) => HighIncome(X)).
! [X] : (HighIncome(X) => -MeansToDestination(X, bus)).
! [X] : (MeansToDestination(X, bus) <~> MeansToDestination(X, drive)).
! [X] : (HaveCar(X) => MeansToDestination(X, drive)).
! [X] : (Student(X) => - MeansToDestination(X, drive)).
HaveCar(james) | WorkAt(james, meta).

[CONCLUSION]:
James does not have a high income.

[CONCLUSION (FOL)]:
¬HighIncome(james)

[CONCLUSION (GK)]:
-HighIncome(james).


===

['x']
['x']
[PREMISE]:
Everyone working at Meta has a high income. 
A person with a high income will not take a bus to their destination.
People will either take a bus or drive to their destination. 
Everyone who has a car will choose to drive to their destination. 
No students drive to their destination. 
James has a car or works at Meta.

[PREMISE (FOL)]:
∀x (WorkAt(x, meta) → HighIncome(x))
∀x (HighIncome(x) → ¬MeansToDestination(x, bus))
∀x (MeansToDestination(x, bus) ⊕ MeansToDestination(x, drive))
∀x (HaveCar(x) → MeansToDestination(x, drive))
∀x (Student(x) → ¬ MeansToDestination(x, drive))
HaveCar(james) ∨ WorkAt(james, meta)

[PREMISE (GK)]:
! [X] : (WorkAt(X, meta) => HighIncome(X)).
! [X] : (HighIncome(X) => -MeansToDestination(X, bus)).
! [X] : (MeansToDestination(X, bus) <~> MeansToDestination(X, drive)).
! [X] : (HaveCar(X) => MeansToDestination(X, drive)).
! [X] : (Student(X) => - MeansToDestination(X, drive)).
HaveCar(james) | WorkAt(james, meta).

[CONCLUSION]:
James is a student.

[CONCLUSION (FOL)]:
Student(james)

[CONCLUSION (GK)]:
Student(james).


===

['x']
['x']
[PREMISE]:
Everyone working at Meta has a high income. 
A person with a high income will not take a bus to their destination.
People will either take a bus or drive to their destination. 
Everyone who has a car will choose to drive to their destination. 
No students drive to their destination. 
James has a car or works at Meta.

[PREMISE (FOL)]:
∀x (WorkAt(x, meta) → HighIncome(x))
∀x (HighIncome(x) → ¬MeansToDestination(x, bus))
∀x (MeansToDestination(x, bus) ⊕ MeansToDestination(x, drive))
∀x (HaveCar(x) → MeansToDestination(x, drive))
∀x (Student(x) → ¬ MeansToDestination(x, drive))
HaveCar(james) ∨ WorkAt(james, meta)

[PREMISE (GK)]:
! [X] : (WorkAt(X, meta) => HighIncome(X)).
! [X] : (HighIncome(X) => -MeansToDestination(X, bus)).
! [X] : (MeansToDestination(X, bus) <~> MeansToDestination(X, drive)).
! [X] : (HaveCar(X) => MeansToDestination(X, drive)).
! [X] : (Student(X) => - MeansToDestination(X, drive)).
HaveCar(james) | WorkAt(james, meta).

[CONCLUSION]:
James drives to his destination or he is a student.

[CONCLUSION (FOL)]:
MeansToDestination(x, drive) ∨ Student(james)

[CONCLUSION (GK)]:
MeansToDestination(X, drive) | Student(james).


===

['x']
['x']
[PREMISE]:
Everyone working at Meta has a high income. 
A person with a high income will not take a bus to their destination.
People will either take a bus or drive to their destination. 
Everyone who has a car will choose to drive to their destination. 
No students drive to their destination. 
James has a car or works at Meta.

[PREMISE (FOL)]:
∀x (WorkAt(x, meta) → HighIncome(x))
∀x (HighIncome(x) → ¬MeansToDestination(x, bus))
∀x (MeansToDestination(x, bus) ⊕ MeansToDestination(x, drive))
∀x (HaveCar(x) → MeansToDestination(x, drive))
∀x (Student(x) → ¬ MeansToDestination(x, drive))
HaveCar(james) ∨ WorkAt(james, meta)

[PREMISE (GK)]:
! [X] : (WorkAt(X, meta) => HighIncome(X)).
! [X] : (HighIncome(X) => -MeansToDestination(X, bus)).
! [X] : (MeansToDestination(X, bus) <~> MeansToDestination(X, drive)).
! [X] : (HaveCar(X) => MeansToDestination(X, drive)).
! [X] : (Student(X) => - MeansToDestination(X, drive)).
HaveCar(james) | WorkAt(james, meta).

[CONCLUSION]:
James either drives to their destination or is a student.

[CONCLUSION (FOL)]:
MeansToDestination(x, drive) ⊕ Student(james)

[CONCLUSION (GK)]:
MeansToDestination(X, drive) <~> Student(james).


===

['x']
['x']
[PREMISE]:
Everyone working at Meta has a high income. 
A person with a high income will not take a bus to their destination.
People will either take a bus or drive to their destination. 
Everyone who has a car will choose to drive to their destination. 
No students drive to their destination. 
James has a car or works at Meta.

[PREMISE (FOL)]:
∀x (WorkAt(x, meta) → HighIncome(x))
∀x (HighIncome(x) → ¬MeansToDestination(x, bus))
∀x (MeansToDestination(x, bus) ⊕ MeansToDestination(x, drive))
∀x (HaveCar(x) → MeansToDestination(x, drive))
∀x (Student(x) → ¬ MeansToDestination(x, drive))
HaveCar(james) ∨ WorkAt(james, meta)

[PREMISE (GK)]:
! [X] : (WorkAt(X, meta) => HighIncome(X)).
! [X] : (HighIncome(X) => -MeansToDestination(X, bus)).
! [X] : (MeansToDestination(X, bus) <~> MeansToDestination(X, drive)).
! [X] : (HaveCar(X) => MeansToDestination(X, drive)).
! [X] : (Student(X) => - MeansToDestination(X, drive)).
HaveCar(james) | WorkAt(james, meta).

[CONCLUSION]:
If James either drives to his destination or is a student, then he has a high income and is a student.

[CONCLUSION (FOL)]:
(MeansToDestination(x, drive) ⊕ Student(james)) → (HighIncome(james) ∧ Student(james))

[CONCLUSION (GK)]:
(MeansToDestination(X, drive) <~> Student(james)) => (HighIncome(james) & Student(james)).


===

['x']
['x']
[PREMISE]:
Everyone at the business conference is either an investor or an entrepreneur.
None of those at the business conference who enjoy the opportunity of starting a business prefer a planned economy. 
All entrepreneurs at the business conference enjoy the opportunity of starting a business. 
Everyone at the business conference who enjoys state ownership of means of production prefers a planned economy. 
Everyone at the business conference who is an ardent communist prefers state ownership of the means of production.
Ho is at the business conference and prefers state ownership of the means of production. 

[PREMISE (FOL)]:
∀x (At(x, businessConference) → (Investor(x) ⊕ Entrepreneur(x)))
∀x ((At(x, businessConference) ∧ Enjoy(x, opportunityOfStartingOwnBusiness)) → ¬Prefer(x, plannedEconomy))
∀x ((At(x, businessConference) ∧ Entrepreneur(x)) → Enjoy(x, opportunityOfStartingOwnBusiness))
∀x ((At(x, businessConference) ∧ Enjoy(x, stateOwnershipOfMeansOfProduction)) → Prefer(x, plannedEconomy))
∀x ((At(x, businessConference) ∧ ArdentCommunist(x)) → Prefer(x, stateOwnershipOfMeansOfProduction))
At(ho, businessConference) ∧ Prefer(ho, stateOwnershipOfMeansOfProduction)

[PREMISE (GK)]:
! [X] : (At(X, businessConference) => (Investor(X) <~> Entrepreneur(X))).
! [X] : ((At(X, businessConference) & Enjoy(X, opportunityOfStartingOwnBusiness)) => -Prefer(X, plannedEconomy)).
! [X] : ((At(X, businessConference) & Entrepreneur(X)) => Enjoy(X, opportunityOfStartingOwnBusiness)).
! [X] : ((At(X, businessConference) & Enjoy(X, stateOwnershipOfMeansOfProduction)) => Prefer(X, plannedEconomy)).
! [X] : ((At(X, businessConference) & ArdentCommunist(X)) => Prefer(X, stateOwnershipOfMeansOfProduction)).
At(ho, businessConference) & Prefer(ho, stateOwnershipOfMeansOfProduction).

[CONCLUSION]:
Ho is not an ardent communist.

[CONCLUSION (FOL)]:
¬ArdentCommunist(ho)

[CONCLUSION (GK)]:
-ArdentCommunist(ho).


===

['x']
['x']
[PREMISE]:
Everyone at the business conference is either an investor or an entrepreneur.
None of those at the business conference who enjoy the opportunity of starting a business prefer a planned economy. 
All entrepreneurs at the business conference enjoy the opportunity of starting a business. 
Everyone at the business conference who enjoys state ownership of means of production prefers a planned economy. 
Everyone at the business conference who is an ardent communist prefers state ownership of the means of production.
Ho is at the business conference and prefers state ownership of the means of production. 

[PREMISE (FOL)]:
∀x (At(x, businessConference) → (Investor(x) ⊕ Entrepreneur(x)))
∀x ((At(x, businessConference) ∧ Enjoy(x, opportunityOfStartingOwnBusiness)) → ¬Prefer(x, plannedEconomy))
∀x ((At(x, businessConference) ∧ Entrepreneur(x)) → Enjoy(x, opportunityOfStartingOwnBusiness))
∀x ((At(x, businessConference) ∧ Enjoy(x, stateOwnershipOfMeansOfProduction)) → Prefer(x, plannedEconomy))
∀x ((At(x, businessConference) ∧ ArdentCommunist(x)) → Prefer(x, stateOwnershipOfMeansOfProduction))
At(ho, businessConference) ∧ Prefer(ho, stateOwnershipOfMeansOfProduction)

[PREMISE (GK)]:
! [X] : (At(X, businessConference) => (Investor(X) <~> Entrepreneur(X))).
! [X] : ((At(X, businessConference) & Enjoy(X, opportunityOfStartingOwnBusiness)) => -Prefer(X, plannedEconomy)).
! [X] : ((At(X, businessConference) & Entrepreneur(X)) => Enjoy(X, opportunityOfStartingOwnBusiness)).
! [X] : ((At(X, businessConference) & Enjoy(X, stateOwnershipOfMeansOfProduction)) => Prefer(X, plannedEconomy)).
! [X] : ((At(X, businessConference) & ArdentCommunist(X)) => Prefer(X, stateOwnershipOfMeansOfProduction)).
At(ho, businessConference) & Prefer(ho, stateOwnershipOfMeansOfProduction).

[CONCLUSION]:
Ho is an investor or is not an ardent communist.

[CONCLUSION (FOL)]:
Investor(ho) ∨ (¬ArdentCommunist(ho))

[CONCLUSION (GK)]:
Investor(ho) | (-ArdentCommunist(ho)).


===

['x']
['x']
[PREMISE]:
No television stars are certified public accountants.
All certified public accountants have good business sense.

[PREMISE (FOL)]:
∀x (TelevisionStar(x) → ¬CertifiedPublicAccoutant(x))
∀x (CertifiedPublicAccoutant(x) → Have(x, goodBusinessSense))

[PREMISE (GK)]:
! [X] : (TelevisionStar(X) => -CertifiedPublicAccoutant(X)).
! [X] : (CertifiedPublicAccoutant(X) => Have(X, goodBusinessSense)).

[CONCLUSION]:
All television stars have good business sense.

[CONCLUSION (FOL)]:
∀x (TelevisionStar(x) → Have(x, goodBusinessSense))

[CONCLUSION (GK)]:
! [X] : (TelevisionStar(X) => Have(X, goodBusinessSense)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some students in the class who are good at math are also good at chemistry.
All students in the class who are good at chemistry enjoy conducting experiments. 
All students in the class that enjoy conducting experiments are good at planning. 
None of the students who are good at planning failed the class.
James is a student in the class; he is either good at chemistry and failed the class, or bad at chemistry and passed the class.

[PREMISE (FOL)]:
∃x ∃y (StudentInTheClass(x) ∧ GoodAt(x, math) ∧ GoodAt(x, chemistry) ∧ (¬(x=y)) ∧ StudentInTheClass(y) ∧ GoodAt(y, math) ∧ GoodAt(y, chemistry))
∀x ((StudentInTheClass(x) ∧ GoodAt(x, chemistry)) → Enjoy(x, conductingExperiment))
∀x ((StudentInTheClass(x) ∧ Enjoy(x, conductingExperiment)) → GoodAt(x, planning))
∀x ((StudentInTheClass(x) ∧ GoodAt(x, planning)) → ¬Failed(x, theClass))
StudentInTheClass(james) ∧ (¬(GoodAt(james, chemistry) ⊕ Failed(james, theClass)))

[PREMISE (GK)]:
? [X] : ? [Y] : (StudentInTheClass(X) & GoodAt(X, math) & GoodAt(X, chemistry) & (-(X=Y)) & StudentInTheClass(Y) & GoodAt(Y, math) & GoodAt(Y, chemistry)).
! [X] : ((StudentInTheClass(X) & GoodAt(X, chemistry)) => Enjoy(X, conductingExperiment)).
! [X] : ((StudentInTheClass(X) & Enjoy(X, conductingExperiment)) => GoodAt(X, planning)).
! [X] : ((StudentInTheClass(X) & GoodAt(X, planning)) => -Failed(X, theClass)).
StudentInTheClass(james) & (-(GoodAt(james, chemistry) <~> Failed(james, theClass))).

[CONCLUSION]:
James is good at planning.

[CONCLUSION (FOL)]:
GoodAt(james, planning)

[CONCLUSION (GK)]:
GoodAt(james, planning).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some students in the class who are good at math are also good at chemistry.
All students in the class who are good at chemistry enjoy conducting experiments. 
All students in the class that enjoy conducting experiments are good at planning. 
None of the students who are good at planning failed the class.
James is a student in the class; he is either good at chemistry and failed the class, or bad at chemistry and passed the class.

[PREMISE (FOL)]:
∃x ∃y (StudentInTheClass(x) ∧ GoodAt(x, math) ∧ GoodAt(x, chemistry) ∧ (¬(x=y)) ∧ StudentInTheClass(y) ∧ GoodAt(y, math) ∧ GoodAt(y, chemistry))
∀x ((StudentInTheClass(x) ∧ GoodAt(x, chemistry)) → Enjoy(x, conductingExperiment))
∀x ((StudentInTheClass(x) ∧ Enjoy(x, conductingExperiment)) → GoodAt(x, planning))
∀x ((StudentInTheClass(x) ∧ GoodAt(x, planning)) → ¬Failed(x, theClass))
StudentInTheClass(james) ∧ (¬(GoodAt(james, chemistry) ⊕ Failed(james, theClass)))

[PREMISE (GK)]:
? [X] : ? [Y] : (StudentInTheClass(X) & GoodAt(X, math) & GoodAt(X, chemistry) & (-(X=Y)) & StudentInTheClass(Y) & GoodAt(Y, math) & GoodAt(Y, chemistry)).
! [X] : ((StudentInTheClass(X) & GoodAt(X, chemistry)) => Enjoy(X, conductingExperiment)).
! [X] : ((StudentInTheClass(X) & Enjoy(X, conductingExperiment)) => GoodAt(X, planning)).
! [X] : ((StudentInTheClass(X) & GoodAt(X, planning)) => -Failed(X, theClass)).
StudentInTheClass(james) & (-(GoodAt(james, chemistry) <~> Failed(james, theClass))).

[CONCLUSION]:
James is good at math and chemistry.

[CONCLUSION (FOL)]:
GoodAt(james, chemistry) ∧ GoodAt(james, math)

[CONCLUSION (GK)]:
GoodAt(james, chemistry) & GoodAt(james, math).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some students in the class who are good at math are also good at chemistry.
All students in the class who are good at chemistry enjoy conducting experiments. 
All students in the class that enjoy conducting experiments are good at planning. 
None of the students who are good at planning failed the class.
James is a student in the class; he is either good at chemistry and failed the class, or bad at chemistry and passed the class.

[PREMISE (FOL)]:
∃x ∃y (StudentInTheClass(x) ∧ GoodAt(x, math) ∧ GoodAt(x, chemistry) ∧ (¬(x=y)) ∧ StudentInTheClass(y) ∧ GoodAt(y, math) ∧ GoodAt(y, chemistry))
∀x ((StudentInTheClass(x) ∧ GoodAt(x, chemistry)) → Enjoy(x, conductingExperiment))
∀x ((StudentInTheClass(x) ∧ Enjoy(x, conductingExperiment)) → GoodAt(x, planning))
∀x ((StudentInTheClass(x) ∧ GoodAt(x, planning)) → ¬Failed(x, theClass))
StudentInTheClass(james) ∧ (¬(GoodAt(james, chemistry) ⊕ Failed(james, theClass)))

[PREMISE (GK)]:
? [X] : ? [Y] : (StudentInTheClass(X) & GoodAt(X, math) & GoodAt(X, chemistry) & (-(X=Y)) & StudentInTheClass(Y) & GoodAt(Y, math) & GoodAt(Y, chemistry)).
! [X] : ((StudentInTheClass(X) & GoodAt(X, chemistry)) => Enjoy(X, conductingExperiment)).
! [X] : ((StudentInTheClass(X) & Enjoy(X, conductingExperiment)) => GoodAt(X, planning)).
! [X] : ((StudentInTheClass(X) & GoodAt(X, planning)) => -Failed(X, theClass)).
StudentInTheClass(james) & (-(GoodAt(james, chemistry) <~> Failed(james, theClass))).

[CONCLUSION]:
James failed the class and is good at math.

[CONCLUSION (FOL)]:
Failed(james, james) ∧ GoodAt(james, math)

[CONCLUSION (GK)]:
Failed(james, james) & GoodAt(james, math).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some students in the class who are good at math are also good at chemistry.
All students in the class who are good at chemistry enjoy conducting experiments. 
All students in the class that enjoy conducting experiments are good at planning. 
None of the students who are good at planning failed the class.
James is a student in the class; he is either good at chemistry and failed the class, or bad at chemistry and passed the class.

[PREMISE (FOL)]:
∃x ∃y (StudentInTheClass(x) ∧ GoodAt(x, math) ∧ GoodAt(x, chemistry) ∧ (¬(x=y)) ∧ StudentInTheClass(y) ∧ GoodAt(y, math) ∧ GoodAt(y, chemistry))
∀x ((StudentInTheClass(x) ∧ GoodAt(x, chemistry)) → Enjoy(x, conductingExperiment))
∀x ((StudentInTheClass(x) ∧ Enjoy(x, conductingExperiment)) → GoodAt(x, planning))
∀x ((StudentInTheClass(x) ∧ GoodAt(x, planning)) → ¬Failed(x, theClass))
StudentInTheClass(james) ∧ (¬(GoodAt(james, chemistry) ⊕ Failed(james, theClass)))

[PREMISE (GK)]:
? [X] : ? [Y] : (StudentInTheClass(X) & GoodAt(X, math) & GoodAt(X, chemistry) & (-(X=Y)) & StudentInTheClass(Y) & GoodAt(Y, math) & GoodAt(Y, chemistry)).
! [X] : ((StudentInTheClass(X) & GoodAt(X, chemistry)) => Enjoy(X, conductingExperiment)).
! [X] : ((StudentInTheClass(X) & Enjoy(X, conductingExperiment)) => GoodAt(X, planning)).
! [X] : ((StudentInTheClass(X) & GoodAt(X, planning)) => -Failed(X, theClass)).
StudentInTheClass(james) & (-(GoodAt(james, chemistry) <~> Failed(james, theClass))).

[CONCLUSION]:
If James is good at Chemistry or failed the class, then James is either good at planning or good at math.

[CONCLUSION (FOL)]:
(GoodAt(james, chemistry) ∨ Failed(james, theClass)) → (GoodAt(james, planning) ⊕ GoodAt(james, math))

[CONCLUSION (GK)]:
(GoodAt(james, chemistry) | Failed(james, theClass)) => (GoodAt(james, planning) <~> GoodAt(james, math)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent. 
All Leetcode problems that are recommended to novices are easy. 
A Leetode problem is either easy or hard.
Leetcode problems that are starred by more than one thousand users are hard.
2Sum is recommended to novices. 
4Sum is starred by more than 1,000 users.

[PREMISE (FOL)]:
∀x (Easy(x) → ∃y (LessThan(y, percent20) ∧ ACRate(x,y)))
∀x (Recommended(x) → Easy(x))
∀x (Easy(x) ⊕ Hard(x))
∀x (Starred(x)) → Hard(x))
Recommended(twosum) 
Starred(foursum)

[PREMISE (GK)]:
! [X] : (Easy(X) => ? [Y] : (LessThan(Y, percent20) & ACRate(X,Y))).
! [X] : (Recommended(X) => Easy(X)).
! [X] : (Easy(X) <~> Hard(X)).
! [X] : (Starred(X)) => Hard(X)).
Recommended(twosum) .
Starred(foursum).

[CONCLUSION]:
2Sum is a Leetcode problem at the easy level.

[CONCLUSION (FOL)]:
Easy(twosum)

[CONCLUSION (GK)]:
Easy(twosum).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent. 
All Leetcode problems that are recommended to novices are easy. 
A Leetode problem is either easy or hard.
Leetcode problems that are starred by more than one thousand users are hard.
2Sum is recommended to novices. 
4Sum is starred by more than 1,000 users.

[PREMISE (FOL)]:
∀x (Easy(x) → ∃y (LessThan(y, percent20) ∧ ACRate(x,y)))
∀x (Recommended(x) → Easy(x))
∀x (Easy(x) ⊕ Hard(x))
∀x (Starred(x)) → Hard(x))
Recommended(twosum) 
Starred(foursum)

[PREMISE (GK)]:
! [X] : (Easy(X) => ? [Y] : (LessThan(Y, percent20) & ACRate(X,Y))).
! [X] : (Recommended(X) => Easy(X)).
! [X] : (Easy(X) <~> Hard(X)).
! [X] : (Starred(X)) => Hard(X)).
Recommended(twosum) .
Starred(foursum).

[CONCLUSION]:
4Sum is a Leetcode problem recommended to the novice.

[CONCLUSION (FOL)]:
Recommended(foursum)

[CONCLUSION (GK)]:
Recommended(foursum).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent. 
All Leetcode problems that are recommended to novices are easy. 
A Leetode problem is either easy or hard.
Leetcode problems that are starred by more than one thousand users are hard.
2Sum is recommended to novices. 
4Sum is starred by more than 1,000 users.

[PREMISE (FOL)]:
∀x (Easy(x) → ∃y (LessThan(y, percent20) ∧ ACRate(x,y)))
∀x (Recommended(x) → Easy(x))
∀x (Easy(x) ⊕ Hard(x))
∀x (Starred(x)) → Hard(x))
Recommended(twosum) 
Starred(foursum)

[PREMISE (GK)]:
! [X] : (Easy(X) => ? [Y] : (LessThan(Y, percent20) & ACRate(X,Y))).
! [X] : (Recommended(X) => Easy(X)).
! [X] : (Easy(X) <~> Hard(X)).
! [X] : (Starred(X)) => Hard(X)).
Recommended(twosum) .
Starred(foursum).

[CONCLUSION]:
2Sum has an AC rate higher than 20 percent.

[CONCLUSION (FOL)]:
∃y(GreaterThan(y, percent20) ∧ ACRate(2Sum,y))

[CONCLUSION (GK)]:
? [Y] :(GreaterThan(Y, percent20) & ACRate(2Sum,Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Everyone who rents a car spends money.
Whenever Sarah goes to Vermont, Sarah drives there.
Someone who does not own a car to drive somewhere must either borrow a car or rent a car.
Sarah doesn’t own a car.
Sarah never borrows a car to go camping.
Sarah is going to go camping in Vermont.
To go camping somewhere, you must go to that place.

[PREMISE (FOL)]:
∀x (Rent(x, car) → Spend(x, money))
GoTo(sarah, vermont) → DriveTo(sarah, vermont)
∀x ∀y (¬Own(x, car) ∧ DriveTo(x, y) → Borrow(x, car) ⊕ Rent(x, car))
¬Own(sarah, car)
∀x (Camping(sarah, x) → ¬(Borrow(sarah, car)))
Camping(sarah, vermont)
∀x ∀y (Camping(x, y) → GoTo(x, y))

[PREMISE (GK)]:
! [X] : (Rent(X, car) => Spend(X, money)).
GoTo(sarah, vermont) => DriveTo(sarah, vermont).
! [X] : ! [Y] : (-Own(X, car) & DriveTo(X, Y) => Borrow(X, car) <~> Rent(X, car)).
-Own(sarah, car).
! [X] : (Camping(sarah, X) => -(Borrow(sarah, car))).
Camping(sarah, vermont).
! [X] : ! [Y] : (Camping(X, Y) => GoTo(X, Y)).

[CONCLUSION]:
Sarah will spend money this weekend.

[CONCLUSION (FOL)]:
Spend(sarah, money)

[CONCLUSION (GK)]:
Spend(sarah, money).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
All people who attend weddings are getting married or know the people who are getting married.
No preteens or young children are getting married or know the people who are getting married.
People who enjoy celebrating life milestone events with other people attend weddings.
People who are fond of large group functions enjoy celebrating life milestone events with other people.
All people who are outgoing and spirited are fond of large group functions.
If Carol is not both a pre-teen or young child and attends a wedding, then Carol is not getting married or knows the people who are getting married.  

[PREMISE (FOL)]:
∀x (Attend(x, wedding) → GettingMarried(x) ∨ (∃y (Know(x, y) ∧ GettingMarried(y)))
∀x (PreTeen(x) ∨ YoungChild(x) → ¬(GettingMarried(x) ⊕ (∃y (Know(x, y) ∧ GettingMarried(y)))))
∀x (∃y ∃z (¬(x=y) ∧ ¬(x=z) ∧ ¬(y=z) ∧ Enjoy(x, celebratingLifeMileStoneEvent, y) ∧ Enjoy(x, celebratingLifeStoneEvent, z)) → Attend(x, wedding))
∀x (FondOf(x, largeGroupFunction) → ∃y ∃z (¬(x=y) ∧ ¬(x=z) ∧ ¬(y=z) ∧ Enjoy(x, celebratingLifeMileStoneEventWith, y) ∧ Enjoy(x, celebratingLifeStoneEvent, z)))
∀x (Outgoing(x) ∧ Sprited(x)  → FondOf(x, largeGroupFunction))
¬((PreTeen(carol) ∨ YoungChildren(carol)) ∧ Attend(carol, wedding)) → ¬(GettingMarried(carol) ∨ (∃y (Know(carol, y) ∧ GettingMarried(y))))

[PREMISE (GK)]:
! [X] : (Attend(X, wedding) => GettingMarried(X) | (? [Y] : (Know(X, Y) & GettingMarried(Y))).
! [X] : (PreTeen(X) | YoungChild(X) => -(GettingMarried(X) <~> (? [Y] : (Know(X, Y) & GettingMarried(Y))))).
! [X] : (? [Y] : ? [Z] : (-(X=Y) & -(X=Z) & -(Y=Z) & Enjoy(X, celebratingLifeMileStoneEvent, Y) & Enjoy(X, celebratingLifeStoneEvent, Z)) => Attend(X, wedding)).
! [X] : (FondOf(X, largeGroupFunction) => ? [Y] : ? [Z] : (-(X=Y) & -(X=Z) & -(Y=Z) & Enjoy(X, celebratingLifeMileStoneEventWith, Y) & Enjoy(X, celebratingLifeStoneEvent, Z))).
! [X] : (Outgoing(X) & Sprited(X)  => FondOf(X, largeGroupFunction)).
-((PreTeen(carol) | YoungChildren(carol)) & Attend(carol, wedding)) => -(GettingMarried(carol) | (? [Y] : (Know(carol, Y) & GettingMarried(Y)))).

[CONCLUSION]:
Carol is outgoing and very spirited.

[CONCLUSION (FOL)]:
Outgoing(carol) ∧ Sprited(carol)

[CONCLUSION (GK)]:
Outgoing(carol) & Sprited(carol).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
All people who attend weddings are getting married or know the people who are getting married.
No preteens or young children are getting married or know the people who are getting married.
People who enjoy celebrating life milestone events with other people attend weddings.
People who are fond of large group functions enjoy celebrating life milestone events with other people.
All people who are outgoing and spirited are fond of large group functions.
If Carol is not both a pre-teen or young child and attends a wedding, then Carol is not getting married or knows the people who are getting married.  

[PREMISE (FOL)]:
∀x (Attend(x, wedding) → GettingMarried(x) ∨ (∃y (Know(x, y) ∧ GettingMarried(y)))
∀x (PreTeen(x) ∨ YoungChild(x) → ¬(GettingMarried(x) ⊕ (∃y (Know(x, y) ∧ GettingMarried(y)))))
∀x (∃y ∃z (¬(x=y) ∧ ¬(x=z) ∧ ¬(y=z) ∧ Enjoy(x, celebratingLifeMileStoneEvent, y) ∧ Enjoy(x, celebratingLifeStoneEvent, z)) → Attend(x, wedding))
∀x (FondOf(x, largeGroupFunction) → ∃y ∃z (¬(x=y) ∧ ¬(x=z) ∧ ¬(y=z) ∧ Enjoy(x, celebratingLifeMileStoneEventWith, y) ∧ Enjoy(x, celebratingLifeStoneEvent, z)))
∀x (Outgoing(x) ∧ Sprited(x)  → FondOf(x, largeGroupFunction))
¬((PreTeen(carol) ∨ YoungChildren(carol)) ∧ Attend(carol, wedding)) → ¬(GettingMarried(carol) ∨ (∃y (Know(carol, y) ∧ GettingMarried(y))))

[PREMISE (GK)]:
! [X] : (Attend(X, wedding) => GettingMarried(X) | (? [Y] : (Know(X, Y) & GettingMarried(Y))).
! [X] : (PreTeen(X) | YoungChild(X) => -(GettingMarried(X) <~> (? [Y] : (Know(X, Y) & GettingMarried(Y))))).
! [X] : (? [Y] : ? [Z] : (-(X=Y) & -(X=Z) & -(Y=Z) & Enjoy(X, celebratingLifeMileStoneEvent, Y) & Enjoy(X, celebratingLifeStoneEvent, Z)) => Attend(X, wedding)).
! [X] : (FondOf(X, largeGroupFunction) => ? [Y] : ? [Z] : (-(X=Y) & -(X=Z) & -(Y=Z) & Enjoy(X, celebratingLifeMileStoneEventWith, Y) & Enjoy(X, celebratingLifeStoneEvent, Z))).
! [X] : (Outgoing(X) & Sprited(X)  => FondOf(X, largeGroupFunction)).
-((PreTeen(carol) | YoungChildren(carol)) & Attend(carol, wedding)) => -(GettingMarried(carol) | (? [Y] : (Know(carol, Y) & GettingMarried(Y)))).

[CONCLUSION]:
Carol is a preteen or a young child.

[CONCLUSION (FOL)]:
PreTeen(carol) ∨ YoungChild(carol)

[CONCLUSION (GK)]:
PreTeen(carol) | YoungChild(carol).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
All people who attend weddings are getting married or know the people who are getting married.
No preteens or young children are getting married or know the people who are getting married.
People who enjoy celebrating life milestone events with other people attend weddings.
People who are fond of large group functions enjoy celebrating life milestone events with other people.
All people who are outgoing and spirited are fond of large group functions.
If Carol is not both a pre-teen or young child and attends a wedding, then Carol is not getting married or knows the people who are getting married.  

[PREMISE (FOL)]:
∀x (Attend(x, wedding) → GettingMarried(x) ∨ (∃y (Know(x, y) ∧ GettingMarried(y)))
∀x (PreTeen(x) ∨ YoungChild(x) → ¬(GettingMarried(x) ⊕ (∃y (Know(x, y) ∧ GettingMarried(y)))))
∀x (∃y ∃z (¬(x=y) ∧ ¬(x=z) ∧ ¬(y=z) ∧ Enjoy(x, celebratingLifeMileStoneEvent, y) ∧ Enjoy(x, celebratingLifeStoneEvent, z)) → Attend(x, wedding))
∀x (FondOf(x, largeGroupFunction) → ∃y ∃z (¬(x=y) ∧ ¬(x=z) ∧ ¬(y=z) ∧ Enjoy(x, celebratingLifeMileStoneEventWith, y) ∧ Enjoy(x, celebratingLifeStoneEvent, z)))
∀x (Outgoing(x) ∧ Sprited(x)  → FondOf(x, largeGroupFunction))
¬((PreTeen(carol) ∨ YoungChildren(carol)) ∧ Attend(carol, wedding)) → ¬(GettingMarried(carol) ∨ (∃y (Know(carol, y) ∧ GettingMarried(y))))

[PREMISE (GK)]:
! [X] : (Attend(X, wedding) => GettingMarried(X) | (? [Y] : (Know(X, Y) & GettingMarried(Y))).
! [X] : (PreTeen(X) | YoungChild(X) => -(GettingMarried(X) <~> (? [Y] : (Know(X, Y) & GettingMarried(Y))))).
! [X] : (? [Y] : ? [Z] : (-(X=Y) & -(X=Z) & -(Y=Z) & Enjoy(X, celebratingLifeMileStoneEvent, Y) & Enjoy(X, celebratingLifeStoneEvent, Z)) => Attend(X, wedding)).
! [X] : (FondOf(X, largeGroupFunction) => ? [Y] : ? [Z] : (-(X=Y) & -(X=Z) & -(Y=Z) & Enjoy(X, celebratingLifeMileStoneEventWith, Y) & Enjoy(X, celebratingLifeStoneEvent, Z))).
! [X] : (Outgoing(X) & Sprited(X)  => FondOf(X, largeGroupFunction)).
-((PreTeen(carol) | YoungChildren(carol)) & Attend(carol, wedding)) => -(GettingMarried(carol) | (? [Y] : (Know(carol, Y) & GettingMarried(Y)))).

[CONCLUSION]:
Carol neither enjoys celebrating life milestone events with other people nor is outgoing and very spirited.

[CONCLUSION (FOL)]:
¬((∃y ∃z (¬(x=y) ∧ ¬(x=z) ∧ ¬(y=z) ∧ Enjoy(x, celebratingLifeMileStoneEvent, y) ∧ Enjoy(x, celebratingLifeStoneEvent, z)) ∨ (Outgoing(carol) ∧ Sprited(carol)))

[CONCLUSION (GK)]:
-((? [Y] : ? [Z] : (-(X=Y) & -(X=Z) & -(Y=Z) & Enjoy(X, celebratingLifeMileStoneEvent, Y) & Enjoy(X, celebratingLifeStoneEvent, Z)) | (Outgoing(carol) & Sprited(carol))).


===

['x']
['x']
[PREMISE]:
All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.
Lipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.
No satin-finish lipsticks in the set do not have "rosewood" in its offical description. 
Lipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have "rosewood" in its offical description or it has "rosewood" in its official description. 
ROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has "rosewood" in its official description or has a velvet finish.

[PREMISE (FOL)]:
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ VelvetFinish(x)) → Refillable(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (VelvetFinish(x) ⊕ SatinFinish(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ SatinFinish(x)) → ¬RosewoodInDescription(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (RosewoodInDescription(x) ⊕ ¬RosewoodInDescription(x)))
Lipstick(rougeDiorColoredLipBalm999) ∧ In(rougeDiorColoredLipBalm999, rougeDiorSet) ∧ In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) ∧ (RosewoodInDescription(rougeDiorColoredLipBalm999) ⊕ VelvetFinish(rougeDiorColoredLipBalm999))

[PREMISE (GK)]:
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & VelvetFinish(X)) => Refillable(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (VelvetFinish(X) <~> SatinFinish(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & SatinFinish(X)) => -RosewoodInDescription(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (RosewoodInDescription(X) <~> -RosewoodInDescription(X))).
Lipstick(rougeDiorColoredLipBalm999) & In(rougeDiorColoredLipBalm999, rougeDiorSet) & In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) & (RosewoodInDescription(rougeDiorColoredLipBalm999) <~> VelvetFinish(rougeDiorColoredLipBalm999)).

[CONCLUSION]:
ROUGE Dior Colored Lip Balm 999 has a satin finish.

[CONCLUSION (FOL)]:
SatinFinish(rougeDiorColoredLipBalm999)

[CONCLUSION (GK)]:
SatinFinish(rougeDiorColoredLipBalm999).


===

['x']
['x']
[PREMISE]:
All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.
Lipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.
No satin-finish lipsticks in the set do not have "rosewood" in its offical description. 
Lipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have "rosewood" in its offical description or it has "rosewood" in its official description. 
ROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has "rosewood" in its official description or has a velvet finish.

[PREMISE (FOL)]:
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ VelvetFinish(x)) → Refillable(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (VelvetFinish(x) ⊕ SatinFinish(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ SatinFinish(x)) → ¬RosewoodInDescription(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (RosewoodInDescription(x) ⊕ ¬RosewoodInDescription(x)))
Lipstick(rougeDiorColoredLipBalm999) ∧ In(rougeDiorColoredLipBalm999, rougeDiorSet) ∧ In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) ∧ (RosewoodInDescription(rougeDiorColoredLipBalm999) ⊕ VelvetFinish(rougeDiorColoredLipBalm999))

[PREMISE (GK)]:
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & VelvetFinish(X)) => Refillable(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (VelvetFinish(X) <~> SatinFinish(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & SatinFinish(X)) => -RosewoodInDescription(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (RosewoodInDescription(X) <~> -RosewoodInDescription(X))).
Lipstick(rougeDiorColoredLipBalm999) & In(rougeDiorColoredLipBalm999, rougeDiorSet) & In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) & (RosewoodInDescription(rougeDiorColoredLipBalm999) <~> VelvetFinish(rougeDiorColoredLipBalm999)).

[CONCLUSION]:
ROUGE Dior Colored Lip Balm 999 has a satin finish and has "rosewood" in its official description.

[CONCLUSION (FOL)]:
Refillable(rougeDiorColoredLipBalm999) ∧ RosewoodInDescription(rougeDiorColoredLipBalm999)

[CONCLUSION (GK)]:
Refillable(rougeDiorColoredLipBalm999) & RosewoodInDescription(rougeDiorColoredLipBalm999).


===

['x']
['x']
[PREMISE]:
All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.
Lipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.
No satin-finish lipsticks in the set do not have "rosewood" in its offical description. 
Lipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have "rosewood" in its offical description or it has "rosewood" in its official description. 
ROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has "rosewood" in its official description or has a velvet finish.

[PREMISE (FOL)]:
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ VelvetFinish(x)) → Refillable(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (VelvetFinish(x) ⊕ SatinFinish(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ SatinFinish(x)) → ¬RosewoodInDescription(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (RosewoodInDescription(x) ⊕ ¬RosewoodInDescription(x)))
Lipstick(rougeDiorColoredLipBalm999) ∧ In(rougeDiorColoredLipBalm999, rougeDiorSet) ∧ In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) ∧ (RosewoodInDescription(rougeDiorColoredLipBalm999) ⊕ VelvetFinish(rougeDiorColoredLipBalm999))

[PREMISE (GK)]:
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & VelvetFinish(X)) => Refillable(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (VelvetFinish(X) <~> SatinFinish(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & SatinFinish(X)) => -RosewoodInDescription(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (RosewoodInDescription(X) <~> -RosewoodInDescription(X))).
Lipstick(rougeDiorColoredLipBalm999) & In(rougeDiorColoredLipBalm999, rougeDiorSet) & In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) & (RosewoodInDescription(rougeDiorColoredLipBalm999) <~> VelvetFinish(rougeDiorColoredLipBalm999)).

[CONCLUSION]:
ROUGE Dior Colored Lip Balm 999 either is refillable or has "rosewood" in its official description.

[CONCLUSION (FOL)]:
Refillable(rougeDiorColoredLipBalm999) ⊕ RosewoodInDescription(rougeDiorColoredLipBalm999)

[CONCLUSION (GK)]:
Refillable(rougeDiorColoredLipBalm999) <~> RosewoodInDescription(rougeDiorColoredLipBalm999).


===

['x']
['x']
[PREMISE]:
All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.
Lipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.
No satin-finish lipsticks in the set do not have "rosewood" in its offical description. 
Lipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have "rosewood" in its offical description or it has "rosewood" in its official description. 
ROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has "rosewood" in its official description or has a velvet finish.

[PREMISE (FOL)]:
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ VelvetFinish(x)) → Refillable(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (VelvetFinish(x) ⊕ SatinFinish(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ SatinFinish(x)) → ¬RosewoodInDescription(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (RosewoodInDescription(x) ⊕ ¬RosewoodInDescription(x)))
Lipstick(rougeDiorColoredLipBalm999) ∧ In(rougeDiorColoredLipBalm999, rougeDiorSet) ∧ In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) ∧ (RosewoodInDescription(rougeDiorColoredLipBalm999) ⊕ VelvetFinish(rougeDiorColoredLipBalm999))

[PREMISE (GK)]:
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & VelvetFinish(X)) => Refillable(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (VelvetFinish(X) <~> SatinFinish(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & SatinFinish(X)) => -RosewoodInDescription(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (RosewoodInDescription(X) <~> -RosewoodInDescription(X))).
Lipstick(rougeDiorColoredLipBalm999) & In(rougeDiorColoredLipBalm999, rougeDiorSet) & In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) & (RosewoodInDescription(rougeDiorColoredLipBalm999) <~> VelvetFinish(rougeDiorColoredLipBalm999)).

[CONCLUSION]:
If ROUGE Dior Colored Lip Balm 999 is not both a velvet finish ipstick in the set and refillable, then it neither is refillable nor has "rosewood" in its official description.

[CONCLUSION (FOL)]:
¬((Lipstick(rougeDiorColoredLipBalm999) ∧ In(rougeDiorColoredLipBalm999, rougeDiorSet) ∧ In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) ∧ VelvetFinish(rougeDiorColoredLipBalm999) ∧ Refillable(rougeDiorColoredLipBalm999)) → (¬Refillable(rougeDiorColoredLipBalm999) ∧ ¬RosewoodInDescription(rougeDiorColoredLipBalm999)))

[CONCLUSION (GK)]:
-((Lipstick(rougeDiorColoredLipBalm999) & In(rougeDiorColoredLipBalm999, rougeDiorSet) & In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) & VelvetFinish(rougeDiorColoredLipBalm999) & Refillable(rougeDiorColoredLipBalm999)) => (-Refillable(rougeDiorColoredLipBalm999) & -RosewoodInDescription(rougeDiorColoredLipBalm999))).


===

['x']
['x']
[PREMISE]:
All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.
Lipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.
No satin-finish lipsticks in the set do not have "rosewood" in its offical description. 
Lipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have "rosewood" in its offical description or it has "rosewood" in its official description. 
ROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has "rosewood" in its official description or has a velvet finish.

[PREMISE (FOL)]:
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ VelvetFinish(x)) → Refillable(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (VelvetFinish(x) ⊕ SatinFinish(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ SatinFinish(x)) → ¬RosewoodInDescription(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (RosewoodInDescription(x) ⊕ ¬RosewoodInDescription(x)))
Lipstick(rougeDiorColoredLipBalm999) ∧ In(rougeDiorColoredLipBalm999, rougeDiorSet) ∧ In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) ∧ (RosewoodInDescription(rougeDiorColoredLipBalm999) ⊕ VelvetFinish(rougeDiorColoredLipBalm999))

[PREMISE (GK)]:
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & VelvetFinish(X)) => Refillable(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (VelvetFinish(X) <~> SatinFinish(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & SatinFinish(X)) => -RosewoodInDescription(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (RosewoodInDescription(X) <~> -RosewoodInDescription(X))).
Lipstick(rougeDiorColoredLipBalm999) & In(rougeDiorColoredLipBalm999, rougeDiorSet) & In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) & (RosewoodInDescription(rougeDiorColoredLipBalm999) <~> VelvetFinish(rougeDiorColoredLipBalm999)).

[CONCLUSION]:
If ROUGE Dior Colored Lip Balm 999 is refillable and has "rosewood" in its official description, then it either has a velvet-finish or has "rosewood" in its official description.

[CONCLUSION (FOL)]:
(Refillable(rougeDiorColoredLipBalm999) ∧ RosewoodInDescription(rougeDiorColoredLipBalm999)) —> (VelvetFinish(rougeDiorColoredLipBalm999) ∨ RosewoodInDescription(rougeDiorColoredLipBalm999))

[CONCLUSION (GK)]:
(Refillable(rougeDiorColoredLipBalm999) & RosewoodInDescription(rougeDiorColoredLipBalm999)) —> (VelvetFinish(rougeDiorColoredLipBalm999) | RosewoodInDescription(rougeDiorColoredLipBalm999)).


===

['x']
['x']
[PREMISE]:
All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.
Lipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.
No satin-finish lipsticks in the set do not have "rosewood" in its offical description. 
Lipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have "rosewood" in its offical description or it has "rosewood" in its official description. 
ROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has "rosewood" in its official description or has a velvet finish.

[PREMISE (FOL)]:
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ VelvetFinish(x)) → Refillable(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (VelvetFinish(x) ⊕ SatinFinish(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ SatinFinish(x)) → ¬RosewoodInDescription(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (RosewoodInDescription(x) ⊕ ¬RosewoodInDescription(x)))
Lipstick(rougeDiorColoredLipBalm999) ∧ In(rougeDiorColoredLipBalm999, rougeDiorSet) ∧ In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) ∧ (RosewoodInDescription(rougeDiorColoredLipBalm999) ⊕ VelvetFinish(rougeDiorColoredLipBalm999))

[PREMISE (GK)]:
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & VelvetFinish(X)) => Refillable(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (VelvetFinish(X) <~> SatinFinish(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & SatinFinish(X)) => -RosewoodInDescription(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (RosewoodInDescription(X) <~> -RosewoodInDescription(X))).
Lipstick(rougeDiorColoredLipBalm999) & In(rougeDiorColoredLipBalm999, rougeDiorSet) & In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) & (RosewoodInDescription(rougeDiorColoredLipBalm999) <~> VelvetFinish(rougeDiorColoredLipBalm999)).

[CONCLUSION]:
If ROUGE Dior Colored Lip Balm 999 either does not have "rosewood" in its official description or is refillable, then it has "rosewood" in its official description.

[CONCLUSION (FOL)]:
(¬RosewoodInDescription(rougeEDiorColoredLipBalm999) ⊕ Refillable(rougeDiorColoredLipBalm999)) → RosewoodInDescription(rougeDiorColoredLipBalm999)

[CONCLUSION (GK)]:
(-RosewoodInDescription(rougeEDiorColoredLipBalm999) <~> Refillable(rougeDiorColoredLipBalm999)) => RosewoodInDescription(rougeDiorColoredLipBalm999).


===

['x']
['x']
[PREMISE]:
All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.
Lipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.
No satin-finish lipsticks in the set do not have "rosewood" in its offical description. 
Lipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have "rosewood" in its offical description or it has "rosewood" in its official description. 
ROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has "rosewood" in its official description or has a velvet finish.

[PREMISE (FOL)]:
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ VelvetFinish(x)) → Refillable(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (VelvetFinish(x) ⊕ SatinFinish(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ SatinFinish(x)) → ¬RosewoodInDescription(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (RosewoodInDescription(x) ⊕ ¬RosewoodInDescription(x)))
Lipstick(rougeDiorColoredLipBalm999) ∧ In(rougeDiorColoredLipBalm999, rougeDiorSet) ∧ In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) ∧ (RosewoodInDescription(rougeDiorColoredLipBalm999) ⊕ VelvetFinish(rougeDiorColoredLipBalm999))

[PREMISE (GK)]:
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & VelvetFinish(X)) => Refillable(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (VelvetFinish(X) <~> SatinFinish(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & SatinFinish(X)) => -RosewoodInDescription(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (RosewoodInDescription(X) <~> -RosewoodInDescription(X))).
Lipstick(rougeDiorColoredLipBalm999) & In(rougeDiorColoredLipBalm999, rougeDiorSet) & In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) & (RosewoodInDescription(rougeDiorColoredLipBalm999) <~> VelvetFinish(rougeDiorColoredLipBalm999)).

[CONCLUSION]:
If ROUGE Dior Colored Lip Balm 999 either does not have "rosewood" in its official description or is refillable, then it neither has a satin-finish nor has "rosewood" in its official description.

[CONCLUSION (FOL)]:
(RosewoodInDescription(rougeDiorColoredLipBalm999) ⊕ Refillable(rougeDiorColoredLipBalm999)) → ¬(SatinFinish(rougeDiorColoredLipBalm999) ∨ RosewoodInDescription(rougeDiorColoredLipBalm999))

[CONCLUSION (GK)]:
(RosewoodInDescription(rougeDiorColoredLipBalm999) <~> Refillable(rougeDiorColoredLipBalm999)) => -(SatinFinish(rougeDiorColoredLipBalm999) | RosewoodInDescription(rougeDiorColoredLipBalm999)).


===

['x']
['x']
[PREMISE]:
All velvet-finish lipsticks in the Rouge Dior set, Lunar New Year Limited Edition are refillable.
Lipsticks in the Rouge Dior set, Lunar New Year Limited Edition have either a velvet-finish or a satin-finish.
No satin-finish lipsticks in the set do not have "rosewood" in its offical description. 
Lipstcks in the Rouge Dior set, Lunar New Year Limited Edition either does not have "rosewood" in its offical description or it has "rosewood" in its official description. 
ROUGE Dior Colored Lip Balm 999 is a lipstick in the set, and it either has "rosewood" in its official description or has a velvet finish.

[PREMISE (FOL)]:
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ VelvetFinish(x)) → Refillable(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (VelvetFinish(x) ⊕ SatinFinish(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition) ∧ SatinFinish(x)) → ¬RosewoodInDescription(x))
∀x ((Lipstick(x) ∧ In(x, rougeDiorSet) ∧ In(x, lunarNewYearLimitedEdition)) → (RosewoodInDescription(x) ⊕ ¬RosewoodInDescription(x)))
Lipstick(rougeDiorColoredLipBalm999) ∧ In(rougeDiorColoredLipBalm999, rougeDiorSet) ∧ In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) ∧ (RosewoodInDescription(rougeDiorColoredLipBalm999) ⊕ VelvetFinish(rougeDiorColoredLipBalm999))

[PREMISE (GK)]:
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & VelvetFinish(X)) => Refillable(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (VelvetFinish(X) <~> SatinFinish(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition) & SatinFinish(X)) => -RosewoodInDescription(X)).
! [X] : ((Lipstick(X) & In(X, rougeDiorSet) & In(X, lunarNewYearLimitedEdition)) => (RosewoodInDescription(X) <~> -RosewoodInDescription(X))).
Lipstick(rougeDiorColoredLipBalm999) & In(rougeDiorColoredLipBalm999, rougeDiorSet) & In(rougeDiorColoredLipBalm999, lunarNewYearLimitedEdition) & (RosewoodInDescription(rougeDiorColoredLipBalm999) <~> VelvetFinish(rougeDiorColoredLipBalm999)).

[CONCLUSION]:
If ROUGE Dior Colored Lip Balm 999 is refillable or has "rosewood" in its official description, then it either is refillable or has "rosewood" in its official description..

[CONCLUSION (FOL)]:
(Refillable(rougeDiorColoredLipBalm999) ∨ RosewoodInDescription(rougeDiorColoredLipBalm999)) → (Refillable(rougeEDiorColoredLipBalm999) ⊕ RosewoodInDescription(rougeDiorColoredLipBalm999))

[CONCLUSION (GK)]:
(Refillable(rougeDiorColoredLipBalm999) | RosewoodInDescription(rougeDiorColoredLipBalm999)) => (Refillable(rougeEDiorColoredLipBalm999) <~> RosewoodInDescription(rougeDiorColoredLipBalm999)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All Senate Republicans are elected officials.
Some elected officials are not conservatives.

[PREMISE (FOL)]:
∀x (SenateRepublican(x) → ElectedOfficial(x))
∃x ∃y (ElectedOfficial(x) ∧ ElectedOfficial(y) ∧ ¬Conservative(x) ∧ ¬Conservative(y) ∧ ¬(x=y))

[PREMISE (GK)]:
! [X] : (SenateRepublican(X) => ElectedOfficial(X)).
? [X] : ? [Y] : (ElectedOfficial(X) & ElectedOfficial(Y) & -Conservative(X) & -Conservative(Y) & -(X=Y)).

[CONCLUSION]:
Some conservatives are not Senate Republicans.

[CONCLUSION (FOL)]:
∃x ∃y (Conservative(x) ∧ Conservative(y) ∧ ¬SenateRepublican(x) ∧ ¬SenateRepublican(y) ∧ ¬(x=y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Conservative(X) & Conservative(Y) & -SenateRepublican(X) & -SenateRepublican(Y) & -(X=Y)).


===

['x']
['x']
[PREMISE]:
No athletes never exercise.
All professional basketball players are athletes. 
All NBA players are professional basketball players. 
All Knicks players are NBA players. 
Either John is a professional basketball player and he never exercises, or he is not a professional basketball player and he sometimes exercises.

[PREMISE (FOL)]:
∀x (Athlete(x) → ¬NeverExercises(x)) Never: does not exist a time
∀x (ProfessionalBasketballPlayer(x) → Athlete(x))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
∀x (KnicksPlayer(x) → NBAPlayer(x))
¬(ProfessionalBasketballPlayer(jim) ⊕ NeverExercises(jim))

[PREMISE (GK)]:
! [X] : (Athlete(X) => -NeverExercises(X)) Never: does not exist a time.
! [X] : (ProfessionalBasketballPlayer(X) => Athlete(X)).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
! [X] : (KnicksPlayer(X) => NBAPlayer(X)).
-(ProfessionalBasketballPlayer(jim) <~> NeverExercises(jim)).

[CONCLUSION]:
Jim is a Knicks player.

[CONCLUSION (FOL)]:
KnicksPlayer(jim)

[CONCLUSION (GK)]:
KnicksPlayer(jim).


===

['x']
['x']
[PREMISE]:
No athletes never exercise.
All professional basketball players are athletes. 
All NBA players are professional basketball players. 
All Knicks players are NBA players. 
Either John is a professional basketball player and he never exercises, or he is not a professional basketball player and he sometimes exercises.

[PREMISE (FOL)]:
∀x (Athlete(x) → ¬NeverExercises(x)) Never: does not exist a time
∀x (ProfessionalBasketballPlayer(x) → Athlete(x))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
∀x (KnicksPlayer(x) → NBAPlayer(x))
¬(ProfessionalBasketballPlayer(jim) ⊕ NeverExercises(jim))

[PREMISE (GK)]:
! [X] : (Athlete(X) => -NeverExercises(X)) Never: does not exist a time.
! [X] : (ProfessionalBasketballPlayer(X) => Athlete(X)).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
! [X] : (KnicksPlayer(X) => NBAPlayer(X)).
-(ProfessionalBasketballPlayer(jim) <~> NeverExercises(jim)).

[CONCLUSION]:
Jim is not a Knicks player.

[CONCLUSION (FOL)]:
¬KnicksPlayer(jim)

[CONCLUSION (GK)]:
-KnicksPlayer(jim).


===

['x']
['x']
[PREMISE]:
No athletes never exercise.
All professional basketball players are athletes. 
All NBA players are professional basketball players. 
All Knicks players are NBA players. 
Either John is a professional basketball player and he never exercises, or he is not a professional basketball player and he sometimes exercises.

[PREMISE (FOL)]:
∀x (Athlete(x) → ¬NeverExercises(x)) Never: does not exist a time
∀x (ProfessionalBasketballPlayer(x) → Athlete(x))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
∀x (KnicksPlayer(x) → NBAPlayer(x))
¬(ProfessionalBasketballPlayer(jim) ⊕ NeverExercises(jim))

[PREMISE (GK)]:
! [X] : (Athlete(X) => -NeverExercises(X)) Never: does not exist a time.
! [X] : (ProfessionalBasketballPlayer(X) => Athlete(X)).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
! [X] : (KnicksPlayer(X) => NBAPlayer(X)).
-(ProfessionalBasketballPlayer(jim) <~> NeverExercises(jim)).

[CONCLUSION]:
Jim is an athlete.

[CONCLUSION (FOL)]:
Athlete(jim)

[CONCLUSION (GK)]:
Athlete(jim).


===

['x']
['x']
[PREMISE]:
All kids are young.
All toddlers are kids.
If someone is young, then they are not elderly.
All pirates are seafarers.
If Nancy is not a pirate, then Nancy is young.
If Nancy is not a toddler, then Nancy is a seafarer.

[PREMISE (FOL)]:
∀x (Kid(x) → Young(x))
∀x (Toddler(x) → Kid(x))
∀x (Young(x) → ¬Elderly(x))
∀x (Pirate(x) → Seafarer(x))
¬Pirate(nancy) → Young(nancy)
¬Toddler(nancy) → Seafarer(nancy)

[PREMISE (GK)]:
! [X] : (Kid(X) => Young(X)).
! [X] : (Toddler(X) => Kid(X)).
! [X] : (Young(X) => -Elderly(X)).
! [X] : (Pirate(X) => Seafarer(X)).
-Pirate(nancy) => Young(nancy).
-Toddler(nancy) => Seafarer(nancy).

[CONCLUSION]:
Nancy is a pirate.

[CONCLUSION (FOL)]:
Pirate(nancy)

[CONCLUSION (GK)]:
Pirate(nancy).


===

['x']
['x']
[PREMISE]:
All kids are young.
All toddlers are kids.
If someone is young, then they are not elderly.
All pirates are seafarers.
If Nancy is not a pirate, then Nancy is young.
If Nancy is not a toddler, then Nancy is a seafarer.

[PREMISE (FOL)]:
∀x (Kid(x) → Young(x))
∀x (Toddler(x) → Kid(x))
∀x (Young(x) → ¬Elderly(x))
∀x (Pirate(x) → Seafarer(x))
¬Pirate(nancy) → Young(nancy)
¬Toddler(nancy) → Seafarer(nancy)

[PREMISE (GK)]:
! [X] : (Kid(X) => Young(X)).
! [X] : (Toddler(X) => Kid(X)).
! [X] : (Young(X) => -Elderly(X)).
! [X] : (Pirate(X) => Seafarer(X)).
-Pirate(nancy) => Young(nancy).
-Toddler(nancy) => Seafarer(nancy).

[CONCLUSION]:
Nancy is either both a pirate and a toddler, or neither a pirate nor a toddler.

[CONCLUSION (FOL)]:
¬(Pirate(nancy) ⊕ Toddler(nancy))

[CONCLUSION (GK)]:
-(Pirate(nancy) <~> Toddler(nancy)).


===

['x']
['x']
[PREMISE]:
All kids are young.
All toddlers are kids.
If someone is young, then they are not elderly.
All pirates are seafarers.
If Nancy is not a pirate, then Nancy is young.
If Nancy is not a toddler, then Nancy is a seafarer.

[PREMISE (FOL)]:
∀x (Kid(x) → Young(x))
∀x (Toddler(x) → Kid(x))
∀x (Young(x) → ¬Elderly(x))
∀x (Pirate(x) → Seafarer(x))
¬Pirate(nancy) → Young(nancy)
¬Toddler(nancy) → Seafarer(nancy)

[PREMISE (GK)]:
! [X] : (Kid(X) => Young(X)).
! [X] : (Toddler(X) => Kid(X)).
! [X] : (Young(X) => -Elderly(X)).
! [X] : (Pirate(X) => Seafarer(X)).
-Pirate(nancy) => Young(nancy).
-Toddler(nancy) => Seafarer(nancy).

[CONCLUSION]:
If Nancy is not either a pirate or a toddler, then she is young and is a kid.

[CONCLUSION (FOL)]:
¬(Pirate(nancy) ⊕ Toddler(nancy)) → Young(nancy) ∧ Kid(nancy)

[CONCLUSION (GK)]:
-(Pirate(nancy) <~> Toddler(nancy)) => Young(nancy) & Kid(nancy).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Lana Wilson directed After Tiller, The Departure, and Miss Americana.
If a film is directed by a person, the person is a filmmaker.
After Tiller is a documentary.
The documentary is a type of film.
Lana Wilson is from Kirkland.
Kirkland is a US city.
If a person is from a city in a country, the person is from the country.
After Tiller is nominated for the Independent Spirit Award for Best Documentary.

[PREMISE (FOL)]:
DirectedBy(afterTiller, lanaWilson) ∧ DirectedBy(theDeparture, lanaWilson) ∧ DirectedBy(missAmericana, lanaWilson)
∀x ∀y (DirectedBy(x, y) → Filmmaker(y))
Documentary(afterTiller)
∀x (Documentary(x) → Film(x))
From(lanaWilson, kirkland)
In(kirkland, unitedStates)
∀x ∀y ∀z ((From(x, y) ∧ In(y, z)) → From(x, z))
Nomination(afterTiller, theIndependentSpiritAwardForBestDocumentary)

[PREMISE (GK)]:
DirectedBy(afterTiller, lanaWilson) & DirectedBy(theDeparture, lanaWilson) & DirectedBy(missAmericana, lanaWilson).
! [X] : ! [Y] : (DirectedBy(X, Y) => Filmmaker(Y)).
Documentary(afterTiller).
! [X] : (Documentary(X) => Film(X)).
From(lanaWilson, kirkland).
In(kirkland, unitedStates).
! [X] : ! [Y] : ! [Z] : ((From(X, Y) & In(Y, Z)) => From(X, Z)).
Nomination(afterTiller, theIndependentSpiritAwardForBestDocumentary).

[CONCLUSION]:
Lana Wilson is a US filmmaker.

[CONCLUSION (FOL)]:
From(lanaWilson, unitedStates) ∧ Filmmaker(lanaWilson)

[CONCLUSION (GK)]:
From(lanaWilson, unitedStates) & Filmmaker(lanaWilson).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Lana Wilson directed After Tiller, The Departure, and Miss Americana.
If a film is directed by a person, the person is a filmmaker.
After Tiller is a documentary.
The documentary is a type of film.
Lana Wilson is from Kirkland.
Kirkland is a US city.
If a person is from a city in a country, the person is from the country.
After Tiller is nominated for the Independent Spirit Award for Best Documentary.

[PREMISE (FOL)]:
DirectedBy(afterTiller, lanaWilson) ∧ DirectedBy(theDeparture, lanaWilson) ∧ DirectedBy(missAmericana, lanaWilson)
∀x ∀y (DirectedBy(x, y) → Filmmaker(y))
Documentary(afterTiller)
∀x (Documentary(x) → Film(x))
From(lanaWilson, kirkland)
In(kirkland, unitedStates)
∀x ∀y ∀z ((From(x, y) ∧ In(y, z)) → From(x, z))
Nomination(afterTiller, theIndependentSpiritAwardForBestDocumentary)

[PREMISE (GK)]:
DirectedBy(afterTiller, lanaWilson) & DirectedBy(theDeparture, lanaWilson) & DirectedBy(missAmericana, lanaWilson).
! [X] : ! [Y] : (DirectedBy(X, Y) => Filmmaker(Y)).
Documentary(afterTiller).
! [X] : (Documentary(X) => Film(X)).
From(lanaWilson, kirkland).
In(kirkland, unitedStates).
! [X] : ! [Y] : ! [Z] : ((From(X, Y) & In(Y, Z)) => From(X, Z)).
Nomination(afterTiller, theIndependentSpiritAwardForBestDocumentary).

[CONCLUSION]:
Miss Americana is not directed by a filmmaker from Kirkland.

[CONCLUSION (FOL)]:
¬∃x(Filmmaker(x) ∧ From(x, kirkland) ∧ DirectedBy(missAmericana, x))

[CONCLUSION (GK)]:
-? [X] :(Filmmaker(X) & From(X, kirkland) & DirectedBy(missAmericana, X)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Lana Wilson directed After Tiller, The Departure, and Miss Americana.
If a film is directed by a person, the person is a filmmaker.
After Tiller is a documentary.
The documentary is a type of film.
Lana Wilson is from Kirkland.
Kirkland is a US city.
If a person is from a city in a country, the person is from the country.
After Tiller is nominated for the Independent Spirit Award for Best Documentary.

[PREMISE (FOL)]:
DirectedBy(afterTiller, lanaWilson) ∧ DirectedBy(theDeparture, lanaWilson) ∧ DirectedBy(missAmericana, lanaWilson)
∀x ∀y (DirectedBy(x, y) → Filmmaker(y))
Documentary(afterTiller)
∀x (Documentary(x) → Film(x))
From(lanaWilson, kirkland)
In(kirkland, unitedStates)
∀x ∀y ∀z ((From(x, y) ∧ In(y, z)) → From(x, z))
Nomination(afterTiller, theIndependentSpiritAwardForBestDocumentary)

[PREMISE (GK)]:
DirectedBy(afterTiller, lanaWilson) & DirectedBy(theDeparture, lanaWilson) & DirectedBy(missAmericana, lanaWilson).
! [X] : ! [Y] : (DirectedBy(X, Y) => Filmmaker(Y)).
Documentary(afterTiller).
! [X] : (Documentary(X) => Film(X)).
From(lanaWilson, kirkland).
In(kirkland, unitedStates).
! [X] : ! [Y] : ! [Z] : ((From(X, Y) & In(Y, Z)) => From(X, Z)).
Nomination(afterTiller, theIndependentSpiritAwardForBestDocumentary).

[CONCLUSION]:
Lana Wilson has won the Independent Spirit Award.

[CONCLUSION (FOL)]:
FilmmakerAward(lanaWilson, theIndependentSpiritAwardForBestDocumentary)

[CONCLUSION (GK)]:
FilmmakerAward(lanaWilson, theIndependentSpiritAwardForBestDocumentary).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All bears in zoos are not wild. 
Some bears are in zoos. 

[PREMISE (FOL)]:
∀x ((Bear(x) ∧ In(x, zoo)) → ¬Wild(x))
∃x ∃y (Bear(x) ∧ Bear(y) ∧ In(x, zoo) ∧ In(y, zoo) ∧ ¬(x=y))

[PREMISE (GK)]:
! [X] : ((Bear(X) & In(X, zoo)) => -Wild(X)).
? [X] : ? [Y] : (Bear(X) & Bear(Y) & In(X, zoo) & In(Y, zoo) & -(X=Y)).

[CONCLUSION]:
Not all bears are wild.

[CONCLUSION (FOL)]:
∃x (Bear(x) ∧ ¬Wild(x))

[CONCLUSION (GK)]:
? [X] : (Bear(X) & -Wild(X)).


===

['x']
['x']
[PREMISE]:
If a person is the leader of a country for life, that person has power.
Leaders of a country for life are either a king or a queen.
Queens are female.
Kings are male. 
Elizabeth is a queen.
Elizabeth is a leader of a country for life.

[PREMISE (FOL)]:
∀x (Leader(x) → HavePower(x))
∀x (Leader(x) → (King(x) ⊕ Queen(x)))
∀x (Queen(x) → Female(x))
∀x (King(x) → Male(x))
Queen(elizabeth)
Leader(elizabeth)

[PREMISE (GK)]:
! [X] : (Leader(X) => HavePower(X)).
! [X] : (Leader(X) => (King(X) <~> Queen(X))).
! [X] : (Queen(X) => Female(X)).
! [X] : (King(X) => Male(X)).
Queen(elizabeth).
Leader(elizabeth).

[CONCLUSION]:
Elizabeth is a king.

[CONCLUSION (FOL)]:
King(elizabeth)

[CONCLUSION (GK)]:
King(elizabeth).


===

['x']
['x']
[PREMISE]:
If a person is the leader of a country for life, that person has power.
Leaders of a country for life are either a king or a queen.
Queens are female.
Kings are male. 
Elizabeth is a queen.
Elizabeth is a leader of a country for life.

[PREMISE (FOL)]:
∀x (Leader(x) → HavePower(x))
∀x (Leader(x) → (King(x) ⊕ Queen(x)))
∀x (Queen(x) → Female(x))
∀x (King(x) → Male(x))
Queen(elizabeth)
Leader(elizabeth)

[PREMISE (GK)]:
! [X] : (Leader(X) => HavePower(X)).
! [X] : (Leader(X) => (King(X) <~> Queen(X))).
! [X] : (Queen(X) => Female(X)).
! [X] : (King(X) => Male(X)).
Queen(elizabeth).
Leader(elizabeth).

[CONCLUSION]:
Elizabeth has power.

[CONCLUSION (FOL)]:
HavePower(elizabeth)

[CONCLUSION (GK)]:
HavePower(elizabeth).


===

['x']
['x']
[PREMISE]:
If a person is the leader of a country for life, that person has power.
Leaders of a country for life are either a king or a queen.
Queens are female.
Kings are male. 
Elizabeth is a queen.
Elizabeth is a leader of a country for life.

[PREMISE (FOL)]:
∀x (Leader(x) → HavePower(x))
∀x (Leader(x) → (King(x) ⊕ Queen(x)))
∀x (Queen(x) → Female(x))
∀x (King(x) → Male(x))
Queen(elizabeth)
Leader(elizabeth)

[PREMISE (GK)]:
! [X] : (Leader(X) => HavePower(X)).
! [X] : (Leader(X) => (King(X) <~> Queen(X))).
! [X] : (Queen(X) => Female(X)).
! [X] : (King(X) => Male(X)).
Queen(elizabeth).
Leader(elizabeth).

[CONCLUSION]:
Elizabeth is a leader of a country for life.

[CONCLUSION (FOL)]:
Leader(elizabeth)

[CONCLUSION (GK)]:
Leader(elizabeth).


===

['x']
['x']
[PREMISE]:
All people who went to Clay's school and who make their own matcha teas every morning with ceremonial-grade matcha powder do not wake up late and start their schedules past noon regularly.
All people who went to Clay's school, who live in California, and attend yoga classes regularly, make their own matcha teas every morning with ceremonial-grade matcha powder.
All people who went to Clay's school, and work in the entertainment industry as high-profile celebrities, wake up late and start their schedules past noon regularly.
All people who went to Clay's school that do not have regular 9-5 jobs, work in the entertainment industry as high-profile celebrities.
All people who went to Clay's school and prefer working at home over going to the office daily do not have regular 9-5 jobs.
Bunny went to Clay's school, and she either prefers to work at home over going to the office and makes her own matcha teas every morning with ceremonial-grade matcha powder, or does not prefer to work at home over going to the office every day and does not make her own matcha teas every morning with ceremonial-grade matcha powder.

[PREMISE (FOL)]:
∀x (GoTo(x, claysSchool) ∧ MakeWith(x, theirOwnMatchTea, ceremonialGradePowder) → ¬(WakeUpLate(x) ∧ StartPastNoonRegularly(x, schedule)))
∀x (GoTo(x, claysSchool) ∧ LiveIn(x, california) ∧ AttendRegularly(x, yogaClass) → MakeWith(x, ownMatch, ceremonialGradePowder))
∀x (GoTo(x, claysSchool) ∧ WorkInAs(x, entertainmentIndustry, highProfileCelebrity) → (WakeUpLate(x) ∧ StartPastNoonRegularly(x, schedule)))
∀x (GoTo(x, claysSchool) ∧ ¬(Have(x, y) ∧ Regular(y) ∧ NineToFiveJob(y)) → WorkInAs(x, entertainmentIndustry, highProfileCelebrity))
∀x (GoTo(x, claysSchool) ∧ Prefer(x, workingAtHome, goingToTheOffice) → ¬(Have(x, y) ∧ Regular(y) ∧ NineToFiveJob(y)))
GoTo(bunny, claysSchool) ∧ ¬(Prefer(bunny, workingAtHome, goingToTheOffice) ⊕ MakeWith(bunny, theirOwnMatchTea, ceremonialGradePowder))

[PREMISE (GK)]:
! [X] : (GoTo(X, claysSchool) & MakeWith(X, theirOwnMatchTea, ceremonialGradePowder) => -(WakeUpLate(X) & StartPastNoonRegularly(X, schedule))).
! [X] : (GoTo(X, claysSchool) & LiveIn(X, california) & AttendRegularly(X, yogaClass) => MakeWith(X, ownMatch, ceremonialGradePowder)).
! [X] : (GoTo(X, claysSchool) & WorkInAs(X, entertainmentIndustry, highProfileCelebrity) => (WakeUpLate(X) & StartPastNoonRegularly(X, schedule))).
! [X] : (GoTo(X, claysSchool) & -(Have(X, y) & Regular(y) & NineToFiveJob(y)) => WorkInAs(X, entertainmentIndustry, highProfileCelebrity)).
! [X] : (GoTo(X, claysSchool) & Prefer(X, workingAtHome, goingToTheOffice) => -(Have(X, y) & Regular(y) & NineToFiveJob(y))).
GoTo(bunny, claysSchool) & -(Prefer(bunny, workingAtHome, goingToTheOffice) <~> MakeWith(bunny, theirOwnMatchTea, ceremonialGradePowder)).

[CONCLUSION]:
Bunny does not have a regular 9-5 job.

[CONCLUSION (FOL)]:
Have(bunny, y) ∧ Regular(y) ∧ NineToFiveJob(y)

[CONCLUSION (GK)]:
Have(bunny, y) & Regular(y) & NineToFiveJob(y).


===

['x']
['x']
[PREMISE]:
All people who went to Clay's school and who make their own matcha teas every morning with ceremonial-grade matcha powder do not wake up late and start their schedules past noon regularly.
All people who went to Clay's school, who live in California, and attend yoga classes regularly, make their own matcha teas every morning with ceremonial-grade matcha powder.
All people who went to Clay's school, and work in the entertainment industry as high-profile celebrities, wake up late and start their schedules past noon regularly.
All people who went to Clay's school that do not have regular 9-5 jobs, work in the entertainment industry as high-profile celebrities.
All people who went to Clay's school and prefer working at home over going to the office daily do not have regular 9-5 jobs.
Bunny went to Clay's school, and she either prefers to work at home over going to the office and makes her own matcha teas every morning with ceremonial-grade matcha powder, or does not prefer to work at home over going to the office every day and does not make her own matcha teas every morning with ceremonial-grade matcha powder.

[PREMISE (FOL)]:
∀x (GoTo(x, claysSchool) ∧ MakeWith(x, theirOwnMatchTea, ceremonialGradePowder) → ¬(WakeUpLate(x) ∧ StartPastNoonRegularly(x, schedule)))
∀x (GoTo(x, claysSchool) ∧ LiveIn(x, california) ∧ AttendRegularly(x, yogaClass) → MakeWith(x, ownMatch, ceremonialGradePowder))
∀x (GoTo(x, claysSchool) ∧ WorkInAs(x, entertainmentIndustry, highProfileCelebrity) → (WakeUpLate(x) ∧ StartPastNoonRegularly(x, schedule)))
∀x (GoTo(x, claysSchool) ∧ ¬(Have(x, y) ∧ Regular(y) ∧ NineToFiveJob(y)) → WorkInAs(x, entertainmentIndustry, highProfileCelebrity))
∀x (GoTo(x, claysSchool) ∧ Prefer(x, workingAtHome, goingToTheOffice) → ¬(Have(x, y) ∧ Regular(y) ∧ NineToFiveJob(y)))
GoTo(bunny, claysSchool) ∧ ¬(Prefer(bunny, workingAtHome, goingToTheOffice) ⊕ MakeWith(bunny, theirOwnMatchTea, ceremonialGradePowder))

[PREMISE (GK)]:
! [X] : (GoTo(X, claysSchool) & MakeWith(X, theirOwnMatchTea, ceremonialGradePowder) => -(WakeUpLate(X) & StartPastNoonRegularly(X, schedule))).
! [X] : (GoTo(X, claysSchool) & LiveIn(X, california) & AttendRegularly(X, yogaClass) => MakeWith(X, ownMatch, ceremonialGradePowder)).
! [X] : (GoTo(X, claysSchool) & WorkInAs(X, entertainmentIndustry, highProfileCelebrity) => (WakeUpLate(X) & StartPastNoonRegularly(X, schedule))).
! [X] : (GoTo(X, claysSchool) & -(Have(X, y) & Regular(y) & NineToFiveJob(y)) => WorkInAs(X, entertainmentIndustry, highProfileCelebrity)).
! [X] : (GoTo(X, claysSchool) & Prefer(X, workingAtHome, goingToTheOffice) => -(Have(X, y) & Regular(y) & NineToFiveJob(y))).
GoTo(bunny, claysSchool) & -(Prefer(bunny, workingAtHome, goingToTheOffice) <~> MakeWith(bunny, theirOwnMatchTea, ceremonialGradePowder)).

[CONCLUSION]:
Bunny went to Clay's school and she lives in California and attends yoga classes regularly.

[CONCLUSION (FOL)]:
LiveIn(bunny, california) ∧ AttendRegularly(bunny, yogaClass)

[CONCLUSION (GK)]:
LiveIn(bunny, california) & AttendRegularly(bunny, yogaClass).


===

['x']
['x']
[PREMISE]:
All people who went to Clay's school and who make their own matcha teas every morning with ceremonial-grade matcha powder do not wake up late and start their schedules past noon regularly.
All people who went to Clay's school, who live in California, and attend yoga classes regularly, make their own matcha teas every morning with ceremonial-grade matcha powder.
All people who went to Clay's school, and work in the entertainment industry as high-profile celebrities, wake up late and start their schedules past noon regularly.
All people who went to Clay's school that do not have regular 9-5 jobs, work in the entertainment industry as high-profile celebrities.
All people who went to Clay's school and prefer working at home over going to the office daily do not have regular 9-5 jobs.
Bunny went to Clay's school, and she either prefers to work at home over going to the office and makes her own matcha teas every morning with ceremonial-grade matcha powder, or does not prefer to work at home over going to the office every day and does not make her own matcha teas every morning with ceremonial-grade matcha powder.

[PREMISE (FOL)]:
∀x (GoTo(x, claysSchool) ∧ MakeWith(x, theirOwnMatchTea, ceremonialGradePowder) → ¬(WakeUpLate(x) ∧ StartPastNoonRegularly(x, schedule)))
∀x (GoTo(x, claysSchool) ∧ LiveIn(x, california) ∧ AttendRegularly(x, yogaClass) → MakeWith(x, ownMatch, ceremonialGradePowder))
∀x (GoTo(x, claysSchool) ∧ WorkInAs(x, entertainmentIndustry, highProfileCelebrity) → (WakeUpLate(x) ∧ StartPastNoonRegularly(x, schedule)))
∀x (GoTo(x, claysSchool) ∧ ¬(Have(x, y) ∧ Regular(y) ∧ NineToFiveJob(y)) → WorkInAs(x, entertainmentIndustry, highProfileCelebrity))
∀x (GoTo(x, claysSchool) ∧ Prefer(x, workingAtHome, goingToTheOffice) → ¬(Have(x, y) ∧ Regular(y) ∧ NineToFiveJob(y)))
GoTo(bunny, claysSchool) ∧ ¬(Prefer(bunny, workingAtHome, goingToTheOffice) ⊕ MakeWith(bunny, theirOwnMatchTea, ceremonialGradePowder))

[PREMISE (GK)]:
! [X] : (GoTo(X, claysSchool) & MakeWith(X, theirOwnMatchTea, ceremonialGradePowder) => -(WakeUpLate(X) & StartPastNoonRegularly(X, schedule))).
! [X] : (GoTo(X, claysSchool) & LiveIn(X, california) & AttendRegularly(X, yogaClass) => MakeWith(X, ownMatch, ceremonialGradePowder)).
! [X] : (GoTo(X, claysSchool) & WorkInAs(X, entertainmentIndustry, highProfileCelebrity) => (WakeUpLate(X) & StartPastNoonRegularly(X, schedule))).
! [X] : (GoTo(X, claysSchool) & -(Have(X, y) & Regular(y) & NineToFiveJob(y)) => WorkInAs(X, entertainmentIndustry, highProfileCelebrity)).
! [X] : (GoTo(X, claysSchool) & Prefer(X, workingAtHome, goingToTheOffice) => -(Have(X, y) & Regular(y) & NineToFiveJob(y))).
GoTo(bunny, claysSchool) & -(Prefer(bunny, workingAtHome, goingToTheOffice) <~> MakeWith(bunny, theirOwnMatchTea, ceremonialGradePowder)).

[CONCLUSION]:
Bunny went to Clay's school and she neither prefers working at home over going to the office nor lives in California and attends yoga classes regularly.

[CONCLUSION (FOL)]:
¬(Prefer(bunny, workingAtHome, goingToTheOffice) ∨ (LiveIn(bunny, california) ∧ AttendRegularly(bunny, yogaClass)))

[CONCLUSION (GK)]:
-(Prefer(bunny, workingAtHome, goingToTheOffice) | (LiveIn(bunny, california) & AttendRegularly(bunny, yogaClass))).


===

[]
[]
[PREMISE]:
Thomas Barber was an English professional footballer.
Thomas Barber played in the Football League for Aston Villa.
Thomas Barber played as a halfback and inside left.
Thomas Barber scored the winning goal in the 1913 FA Cup Final.

[PREMISE (FOL)]:
English(thomasBarber) ∧ ProfessionalFootballer(thomasBarber)
PlayedFor(thomasBarber, astonVilla) ∧ PlayedIn(astonVilla,theFootballLeague)
PlayedAs(thomasBarber, halfBack) ∧ PlayedAs(thomasBarber, insideLeft)
ScoredTheWinningGoalIn(thomasBarber, facupfinal1913)

[PREMISE (GK)]:
English(thomasBarber) & ProfessionalFootballer(thomasBarber).
PlayedFor(thomasBarber, astonVilla) & PlayedIn(astonVilla,theFootballLeague).
PlayedAs(thomasBarber, halfBack) & PlayedAs(thomasBarber, insideLeft).
ScoredTheWinningGoalIn(thomasBarber, facupfinal1913).

[CONCLUSION]:
Thomas Barber played in the Football League for Bolton Wanderers

[CONCLUSION (FOL)]:
PlayedFor(thomasBarber, boltonWanderers) ∧ PlayedIn(boltonWanderers,theFootballLeague)

[CONCLUSION (GK)]:
PlayedFor(thomasBarber, boltonWanderers) & PlayedIn(boltonWanderers,theFootballLeague).


===

[]
[]
[PREMISE]:
Thomas Barber was an English professional footballer.
Thomas Barber played in the Football League for Aston Villa.
Thomas Barber played as a halfback and inside left.
Thomas Barber scored the winning goal in the 1913 FA Cup Final.

[PREMISE (FOL)]:
English(thomasBarber) ∧ ProfessionalFootballer(thomasBarber)
PlayedFor(thomasBarber, astonVilla) ∧ PlayedIn(astonVilla,theFootballLeague)
PlayedAs(thomasBarber, halfBack) ∧ PlayedAs(thomasBarber, insideLeft)
ScoredTheWinningGoalIn(thomasBarber, facupfinal1913)

[PREMISE (GK)]:
English(thomasBarber) & ProfessionalFootballer(thomasBarber).
PlayedFor(thomasBarber, astonVilla) & PlayedIn(astonVilla,theFootballLeague).
PlayedAs(thomasBarber, halfBack) & PlayedAs(thomasBarber, insideLeft).
ScoredTheWinningGoalIn(thomasBarber, facupfinal1913).

[CONCLUSION]:
Thomas Barber played as an inside left.

[CONCLUSION (FOL)]:
PlayedAs(thomasBarber, insideLeft)

[CONCLUSION (GK)]:
PlayedAs(thomasBarber, insideLeft).


===

[]
['x']
[PREMISE]:
Thomas Barber was an English professional footballer.
Thomas Barber played in the Football League for Aston Villa.
Thomas Barber played as a halfback and inside left.
Thomas Barber scored the winning goal in the 1913 FA Cup Final.

[PREMISE (FOL)]:
English(thomasBarber) ∧ ProfessionalFootballer(thomasBarber)
PlayedFor(thomasBarber, astonVilla) ∧ PlayedIn(astonVilla,theFootballLeague)
PlayedAs(thomasBarber, halfBack) ∧ PlayedAs(thomasBarber, insideLeft)
ScoredTheWinningGoalIn(thomasBarber, facupfinal1913)

[PREMISE (GK)]:
English(thomasBarber) & ProfessionalFootballer(thomasBarber).
PlayedFor(thomasBarber, astonVilla) & PlayedIn(astonVilla,theFootballLeague).
PlayedAs(thomasBarber, halfBack) & PlayedAs(thomasBarber, insideLeft).
ScoredTheWinningGoalIn(thomasBarber, facupfinal1913).

[CONCLUSION]:
An English professional footballer scored the winning goal in the 1913 FA Cup Final.

[CONCLUSION (FOL)]:
∃x (English(x) ∧ ProfessionalFootballer(x) ∧ ScoredTheWinningGoalIn(x, facupfinal1913))

[CONCLUSION (GK)]:
? [X] : (English(X) & ProfessionalFootballer(X) & ScoredTheWinningGoalIn(X, facupfinal1913)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If a person plays an instrument in a concert, they are good at playing this kind of instrument.
Peter plays piano, violin, and saxophone.
Peter plays piano in a concert.
Oliver and Peter both play instruments in a concert.
Oliver plays a different musical instrument from Peter in the concert.

[PREMISE (FOL)]:
∀x ∀y (PlayIn(y, x, concert) → GoodAtPlaying(y, x))
Play(peter, piano) ∧ Play(peter, violin) ∧ Play(peter, saxophone)
PlayIn(peter, piano, concert)
∃x ∃y (PlayIn(peter, x, concert) ∧ PlayIn(oliver, y, concert))
∀x (PlayIn(oliver, x, concert) → ¬PlayIn(peter, y, concert))

[PREMISE (GK)]:
! [X] : ! [Y] : (PlayIn(Y, X, concert) => GoodAtPlaying(Y, X)).
Play(peter, piano) & Play(peter, violin) & Play(peter, saxophone).
PlayIn(peter, piano, concert).
? [X] : ? [Y] : (PlayIn(peter, X, concert) & PlayIn(oliver, Y, concert)).
! [X] : (PlayIn(oliver, X, concert) => -PlayIn(peter, y, concert)).

[CONCLUSION]:
Oliver plays piano in the concert.

[CONCLUSION (FOL)]:
PlayIn(oliver, piano, concert)

[CONCLUSION (GK)]:
PlayIn(oliver, piano, concert).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If a person plays an instrument in a concert, they are good at playing this kind of instrument.
Peter plays piano, violin, and saxophone.
Peter plays piano in a concert.
Oliver and Peter both play instruments in a concert.
Oliver plays a different musical instrument from Peter in the concert.

[PREMISE (FOL)]:
∀x ∀y (PlayIn(y, x, concert) → GoodAtPlaying(y, x))
Play(peter, piano) ∧ Play(peter, violin) ∧ Play(peter, saxophone)
PlayIn(peter, piano, concert)
∃x ∃y (PlayIn(peter, x, concert) ∧ PlayIn(oliver, y, concert))
∀x (PlayIn(oliver, x, concert) → ¬PlayIn(peter, y, concert))

[PREMISE (GK)]:
! [X] : ! [Y] : (PlayIn(Y, X, concert) => GoodAtPlaying(Y, X)).
Play(peter, piano) & Play(peter, violin) & Play(peter, saxophone).
PlayIn(peter, piano, concert).
? [X] : ? [Y] : (PlayIn(peter, X, concert) & PlayIn(oliver, Y, concert)).
! [X] : (PlayIn(oliver, X, concert) => -PlayIn(peter, y, concert)).

[CONCLUSION]:
Oliver plays violin in the concert.

[CONCLUSION (FOL)]:
PlayIn(oliver, violin, concert)

[CONCLUSION (GK)]:
PlayIn(oliver, violin, concert).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If a person plays an instrument in a concert, they are good at playing this kind of instrument.
Peter plays piano, violin, and saxophone.
Peter plays piano in a concert.
Oliver and Peter both play instruments in a concert.
Oliver plays a different musical instrument from Peter in the concert.

[PREMISE (FOL)]:
∀x ∀y (PlayIn(y, x, concert) → GoodAtPlaying(y, x))
Play(peter, piano) ∧ Play(peter, violin) ∧ Play(peter, saxophone)
PlayIn(peter, piano, concert)
∃x ∃y (PlayIn(peter, x, concert) ∧ PlayIn(oliver, y, concert))
∀x (PlayIn(oliver, x, concert) → ¬PlayIn(peter, y, concert))

[PREMISE (GK)]:
! [X] : ! [Y] : (PlayIn(Y, X, concert) => GoodAtPlaying(Y, X)).
Play(peter, piano) & Play(peter, violin) & Play(peter, saxophone).
PlayIn(peter, piano, concert).
? [X] : ? [Y] : (PlayIn(peter, X, concert) & PlayIn(oliver, Y, concert)).
! [X] : (PlayIn(oliver, X, concert) => -PlayIn(peter, y, concert)).

[CONCLUSION]:
Peter is good at playing piano.

[CONCLUSION (FOL)]:
GoodAtPlaying(peter, piano)

[CONCLUSION (GK)]:
GoodAtPlaying(peter, piano).


===

['x']
['x']
[PREMISE]:
Functional brainstems are necessary for breath control.
All humans that can swim can control their breath. 
Humans can swim or walk. 
Humans who can walk can stand on the ground by themselves. 
Humans whose brainstems are functional can control their balance.
Every human who can stand on the ground by themselves has functional leg muscles. 
George and Archie are humans.
George can control his balance and can swim.
Archie can walk if and only if he has functional brainstems.

[PREMISE (FOL)]:
∀x (CanControl(x, breath) → FunctionalBrainStem(x))
∀x (Human(x) ∧ CanSwim(x) → CanControl(x, breath))
∀x (Human(x) → (CanSwim(x) ∨ CanWalk(x)))
∀x (Human(x) ∧ CanWalk(x) → CanStandOnTheGround(x, themselves))
∀x (Human(x) ∧ FunctionalBrainStem(x) → CanControl(x, balance))
∀x (Human(x) ∧ CanStandOnTheGround(x, themselves) → FunctionalLegMuscle(x)))
Human(george) ∧ Human(archie)
CanControl(george, balance) ∧ CanSwim(george)
¬(CanWalk(archie) ⊕ FunctionalBrainStem(x))


[PREMISE (GK)]:
! [X] : (CanControl(X, breath) => FunctionalBrainStem(X)).
! [X] : (Human(X) & CanSwim(X) => CanControl(X, breath)).
! [X] : (Human(X) => (CanSwim(X) | CanWalk(X))).
! [X] : (Human(X) & CanWalk(X) => CanStandOnTheGround(X, themselves)).
! [X] : (Human(X) & FunctionalBrainStem(X) => CanControl(X, balance)).
! [X] : (Human(X) & CanStandOnTheGround(X, themselves) => FunctionalLegMuscle(X))).
Human(george) & Human(archie).
CanControl(george, balance) & CanSwim(george).
-(CanWalk(archie) <~> FunctionalBrainStem(x)).
.

[CONCLUSION]:
George has functional leg muscles.

[CONCLUSION (FOL)]:
FunctionalLegMuscle(archie)

[CONCLUSION (GK)]:
FunctionalLegMuscle(archie).


===

['x']
['x']
[PREMISE]:
Functional brainstems are necessary for breath control.
All humans that can swim can control their breath. 
Humans can swim or walk. 
Humans who can walk can stand on the ground by themselves. 
Humans whose brainstems are functional can control their balance.
Every human who can stand on the ground by themselves has functional leg muscles. 
George and Archie are humans.
George can control his balance and can swim.
Archie can walk if and only if he has functional brainstems.

[PREMISE (FOL)]:
∀x (CanControl(x, breath) → FunctionalBrainStem(x))
∀x (Human(x) ∧ CanSwim(x) → CanControl(x, breath))
∀x (Human(x) → (CanSwim(x) ∨ CanWalk(x)))
∀x (Human(x) ∧ CanWalk(x) → CanStandOnTheGround(x, themselves))
∀x (Human(x) ∧ FunctionalBrainStem(x) → CanControl(x, balance))
∀x (Human(x) ∧ CanStandOnTheGround(x, themselves) → FunctionalLegMuscle(x)))
Human(george) ∧ Human(archie)
CanControl(george, balance) ∧ CanSwim(george)
¬(CanWalk(archie) ⊕ FunctionalBrainStem(x))


[PREMISE (GK)]:
! [X] : (CanControl(X, breath) => FunctionalBrainStem(X)).
! [X] : (Human(X) & CanSwim(X) => CanControl(X, breath)).
! [X] : (Human(X) => (CanSwim(X) | CanWalk(X))).
! [X] : (Human(X) & CanWalk(X) => CanStandOnTheGround(X, themselves)).
! [X] : (Human(X) & FunctionalBrainStem(X) => CanControl(X, balance)).
! [X] : (Human(X) & CanStandOnTheGround(X, themselves) => FunctionalLegMuscle(X))).
Human(george) & Human(archie).
CanControl(george, balance) & CanSwim(george).
-(CanWalk(archie) <~> FunctionalBrainStem(x)).
.

[CONCLUSION]:
Archie has functional leg muscles and can control his balance.

[CONCLUSION (FOL)]:
FunctionalLegMuscle(archie) ∧ CanControl(archie, balance)

[CONCLUSION (GK)]:
FunctionalLegMuscle(archie) & CanControl(archie, balance).


===

['x']
['x']
[PREMISE]:
Functional brainstems are necessary for breath control.
All humans that can swim can control their breath. 
Humans can swim or walk. 
Humans who can walk can stand on the ground by themselves. 
Humans whose brainstems are functional can control their balance.
Every human who can stand on the ground by themselves has functional leg muscles. 
George and Archie are humans.
George can control his balance and can swim.
Archie can walk if and only if he has functional brainstems.

[PREMISE (FOL)]:
∀x (CanControl(x, breath) → FunctionalBrainStem(x))
∀x (Human(x) ∧ CanSwim(x) → CanControl(x, breath))
∀x (Human(x) → (CanSwim(x) ∨ CanWalk(x)))
∀x (Human(x) ∧ CanWalk(x) → CanStandOnTheGround(x, themselves))
∀x (Human(x) ∧ FunctionalBrainStem(x) → CanControl(x, balance))
∀x (Human(x) ∧ CanStandOnTheGround(x, themselves) → FunctionalLegMuscle(x)))
Human(george) ∧ Human(archie)
CanControl(george, balance) ∧ CanSwim(george)
¬(CanWalk(archie) ⊕ FunctionalBrainStem(x))


[PREMISE (GK)]:
! [X] : (CanControl(X, breath) => FunctionalBrainStem(X)).
! [X] : (Human(X) & CanSwim(X) => CanControl(X, breath)).
! [X] : (Human(X) => (CanSwim(X) | CanWalk(X))).
! [X] : (Human(X) & CanWalk(X) => CanStandOnTheGround(X, themselves)).
! [X] : (Human(X) & FunctionalBrainStem(X) => CanControl(X, balance)).
! [X] : (Human(X) & CanStandOnTheGround(X, themselves) => FunctionalLegMuscle(X))).
Human(george) & Human(archie).
CanControl(george, balance) & CanSwim(george).
-(CanWalk(archie) <~> FunctionalBrainStem(x)).
.

[CONCLUSION]:
Archie cannot control his balance and doesn't have functional leg muscles.

[CONCLUSION (FOL)]:
¬CanControl(archie, balance) ∧ ¬FunctionalLegMuscle(x)

[CONCLUSION (GK)]:
-CanControl(archie, balance) & -FunctionalLegMuscle(X).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Cancer biology is finding genetic alterations that confer a selective advantage to cancer cells. 
Cancer researchers have frequently ranked the importance of substitutions to cancer growth by the P value.
P values are thresholds for belief, not metrics of effect. 

[PREMISE (FOL)]:
Finding(cancerBiology, geneticAlteration) ∧ Confer(geneticAlteration, selectiveAdvantage, toCancerCell)
∃x ∃y (CancerResearcher(x) ∧ Ranked(x, importanceOfSubstitutionsToCancerGrowth) ∧ PValue(y) ∧ RankedBy(importanceOfSubstitutionsToCancerGrowth, y))
∀x (PValue(x) → ThresholdForBelief(x) ∧ ¬MetricOfEffect(x))

[PREMISE (GK)]:
Finding(cancerBiology, geneticAlteration) & Confer(geneticAlteration, selectiveAdvantage, toCancerCell).
? [X] : ? [Y] : (CancerResearcher(X) & Ranked(X, importanceOfSubstitutionsToCancerGrowth) & PValue(Y) & RankedBy(importanceOfSubstitutionsToCancerGrowth, Y)).
! [X] : (PValue(X) => ThresholdForBelief(X) & -MetricOfEffect(X)).

[CONCLUSION]:
Cancer researchers tend to use the cancer effect size to determine the relative importance of the genetic alterations that confer selective advantage to cancer cells.

[CONCLUSION (FOL)]:
∃x ∃y (CancerResearcher(x) ∧ Use(x, cancerEffectSize) ∧ UsedToDetermine(cancerEffectSize, relativeImportanceOfGeneteticAlterations))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (CancerResearcher(X) & Use(X, cancerEffectSize) & UsedToDetermine(cancerEffectSize, relativeImportanceOfGeneteticAlterations)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Cancer biology is finding genetic alterations that confer a selective advantage to cancer cells. 
Cancer researchers have frequently ranked the importance of substitutions to cancer growth by the P value.
P values are thresholds for belief, not metrics of effect. 

[PREMISE (FOL)]:
Finding(cancerBiology, geneticAlteration) ∧ Confer(geneticAlteration, selectiveAdvantage, toCancerCell)
∃x ∃y (CancerResearcher(x) ∧ Ranked(x, importanceOfSubstitutionsToCancerGrowth) ∧ PValue(y) ∧ RankedBy(importanceOfSubstitutionsToCancerGrowth, y))
∀x (PValue(x) → ThresholdForBelief(x) ∧ ¬MetricOfEffect(x))

[PREMISE (GK)]:
Finding(cancerBiology, geneticAlteration) & Confer(geneticAlteration, selectiveAdvantage, toCancerCell).
? [X] : ? [Y] : (CancerResearcher(X) & Ranked(X, importanceOfSubstitutionsToCancerGrowth) & PValue(Y) & RankedBy(importanceOfSubstitutionsToCancerGrowth, Y)).
! [X] : (PValue(X) => ThresholdForBelief(X) & -MetricOfEffect(X)).

[CONCLUSION]:
P value represents the selection intensity for somatic variants in cancer cell lineages.

[CONCLUSION (FOL)]:
SelectionIntensitySomaticVariants(pValue)

[CONCLUSION (GK)]:
SelectionIntensitySomaticVariants(pValue).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Cancer biology is finding genetic alterations that confer a selective advantage to cancer cells. 
Cancer researchers have frequently ranked the importance of substitutions to cancer growth by the P value.
P values are thresholds for belief, not metrics of effect. 

[PREMISE (FOL)]:
Finding(cancerBiology, geneticAlteration) ∧ Confer(geneticAlteration, selectiveAdvantage, toCancerCell)
∃x ∃y (CancerResearcher(x) ∧ Ranked(x, importanceOfSubstitutionsToCancerGrowth) ∧ PValue(y) ∧ RankedBy(importanceOfSubstitutionsToCancerGrowth, y))
∀x (PValue(x) → ThresholdForBelief(x) ∧ ¬MetricOfEffect(x))

[PREMISE (GK)]:
Finding(cancerBiology, geneticAlteration) & Confer(geneticAlteration, selectiveAdvantage, toCancerCell).
? [X] : ? [Y] : (CancerResearcher(X) & Ranked(X, importanceOfSubstitutionsToCancerGrowth) & PValue(Y) & RankedBy(importanceOfSubstitutionsToCancerGrowth, Y)).
! [X] : (PValue(X) => ThresholdForBelief(X) & -MetricOfEffect(X)).

[CONCLUSION]:
Cancer effect size is preferred by cancer researchers.

[CONCLUSION (FOL)]:
Preferred(cancerResearchers, cancerEffectSize)

[CONCLUSION (GK)]:
Preferred(cancerResearchers, cancerEffectSize).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Cancer biology is finding genetic alterations that confer a selective advantage to cancer cells. 
Cancer researchers have frequently ranked the importance of substitutions to cancer growth by the P value.
P values are thresholds for belief, not metrics of effect. 

[PREMISE (FOL)]:
Finding(cancerBiology, geneticAlteration) ∧ Confer(geneticAlteration, selectiveAdvantage, toCancerCell)
∃x ∃y (CancerResearcher(x) ∧ Ranked(x, importanceOfSubstitutionsToCancerGrowth) ∧ PValue(y) ∧ RankedBy(importanceOfSubstitutionsToCancerGrowth, y))
∀x (PValue(x) → ThresholdForBelief(x) ∧ ¬MetricOfEffect(x))

[PREMISE (GK)]:
Finding(cancerBiology, geneticAlteration) & Confer(geneticAlteration, selectiveAdvantage, toCancerCell).
? [X] : ? [Y] : (CancerResearcher(X) & Ranked(X, importanceOfSubstitutionsToCancerGrowth) & PValue(Y) & RankedBy(importanceOfSubstitutionsToCancerGrowth, Y)).
! [X] : (PValue(X) => ThresholdForBelief(X) & -MetricOfEffect(X)).

[CONCLUSION]:
P values don't represent metrics of effect.

[CONCLUSION (FOL)]:
∀x (PValue(x) → ¬MetricsOfEffect(x))

[CONCLUSION (GK)]:
! [X] : (PValue(X) => -MetricsOfEffect(X)).


===

['x']
['x']
[PREMISE]:
All biodegradable things are environment-friendly. 
All woodware is biodegradable.
All paper is woodware. 
Nothing is a good thing and also a bad thing.
All environment-friendly things are good.
A worksheet is either paper or environment-friendly.

[PREMISE (FOL)]:
∀x (Biodegradable(x) → EnvironmentFriendly(x))
∀x (Woodware(x) → Biodegradable(x))
∀x (Paper(x) → Woodware(x))
¬(∃x (Good(x) ∧ Bad(x)))
∀x (EnvironmentFriendly(x) → Good(x))
Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)

[PREMISE (GK)]:
! [X] : (Biodegradable(X) => EnvironmentFriendly(X)).
! [X] : (Woodware(X) => Biodegradable(X)).
! [X] : (Paper(X) => Woodware(X)).
-(? [X] : (Good(X) & Bad(X))).
! [X] : (EnvironmentFriendly(X) => Good(X)).
Paper(worksheet) <~> EnvironmentFriendly(worksheet).

[CONCLUSION]:
A worksheet is biodegradable.

[CONCLUSION (FOL)]:
Bioegradable(worksheet)

[CONCLUSION (GK)]:
Bioegradable(worksheet).


===

['x']
['x']
[PREMISE]:
All biodegradable things are environment-friendly. 
All woodware is biodegradable.
All paper is woodware. 
Nothing is a good thing and also a bad thing.
All environment-friendly things are good.
A worksheet is either paper or environment-friendly.

[PREMISE (FOL)]:
∀x (Biodegradable(x) → EnvironmentFriendly(x))
∀x (Woodware(x) → Biodegradable(x))
∀x (Paper(x) → Woodware(x))
¬(∃x (Good(x) ∧ Bad(x)))
∀x (EnvironmentFriendly(x) → Good(x))
Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)

[PREMISE (GK)]:
! [X] : (Biodegradable(X) => EnvironmentFriendly(X)).
! [X] : (Woodware(X) => Biodegradable(X)).
! [X] : (Paper(X) => Woodware(X)).
-(? [X] : (Good(X) & Bad(X))).
! [X] : (EnvironmentFriendly(X) => Good(X)).
Paper(worksheet) <~> EnvironmentFriendly(worksheet).

[CONCLUSION]:
A worksheet is not biodegradable.

[CONCLUSION (FOL)]:
¬Bioegradable(worksheet)

[CONCLUSION (GK)]:
-Bioegradable(worksheet).


===

['x']
['x']
[PREMISE]:
All biodegradable things are environment-friendly. 
All woodware is biodegradable.
All paper is woodware. 
Nothing is a good thing and also a bad thing.
All environment-friendly things are good.
A worksheet is either paper or environment-friendly.

[PREMISE (FOL)]:
∀x (Biodegradable(x) → EnvironmentFriendly(x))
∀x (Woodware(x) → Biodegradable(x))
∀x (Paper(x) → Woodware(x))
¬(∃x (Good(x) ∧ Bad(x)))
∀x (EnvironmentFriendly(x) → Good(x))
Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)

[PREMISE (GK)]:
! [X] : (Biodegradable(X) => EnvironmentFriendly(X)).
! [X] : (Woodware(X) => Biodegradable(X)).
! [X] : (Paper(X) => Woodware(X)).
-(? [X] : (Good(X) & Bad(X))).
! [X] : (EnvironmentFriendly(X) => Good(X)).
Paper(worksheet) <~> EnvironmentFriendly(worksheet).

[CONCLUSION]:
A worksheet is bad.

[CONCLUSION (FOL)]:
Bad(worksheet)

[CONCLUSION (GK)]:
Bad(worksheet).


===

['x']
['x']
[PREMISE]:
All biodegradable things are environment-friendly. 
All woodware is biodegradable.
All paper is woodware. 
Nothing is a good thing and also a bad thing.
All environment-friendly things are good.
A worksheet is either paper or environment-friendly.

[PREMISE (FOL)]:
∀x (Biodegradable(x) → EnvironmentFriendly(x))
∀x (Woodware(x) → Biodegradable(x))
∀x (Paper(x) → Woodware(x))
¬(∃x (Good(x) ∧ Bad(x)))
∀x (EnvironmentFriendly(x) → Good(x))
Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)

[PREMISE (GK)]:
! [X] : (Biodegradable(X) => EnvironmentFriendly(X)).
! [X] : (Woodware(X) => Biodegradable(X)).
! [X] : (Paper(X) => Woodware(X)).
-(? [X] : (Good(X) & Bad(X))).
! [X] : (EnvironmentFriendly(X) => Good(X)).
Paper(worksheet) <~> EnvironmentFriendly(worksheet).

[CONCLUSION]:
A worksheet is not bad.

[CONCLUSION (FOL)]:
¬Bad(worksheet)

[CONCLUSION (GK)]:
-Bad(worksheet).


===

['x']
['x']
[PREMISE]:
No reptile has fur.
All snakes are reptiles.

[PREMISE (FOL)]:
∀x (Reptile(x) → ¬Have(x, fur))
∀x (Snake(x) → Reptile(x))

[PREMISE (GK)]:
! [X] : (Reptile(X) => -Have(X, fur)).
! [X] : (Snake(X) => Reptile(X)).

[CONCLUSION]:
Some snake has fur.

[CONCLUSION (FOL)]:
∃x (Snake(x) ∧ Have(x, fur))

[CONCLUSION (GK)]:
? [X] : (Snake(X) & Have(X, fur)).


===

['x']
['x']
[PREMISE]:
All buildings in New Haven are not high.
All buildings managed by Yale Housing are located in New Haven. 
All buildings in Manhattans are high. 
All buildings owned by Bloomberg are located in Manhattans. 
All buildings with the Bloomberg logo are owned by Bloomberg. 
Tower A is managed by Yale Housing.
Tower B is with the Bloomberg logo.

[PREMISE (FOL)]:
∀x (In(x, newHaven) → ¬High(x))
∀x (YaleHousing(x) → In(x, newHaven))
∀x (In(x, manhattan) → High(x))
∀x (Bloomberg(x) → In(x, manhattan))
∀x (BloombergLogo(x) → Bloomberg(x))
YaleHousing(tower-a)
BloombergLogo(tower-b)

[PREMISE (GK)]:
! [X] : (In(X, newHaven) => -High(X)).
! [X] : (YaleHousing(X) => In(X, newHaven)).
! [X] : (In(X, manhattan) => High(X)).
! [X] : (Bloomberg(X) => In(X, manhattan)).
! [X] : (BloombergLogo(X) => Bloomberg(X)).
YaleHousing(tower-a).
BloombergLogo(tower-b).

[CONCLUSION]:
Tower A is low.

[CONCLUSION (FOL)]:
¬High(tower-a)

[CONCLUSION (GK)]:
-High(tower-a).


===

['x']
['x']
[PREMISE]:
All buildings in New Haven are not high.
All buildings managed by Yale Housing are located in New Haven. 
All buildings in Manhattans are high. 
All buildings owned by Bloomberg are located in Manhattans. 
All buildings with the Bloomberg logo are owned by Bloomberg. 
Tower A is managed by Yale Housing.
Tower B is with the Bloomberg logo.

[PREMISE (FOL)]:
∀x (In(x, newHaven) → ¬High(x))
∀x (YaleHousing(x) → In(x, newHaven))
∀x (In(x, manhattan) → High(x))
∀x (Bloomberg(x) → In(x, manhattan))
∀x (BloombergLogo(x) → Bloomberg(x))
YaleHousing(tower-a)
BloombergLogo(tower-b)

[PREMISE (GK)]:
! [X] : (In(X, newHaven) => -High(X)).
! [X] : (YaleHousing(X) => In(X, newHaven)).
! [X] : (In(X, manhattan) => High(X)).
! [X] : (Bloomberg(X) => In(X, manhattan)).
! [X] : (BloombergLogo(X) => Bloomberg(X)).
YaleHousing(tower-a).
BloombergLogo(tower-b).

[CONCLUSION]:
Tower B is not located in Manhattans.

[CONCLUSION (FOL)]:
¬In(tower-b, manhattan)

[CONCLUSION (GK)]:
-In(tower-b, manhattan).


===

['x']
['x']
[PREMISE]:
All buildings in New Haven are not high.
All buildings managed by Yale Housing are located in New Haven. 
All buildings in Manhattans are high. 
All buildings owned by Bloomberg are located in Manhattans. 
All buildings with the Bloomberg logo are owned by Bloomberg. 
Tower A is managed by Yale Housing.
Tower B is with the Bloomberg logo.

[PREMISE (FOL)]:
∀x (In(x, newHaven) → ¬High(x))
∀x (YaleHousing(x) → In(x, newHaven))
∀x (In(x, manhattan) → High(x))
∀x (Bloomberg(x) → In(x, manhattan))
∀x (BloombergLogo(x) → Bloomberg(x))
YaleHousing(tower-a)
BloombergLogo(tower-b)

[PREMISE (GK)]:
! [X] : (In(X, newHaven) => -High(X)).
! [X] : (YaleHousing(X) => In(X, newHaven)).
! [X] : (In(X, manhattan) => High(X)).
! [X] : (Bloomberg(X) => In(X, manhattan)).
! [X] : (BloombergLogo(X) => Bloomberg(X)).
YaleHousing(tower-a).
BloombergLogo(tower-b).

[CONCLUSION]:
Tower B is located in New Haven.

[CONCLUSION (FOL)]:
¬In(tower-b, newHaven)

[CONCLUSION (GK)]:
-In(tower-b, newHaven).


===

['x']
['x']
[PREMISE]:
No birds are ectothermic.
All penguins are birds.
An animal is ectothermic or endothermic.
All endothermic animals produce heat within the body.
Ron and Henry are both animals.
Ron is not a bird and does not produce heat with the body. 
Henry is not a cat and does not produce heat with the body. 

[PREMISE (FOL)]:
∀x (Bird(x) → ¬Ectothermic(x))
∀x (Penguin(x) → Bird(x))
∀x (Animal(x) → Ectothermic(x) ∨ Endothermic(x))
∀x (Endothermic(x) → ProduceWithIn(x, heat, body))
Animal(ron) ∧ Animal(henry)
¬Bird(ron) ∧ ¬ProduceWithIn(ron, heat, body)
¬Cat(henry) ∧ ¬ProduceWithIn(henry, heat, body)

[PREMISE (GK)]:
! [X] : (Bird(X) => -Ectothermic(X)).
! [X] : (Penguin(X) => Bird(X)).
! [X] : (Animal(X) => Ectothermic(X) | Endothermic(X)).
! [X] : (Endothermic(X) => ProduceWithIn(X, heat, body)).
Animal(ron) & Animal(henry).
-Bird(ron) & -ProduceWithIn(ron, heat, body).
-Cat(henry) & -ProduceWithIn(henry, heat, body).

[CONCLUSION]:
Ron is a cat.

[CONCLUSION (FOL)]:
Cat(ron)

[CONCLUSION (GK)]:
Cat(ron).


===

['x']
['x']
[PREMISE]:
No birds are ectothermic.
All penguins are birds.
An animal is ectothermic or endothermic.
All endothermic animals produce heat within the body.
Ron and Henry are both animals.
Ron is not a bird and does not produce heat with the body. 
Henry is not a cat and does not produce heat with the body. 

[PREMISE (FOL)]:
∀x (Bird(x) → ¬Ectothermic(x))
∀x (Penguin(x) → Bird(x))
∀x (Animal(x) → Ectothermic(x) ∨ Endothermic(x))
∀x (Endothermic(x) → ProduceWithIn(x, heat, body))
Animal(ron) ∧ Animal(henry)
¬Bird(ron) ∧ ¬ProduceWithIn(ron, heat, body)
¬Cat(henry) ∧ ¬ProduceWithIn(henry, heat, body)

[PREMISE (GK)]:
! [X] : (Bird(X) => -Ectothermic(X)).
! [X] : (Penguin(X) => Bird(X)).
! [X] : (Animal(X) => Ectothermic(X) | Endothermic(X)).
! [X] : (Endothermic(X) => ProduceWithIn(X, heat, body)).
Animal(ron) & Animal(henry).
-Bird(ron) & -ProduceWithIn(ron, heat, body).
-Cat(henry) & -ProduceWithIn(henry, heat, body).

[CONCLUSION]:
Either Henry is a penguin or Henry is endothermic.

[CONCLUSION (FOL)]:
Penguin(henry) ⊕ Endothermic(henry)

[CONCLUSION (GK)]:
Penguin(henry) <~> Endothermic(henry).


===

['x']
['x']
[PREMISE]:
No birds are ectothermic.
All penguins are birds.
An animal is ectothermic or endothermic.
All endothermic animals produce heat within the body.
Ron and Henry are both animals.
Ron is not a bird and does not produce heat with the body. 
Henry is not a cat and does not produce heat with the body. 

[PREMISE (FOL)]:
∀x (Bird(x) → ¬Ectothermic(x))
∀x (Penguin(x) → Bird(x))
∀x (Animal(x) → Ectothermic(x) ∨ Endothermic(x))
∀x (Endothermic(x) → ProduceWithIn(x, heat, body))
Animal(ron) ∧ Animal(henry)
¬Bird(ron) ∧ ¬ProduceWithIn(ron, heat, body)
¬Cat(henry) ∧ ¬ProduceWithIn(henry, heat, body)

[PREMISE (GK)]:
! [X] : (Bird(X) => -Ectothermic(X)).
! [X] : (Penguin(X) => Bird(X)).
! [X] : (Animal(X) => Ectothermic(X) | Endothermic(X)).
! [X] : (Endothermic(X) => ProduceWithIn(X, heat, body)).
Animal(ron) & Animal(henry).
-Bird(ron) & -ProduceWithIn(ron, heat, body).
-Cat(henry) & -ProduceWithIn(henry, heat, body).

[CONCLUSION]:
Ron is either both a penguin and endothermic, or he is nether.

[CONCLUSION (FOL)]:
¬(Penguin(ron) ⊕ Endothermic(henry))

[CONCLUSION (GK)]:
-(Penguin(ron) <~> Endothermic(henry)).


===

['x']
['x']
[PREMISE]:
Ambiortus is a prehistoric bird genus.
Ambiortus Dementjevi is the only known species of Ambiortus.
Mongolia was where Ambiortus Dementjevi lived.
Yevgeny Kurochkin was the discoverer of Ambiortus.

[PREMISE (FOL)]:
Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)
∀x(KnownSpeciesOf(x, ambiortus) → IsSpecies(x, ambiortusDementjevi))
LiveIn(ambiortusDementjevi, mongolia)
Discover(yevgenykurochkin, ambiortus)

[PREMISE (GK)]:
Prehistoric(ambiortus) & BirdGenus(ambiortus).
! [X] :(KnownSpeciesOf(X, ambiortus) => IsSpecies(X, ambiortusDementjevi)).
LiveIn(ambiortusDementjevi, mongolia).
Discover(yevgenykurochkin, ambiortus).

[CONCLUSION]:
Yevgeny Kurochkin discovered a new bird genus.

[CONCLUSION (FOL)]:
∃x (Discover(yevgenykurochkin, x) ∧ BirdGenus(x))

[CONCLUSION (GK)]:
? [X] : (Discover(yevgenykurochkin, X) & BirdGenus(X)).


===

['x']
['x']
[PREMISE]:
Ambiortus is a prehistoric bird genus.
Ambiortus Dementjevi is the only known species of Ambiortus.
Mongolia was where Ambiortus Dementjevi lived.
Yevgeny Kurochkin was the discoverer of Ambiortus.

[PREMISE (FOL)]:
Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)
∀x(KnownSpeciesOf(x, ambiortus) → IsSpecies(x, ambiortusDementjevi))
LiveIn(ambiortusDementjevi, mongolia)
Discover(yevgenykurochkin, ambiortus)

[PREMISE (GK)]:
Prehistoric(ambiortus) & BirdGenus(ambiortus).
! [X] :(KnownSpeciesOf(X, ambiortus) => IsSpecies(X, ambiortusDementjevi)).
LiveIn(ambiortusDementjevi, mongolia).
Discover(yevgenykurochkin, ambiortus).

[CONCLUSION]:
There is a species of Ambiortus that doesn't live in Mongolia.

[CONCLUSION (FOL)]:
∃x (KnownSpeciesOf(x, ambiortus) ∧ ¬LiveIn(x, mongolia))

[CONCLUSION (GK)]:
? [X] : (KnownSpeciesOf(X, ambiortus) & -LiveIn(X, mongolia)).


===

['x']
['x']
[PREMISE]:
Ambiortus is a prehistoric bird genus.
Ambiortus Dementjevi is the only known species of Ambiortus.
Mongolia was where Ambiortus Dementjevi lived.
Yevgeny Kurochkin was the discoverer of Ambiortus.

[PREMISE (FOL)]:
Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)
∀x(KnownSpeciesOf(x, ambiortus) → IsSpecies(x, ambiortusDementjevi))
LiveIn(ambiortusDementjevi, mongolia)
Discover(yevgenykurochkin, ambiortus)

[PREMISE (GK)]:
Prehistoric(ambiortus) & BirdGenus(ambiortus).
! [X] :(KnownSpeciesOf(X, ambiortus) => IsSpecies(X, ambiortusDementjevi)).
LiveIn(ambiortusDementjevi, mongolia).
Discover(yevgenykurochkin, ambiortus).

[CONCLUSION]:
Yevgeny Kurochkin lived in Mongolia.

[CONCLUSION (FOL)]:
LiveIn(yevgenykurochkin, mongolia)

[CONCLUSION (GK)]:
LiveIn(yevgenykurochkin, mongolia).


===

['x']
['x']
[PREMISE]:
Ambiortus is a prehistoric bird genus.
Ambiortus Dementjevi is the only known species of Ambiortus.
Mongolia was where Ambiortus Dementjevi lived.
Yevgeny Kurochkin was the discoverer of Ambiortus.

[PREMISE (FOL)]:
Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)
∀x(KnownSpeciesOf(x, ambiortus) → IsSpecies(x, ambiortusDementjevi))
LiveIn(ambiortusDementjevi, mongolia)
Discover(yevgenykurochkin, ambiortus)

[PREMISE (GK)]:
Prehistoric(ambiortus) & BirdGenus(ambiortus).
! [X] :(KnownSpeciesOf(X, ambiortus) => IsSpecies(X, ambiortusDementjevi)).
LiveIn(ambiortusDementjevi, mongolia).
Discover(yevgenykurochkin, ambiortus).

[CONCLUSION]:
All species of Ambiortus live in Mongolia.

[CONCLUSION (FOL)]:
∀x (SpeciesOf(x, ambiortus) → LiveIn(x, mongolia))

[CONCLUSION (GK)]:
! [X] : (SpeciesOf(X, ambiortus) => LiveIn(X, mongolia)).


===

['x']
['x']
[PREMISE]:
Everyone that knows about breath-first-search knows how to use a queue. 
If someone is a seasoned software engineer interviewer at Google, then they know what breath-first-search is. 
Someone is either a seasoned software engineer interviewer at Google, has human rights, or both. 
Every person who has human rights is entitled to the right to life and liberty. 
Everyone that knows how to use a queue knows about the first-in-first-out data structure. 
Everyone that is entitled to the right to life and liberty cannot be deprived of their rights without due process of law. 
Jack is entitled to the right to life and liberty, has human rights, or knows about the first-in-first-out data structure. 

[PREMISE (FOL)]:
∀x (Know(x, breathFirstSearch) → Know(x, howToUseQueue))
∀x (Seasoned(x) ∧ SoftwareEngineerInterviewer(x) ∧ At(x, google) → Know(x, breathFirstSearch))
∀x ((Seasoned(x) ∧ SoftwareEngineerInterviewer(x) ∧ At(x, google)) ∨ Have(x, humanRights))
∀x (Have(x, humanRights) → EntitledTo(x, rightToLifeAndLiberty))
∀x (Know(x, howToUseQueue) → Know(x, firstInFirstOutDataStructure))
∀x (EntitledTo(x, rightToLifeAndLiberty) → ¬DeprivedOfWithout(x, rights, dueProcessOfLaw))
(EntitledTo(jack, rightToLifeAndLiberty) ∨ Have(jack, humanRights) ∨ Know(jack, firstInFirstOutDataStructure))

[PREMISE (GK)]:
! [X] : (Know(X, breathFirstSearch) => Know(X, howToUseQueue)).
! [X] : (Seasoned(X) & SoftwareEngineerInterviewer(X) & At(X, google) => Know(X, breathFirstSearch)).
! [X] : ((Seasoned(X) & SoftwareEngineerInterviewer(X) & At(X, google)) | Have(X, humanRights)).
! [X] : (Have(X, humanRights) => EntitledTo(X, rightToLifeAndLiberty)).
! [X] : (Know(X, howToUseQueue) => Know(X, firstInFirstOutDataStructure)).
! [X] : (EntitledTo(X, rightToLifeAndLiberty) => -DeprivedOfWithout(X, rights, dueProcessOfLaw)).
(EntitledTo(jack, rightToLifeAndLiberty) | Have(jack, humanRights) | Know(jack, firstInFirstOutDataStructure)).

[CONCLUSION]:
Jack is a seasoned software engineer interviewer.

[CONCLUSION (FOL)]:
Seasoned(jack) ∧ SoftwareEngineerInterviewer(jack) ∧ At(jack, google)

[CONCLUSION (GK)]:
Seasoned(jack) & SoftwareEngineerInterviewer(jack) & At(jack, google).


===

['x']
['x']
[PREMISE]:
Everyone that knows about breath-first-search knows how to use a queue. 
If someone is a seasoned software engineer interviewer at Google, then they know what breath-first-search is. 
Someone is either a seasoned software engineer interviewer at Google, has human rights, or both. 
Every person who has human rights is entitled to the right to life and liberty. 
Everyone that knows how to use a queue knows about the first-in-first-out data structure. 
Everyone that is entitled to the right to life and liberty cannot be deprived of their rights without due process of law. 
Jack is entitled to the right to life and liberty, has human rights, or knows about the first-in-first-out data structure. 

[PREMISE (FOL)]:
∀x (Know(x, breathFirstSearch) → Know(x, howToUseQueue))
∀x (Seasoned(x) ∧ SoftwareEngineerInterviewer(x) ∧ At(x, google) → Know(x, breathFirstSearch))
∀x ((Seasoned(x) ∧ SoftwareEngineerInterviewer(x) ∧ At(x, google)) ∨ Have(x, humanRights))
∀x (Have(x, humanRights) → EntitledTo(x, rightToLifeAndLiberty))
∀x (Know(x, howToUseQueue) → Know(x, firstInFirstOutDataStructure))
∀x (EntitledTo(x, rightToLifeAndLiberty) → ¬DeprivedOfWithout(x, rights, dueProcessOfLaw))
(EntitledTo(jack, rightToLifeAndLiberty) ∨ Have(jack, humanRights) ∨ Know(jack, firstInFirstOutDataStructure))

[PREMISE (GK)]:
! [X] : (Know(X, breathFirstSearch) => Know(X, howToUseQueue)).
! [X] : (Seasoned(X) & SoftwareEngineerInterviewer(X) & At(X, google) => Know(X, breathFirstSearch)).
! [X] : ((Seasoned(X) & SoftwareEngineerInterviewer(X) & At(X, google)) | Have(X, humanRights)).
! [X] : (Have(X, humanRights) => EntitledTo(X, rightToLifeAndLiberty)).
! [X] : (Know(X, howToUseQueue) => Know(X, firstInFirstOutDataStructure)).
! [X] : (EntitledTo(X, rightToLifeAndLiberty) => -DeprivedOfWithout(X, rights, dueProcessOfLaw)).
(EntitledTo(jack, rightToLifeAndLiberty) | Have(jack, humanRights) | Know(jack, firstInFirstOutDataStructure)).

[CONCLUSION]:
Jack cannot be deprived of their rights without due process of law.

[CONCLUSION (FOL)]:
¬DeprivedOfWithout(jack, rights, dueProcessOfLaw)

[CONCLUSION (GK)]:
-DeprivedOfWithout(jack, rights, dueProcessOfLaw).


===

['x']
['x']
[PREMISE]:
Everyone that knows about breath-first-search knows how to use a queue. 
If someone is a seasoned software engineer interviewer at Google, then they know what breath-first-search is. 
Someone is either a seasoned software engineer interviewer at Google, has human rights, or both. 
Every person who has human rights is entitled to the right to life and liberty. 
Everyone that knows how to use a queue knows about the first-in-first-out data structure. 
Everyone that is entitled to the right to life and liberty cannot be deprived of their rights without due process of law. 
Jack is entitled to the right to life and liberty, has human rights, or knows about the first-in-first-out data structure. 

[PREMISE (FOL)]:
∀x (Know(x, breathFirstSearch) → Know(x, howToUseQueue))
∀x (Seasoned(x) ∧ SoftwareEngineerInterviewer(x) ∧ At(x, google) → Know(x, breathFirstSearch))
∀x ((Seasoned(x) ∧ SoftwareEngineerInterviewer(x) ∧ At(x, google)) ∨ Have(x, humanRights))
∀x (Have(x, humanRights) → EntitledTo(x, rightToLifeAndLiberty))
∀x (Know(x, howToUseQueue) → Know(x, firstInFirstOutDataStructure))
∀x (EntitledTo(x, rightToLifeAndLiberty) → ¬DeprivedOfWithout(x, rights, dueProcessOfLaw))
(EntitledTo(jack, rightToLifeAndLiberty) ∨ Have(jack, humanRights) ∨ Know(jack, firstInFirstOutDataStructure))

[PREMISE (GK)]:
! [X] : (Know(X, breathFirstSearch) => Know(X, howToUseQueue)).
! [X] : (Seasoned(X) & SoftwareEngineerInterviewer(X) & At(X, google) => Know(X, breathFirstSearch)).
! [X] : ((Seasoned(X) & SoftwareEngineerInterviewer(X) & At(X, google)) | Have(X, humanRights)).
! [X] : (Have(X, humanRights) => EntitledTo(X, rightToLifeAndLiberty)).
! [X] : (Know(X, howToUseQueue) => Know(X, firstInFirstOutDataStructure)).
! [X] : (EntitledTo(X, rightToLifeAndLiberty) => -DeprivedOfWithout(X, rights, dueProcessOfLaw)).
(EntitledTo(jack, rightToLifeAndLiberty) | Have(jack, humanRights) | Know(jack, firstInFirstOutDataStructure)).

[CONCLUSION]:
Jack can be deprived of their rights without due process of law.

[CONCLUSION (FOL)]:
DeprivedOfWithout(jack, rights, dueProcessOfLaw)

[CONCLUSION (GK)]:
DeprivedOfWithout(jack, rights, dueProcessOfLaw).


===

[]
['x']
[PREMISE]:
Fort Ticonderoga is the current name for Fort Carillon.
Pierre de Rigaud de Vaudreuil built Fort Carillon.
Fort Carillon was located in New France.
New France is not in Europe.

[PREMISE (FOL)]:
RenamedAs(fortCarillon, fortTiconderoga)
Built(pierredeRigauddeVaudreuil, fortCarillon)
LocatedIn(fortCarillon, newFrance)
¬LocatedIn(newFrance, europe) 

[PREMISE (GK)]:
RenamedAs(fortCarillon, fortTiconderoga).
Built(pierredeRigauddeVaudreuil, fortCarillon).
LocatedIn(fortCarillon, newFrance).
-LocatedIn(newFrance, europe) .

[CONCLUSION]:
Pierre de Rigaud de Vaudreuil built a fort in New France.

[CONCLUSION (FOL)]:
∃x (Built(pierredeRigauddeVaudreuil, x) ∧ LocatedIn(x, newFrance))

[CONCLUSION (GK)]:
? [X] : (Built(pierredeRigauddeVaudreuil, X) & LocatedIn(X, newFrance)).


===

[]
['x']
[PREMISE]:
Fort Ticonderoga is the current name for Fort Carillon.
Pierre de Rigaud de Vaudreuil built Fort Carillon.
Fort Carillon was located in New France.
New France is not in Europe.

[PREMISE (FOL)]:
RenamedAs(fortCarillon, fortTiconderoga)
Built(pierredeRigauddeVaudreuil, fortCarillon)
LocatedIn(fortCarillon, newFrance)
¬LocatedIn(newFrance, europe) 

[PREMISE (GK)]:
RenamedAs(fortCarillon, fortTiconderoga).
Built(pierredeRigauddeVaudreuil, fortCarillon).
LocatedIn(fortCarillon, newFrance).
-LocatedIn(newFrance, europe) .

[CONCLUSION]:
Pierre de Rigaud de Vaudreuil built a fort in New England.

[CONCLUSION (FOL)]:
∃x (Built(pierredeRigauddeVaudreuil, x) ∧ LocatedIn(x, newEngland))

[CONCLUSION (GK)]:
? [X] : (Built(pierredeRigauddeVaudreuil, X) & LocatedIn(X, newEngland)).


===

[]
[]
[PREMISE]:
Fort Ticonderoga is the current name for Fort Carillon.
Pierre de Rigaud de Vaudreuil built Fort Carillon.
Fort Carillon was located in New France.
New France is not in Europe.

[PREMISE (FOL)]:
RenamedAs(fortCarillon, fortTiconderoga)
Built(pierredeRigauddeVaudreuil, fortCarillon)
LocatedIn(fortCarillon, newFrance)
¬LocatedIn(newFrance, europe) 

[PREMISE (GK)]:
RenamedAs(fortCarillon, fortTiconderoga).
Built(pierredeRigauddeVaudreuil, fortCarillon).
LocatedIn(fortCarillon, newFrance).
-LocatedIn(newFrance, europe) .

[CONCLUSION]:
Fort Carillon was located in Europe.

[CONCLUSION (FOL)]:
LocatedIn(fortCarillon, europe)

[CONCLUSION (GK)]:
LocatedIn(fortCarillon, europe).


===

['x']
['x']
[PREMISE]:
No soccer players are professional basketball players.
All NBA players are professional basketball players.
All soccer defenders are soccer players.
All centerback players are soccer defenders.
If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.

[PREMISE (FOL)]:
∀x (ProfessionalSoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
∀x (ProfessionalSoccerDefender(x) → ProfessionalSoccerPlayer(x))
∀x (ProfessionalCenterback(x) → ProfessionalSoccerDefender(x))
(NBAPlayer(stephencurry) ⊕ ProfessionalSoccerPlayer(stephencurry)) → ProfessionalBasketballPlayer(stephencurry)

[PREMISE (GK)]:
! [X] : (ProfessionalSoccerPlayer(X) => -ProfessionalBasketballPlayer(X)).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
! [X] : (ProfessionalSoccerDefender(X) => ProfessionalSoccerPlayer(X)).
! [X] : (ProfessionalCenterback(X) => ProfessionalSoccerDefender(X)).
(NBAPlayer(stephencurry) <~> ProfessionalSoccerPlayer(stephencurry)) => ProfessionalBasketballPlayer(stephencurry).

[CONCLUSION]:
Stephen Curry is an NBA player.

[CONCLUSION (FOL)]:
NBAPlayer(stephenCurry)

[CONCLUSION (GK)]:
NBAPlayer(stephenCurry).


===

['x']
['x']
[PREMISE]:
No soccer players are professional basketball players.
All NBA players are professional basketball players.
All soccer defenders are soccer players.
All centerback players are soccer defenders.
If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.

[PREMISE (FOL)]:
∀x (ProfessionalSoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
∀x (ProfessionalSoccerDefender(x) → ProfessionalSoccerPlayer(x))
∀x (ProfessionalCenterback(x) → ProfessionalSoccerDefender(x))
(NBAPlayer(stephencurry) ⊕ ProfessionalSoccerPlayer(stephencurry)) → ProfessionalBasketballPlayer(stephencurry)

[PREMISE (GK)]:
! [X] : (ProfessionalSoccerPlayer(X) => -ProfessionalBasketballPlayer(X)).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
! [X] : (ProfessionalSoccerDefender(X) => ProfessionalSoccerPlayer(X)).
! [X] : (ProfessionalCenterback(X) => ProfessionalSoccerDefender(X)).
(NBAPlayer(stephencurry) <~> ProfessionalSoccerPlayer(stephencurry)) => ProfessionalBasketballPlayer(stephencurry).

[CONCLUSION]:
Stephen Curry is a centerback player.

[CONCLUSION (FOL)]:
ProfessionalCenterback(stephenCurry)

[CONCLUSION (GK)]:
ProfessionalCenterback(stephenCurry).


===

['x']
['x']
[PREMISE]:
No soccer players are professional basketball players.
All NBA players are professional basketball players.
All soccer defenders are soccer players.
All centerback players are soccer defenders.
If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.

[PREMISE (FOL)]:
∀x (ProfessionalSoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
∀x (ProfessionalSoccerDefender(x) → ProfessionalSoccerPlayer(x))
∀x (ProfessionalCenterback(x) → ProfessionalSoccerDefender(x))
(NBAPlayer(stephencurry) ⊕ ProfessionalSoccerPlayer(stephencurry)) → ProfessionalBasketballPlayer(stephencurry)

[PREMISE (GK)]:
! [X] : (ProfessionalSoccerPlayer(X) => -ProfessionalBasketballPlayer(X)).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
! [X] : (ProfessionalSoccerDefender(X) => ProfessionalSoccerPlayer(X)).
! [X] : (ProfessionalCenterback(X) => ProfessionalSoccerDefender(X)).
(NBAPlayer(stephencurry) <~> ProfessionalSoccerPlayer(stephencurry)) => ProfessionalBasketballPlayer(stephencurry).

[CONCLUSION]:
Stephen Curry is not a centerback player.

[CONCLUSION (FOL)]:
¬ProfessionalCenterback(stephenCurry)

[CONCLUSION (GK)]:
-ProfessionalCenterback(stephenCurry).


===

['x']
['x']
[PREMISE]:
No songs are visuals. 
All folk songs are songs. 
All videos are visuals. 
All movies are videos.
All sci-fi movies are movies.
Inception is a sci-fi movie.
Mac is neither a folk song nor a sci-fi movie.

[PREMISE (FOL)]:
∀x (Song(x) → ¬Visual(x))
∀x (FolkSong(x) → Song(x))
∀x (Video(x) → Visual(x))
∀x (Movie(x) → Video(x))
∀x (ScifiMovie(x) → Movie(x))
ScifiMovie(inception)
¬FolkSong(mac) ∧ ¬ScifiMovie(mac)

[PREMISE (GK)]:
! [X] : (Song(X) => -Visual(X)).
! [X] : (FolkSong(X) => Song(X)).
! [X] : (Video(X) => Visual(X)).
! [X] : (Movie(X) => Video(X)).
! [X] : (ScifiMovie(X) => Movie(X)).
ScifiMovie(inception).
-FolkSong(mac) & -ScifiMovie(mac).

[CONCLUSION]:
Inception is a folk song.

[CONCLUSION (FOL)]:
FolkSong(inception)

[CONCLUSION (GK)]:
FolkSong(inception).


===

['x']
['x']
[PREMISE]:
No songs are visuals. 
All folk songs are songs. 
All videos are visuals. 
All movies are videos.
All sci-fi movies are movies.
Inception is a sci-fi movie.
Mac is neither a folk song nor a sci-fi movie.

[PREMISE (FOL)]:
∀x (Song(x) → ¬Visual(x))
∀x (FolkSong(x) → Song(x))
∀x (Video(x) → Visual(x))
∀x (Movie(x) → Video(x))
∀x (ScifiMovie(x) → Movie(x))
ScifiMovie(inception)
¬FolkSong(mac) ∧ ¬ScifiMovie(mac)

[PREMISE (GK)]:
! [X] : (Song(X) => -Visual(X)).
! [X] : (FolkSong(X) => Song(X)).
! [X] : (Video(X) => Visual(X)).
! [X] : (Movie(X) => Video(X)).
! [X] : (ScifiMovie(X) => Movie(X)).
ScifiMovie(inception).
-FolkSong(mac) & -ScifiMovie(mac).

[CONCLUSION]:
Inception is not a folk song.

[CONCLUSION (FOL)]:
¬FolkSong(inception)

[CONCLUSION (GK)]:
-FolkSong(inception).


===

['x']
['x']
[PREMISE]:
No songs are visuals. 
All folk songs are songs. 
All videos are visuals. 
All movies are videos.
All sci-fi movies are movies.
Inception is a sci-fi movie.
Mac is neither a folk song nor a sci-fi movie.

[PREMISE (FOL)]:
∀x (Song(x) → ¬Visual(x))
∀x (FolkSong(x) → Song(x))
∀x (Video(x) → Visual(x))
∀x (Movie(x) → Video(x))
∀x (ScifiMovie(x) → Movie(x))
ScifiMovie(inception)
¬FolkSong(mac) ∧ ¬ScifiMovie(mac)

[PREMISE (GK)]:
! [X] : (Song(X) => -Visual(X)).
! [X] : (FolkSong(X) => Song(X)).
! [X] : (Video(X) => Visual(X)).
! [X] : (Movie(X) => Video(X)).
! [X] : (ScifiMovie(X) => Movie(X)).
ScifiMovie(inception).
-FolkSong(mac) & -ScifiMovie(mac).

[CONCLUSION]:
Inception is either a video or a folk song.

[CONCLUSION (FOL)]:
Video(inception) ⊕ FolkSong(inception)

[CONCLUSION (GK)]:
Video(inception) <~> FolkSong(inception).


===

['x']
['x']
[PREMISE]:
No songs are visuals. 
All folk songs are songs. 
All videos are visuals. 
All movies are videos.
All sci-fi movies are movies.
Inception is a sci-fi movie.
Mac is neither a folk song nor a sci-fi movie.

[PREMISE (FOL)]:
∀x (Song(x) → ¬Visual(x))
∀x (FolkSong(x) → Song(x))
∀x (Video(x) → Visual(x))
∀x (Movie(x) → Video(x))
∀x (ScifiMovie(x) → Movie(x))
ScifiMovie(inception)
¬FolkSong(mac) ∧ ¬ScifiMovie(mac)

[PREMISE (GK)]:
! [X] : (Song(X) => -Visual(X)).
! [X] : (FolkSong(X) => Song(X)).
! [X] : (Video(X) => Visual(X)).
! [X] : (Movie(X) => Video(X)).
! [X] : (ScifiMovie(X) => Movie(X)).
ScifiMovie(inception).
-FolkSong(mac) & -ScifiMovie(mac).

[CONCLUSION]:
Mac is a video.

[CONCLUSION (FOL)]:
Video(mac)

[CONCLUSION (GK)]:
Video(mac).


===

['x']
['x']
[PREMISE]:
All inductive reasoning processes derive general principles from a body of observations.
Two major types of reasoning rules are inductive reasoning and deductive reasoning. 
All deductive reasoning processes are only based on facts and rules. 
Nothing only based on facts and rules is used for statistical generalization. 
Modus Ponens is not both used in inductive reasoning and used for statistical generalization. 
Modus Ponens is a component of a major part of reasoning rule. 

[PREMISE (FOL)]:
∀x (InductiveReasoning(x) → DeriveFrom(generalPrinciple, observations))
∀x (MajorArgumentForm(x) → (InductiveReasoning(x) ⊕ DeductiveReasoning(x))
∀x (DeductiveReasoning(x) → (BasedOn(x, fact) ∨ BasedOn(x, rule)))
∀x ((BasedOn(x, fact) ∨ BasedOn(x, rule)) → (¬UsedFor(x, statisticalGeneralization)))
¬(InductiveReasoning(modusPonens) ∧ UsedFor(modusPonens, statisticalGeneralization))
ArgumentForm(modusPonens)

[PREMISE (GK)]:
! [X] : (InductiveReasoning(X) => DeriveFrom(generalPrinciple, observations)).
! [X] : (MajorArgumentForm(X) => (InductiveReasoning(X) <~> DeductiveReasoning(X)).
! [X] : (DeductiveReasoning(X) => (BasedOn(X, fact) | BasedOn(X, rule))).
! [X] : ((BasedOn(X, fact) | BasedOn(X, rule)) => (-UsedFor(X, statisticalGeneralization))).
-(InductiveReasoning(modusPonens) & UsedFor(modusPonens, statisticalGeneralization)).
ArgumentForm(modusPonens).

[CONCLUSION]:
Reasoning with Modus Ponens is based on facts and rules.

[CONCLUSION (FOL)]:
BasedOn(x, fact) ∨ BasedOn(x, rule)

[CONCLUSION (GK)]:
BasedOn(X, fact) | BasedOn(X, rule).


===

['x']
['x']
[PREMISE]:
All inductive reasoning processes derive general principles from a body of observations.
Two major types of reasoning rules are inductive reasoning and deductive reasoning. 
All deductive reasoning processes are only based on facts and rules. 
Nothing only based on facts and rules is used for statistical generalization. 
Modus Ponens is not both used in inductive reasoning and used for statistical generalization. 
Modus Ponens is a component of a major part of reasoning rule. 

[PREMISE (FOL)]:
∀x (InductiveReasoning(x) → DeriveFrom(generalPrinciple, observations))
∀x (MajorArgumentForm(x) → (InductiveReasoning(x) ⊕ DeductiveReasoning(x))
∀x (DeductiveReasoning(x) → (BasedOn(x, fact) ∨ BasedOn(x, rule)))
∀x ((BasedOn(x, fact) ∨ BasedOn(x, rule)) → (¬UsedFor(x, statisticalGeneralization)))
¬(InductiveReasoning(modusPonens) ∧ UsedFor(modusPonens, statisticalGeneralization))
ArgumentForm(modusPonens)

[PREMISE (GK)]:
! [X] : (InductiveReasoning(X) => DeriveFrom(generalPrinciple, observations)).
! [X] : (MajorArgumentForm(X) => (InductiveReasoning(X) <~> DeductiveReasoning(X)).
! [X] : (DeductiveReasoning(X) => (BasedOn(X, fact) | BasedOn(X, rule))).
! [X] : ((BasedOn(X, fact) | BasedOn(X, rule)) => (-UsedFor(X, statisticalGeneralization))).
-(InductiveReasoning(modusPonens) & UsedFor(modusPonens, statisticalGeneralization)).
ArgumentForm(modusPonens).

[CONCLUSION]:
Modus Ponens derives general principles from a body of observations and is used for statistical generalization.

[CONCLUSION (FOL)]:
DeriveFrom(generalPrinciple, observations) ∧ UsedFor(x, statisticalGeneralization)

[CONCLUSION (GK)]:
DeriveFrom(generalPrinciple, observations) & UsedFor(X, statisticalGeneralization).


===

['x']
['x']
[PREMISE]:
All inductive reasoning processes derive general principles from a body of observations.
Two major types of reasoning rules are inductive reasoning and deductive reasoning. 
All deductive reasoning processes are only based on facts and rules. 
Nothing only based on facts and rules is used for statistical generalization. 
Modus Ponens is not both used in inductive reasoning and used for statistical generalization. 
Modus Ponens is a component of a major part of reasoning rule. 

[PREMISE (FOL)]:
∀x (InductiveReasoning(x) → DeriveFrom(generalPrinciple, observations))
∀x (MajorArgumentForm(x) → (InductiveReasoning(x) ⊕ DeductiveReasoning(x))
∀x (DeductiveReasoning(x) → (BasedOn(x, fact) ∨ BasedOn(x, rule)))
∀x ((BasedOn(x, fact) ∨ BasedOn(x, rule)) → (¬UsedFor(x, statisticalGeneralization)))
¬(InductiveReasoning(modusPonens) ∧ UsedFor(modusPonens, statisticalGeneralization))
ArgumentForm(modusPonens)

[PREMISE (GK)]:
! [X] : (InductiveReasoning(X) => DeriveFrom(generalPrinciple, observations)).
! [X] : (MajorArgumentForm(X) => (InductiveReasoning(X) <~> DeductiveReasoning(X)).
! [X] : (DeductiveReasoning(X) => (BasedOn(X, fact) | BasedOn(X, rule))).
! [X] : ((BasedOn(X, fact) | BasedOn(X, rule)) => (-UsedFor(X, statisticalGeneralization))).
-(InductiveReasoning(modusPonens) & UsedFor(modusPonens, statisticalGeneralization)).
ArgumentForm(modusPonens).

[CONCLUSION]:
If Modus Ponens either derives general principles from a body of observations and is used for statistical generalization, or neither, then Modus Ponens is is neither used in inductive reasoning  nor used for statistical generalization.

[CONCLUSION (FOL)]:
¬(Derive(generalPrinciple, observations) ⊕ UsedFor(x, statisticalGeneralization)) → (¬InductiveReasoning(modusPonens) ∧ (¬UsedFor(modusPonens, statisticalGeneralization)))

[CONCLUSION (GK)]:
-(Derive(generalPrinciple, observations) <~> UsedFor(X, statisticalGeneralization)) => (-InductiveReasoning(modusPonens) & (-UsedFor(modusPonens, statisticalGeneralization))).


===

['x']
['x']
[PREMISE]:
No trick-shot artist in Yale's varsity team struggles with half court shots.
Everyone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  
Everyone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  
No one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  
Jack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.

[PREMISE (FOL)]:
∀x ((In(x, yaleSVarsityTeam) ∧ TrickShotArtist(x)) → ¬StruggleAt(x, halfCourtShot))
∀x (In(x, yaleSVarsityTeam) → (StruggleAt(x, halfCourtShot) ∨ GoodAt(x, threes)))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, threes)) → GoodAt(x, twos))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, twos)) → BadAt(x, midRangeShot))
In(jack, yaleSVarsityTeam) ∧ (TrickShotArtist(jack) ⊕  GoodAt(jack, threes))

[PREMISE (GK)]:
! [X] : ((In(X, yaleSVarsityTeam) & TrickShotArtist(X)) => -StruggleAt(X, halfCourtShot)).
! [X] : (In(X, yaleSVarsityTeam) => (StruggleAt(X, halfCourtShot) | GoodAt(X, threes))).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, threes)) => GoodAt(X, twos)).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, twos)) => BadAt(X, midRangeShot)).
In(jack, yaleSVarsityTeam) & (TrickShotArtist(jack) <~>  GoodAt(jack, threes)).

[CONCLUSION]:
Jack struggles at half court shots.

[CONCLUSION (FOL)]:
StruggleAt(jack, halfCourtShot)

[CONCLUSION (GK)]:
StruggleAt(jack, halfCourtShot).


===

['x']
['x']
[PREMISE]:
No trick-shot artist in Yale's varsity team struggles with half court shots.
Everyone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  
Everyone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  
No one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  
Jack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.

[PREMISE (FOL)]:
∀x ((In(x, yaleSVarsityTeam) ∧ TrickShotArtist(x)) → ¬StruggleAt(x, halfCourtShot))
∀x (In(x, yaleSVarsityTeam) → (StruggleAt(x, halfCourtShot) ∨ GoodAt(x, threes)))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, threes)) → GoodAt(x, twos))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, twos)) → BadAt(x, midRangeShot))
In(jack, yaleSVarsityTeam) ∧ (TrickShotArtist(jack) ⊕  GoodAt(jack, threes))

[PREMISE (GK)]:
! [X] : ((In(X, yaleSVarsityTeam) & TrickShotArtist(X)) => -StruggleAt(X, halfCourtShot)).
! [X] : (In(X, yaleSVarsityTeam) => (StruggleAt(X, halfCourtShot) | GoodAt(X, threes))).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, threes)) => GoodAt(X, twos)).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, twos)) => BadAt(X, midRangeShot)).
In(jack, yaleSVarsityTeam) & (TrickShotArtist(jack) <~>  GoodAt(jack, threes)).

[CONCLUSION]:
Jack is bad at mid-range shots.

[CONCLUSION (FOL)]:
BadAt(jack, midRangeShot)

[CONCLUSION (GK)]:
BadAt(jack, midRangeShot).


===

['x']
['x']
[PREMISE]:
No trick-shot artist in Yale's varsity team struggles with half court shots.
Everyone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  
Everyone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  
No one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  
Jack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.

[PREMISE (FOL)]:
∀x ((In(x, yaleSVarsityTeam) ∧ TrickShotArtist(x)) → ¬StruggleAt(x, halfCourtShot))
∀x (In(x, yaleSVarsityTeam) → (StruggleAt(x, halfCourtShot) ∨ GoodAt(x, threes)))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, threes)) → GoodAt(x, twos))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, twos)) → BadAt(x, midRangeShot))
In(jack, yaleSVarsityTeam) ∧ (TrickShotArtist(jack) ⊕  GoodAt(jack, threes))

[PREMISE (GK)]:
! [X] : ((In(X, yaleSVarsityTeam) & TrickShotArtist(X)) => -StruggleAt(X, halfCourtShot)).
! [X] : (In(X, yaleSVarsityTeam) => (StruggleAt(X, halfCourtShot) | GoodAt(X, threes))).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, threes)) => GoodAt(X, twos)).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, twos)) => BadAt(X, midRangeShot)).
In(jack, yaleSVarsityTeam) & (TrickShotArtist(jack) <~>  GoodAt(jack, threes)).

[CONCLUSION]:
Jack is solid at shooting 2-pointers or bad at mid-range shots.

[CONCLUSION (FOL)]:
GoodAt(jack, twos) ∨ BadAt(jack, midRangeShot)

[CONCLUSION (GK)]:
GoodAt(jack, twos) | BadAt(jack, midRangeShot).


===

['x']
['x']
[PREMISE]:
No trick-shot artist in Yale's varsity team struggles with half court shots.
Everyone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  
Everyone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  
No one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  
Jack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.

[PREMISE (FOL)]:
∀x ((In(x, yaleSVarsityTeam) ∧ TrickShotArtist(x)) → ¬StruggleAt(x, halfCourtShot))
∀x (In(x, yaleSVarsityTeam) → (StruggleAt(x, halfCourtShot) ∨ GoodAt(x, threes)))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, threes)) → GoodAt(x, twos))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, twos)) → BadAt(x, midRangeShot))
In(jack, yaleSVarsityTeam) ∧ (TrickShotArtist(jack) ⊕  GoodAt(jack, threes))

[PREMISE (GK)]:
! [X] : ((In(X, yaleSVarsityTeam) & TrickShotArtist(X)) => -StruggleAt(X, halfCourtShot)).
! [X] : (In(X, yaleSVarsityTeam) => (StruggleAt(X, halfCourtShot) | GoodAt(X, threes))).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, threes)) => GoodAt(X, twos)).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, twos)) => BadAt(X, midRangeShot)).
In(jack, yaleSVarsityTeam) & (TrickShotArtist(jack) <~>  GoodAt(jack, threes)).

[CONCLUSION]:
Jack is either solid at shooting 2-pointers or bad at mid-range shots.

[CONCLUSION (FOL)]:
GoodAt(jack, twos) ⊕ BadAt(jack, midRangeShot)

[CONCLUSION (GK)]:
GoodAt(jack, twos) <~> BadAt(jack, midRangeShot).


===

['x']
['x']
[PREMISE]:
No trick-shot artist in Yale's varsity team struggles with half court shots.
Everyone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  
Everyone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  
No one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  
Jack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.

[PREMISE (FOL)]:
∀x ((In(x, yaleSVarsityTeam) ∧ TrickShotArtist(x)) → ¬StruggleAt(x, halfCourtShot))
∀x (In(x, yaleSVarsityTeam) → (StruggleAt(x, halfCourtShot) ∨ GoodAt(x, threes)))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, threes)) → GoodAt(x, twos))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, twos)) → BadAt(x, midRangeShot))
In(jack, yaleSVarsityTeam) ∧ (TrickShotArtist(jack) ⊕  GoodAt(jack, threes))

[PREMISE (GK)]:
! [X] : ((In(X, yaleSVarsityTeam) & TrickShotArtist(X)) => -StruggleAt(X, halfCourtShot)).
! [X] : (In(X, yaleSVarsityTeam) => (StruggleAt(X, halfCourtShot) | GoodAt(X, threes))).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, threes)) => GoodAt(X, twos)).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, twos)) => BadAt(X, midRangeShot)).
In(jack, yaleSVarsityTeam) & (TrickShotArtist(jack) <~>  GoodAt(jack, threes)).

[CONCLUSION]:
Jack is a trick-shot artist or bad at mid-range shots.

[CONCLUSION (FOL)]:
TrickShotArtist(jack) ∨ BadAt(jack, midRangeShot))

[CONCLUSION (GK)]:
TrickShotArtist(jack) | BadAt(jack, midRangeShot)).


===

['x']
['x']
[PREMISE]:
No trick-shot artist in Yale's varsity team struggles with half court shots.
Everyone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  
Everyone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  
No one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  
Jack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.

[PREMISE (FOL)]:
∀x ((In(x, yaleSVarsityTeam) ∧ TrickShotArtist(x)) → ¬StruggleAt(x, halfCourtShot))
∀x (In(x, yaleSVarsityTeam) → (StruggleAt(x, halfCourtShot) ∨ GoodAt(x, threes)))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, threes)) → GoodAt(x, twos))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, twos)) → BadAt(x, midRangeShot))
In(jack, yaleSVarsityTeam) ∧ (TrickShotArtist(jack) ⊕  GoodAt(jack, threes))

[PREMISE (GK)]:
! [X] : ((In(X, yaleSVarsityTeam) & TrickShotArtist(X)) => -StruggleAt(X, halfCourtShot)).
! [X] : (In(X, yaleSVarsityTeam) => (StruggleAt(X, halfCourtShot) | GoodAt(X, threes))).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, threes)) => GoodAt(X, twos)).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, twos)) => BadAt(X, midRangeShot)).
In(jack, yaleSVarsityTeam) & (TrickShotArtist(jack) <~>  GoodAt(jack, threes)).

[CONCLUSION]:
Jack is either a trick-shot artist or bad at mid-range shots.

[CONCLUSION (FOL)]:
TrickShotArtist(jack) ⊕ BadAt(jack, midRangeShots)

[CONCLUSION (GK)]:
TrickShotArtist(jack) <~> BadAt(jack, midRangeShots).


===

['x']
['x']
[PREMISE]:
No trick-shot artist in Yale's varsity team struggles with half court shots.
Everyone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  
Everyone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  
No one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  
Jack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.

[PREMISE (FOL)]:
∀x ((In(x, yaleSVarsityTeam) ∧ TrickShotArtist(x)) → ¬StruggleAt(x, halfCourtShot))
∀x (In(x, yaleSVarsityTeam) → (StruggleAt(x, halfCourtShot) ∨ GoodAt(x, threes)))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, threes)) → GoodAt(x, twos))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, twos)) → BadAt(x, midRangeShot))
In(jack, yaleSVarsityTeam) ∧ (TrickShotArtist(jack) ⊕  GoodAt(jack, threes))

[PREMISE (GK)]:
! [X] : ((In(X, yaleSVarsityTeam) & TrickShotArtist(X)) => -StruggleAt(X, halfCourtShot)).
! [X] : (In(X, yaleSVarsityTeam) => (StruggleAt(X, halfCourtShot) | GoodAt(X, threes))).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, threes)) => GoodAt(X, twos)).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, twos)) => BadAt(X, midRangeShot)).
In(jack, yaleSVarsityTeam) & (TrickShotArtist(jack) <~>  GoodAt(jack, threes)).

[CONCLUSION]:
Jack is either a player who successfully shoots a high percentage of 3-pointers or is bad at mid-range shots.

[CONCLUSION (FOL)]:
GoodAt(jack, threes) ⊕ BadAt(jack, midRangeShot)

[CONCLUSION (GK)]:
GoodAt(jack, threes) <~> BadAt(jack, midRangeShot).


===

['x']
['x']
[PREMISE]:
No trick-shot artist in Yale's varsity team struggles with half court shots.
Everyone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  
Everyone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  
No one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  
Jack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.

[PREMISE (FOL)]:
∀x ((In(x, yaleSVarsityTeam) ∧ TrickShotArtist(x)) → ¬StruggleAt(x, halfCourtShot))
∀x (In(x, yaleSVarsityTeam) → (StruggleAt(x, halfCourtShot) ∨ GoodAt(x, threes)))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, threes)) → GoodAt(x, twos))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, twos)) → BadAt(x, midRangeShot))
In(jack, yaleSVarsityTeam) ∧ (TrickShotArtist(jack) ⊕  GoodAt(jack, threes))

[PREMISE (GK)]:
! [X] : ((In(X, yaleSVarsityTeam) & TrickShotArtist(X)) => -StruggleAt(X, halfCourtShot)).
! [X] : (In(X, yaleSVarsityTeam) => (StruggleAt(X, halfCourtShot) | GoodAt(X, threes))).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, threes)) => GoodAt(X, twos)).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, twos)) => BadAt(X, midRangeShot)).
In(jack, yaleSVarsityTeam) & (TrickShotArtist(jack) <~>  GoodAt(jack, threes)).

[CONCLUSION]:
If Jack is not solid at shooting 2-pointers and bad at mid-range shots, then Jack is not solid at shooting 2-pointers and is a player who successfully shoots a high percentage of 3-pointers.

[CONCLUSION (FOL)]:
BadAt(jack, midRangeShot) ∧ GoodAt(jack, twos) → ¬GoodAt(jack, twos) ∧ GoodAt(jack, threes)

[CONCLUSION (GK)]:
BadAt(jack, midRangeShot) & GoodAt(jack, twos) => -GoodAt(jack, twos) & GoodAt(jack, threes).


===

['x']
['x']
[PREMISE]:
No trick-shot artist in Yale's varsity team struggles with half court shots.
Everyone on Yale's varsity team is someone who struggles with half court shots or who successfully shoots a high percentage of 3-pointers.  
Everyone on Yale's varsity team who successfully shoots a high percentage of 3-pointers is solid at shooting 2-pointers.  
No one on Yale's varsity team who is solid at shooting 2-pointers is bad at mid-range shots.  
Jack is on Yale's varsity team, and he is either a trick-shot artist or he successfully shoots a high percentage of 3-pointers.

[PREMISE (FOL)]:
∀x ((In(x, yaleSVarsityTeam) ∧ TrickShotArtist(x)) → ¬StruggleAt(x, halfCourtShot))
∀x (In(x, yaleSVarsityTeam) → (StruggleAt(x, halfCourtShot) ∨ GoodAt(x, threes)))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, threes)) → GoodAt(x, twos))
∀x ((In(x, yaleSVarsityTeam) ∧ GoodAt(x, twos)) → BadAt(x, midRangeShot))
In(jack, yaleSVarsityTeam) ∧ (TrickShotArtist(jack) ⊕  GoodAt(jack, threes))

[PREMISE (GK)]:
! [X] : ((In(X, yaleSVarsityTeam) & TrickShotArtist(X)) => -StruggleAt(X, halfCourtShot)).
! [X] : (In(X, yaleSVarsityTeam) => (StruggleAt(X, halfCourtShot) | GoodAt(X, threes))).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, threes)) => GoodAt(X, twos)).
! [X] : ((In(X, yaleSVarsityTeam) & GoodAt(X, twos)) => BadAt(X, midRangeShot)).
In(jack, yaleSVarsityTeam) & (TrickShotArtist(jack) <~>  GoodAt(jack, threes)).

[CONCLUSION]:
If Jack is solid at shooting 2-pointers or successfully shoots a high percentage of 3-pointers, then Jack struggles at half court shots and is bad at mid-range shots.

[CONCLUSION (FOL)]:
GoodAt(jack, twos) ∨ GoodAt(jack, threes) → BadAt(jack, halfCourtShot) ∧ BadAt(jack, midRangeShot)

[CONCLUSION (GK)]:
GoodAt(jack, twos) | GoodAt(jack, threes) => BadAt(jack, halfCourtShot) & BadAt(jack, midRangeShot).


===

['x']
['x']
[PREMISE]:
No plants are fungi.
Mushrooms are fungi.

[PREMISE (FOL)]:
∀x (Plant(x) → ¬Fungi(x))
∀x (Mushroom(x) → Fungi(x))

[PREMISE (GK)]:
! [X] : (Plant(X) => -Fungi(X)).
! [X] : (Mushroom(X) => Fungi(X)).

[CONCLUSION]:
No plants are mushrooms.

[CONCLUSION (FOL)]:
∀x (Plant(x) → ¬Mushroom(x))

[CONCLUSION (GK)]:
! [X] : (Plant(X) => -Mushroom(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
No road is dustless.
Some streets are roads.

[PREMISE (FOL)]:
∀x (Road(x) → ¬Dustless(x))
∃x ∃y (Street(x) ∧ Street(y) ∧ Road(x) ∧ Road(y) ∧ ¬(x=y))

[PREMISE (GK)]:
! [X] : (Road(X) => -Dustless(X)).
? [X] : ? [Y] : (Street(X) & Street(Y) & Road(X) & Road(Y) & -(X=Y)).

[CONCLUSION]:
Some streets are dustless.

[CONCLUSION (FOL)]:
∃x ∃y (Street(x) ∧ Street(y) ∧ Dustless(x) ∧ Dustless(y) ∧ ¬(x=y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Street(X) & Street(Y) & Dustless(X) & Dustless(Y) & -(X=Y)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
New York City is located on the East Coast. 
Seattle is located on the West Coast. 
If a person is somewhere located on the East coast and is traveling to somewhere located on the west coast, they will be on a long flight.
People in business class from New York City to Seattle are not in first class.
People on long flights are uncomfortable unless they're in first class.

[PREMISE (FOL)]:
LocatedOn(newYorkCity, eastCoast)
LocatedOn(seattle, westCoast)
∀x ∀y ∀z ((TravelingFrom(x, y) ∧ LocatedOn(y, eastcoast) ∧ TravelingTo(x, z) ∧ LocatedOn(z, westcoast)) → OnLongFlight(x))
∀x (InBuisnessClass(x) ∧ TravelingTo(x, seattle) ∧ TravelingFrom(x, newYorkCity) → ¬InFirstClass(x))
∀x (OnLongFlight(x) ∧ ¬InFirstClass(x) → Uncomfortable(x))

[PREMISE (GK)]:
LocatedOn(newYorkCity, eastCoast).
LocatedOn(seattle, westCoast).
! [X] : ! [Y] : ! [Z] : ((TravelingFrom(X, Y) & LocatedOn(Y, eastcoast) & TravelingTo(X, Z) & LocatedOn(Z, westcoast)) => OnLongFlight(X)).
! [X] : (InBuisnessClass(X) & TravelingTo(X, seattle) & TravelingFrom(X, newYorkCity) => -InFirstClass(X)).
! [X] : (OnLongFlight(X) & -InFirstClass(X) => Uncomfortable(X)).

[CONCLUSION]:
People traveling in business class from New York City to Seattle will be uncomfortable.

[CONCLUSION (FOL)]:
∃x (TravelingTo(x, seattle) ∧ TravelingFrom(x, newYorkCity) ∧ uncomfortable(x))

[CONCLUSION (GK)]:
? [X] : (TravelingTo(X, seattle) & TravelingFrom(X, newYorkCity) & uncomfortable(X)).


===

['x']
['x']
[PREMISE]:
Musicians have very busy lives.
Singh Kaur is a musician and famous.
If a musician is not famous, that musician will not make a lot of money.
A musician can be a singer or a writer.

[PREMISE (FOL)]:
∀x (Musician(x) → Have(x, busyLife))
Musician(singhKaur) ∧ Famous(singhKaur)
∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeALotOfMoney(x))
∃x (Musician(x) ∧ (Singer(x) ∨ Writer(x)))

[PREMISE (GK)]:
! [X] : (Musician(X) => Have(X, busyLife)).
Musician(singhKaur) & Famous(singhKaur).
! [X] : (Musician(X) & -Famous(X) => -MakeALotOfMoney(X)).
? [X] : (Musician(X) & (Singer(X) | Writer(X))).

[CONCLUSION]:
Singh Kaur makes a lot of money.

[CONCLUSION (FOL)]:
MakeALotOfMoney(singhKaur)

[CONCLUSION (GK)]:
MakeALotOfMoney(singhKaur).


===

['x']
['x']
[PREMISE]:
Musicians have very busy lives.
Singh Kaur is a musician and famous.
If a musician is not famous, that musician will not make a lot of money.
A musician can be a singer or a writer.

[PREMISE (FOL)]:
∀x (Musician(x) → Have(x, busyLife))
Musician(singhKaur) ∧ Famous(singhKaur)
∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeALotOfMoney(x))
∃x (Musician(x) ∧ (Singer(x) ∨ Writer(x)))

[PREMISE (GK)]:
! [X] : (Musician(X) => Have(X, busyLife)).
Musician(singhKaur) & Famous(singhKaur).
! [X] : (Musician(X) & -Famous(X) => -MakeALotOfMoney(X)).
? [X] : (Musician(X) & (Singer(X) | Writer(X))).

[CONCLUSION]:
Singh Kaur is a writer.

[CONCLUSION (FOL)]:
Writer(singhKaur)

[CONCLUSION (GK)]:
Writer(singhKaur).


===

['x']
['x']
[PREMISE]:
Musicians have very busy lives.
Singh Kaur is a musician and famous.
If a musician is not famous, that musician will not make a lot of money.
A musician can be a singer or a writer.

[PREMISE (FOL)]:
∀x (Musician(x) → Have(x, busyLife))
Musician(singhKaur) ∧ Famous(singhKaur)
∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeALotOfMoney(x))
∃x (Musician(x) ∧ (Singer(x) ∨ Writer(x)))

[PREMISE (GK)]:
! [X] : (Musician(X) => Have(X, busyLife)).
Musician(singhKaur) & Famous(singhKaur).
! [X] : (Musician(X) & -Famous(X) => -MakeALotOfMoney(X)).
? [X] : (Musician(X) & (Singer(X) | Writer(X))).

[CONCLUSION]:
Singh Kaur has a very busy life.

[CONCLUSION (FOL)]:
Have(singhKaur, busyLife)

[CONCLUSION (GK)]:
Have(singhKaur, busyLife).


===

['x']
['x']
[PREMISE]:
Each building is tall. 
Everything tall has height.

[PREMISE (FOL)]:
∀x (Building(x) → Tall(x))
∀x (Tall(x) → Height(x))

[PREMISE (GK)]:
! [X] : (Building(X) => Tall(X)).
! [X] : (Tall(X) => Height(X)).

[CONCLUSION]:
All buildings are magnificent.

[CONCLUSION (FOL)]:
∀x (Building(x) → Magnificent(x))

[CONCLUSION (GK)]:
! [X] : (Building(X) => Magnificent(X)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
A cat named Garfield, the main character of the film Garfield, is orange and fat and likes having lasagna. 
Garfield shares a home with Odie, another pet of Jon's. 
Garfield hates Odie.
A pet who hates the pet with whom he shares the same owner is childish and possessive.

[PREMISE (FOL)]:
Cat(garfield) ∧ MainCharacterOf(garfield, filmGarfield) ∧ Orange(garfield) ∧ Fat(garfield) ∧ Like(garfield, lasagna)
PetOf(garfield, jon) ∧ PetOf(odie, jon) ∧ ShareHomeWith(garfield, odie)
Hate(garfield, odie)
∀x ∀y ∃z (PetOf(x, z) ∧ PetOf(y, z) ∧ Hate(x, y) → Childish(x) ∧ Possessive(x))

[PREMISE (GK)]:
Cat(garfield) & MainCharacterOf(garfield, filmGarfield) & Orange(garfield) & Fat(garfield) & Like(garfield, lasagna).
PetOf(garfield, jon) & PetOf(odie, jon) & ShareHomeWith(garfield, odie).
Hate(garfield, odie).
! [X] : ! [Y] : ? [Z] : (PetOf(X, Z) & PetOf(Y, Z) & Hate(X, Y) => Childish(X) & Possessive(X)).

[CONCLUSION]:
The main character of the film Garfield is childish and possessive.

[CONCLUSION (FOL)]:
∃x (MainCharacterOf(x, garfield) ∧ Childish(x) ∧ Possessive(x))

[CONCLUSION (GK)]:
? [X] : (MainCharacterOf(X, garfield) & Childish(X) & Possessive(X)).


===

['x']
['x']
[PREMISE]:
All humans are capable of abstract thoughts.
Plants are not capable of abstract thoughts.
All multicellular creatures that are autotrophic or digest food internally are plants and animals.
All goats are animals.
Dirt is not an animal.
Hulu is a goat or a human.
Hulu is a multicellular creature that is autotrophic or digests food internally. 

[PREMISE (FOL)]:
∀x (Human(x) → CapableOf(x, abstractThought))
∀x (Plant(x) → ¬CapableOf(x, abstractThought))
∀x (MulticellularCreature(x) ∧ (Autotrophic(x) ∨ DigestFoodInternally (x)) → Plant(x) ⊕ Animal(x))
∀x (Goat(x) → Animal(x))
∀x (Dirt(x) → ¬Animal(x))
Goat(hulu) ∨ HumanBeing(hulu)
(MulticellularCreature(hulu) ∧ (Autotrophic(hulu) ∨ DigestFoodInternally (hulu))

[PREMISE (GK)]:
! [X] : (Human(X) => CapableOf(X, abstractThought)).
! [X] : (Plant(X) => -CapableOf(X, abstractThought)).
! [X] : (MulticellularCreature(X) & (Autotrophic(X) | DigestFoodInternally (X)) => Plant(X) <~> Animal(X)).
! [X] : (Goat(X) => Animal(X)).
! [X] : (Dirt(X) => -Animal(X)).
Goat(hulu) | HumanBeing(hulu).
(MulticellularCreature(hulu) & (Autotrophic(hulu) | DigestFoodInternally (hulu)).

[CONCLUSION]:
Hulu is capable of abstract thoughts.

[CONCLUSION (FOL)]:
CapableOf(hulu, abstractThought)

[CONCLUSION (GK)]:
CapableOf(hulu, abstractThought).


===

['x']
['x']
[PREMISE]:
All humans are capable of abstract thoughts.
Plants are not capable of abstract thoughts.
All multicellular creatures that are autotrophic or digest food internally are plants and animals.
All goats are animals.
Dirt is not an animal.
Hulu is a goat or a human.
Hulu is a multicellular creature that is autotrophic or digests food internally. 

[PREMISE (FOL)]:
∀x (Human(x) → CapableOf(x, abstractThought))
∀x (Plant(x) → ¬CapableOf(x, abstractThought))
∀x (MulticellularCreature(x) ∧ (Autotrophic(x) ∨ DigestFoodInternally (x)) → Plant(x) ⊕ Animal(x))
∀x (Goat(x) → Animal(x))
∀x (Dirt(x) → ¬Animal(x))
Goat(hulu) ∨ HumanBeing(hulu)
(MulticellularCreature(hulu) ∧ (Autotrophic(hulu) ∨ DigestFoodInternally (hulu))

[PREMISE (GK)]:
! [X] : (Human(X) => CapableOf(X, abstractThought)).
! [X] : (Plant(X) => -CapableOf(X, abstractThought)).
! [X] : (MulticellularCreature(X) & (Autotrophic(X) | DigestFoodInternally (X)) => Plant(X) <~> Animal(X)).
! [X] : (Goat(X) => Animal(X)).
! [X] : (Dirt(X) => -Animal(X)).
Goat(hulu) | HumanBeing(hulu).
(MulticellularCreature(hulu) & (Autotrophic(hulu) | DigestFoodInternally (hulu)).

[CONCLUSION]:
Hulu is not capable of abstract thoughts.

[CONCLUSION (FOL)]:
¬CapableOf(hulu, abstractThought)

[CONCLUSION (GK)]:
-CapableOf(hulu, abstractThought).


===

['x']
['x']
[PREMISE]:
All humans are capable of abstract thoughts.
Plants are not capable of abstract thoughts.
All multicellular creatures that are autotrophic or digest food internally are plants and animals.
All goats are animals.
Dirt is not an animal.
Hulu is a goat or a human.
Hulu is a multicellular creature that is autotrophic or digests food internally. 

[PREMISE (FOL)]:
∀x (Human(x) → CapableOf(x, abstractThought))
∀x (Plant(x) → ¬CapableOf(x, abstractThought))
∀x (MulticellularCreature(x) ∧ (Autotrophic(x) ∨ DigestFoodInternally (x)) → Plant(x) ⊕ Animal(x))
∀x (Goat(x) → Animal(x))
∀x (Dirt(x) → ¬Animal(x))
Goat(hulu) ∨ HumanBeing(hulu)
(MulticellularCreature(hulu) ∧ (Autotrophic(hulu) ∨ DigestFoodInternally (hulu))

[PREMISE (GK)]:
! [X] : (Human(X) => CapableOf(X, abstractThought)).
! [X] : (Plant(X) => -CapableOf(X, abstractThought)).
! [X] : (MulticellularCreature(X) & (Autotrophic(X) | DigestFoodInternally (X)) => Plant(X) <~> Animal(X)).
! [X] : (Goat(X) => Animal(X)).
! [X] : (Dirt(X) => -Animal(X)).
Goat(hulu) | HumanBeing(hulu).
(MulticellularCreature(hulu) & (Autotrophic(hulu) | DigestFoodInternally (hulu)).

[CONCLUSION]:
Hulu is dirt.

[CONCLUSION (FOL)]:
Dirt(hulu)

[CONCLUSION (GK)]:
Dirt(hulu).


===

['x']
['x']
[PREMISE]:
All humans are capable of abstract thoughts.
Plants are not capable of abstract thoughts.
All multicellular creatures that are autotrophic or digest food internally are plants and animals.
All goats are animals.
Dirt is not an animal.
Hulu is a goat or a human.
Hulu is a multicellular creature that is autotrophic or digests food internally. 

[PREMISE (FOL)]:
∀x (Human(x) → CapableOf(x, abstractThought))
∀x (Plant(x) → ¬CapableOf(x, abstractThought))
∀x (MulticellularCreature(x) ∧ (Autotrophic(x) ∨ DigestFoodInternally (x)) → Plant(x) ⊕ Animal(x))
∀x (Goat(x) → Animal(x))
∀x (Dirt(x) → ¬Animal(x))
Goat(hulu) ∨ HumanBeing(hulu)
(MulticellularCreature(hulu) ∧ (Autotrophic(hulu) ∨ DigestFoodInternally (hulu))

[PREMISE (GK)]:
! [X] : (Human(X) => CapableOf(X, abstractThought)).
! [X] : (Plant(X) => -CapableOf(X, abstractThought)).
! [X] : (MulticellularCreature(X) & (Autotrophic(X) | DigestFoodInternally (X)) => Plant(X) <~> Animal(X)).
! [X] : (Goat(X) => Animal(X)).
! [X] : (Dirt(X) => -Animal(X)).
Goat(hulu) | HumanBeing(hulu).
(MulticellularCreature(hulu) & (Autotrophic(hulu) | DigestFoodInternally (hulu)).

[CONCLUSION]:
Hulu is an animal or dirt.

[CONCLUSION (FOL)]:
Animal(hulu) ∨ Dirt(hulu)

[CONCLUSION (GK)]:
Animal(hulu) | Dirt(hulu).


===

['x']
['x']
[PREMISE]:
All humans are capable of abstract thoughts.
Plants are not capable of abstract thoughts.
All multicellular creatures that are autotrophic or digest food internally are plants and animals.
All goats are animals.
Dirt is not an animal.
Hulu is a goat or a human.
Hulu is a multicellular creature that is autotrophic or digests food internally. 

[PREMISE (FOL)]:
∀x (Human(x) → CapableOf(x, abstractThought))
∀x (Plant(x) → ¬CapableOf(x, abstractThought))
∀x (MulticellularCreature(x) ∧ (Autotrophic(x) ∨ DigestFoodInternally (x)) → Plant(x) ⊕ Animal(x))
∀x (Goat(x) → Animal(x))
∀x (Dirt(x) → ¬Animal(x))
Goat(hulu) ∨ HumanBeing(hulu)
(MulticellularCreature(hulu) ∧ (Autotrophic(hulu) ∨ DigestFoodInternally (hulu))

[PREMISE (GK)]:
! [X] : (Human(X) => CapableOf(X, abstractThought)).
! [X] : (Plant(X) => -CapableOf(X, abstractThought)).
! [X] : (MulticellularCreature(X) & (Autotrophic(X) | DigestFoodInternally (X)) => Plant(X) <~> Animal(X)).
! [X] : (Goat(X) => Animal(X)).
! [X] : (Dirt(X) => -Animal(X)).
Goat(hulu) | HumanBeing(hulu).
(MulticellularCreature(hulu) & (Autotrophic(hulu) | DigestFoodInternally (hulu)).

[CONCLUSION]:
Hulu is either an animal or dirt, but not both.

[CONCLUSION (FOL)]:
Animal(hulu) ⊕ Dirt(hulu)

[CONCLUSION (GK)]:
Animal(hulu) <~> Dirt(hulu).


===

['x']
['x']
[PREMISE]:
All humans are capable of abstract thoughts.
Plants are not capable of abstract thoughts.
All multicellular creatures that are autotrophic or digest food internally are plants and animals.
All goats are animals.
Dirt is not an animal.
Hulu is a goat or a human.
Hulu is a multicellular creature that is autotrophic or digests food internally. 

[PREMISE (FOL)]:
∀x (Human(x) → CapableOf(x, abstractThought))
∀x (Plant(x) → ¬CapableOf(x, abstractThought))
∀x (MulticellularCreature(x) ∧ (Autotrophic(x) ∨ DigestFoodInternally (x)) → Plant(x) ⊕ Animal(x))
∀x (Goat(x) → Animal(x))
∀x (Dirt(x) → ¬Animal(x))
Goat(hulu) ∨ HumanBeing(hulu)
(MulticellularCreature(hulu) ∧ (Autotrophic(hulu) ∨ DigestFoodInternally (hulu))

[PREMISE (GK)]:
! [X] : (Human(X) => CapableOf(X, abstractThought)).
! [X] : (Plant(X) => -CapableOf(X, abstractThought)).
! [X] : (MulticellularCreature(X) & (Autotrophic(X) | DigestFoodInternally (X)) => Plant(X) <~> Animal(X)).
! [X] : (Goat(X) => Animal(X)).
! [X] : (Dirt(X) => -Animal(X)).
Goat(hulu) | HumanBeing(hulu).
(MulticellularCreature(hulu) & (Autotrophic(hulu) | DigestFoodInternally (hulu)).

[CONCLUSION]:
If Hulu is either an animal or dirt, then Hulu is capable of abstract thoughts and is dirt.

[CONCLUSION (FOL)]:
Animal(hulu) ⊕ Dirt(hulu) → CapableOf(hulu, abstractThought) ∧ Dirt(hulu)

[CONCLUSION (GK)]:
Animal(hulu) <~> Dirt(hulu) => CapableOf(hulu, abstractThought) & Dirt(hulu).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A controlled substance is a drug.
There exist both harmful and beneficial controlled substances.
If a child is exposed to a controlled substance, they are in chemical endangerment.
Chemical Endangerment is harmful. 
The Controlled Substances Act was an act passed in 1971.
Some Acts prevent harmful things.

[PREMISE (FOL)]:
∀x (ControlledSubstances(x) → Drugs(x))
∃x ∃y (ControlledSubstances(x) ∧ ControlledSubstances(y) ∧ (¬(x=y)) ∧ Beneficial(x) ∧ Harmful(y))
∀x ∀y ((Child(x) ∧ ControlledSubstances(y) ∧ ExposedTo(x, y)) → InChemicalEndangerment(x))
∀x (InChemicalEndangerment(x) → Harmful(x))
PassedIn(controlledSubstancesAct, yr1971) ∧ Act(controlledSubstancesAct)
∃x ∃y(Act(x) ∧ PreventsHarm(x) ∧ (¬(x=y)) ∧ Act(y) ∧ PreventsHarm(y))

[PREMISE (GK)]:
! [X] : (ControlledSubstances(X) => Drugs(X)).
? [X] : ? [Y] : (ControlledSubstances(X) & ControlledSubstances(Y) & (-(X=Y)) & Beneficial(X) & Harmful(Y)).
! [X] : ! [Y] : ((Child(X) & ControlledSubstances(Y) & ExposedTo(X, Y)) => InChemicalEndangerment(X)).
! [X] : (InChemicalEndangerment(X) => Harmful(X)).
PassedIn(controlledSubstancesAct, yr1971) & Act(controlledSubstancesAct).
? [X] : ? [Y] :(Act(X) & PreventsHarm(X) & (-(X=Y)) & Act(Y) & PreventsHarm(Y)).

[CONCLUSION]:
The Controlled Substances Act prevents harmful things.

[CONCLUSION (FOL)]:
PreventsHarm(controlledSubstancesAct)

[CONCLUSION (GK)]:
PreventsHarm(controlledSubstancesAct).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A controlled substance is a drug.
There exist both harmful and beneficial controlled substances.
If a child is exposed to a controlled substance, they are in chemical endangerment.
Chemical Endangerment is harmful. 
The Controlled Substances Act was an act passed in 1971.
Some Acts prevent harmful things.

[PREMISE (FOL)]:
∀x (ControlledSubstances(x) → Drugs(x))
∃x ∃y (ControlledSubstances(x) ∧ ControlledSubstances(y) ∧ (¬(x=y)) ∧ Beneficial(x) ∧ Harmful(y))
∀x ∀y ((Child(x) ∧ ControlledSubstances(y) ∧ ExposedTo(x, y)) → InChemicalEndangerment(x))
∀x (InChemicalEndangerment(x) → Harmful(x))
PassedIn(controlledSubstancesAct, yr1971) ∧ Act(controlledSubstancesAct)
∃x ∃y(Act(x) ∧ PreventsHarm(x) ∧ (¬(x=y)) ∧ Act(y) ∧ PreventsHarm(y))

[PREMISE (GK)]:
! [X] : (ControlledSubstances(X) => Drugs(X)).
? [X] : ? [Y] : (ControlledSubstances(X) & ControlledSubstances(Y) & (-(X=Y)) & Beneficial(X) & Harmful(Y)).
! [X] : ! [Y] : ((Child(X) & ControlledSubstances(Y) & ExposedTo(X, Y)) => InChemicalEndangerment(X)).
! [X] : (InChemicalEndangerment(X) => Harmful(X)).
PassedIn(controlledSubstancesAct, yr1971) & Act(controlledSubstancesAct).
? [X] : ? [Y] :(Act(X) & PreventsHarm(X) & (-(X=Y)) & Act(Y) & PreventsHarm(Y)).

[CONCLUSION]:
Some drugs are beneficial.

[CONCLUSION (FOL)]:
∃x ∃y(Drugs(x) ∧ Beneficial(x) ∧ (¬(x=y)) ∧ Drugs(y) ∧ Beneficial(y))

[CONCLUSION (GK)]:
? [X] : ? [Y] :(Drugs(X) & Beneficial(X) & (-(X=Y)) & Drugs(Y) & Beneficial(Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A controlled substance is a drug.
There exist both harmful and beneficial controlled substances.
If a child is exposed to a controlled substance, they are in chemical endangerment.
Chemical Endangerment is harmful. 
The Controlled Substances Act was an act passed in 1971.
Some Acts prevent harmful things.

[PREMISE (FOL)]:
∀x (ControlledSubstances(x) → Drugs(x))
∃x ∃y (ControlledSubstances(x) ∧ ControlledSubstances(y) ∧ (¬(x=y)) ∧ Beneficial(x) ∧ Harmful(y))
∀x ∀y ((Child(x) ∧ ControlledSubstances(y) ∧ ExposedTo(x, y)) → InChemicalEndangerment(x))
∀x (InChemicalEndangerment(x) → Harmful(x))
PassedIn(controlledSubstancesAct, yr1971) ∧ Act(controlledSubstancesAct)
∃x ∃y(Act(x) ∧ PreventsHarm(x) ∧ (¬(x=y)) ∧ Act(y) ∧ PreventsHarm(y))

[PREMISE (GK)]:
! [X] : (ControlledSubstances(X) => Drugs(X)).
? [X] : ? [Y] : (ControlledSubstances(X) & ControlledSubstances(Y) & (-(X=Y)) & Beneficial(X) & Harmful(Y)).
! [X] : ! [Y] : ((Child(X) & ControlledSubstances(Y) & ExposedTo(X, Y)) => InChemicalEndangerment(X)).
! [X] : (InChemicalEndangerment(X) => Harmful(X)).
PassedIn(controlledSubstancesAct, yr1971) & Act(controlledSubstancesAct).
? [X] : ? [Y] :(Act(X) & PreventsHarm(X) & (-(X=Y)) & Act(Y) & PreventsHarm(Y)).

[CONCLUSION]:
A child in chemical endangerment is in harm.

[CONCLUSION (FOL)]:
∀x ((Child(x) ∧ InChemicalEndangerment(x)) → Harmful(x))

[CONCLUSION (GK)]:
! [X] : ((Child(X) & InChemicalEndangerment(X)) => Harmful(X)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
No people who have corporate jobs are taking more than normal financial risks.
All entrepreneurs are taking more than normal financial risks.
All risk-averse working people are people who have corporate jobs.
All working people who hate working for others want to be entrepreneurs.
If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse working person.

[PREMISE (FOL)]:
∀x (Have(x, corporateJob) → ¬Take(x, financialRisk))
∀x (Entrepreneur(x) → Take(x, financialRisk))
∀x (RiskAverse(x) → Have(x, corporateJob))
∀x (∃y ∃z (¬(y=x) ∧ ¬(z=x) ∧ ¬(y=z) ∧ HateWorkingFor(x, y) ∧ HateWorkingFor(x, z)) → Entrepreneur(x))
¬Entrepreneur(markZuckerberg) ∧ ¬(∃y ∃z (¬(y=markZuckerberg) ∧ ¬(z=markZuckerberg) ∧ ¬(y=z) ∧ HateWorkingFor(markZuckerberg, y) ∧ HateWorkingFor(markZuckerberg, z))) → ¬RiskAverse(markZuckerberg)

[PREMISE (GK)]:
! [X] : (Have(X, corporateJob) => -Take(X, financialRisk)).
! [X] : (Entrepreneur(X) => Take(X, financialRisk)).
! [X] : (RiskAverse(X) => Have(X, corporateJob)).
! [X] : (? [Y] : ? [Z] : (-(Y=X) & -(Z=X) & -(Y=Z) & HateWorkingFor(X, Y) & HateWorkingFor(X, Z)) => Entrepreneur(X)).
-Entrepreneur(markZuckerberg) & -(? [Y] : ? [Z] : (-(Y=markZuckerberg) & -(Z=markZuckerberg) & -(Y=Z) & HateWorkingFor(markZuckerberg, Y) & HateWorkingFor(markZuckerberg, Z))) => -RiskAverse(markZuckerberg).

[CONCLUSION]:
Mark Zuckerberg is an entrepreneur.

[CONCLUSION (FOL)]:
Entrepreneur(markZuckerberg)

[CONCLUSION (GK)]:
Entrepreneur(markZuckerberg).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
No people who have corporate jobs are taking more than normal financial risks.
All entrepreneurs are taking more than normal financial risks.
All risk-averse working people are people who have corporate jobs.
All working people who hate working for others want to be entrepreneurs.
If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse working person.

[PREMISE (FOL)]:
∀x (Have(x, corporateJob) → ¬Take(x, financialRisk))
∀x (Entrepreneur(x) → Take(x, financialRisk))
∀x (RiskAverse(x) → Have(x, corporateJob))
∀x (∃y ∃z (¬(y=x) ∧ ¬(z=x) ∧ ¬(y=z) ∧ HateWorkingFor(x, y) ∧ HateWorkingFor(x, z)) → Entrepreneur(x))
¬Entrepreneur(markZuckerberg) ∧ ¬(∃y ∃z (¬(y=markZuckerberg) ∧ ¬(z=markZuckerberg) ∧ ¬(y=z) ∧ HateWorkingFor(markZuckerberg, y) ∧ HateWorkingFor(markZuckerberg, z))) → ¬RiskAverse(markZuckerberg)

[PREMISE (GK)]:
! [X] : (Have(X, corporateJob) => -Take(X, financialRisk)).
! [X] : (Entrepreneur(X) => Take(X, financialRisk)).
! [X] : (RiskAverse(X) => Have(X, corporateJob)).
! [X] : (? [Y] : ? [Z] : (-(Y=X) & -(Z=X) & -(Y=Z) & HateWorkingFor(X, Y) & HateWorkingFor(X, Z)) => Entrepreneur(X)).
-Entrepreneur(markZuckerberg) & -(? [Y] : ? [Z] : (-(Y=markZuckerberg) & -(Z=markZuckerberg) & -(Y=Z) & HateWorkingFor(markZuckerberg, Y) & HateWorkingFor(markZuckerberg, Z))) => -RiskAverse(markZuckerberg).

[CONCLUSION]:
Mark Zuckerberg is a risk-averse person.

[CONCLUSION (FOL)]:
RiskAverse(markZuckerberg)

[CONCLUSION (GK)]:
RiskAverse(markZuckerberg).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
No people who have corporate jobs are taking more than normal financial risks.
All entrepreneurs are taking more than normal financial risks.
All risk-averse working people are people who have corporate jobs.
All working people who hate working for others want to be entrepreneurs.
If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse working person.

[PREMISE (FOL)]:
∀x (Have(x, corporateJob) → ¬Take(x, financialRisk))
∀x (Entrepreneur(x) → Take(x, financialRisk))
∀x (RiskAverse(x) → Have(x, corporateJob))
∀x (∃y ∃z (¬(y=x) ∧ ¬(z=x) ∧ ¬(y=z) ∧ HateWorkingFor(x, y) ∧ HateWorkingFor(x, z)) → Entrepreneur(x))
¬Entrepreneur(markZuckerberg) ∧ ¬(∃y ∃z (¬(y=markZuckerberg) ∧ ¬(z=markZuckerberg) ∧ ¬(y=z) ∧ HateWorkingFor(markZuckerberg, y) ∧ HateWorkingFor(markZuckerberg, z))) → ¬RiskAverse(markZuckerberg)

[PREMISE (GK)]:
! [X] : (Have(X, corporateJob) => -Take(X, financialRisk)).
! [X] : (Entrepreneur(X) => Take(X, financialRisk)).
! [X] : (RiskAverse(X) => Have(X, corporateJob)).
! [X] : (? [Y] : ? [Z] : (-(Y=X) & -(Z=X) & -(Y=Z) & HateWorkingFor(X, Y) & HateWorkingFor(X, Z)) => Entrepreneur(X)).
-Entrepreneur(markZuckerberg) & -(? [Y] : ? [Z] : (-(Y=markZuckerberg) & -(Z=markZuckerberg) & -(Y=Z) & HateWorkingFor(markZuckerberg, Y) & HateWorkingFor(markZuckerberg, Z))) => -RiskAverse(markZuckerberg).

[CONCLUSION]:
Mark Zuckerberg is not a risk-averse person.

[CONCLUSION (FOL)]:
¬RiskAverse(markZuckerberg)

[CONCLUSION (GK)]:
-RiskAverse(markZuckerberg).


===

['x']
['x']
[PREMISE]:
Wildfeed exists as an unannounced program.
Wildfeed can be sporting events, news, or syndicated shows.
Pre-recorded content is a copyright violation.
Programs are pre-recorded.

[PREMISE (FOL)]:
∃x (Wildfeed(x) ∧ Unannounced(x) ∧ Program(x))
∀x (Wildfeed(x) → SportingEvent(x) ∨ News(x) ∨ SyndicatedShow(x))
∀x (Prerecorded(x) → CopyrightViolation(x))
∀x (Program(x) → Prerecorded(x))

[PREMISE (GK)]:
? [X] : (Wildfeed(X) & Unannounced(X) & Program(X)).
! [X] : (Wildfeed(X) => SportingEvent(X) | News(X) | SyndicatedShow(X)).
! [X] : (Prerecorded(X) => CopyrightViolation(X)).
! [X] : (Program(X) => Prerecorded(X)).

[CONCLUSION]:
Some wildfeed is violating copyright laws.

[CONCLUSION (FOL)]:
∃x (Wildfeed(x) ∧ CopyrightViolation(x))

[CONCLUSION (GK)]:
? [X] : (Wildfeed(X) & CopyrightViolation(X)).


===

['x']
['x']
[PREMISE]:
Wildfeed exists as an unannounced program.
Wildfeed can be sporting events, news, or syndicated shows.
Pre-recorded content is a copyright violation.
Programs are pre-recorded.

[PREMISE (FOL)]:
∃x (Wildfeed(x) ∧ Unannounced(x) ∧ Program(x))
∀x (Wildfeed(x) → SportingEvent(x) ∨ News(x) ∨ SyndicatedShow(x))
∀x (Prerecorded(x) → CopyrightViolation(x))
∀x (Program(x) → Prerecorded(x))

[PREMISE (GK)]:
? [X] : (Wildfeed(X) & Unannounced(X) & Program(X)).
! [X] : (Wildfeed(X) => SportingEvent(X) | News(X) | SyndicatedShow(X)).
! [X] : (Prerecorded(X) => CopyrightViolation(X)).
! [X] : (Program(X) => Prerecorded(X)).

[CONCLUSION]:
Wildfeed can be prerecorded.

[CONCLUSION (FOL)]:
∃x (Wildfeed(x) ∧ Prerecorded(x))

[CONCLUSION (GK)]:
? [X] : (Wildfeed(X) & Prerecorded(X)).


===

['x']
['x']
[PREMISE]:
Wildfeed exists as an unannounced program.
Wildfeed can be sporting events, news, or syndicated shows.
Pre-recorded content is a copyright violation.
Programs are pre-recorded.

[PREMISE (FOL)]:
∃x (Wildfeed(x) ∧ Unannounced(x) ∧ Program(x))
∀x (Wildfeed(x) → SportingEvent(x) ∨ News(x) ∨ SyndicatedShow(x))
∀x (Prerecorded(x) → CopyrightViolation(x))
∀x (Program(x) → Prerecorded(x))

[PREMISE (GK)]:
? [X] : (Wildfeed(X) & Unannounced(X) & Program(X)).
! [X] : (Wildfeed(X) => SportingEvent(X) | News(X) | SyndicatedShow(X)).
! [X] : (Prerecorded(X) => CopyrightViolation(X)).
! [X] : (Program(X) => Prerecorded(X)).

[CONCLUSION]:
Syndicated shows are copyright violations.

[CONCLUSION (FOL)]:
∃x (SyndicatedShows(x) ∧ CopyrightViolation(x))

[CONCLUSION (GK)]:
? [X] : (SyndicatedShows(X) & CopyrightViolation(X)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
New York City is Located in the United States of America.
The United States of America is part of North America.
North America is in the western hemisphere of the earth.
New York City is a highly developed city.
If place A is located in place B and place B is located in place C, then place A is located in place C.

[PREMISE (FOL)]:
LocatedIn(newYorkCity, unitedStatesOfAmerica)
LocatedIn(usa, northAmerica)
LocatedIn(northAmerica, westernHemisphere)
HighlyDeveloped(newYorkCity)
∀x ∀y ∀z ((LocatedIn(x, y) ∧ LocatedIn(y, z)) → LocatedIn(x, z))

[PREMISE (GK)]:
LocatedIn(newYorkCity, unitedStatesOfAmerica).
LocatedIn(usa, northAmerica).
LocatedIn(northAmerica, westernHemisphere).
HighlyDeveloped(newYorkCity).
! [X] : ! [Y] : ! [Z] : ((LocatedIn(X, Y) & LocatedIn(Y, Z)) => LocatedIn(X, Z)).

[CONCLUSION]:
A highly developed city is located in the western hemisphere of the earth.

[CONCLUSION (FOL)]:
∃x (HighlyDeveloped(x) ∧ LocatedIn(x, westernHemisphere))

[CONCLUSION (GK)]:
? [X] : (HighlyDeveloped(X) & LocatedIn(X, westernHemisphere)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
New York City is Located in the United States of America.
The United States of America is part of North America.
North America is in the western hemisphere of the earth.
New York City is a highly developed city.
If place A is located in place B and place B is located in place C, then place A is located in place C.

[PREMISE (FOL)]:
LocatedIn(newYorkCity, unitedStatesOfAmerica)
LocatedIn(usa, northAmerica)
LocatedIn(northAmerica, westernHemisphere)
HighlyDeveloped(newYorkCity)
∀x ∀y ∀z ((LocatedIn(x, y) ∧ LocatedIn(y, z)) → LocatedIn(x, z))

[PREMISE (GK)]:
LocatedIn(newYorkCity, unitedStatesOfAmerica).
LocatedIn(usa, northAmerica).
LocatedIn(northAmerica, westernHemisphere).
HighlyDeveloped(newYorkCity).
! [X] : ! [Y] : ! [Z] : ((LocatedIn(X, Y) & LocatedIn(Y, Z)) => LocatedIn(X, Z)).

[CONCLUSION]:
The United States of America is not located in the western hemisphere of the earth.

[CONCLUSION (FOL)]:
¬LocatedIn(unitedStatesOfAmerica, westHemisphere)

[CONCLUSION (GK)]:
-LocatedIn(unitedStatesOfAmerica, westHemisphere).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
New York City is Located in the United States of America.
The United States of America is part of North America.
North America is in the western hemisphere of the earth.
New York City is a highly developed city.
If place A is located in place B and place B is located in place C, then place A is located in place C.

[PREMISE (FOL)]:
LocatedIn(newYorkCity, unitedStatesOfAmerica)
LocatedIn(usa, northAmerica)
LocatedIn(northAmerica, westernHemisphere)
HighlyDeveloped(newYorkCity)
∀x ∀y ∀z ((LocatedIn(x, y) ∧ LocatedIn(y, z)) → LocatedIn(x, z))

[PREMISE (GK)]:
LocatedIn(newYorkCity, unitedStatesOfAmerica).
LocatedIn(usa, northAmerica).
LocatedIn(northAmerica, westernHemisphere).
HighlyDeveloped(newYorkCity).
! [X] : ! [Y] : ! [Z] : ((LocatedIn(X, Y) & LocatedIn(Y, Z)) => LocatedIn(X, Z)).

[CONCLUSION]:
New York City is located in New York State.

[CONCLUSION (FOL)]:
LocatedIn(newYorkCity, newYork)

[CONCLUSION (GK)]:
LocatedIn(newYorkCity, newYork).


===

[]
['x', 'y']
[PREMISE]:
Catullus 4 is a poem written by the ancient Roman writer Catullus.
Catullus 4 is a story about the retirement of a well-traveled ship.
There is a strong analogy of human aging in the poem Catullus 4.
Catullus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.

[PREMISE (FOL)]:
Poem(catullus4) ∧ WrittenBy(catullus4, catullus) ∧ AncientRomanWriter(catullus)
Story(catullus4) ∧ About(catullus4, retirementOfAWellTraveledShip)
Poem(catullus4) ∧ StrongAgingAnalogy(catullus4)
Poem(catullus4) ∧ WrittenIn(catullus4, iambicTrimeter) ∧ Convey(catullus4, aSenseOfSpeedOverTheWaves)

[PREMISE (GK)]:
Poem(catullus4) & WrittenBy(catullus4, catullus) & AncientRomanWriter(catullus).
Story(catullus4) & About(catullus4, retirementOfAWellTraveledShip).
Poem(catullus4) & StrongAgingAnalogy(catullus4).
Poem(catullus4) & WrittenIn(catullus4, iambicTrimeter) & Convey(catullus4, aSenseOfSpeedOverTheWaves).

[CONCLUSION]:
There is a poem written by an ancient Roman writer with a strong analogy of human aging.

[CONCLUSION (FOL)]:
∃x ∃y (Poem(x) ∧ WrittenBy(x, y) ∧ AncietRomanWriter(y) ∧ StrongAgingAnalogy(x))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Poem(X) & WrittenBy(X, Y) & AncietRomanWriter(Y) & StrongAgingAnalogy(X)).


===

[]
['x', 'y']
[PREMISE]:
Catullus 4 is a poem written by the ancient Roman writer Catullus.
Catullus 4 is a story about the retirement of a well-traveled ship.
There is a strong analogy of human aging in the poem Catullus 4.
Catullus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.

[PREMISE (FOL)]:
Poem(catullus4) ∧ WrittenBy(catullus4, catullus) ∧ AncientRomanWriter(catullus)
Story(catullus4) ∧ About(catullus4, retirementOfAWellTraveledShip)
Poem(catullus4) ∧ StrongAgingAnalogy(catullus4)
Poem(catullus4) ∧ WrittenIn(catullus4, iambicTrimeter) ∧ Convey(catullus4, aSenseOfSpeedOverTheWaves)

[PREMISE (GK)]:
Poem(catullus4) & WrittenBy(catullus4, catullus) & AncientRomanWriter(catullus).
Story(catullus4) & About(catullus4, retirementOfAWellTraveledShip).
Poem(catullus4) & StrongAgingAnalogy(catullus4).
Poem(catullus4) & WrittenIn(catullus4, iambicTrimeter) & Convey(catullus4, aSenseOfSpeedOverTheWaves).

[CONCLUSION]:
There is a poem written by an ancient Roman writer in iambic trimeter.

[CONCLUSION (FOL)]:
∃x ∃y (Poem(x) ∧ WrittenBy(x, y) ∧ AncientRomanWriter(y) ∧ WrittenIn(x, iambicTrimeter))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Poem(X) & WrittenBy(X, Y) & AncientRomanWriter(Y) & WrittenIn(X, iambicTrimeter)).


===

[]
[]
[PREMISE]:
Catullus 4 is a poem written by the ancient Roman writer Catullus.
Catullus 4 is a story about the retirement of a well-traveled ship.
There is a strong analogy of human aging in the poem Catullus 4.
Catullus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.

[PREMISE (FOL)]:
Poem(catullus4) ∧ WrittenBy(catullus4, catullus) ∧ AncientRomanWriter(catullus)
Story(catullus4) ∧ About(catullus4, retirementOfAWellTraveledShip)
Poem(catullus4) ∧ StrongAgingAnalogy(catullus4)
Poem(catullus4) ∧ WrittenIn(catullus4, iambicTrimeter) ∧ Convey(catullus4, aSenseOfSpeedOverTheWaves)

[PREMISE (GK)]:
Poem(catullus4) & WrittenBy(catullus4, catullus) & AncientRomanWriter(catullus).
Story(catullus4) & About(catullus4, retirementOfAWellTraveledShip).
Poem(catullus4) & StrongAgingAnalogy(catullus4).
Poem(catullus4) & WrittenIn(catullus4, iambicTrimeter) & Convey(catullus4, aSenseOfSpeedOverTheWaves).

[CONCLUSION]:
Callus 4 is written in an unusual iambic trimeter to convey a strong analogy of human aging.

[CONCLUSION (FOL)]:
Poem(catullus4) ∧ WrittenIn(catullus4, iambicTrimeter) ∧ StrongAgingAnalogy(catullus4)

[CONCLUSION (GK)]:
Poem(catullus4) & WrittenIn(catullus4, iambicTrimeter) & StrongAgingAnalogy(catullus4).


===

[]
['x']
[PREMISE]:
Westworld is an American science fiction-thriller TV series.
In 2016, a television series named Westworld debuted on HBO.
The TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.
The 1973 film Westworld is about robots that malfunction and begin killing human visitors.

[PREMISE (FOL)]:
American(westworld) ∧ ScienceFictionThriller(westworld)
Debut(westworld, year2016) ∧ TvSeries(westworld)
Adapted(westworld, westworldTheFilm) ∧ Produce(westworldTheFilm, year1973) ∧ Wrote(michael, westworldTheFilm) ∧ Directed(michael, westworldTheFilm)
Film(westworldTheFilm) ∧ About(westworldTheFilm, malfunctioningRobots)

[PREMISE (GK)]:
American(westworld) & ScienceFictionThriller(westworld).
Debut(westworld, year2016) & TvSeries(westworld).
Adapted(westworld, westworldTheFilm) & Produce(westworldTheFilm, year1973) & Wrote(michael, westworldTheFilm) & Directed(michael, westworldTheFilm).
Film(westworldTheFilm) & About(westworldTheFilm, malfunctioningRobots).

[CONCLUSION]:
Michael Crichton has directed a film about malfunctioning robots.

[CONCLUSION (FOL)]:
∃x (Film(x) ∧ Directed(michael, x) ∧ About(x, malfunctioningRobots))

[CONCLUSION (GK)]:
? [X] : (Film(X) & Directed(michael, X) & About(X, malfunctioningRobots)).


===

[]
['x']
[PREMISE]:
Westworld is an American science fiction-thriller TV series.
In 2016, a television series named Westworld debuted on HBO.
The TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.
The 1973 film Westworld is about robots that malfunction and begin killing human visitors.

[PREMISE (FOL)]:
American(westworld) ∧ ScienceFictionThriller(westworld)
Debut(westworld, year2016) ∧ TvSeries(westworld)
Adapted(westworld, westworldTheFilm) ∧ Produce(westworldTheFilm, year1973) ∧ Wrote(michael, westworldTheFilm) ∧ Directed(michael, westworldTheFilm)
Film(westworldTheFilm) ∧ About(westworldTheFilm, malfunctioningRobots)

[PREMISE (GK)]:
American(westworld) & ScienceFictionThriller(westworld).
Debut(westworld, year2016) & TvSeries(westworld).
Adapted(westworld, westworldTheFilm) & Produce(westworldTheFilm, year1973) & Wrote(michael, westworldTheFilm) & Directed(michael, westworldTheFilm).
Film(westworldTheFilm) & About(westworldTheFilm, malfunctioningRobots).

[CONCLUSION]:
An American TV series debuted in 2016.

[CONCLUSION (FOL)]:
∃x (TVSeries(x) ∧ American(x) ∧ Debut(x, year2016))

[CONCLUSION (GK)]:
? [X] : (TVSeries(X) & American(X) & Debut(X, year2016)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
The 2008 Summer Olympics were held in Beijing, China.
The 2008 Summer Olympics was the second Summer Olympic Games held in a communist state.
China won the most gold medals (48) in the 2008 Summer Olympics.
The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.
The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.
If a country placed third in gold medals, then it had fewer gold medals than the team that won the most gold medals.

[PREMISE (FOL)]:
HeldIn(2008SummerOlympics, beijingChina)
SecondSummerOlympicsGames(2008SummerOlympics) ∧ BeHeldIn(2008SummerOlympics, communistState)
Won(china, theMostGoldMedals)
PlacedSecondInGoldMedalsIn(unitedStates, 2008SummerOlympics) ∧ Won(unitedStates, highestNumberOfMedals)
PlacedThirdInGoldMedalsIn(russia, 2008SummerOlympics)
∀x ∀y (Placed(x, thirdInGoldMedals) ∧ Won(y, mostGoldMedals) → FewerGoldMedalsThan(x, y))

[PREMISE (GK)]:
HeldIn(2008SummerOlympics, beijingChina).
SecondSummerOlympicsGames(2008SummerOlympics) & BeHeldIn(2008SummerOlympics, communistState).
Won(china, theMostGoldMedals).
PlacedSecondInGoldMedalsIn(unitedStates, 2008SummerOlympics) & Won(unitedStates, highestNumberOfMedals).
PlacedThirdInGoldMedalsIn(russia, 2008SummerOlympics).
! [X] : ! [Y] : (Placed(X, thirdInGoldMedals) & Won(Y, mostGoldMedals) => FewerGoldMedalsThan(X, Y)).

[CONCLUSION]:
Russia did not win fewer gold medals than China.

[CONCLUSION (FOL)]:
¬FewerGoldMedalsThan(russia, china)

[CONCLUSION (GK)]:
-FewerGoldMedalsThan(russia, china).


===

['x', 'y']
['x', 'y']
[PREMISE]:
The 2008 Summer Olympics were held in Beijing, China.
The 2008 Summer Olympics was the second Summer Olympic Games held in a communist state.
China won the most gold medals (48) in the 2008 Summer Olympics.
The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.
The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.
If a country placed third in gold medals, then it had fewer gold medals than the team that won the most gold medals.

[PREMISE (FOL)]:
HeldIn(2008SummerOlympics, beijingChina)
SecondSummerOlympicsGames(2008SummerOlympics) ∧ BeHeldIn(2008SummerOlympics, communistState)
Won(china, theMostGoldMedals)
PlacedSecondInGoldMedalsIn(unitedStates, 2008SummerOlympics) ∧ Won(unitedStates, highestNumberOfMedals)
PlacedThirdInGoldMedalsIn(russia, 2008SummerOlympics)
∀x ∀y (Placed(x, thirdInGoldMedals) ∧ Won(y, mostGoldMedals) → FewerGoldMedalsThan(x, y))

[PREMISE (GK)]:
HeldIn(2008SummerOlympics, beijingChina).
SecondSummerOlympicsGames(2008SummerOlympics) & BeHeldIn(2008SummerOlympics, communistState).
Won(china, theMostGoldMedals).
PlacedSecondInGoldMedalsIn(unitedStates, 2008SummerOlympics) & Won(unitedStates, highestNumberOfMedals).
PlacedThirdInGoldMedalsIn(russia, 2008SummerOlympics).
! [X] : ! [Y] : (Placed(X, thirdInGoldMedals) & Won(Y, mostGoldMedals) => FewerGoldMedalsThan(X, Y)).

[CONCLUSION]:
Russia won fewer gold medals than China.

[CONCLUSION (FOL)]:
FewerGoldMedalsThan(russia, china)

[CONCLUSION (GK)]:
FewerGoldMedalsThan(russia, china).


===

[]
['x']
[PREMISE]:
Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.
Yangshuo is not a district in Guilin. 

[PREMISE (FOL)]:
DistrictIn(xiufeng, guilin) ∧ DistrictIn(xiangshan, guilin) ∧ DistrictIn(diecai, guilin) ∧ DistrictIn(qixing, guilin) ∧ City(guilin)
¬DistrictIn(yangshuo, guilin)

[PREMISE (GK)]:
DistrictIn(xiufeng, guilin) & DistrictIn(xiangshan, guilin) & DistrictIn(diecai, guilin) & DistrictIn(qixing, guilin) & City(guilin).
-DistrictIn(yangshuo, guilin).

[CONCLUSION]:
Xiangshan and Diecai are districts in the same city.

[CONCLUSION (FOL)]:
∃x (DistrictIn(xiangshan, x) ∧ DistrictIn(diecai, x) ∧ City(x))

[CONCLUSION (GK)]:
? [X] : (DistrictIn(xiangshan, X) & DistrictIn(diecai, X) & City(X)).


===

[]
[]
[PREMISE]:
Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.
Yangshuo is not a district in Guilin. 

[PREMISE (FOL)]:
DistrictIn(xiufeng, guilin) ∧ DistrictIn(xiangshan, guilin) ∧ DistrictIn(diecai, guilin) ∧ DistrictIn(qixing, guilin) ∧ City(guilin)
¬DistrictIn(yangshuo, guilin)

[PREMISE (GK)]:
DistrictIn(xiufeng, guilin) & DistrictIn(xiangshan, guilin) & DistrictIn(diecai, guilin) & DistrictIn(qixing, guilin) & City(guilin).
-DistrictIn(yangshuo, guilin).

[CONCLUSION]:
Xiufeng is a district in Guilin.

[CONCLUSION (FOL)]:
DistrictIn(xiufeng, guilin)

[CONCLUSION (GK)]:
DistrictIn(xiufeng, guilin).


===

[]
[]
[PREMISE]:
Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.
Yangshuo is not a district in Guilin. 

[PREMISE (FOL)]:
DistrictIn(xiufeng, guilin) ∧ DistrictIn(xiangshan, guilin) ∧ DistrictIn(diecai, guilin) ∧ DistrictIn(qixing, guilin) ∧ City(guilin)
¬DistrictIn(yangshuo, guilin)

[PREMISE (GK)]:
DistrictIn(xiufeng, guilin) & DistrictIn(xiangshan, guilin) & DistrictIn(diecai, guilin) & DistrictIn(qixing, guilin) & City(guilin).
-DistrictIn(yangshuo, guilin).

[CONCLUSION]:
Kowloon District is in Hong Kong.

[CONCLUSION (FOL)]:
DistrictIn(kowloon, hongKong)

[CONCLUSION (GK)]:
DistrictIn(kowloon, hongKong).


===

['x']
['x']
[PREMISE]:
All of Michael's neighbors who grow their own fresh vegetables in their home gardens also have ample space.
All of Michael's neighbors who are young working professionals and live in large cities, do not have ample space.
All of Michael's neighbors who order takeout from delivery services often grow their own fresh vegetables in their home garden.
All of Michael's neighbors who enjoy going out often to restaurants with friends order takeout from delivery services often.
All of Michael's neighbors who regularly tout the benefits of homegrown and homecooked meals over fast food enjoy going out often to restaurants with friends. 
Peter, Michael's neighbor, grows his own fresh vegetables in his home garden, or regularly touts the benefits of homegrown and homecooked meals over fast food, or both.

[PREMISE (FOL)]:
∀x (MichaelsNeightbor(x) ∧ GrowIn(x, vegetable, garden) → Have(x, ampleSpace))
∀x (MichaelsNeightbor(x) ∧ YoungWorkingProfession(x) ∧ LiveIn(x, largeCity) → ¬Have(x, ampleSpace))
∀x (MichaelsNeightbor(x) ∧ OrderOften(x, takeout) → Grow(x, vegetable, garden))
∀x (MichaelsNeightbor(x) ∧ EnjoyGoingOutOftenToWith(x, restaurant, friend) → OrderOften(x, takeout))
∀x (MichaelsNeightbor(x) ∧ ToutOver(x, homecookedMeals, fastFood) → EnjoyGoingOutOftenToWith(x, restaurant, friend))
MichaelsNeightbor(peter) ∧ (GrowIn(peter, vegetable, garden) ∨ ToutOver(peter, homecookedMeals, fastFood))

[PREMISE (GK)]:
! [X] : (MichaelsNeightbor(X) & GrowIn(X, vegetable, garden) => Have(X, ampleSpace)).
! [X] : (MichaelsNeightbor(X) & YoungWorkingProfession(X) & LiveIn(X, largeCity) => -Have(X, ampleSpace)).
! [X] : (MichaelsNeightbor(X) & OrderOften(X, takeout) => Grow(X, vegetable, garden)).
! [X] : (MichaelsNeightbor(X) & EnjoyGoingOutOftenToWith(X, restaurant, friend) => OrderOften(X, takeout)).
! [X] : (MichaelsNeightbor(X) & ToutOver(X, homecookedMeals, fastFood) => EnjoyGoingOutOftenToWith(X, restaurant, friend)).
MichaelsNeightbor(peter) & (GrowIn(peter, vegetable, garden) | ToutOver(peter, homecookedMeals, fastFood)).

[CONCLUSION]:
Peter enjoys going out often to restaurants with friends.

[CONCLUSION (FOL)]:
EnjoyGoingOutOftenTo(peter, restaurant, friend)

[CONCLUSION (GK)]:
EnjoyGoingOutOftenTo(peter, restaurant, friend).


===

['x']
['x']
[PREMISE]:
All of Michael's neighbors who grow their own fresh vegetables in their home gardens also have ample space.
All of Michael's neighbors who are young working professionals and live in large cities, do not have ample space.
All of Michael's neighbors who order takeout from delivery services often grow their own fresh vegetables in their home garden.
All of Michael's neighbors who enjoy going out often to restaurants with friends order takeout from delivery services often.
All of Michael's neighbors who regularly tout the benefits of homegrown and homecooked meals over fast food enjoy going out often to restaurants with friends. 
Peter, Michael's neighbor, grows his own fresh vegetables in his home garden, or regularly touts the benefits of homegrown and homecooked meals over fast food, or both.

[PREMISE (FOL)]:
∀x (MichaelsNeightbor(x) ∧ GrowIn(x, vegetable, garden) → Have(x, ampleSpace))
∀x (MichaelsNeightbor(x) ∧ YoungWorkingProfession(x) ∧ LiveIn(x, largeCity) → ¬Have(x, ampleSpace))
∀x (MichaelsNeightbor(x) ∧ OrderOften(x, takeout) → Grow(x, vegetable, garden))
∀x (MichaelsNeightbor(x) ∧ EnjoyGoingOutOftenToWith(x, restaurant, friend) → OrderOften(x, takeout))
∀x (MichaelsNeightbor(x) ∧ ToutOver(x, homecookedMeals, fastFood) → EnjoyGoingOutOftenToWith(x, restaurant, friend))
MichaelsNeightbor(peter) ∧ (GrowIn(peter, vegetable, garden) ∨ ToutOver(peter, homecookedMeals, fastFood))

[PREMISE (GK)]:
! [X] : (MichaelsNeightbor(X) & GrowIn(X, vegetable, garden) => Have(X, ampleSpace)).
! [X] : (MichaelsNeightbor(X) & YoungWorkingProfession(X) & LiveIn(X, largeCity) => -Have(X, ampleSpace)).
! [X] : (MichaelsNeightbor(X) & OrderOften(X, takeout) => Grow(X, vegetable, garden)).
! [X] : (MichaelsNeightbor(X) & EnjoyGoingOutOftenToWith(X, restaurant, friend) => OrderOften(X, takeout)).
! [X] : (MichaelsNeightbor(X) & ToutOver(X, homecookedMeals, fastFood) => EnjoyGoingOutOftenToWith(X, restaurant, friend)).
MichaelsNeightbor(peter) & (GrowIn(peter, vegetable, garden) | ToutOver(peter, homecookedMeals, fastFood)).

[CONCLUSION]:
Peter is a young working professional who lives in large cities.

[CONCLUSION (FOL)]:
YoungWorkingProfession(peter) ∧ LiveIn(peter, largeCity)

[CONCLUSION (GK)]:
YoungWorkingProfession(peter) & LiveIn(peter, largeCity).


===

['x']
['x']
[PREMISE]:
All of Michael's neighbors who grow their own fresh vegetables in their home gardens also have ample space.
All of Michael's neighbors who are young working professionals and live in large cities, do not have ample space.
All of Michael's neighbors who order takeout from delivery services often grow their own fresh vegetables in their home garden.
All of Michael's neighbors who enjoy going out often to restaurants with friends order takeout from delivery services often.
All of Michael's neighbors who regularly tout the benefits of homegrown and homecooked meals over fast food enjoy going out often to restaurants with friends. 
Peter, Michael's neighbor, grows his own fresh vegetables in his home garden, or regularly touts the benefits of homegrown and homecooked meals over fast food, or both.

[PREMISE (FOL)]:
∀x (MichaelsNeightbor(x) ∧ GrowIn(x, vegetable, garden) → Have(x, ampleSpace))
∀x (MichaelsNeightbor(x) ∧ YoungWorkingProfession(x) ∧ LiveIn(x, largeCity) → ¬Have(x, ampleSpace))
∀x (MichaelsNeightbor(x) ∧ OrderOften(x, takeout) → Grow(x, vegetable, garden))
∀x (MichaelsNeightbor(x) ∧ EnjoyGoingOutOftenToWith(x, restaurant, friend) → OrderOften(x, takeout))
∀x (MichaelsNeightbor(x) ∧ ToutOver(x, homecookedMeals, fastFood) → EnjoyGoingOutOftenToWith(x, restaurant, friend))
MichaelsNeightbor(peter) ∧ (GrowIn(peter, vegetable, garden) ∨ ToutOver(peter, homecookedMeals, fastFood))

[PREMISE (GK)]:
! [X] : (MichaelsNeightbor(X) & GrowIn(X, vegetable, garden) => Have(X, ampleSpace)).
! [X] : (MichaelsNeightbor(X) & YoungWorkingProfession(X) & LiveIn(X, largeCity) => -Have(X, ampleSpace)).
! [X] : (MichaelsNeightbor(X) & OrderOften(X, takeout) => Grow(X, vegetable, garden)).
! [X] : (MichaelsNeightbor(X) & EnjoyGoingOutOftenToWith(X, restaurant, friend) => OrderOften(X, takeout)).
! [X] : (MichaelsNeightbor(X) & ToutOver(X, homecookedMeals, fastFood) => EnjoyGoingOutOftenToWith(X, restaurant, friend)).
MichaelsNeightbor(peter) & (GrowIn(peter, vegetable, garden) | ToutOver(peter, homecookedMeals, fastFood)).

[CONCLUSION]:
Peter grows his own fresh vegetables in their home garden or is a young working professional who lives in large cities.

[CONCLUSION (FOL)]:
GrowIn(peter, vegetable, garden) ∨ (YoungWorkingProfession(peter) ∧ LiveIn(peter, largeCity))

[CONCLUSION (GK)]:
GrowIn(peter, vegetable, garden) | (YoungWorkingProfession(peter) & LiveIn(peter, largeCity)).


===

['x']
['x']
[PREMISE]:
All devices belonging to the company are connected to Google Home. 
All devices belonging to employees are connected to the company's wifi. 
All devices connected to Google Home are controlled by the managers. 
All devices that connect to the company's wifi are easy to operate. 
ModelXX belongs to employees. 

[PREMISE (FOL)]:
∀x (OwnedBy(x, company) → ConnectedTo(x, googleHome))
∀x (OwnedBy(x, employee) → ConnectedTo(x, companyWiFi))
∀x (ConnectedTo(x, googleHome) → ControlledBy(x, managers))
∀x (ConnectedTo(x, companyWiFi) → EasyToOperate(x))
OwnedBy(modelXX, employee)

[PREMISE (GK)]:
! [X] : (OwnedBy(X, company) => ConnectedTo(X, googleHome)).
! [X] : (OwnedBy(X, employee) => ConnectedTo(X, companyWiFi)).
! [X] : (ConnectedTo(X, googleHome) => ControlledBy(X, managers)).
! [X] : (ConnectedTo(X, companyWiFi) => EasyToOperate(X)).
OwnedBy(modelXX, employee).

[CONCLUSION]:
ModelXX is easy to operate.

[CONCLUSION (FOL)]:
EasyToOperate(modelXX)

[CONCLUSION (GK)]:
EasyToOperate(modelXX).


===

['x']
['x']
[PREMISE]:
All devices belonging to the company are connected to Google Home. 
All devices belonging to employees are connected to the company's wifi. 
All devices connected to Google Home are controlled by the managers. 
All devices that connect to the company's wifi are easy to operate. 
ModelXX belongs to employees. 

[PREMISE (FOL)]:
∀x (OwnedBy(x, company) → ConnectedTo(x, googleHome))
∀x (OwnedBy(x, employee) → ConnectedTo(x, companyWiFi))
∀x (ConnectedTo(x, googleHome) → ControlledBy(x, managers))
∀x (ConnectedTo(x, companyWiFi) → EasyToOperate(x))
OwnedBy(modelXX, employee)

[PREMISE (GK)]:
! [X] : (OwnedBy(X, company) => ConnectedTo(X, googleHome)).
! [X] : (OwnedBy(X, employee) => ConnectedTo(X, companyWiFi)).
! [X] : (ConnectedTo(X, googleHome) => ControlledBy(X, managers)).
! [X] : (ConnectedTo(X, companyWiFi) => EasyToOperate(X)).
OwnedBy(modelXX, employee).

[CONCLUSION]:
ModelXX is controlled by managers.

[CONCLUSION (FOL)]:
ControlledBy(modelXX, managers)

[CONCLUSION (GK)]:
ControlledBy(modelXX, managers).


===

['x']
['x']
[PREMISE]:
All devices belonging to the company are connected to Google Home. 
All devices belonging to employees are connected to the company's wifi. 
All devices connected to Google Home are controlled by the managers. 
All devices that connect to the company's wifi are easy to operate. 
ModelXX belongs to employees. 

[PREMISE (FOL)]:
∀x (OwnedBy(x, company) → ConnectedTo(x, googleHome))
∀x (OwnedBy(x, employee) → ConnectedTo(x, companyWiFi))
∀x (ConnectedTo(x, googleHome) → ControlledBy(x, managers))
∀x (ConnectedTo(x, companyWiFi) → EasyToOperate(x))
OwnedBy(modelXX, employee)

[PREMISE (GK)]:
! [X] : (OwnedBy(X, company) => ConnectedTo(X, googleHome)).
! [X] : (OwnedBy(X, employee) => ConnectedTo(X, companyWiFi)).
! [X] : (ConnectedTo(X, googleHome) => ControlledBy(X, managers)).
! [X] : (ConnectedTo(X, companyWiFi) => EasyToOperate(X)).
OwnedBy(modelXX, employee).

[CONCLUSION]:
ModelXX is connected to Google Home.

[CONCLUSION (FOL)]:
ConnectedTo(modelXX, googleHome)

[CONCLUSION (GK)]:
ConnectedTo(modelXX, googleHome).


===

['x']
['x']
[PREMISE]:
No touring musicians who perform at the New Haven Symphony Orchestra are permanent members of the orchestra.
Musicians who perform at the New Haven Symphony Orchestra are permanent members of an orchestra, or they have temporary roles at the orchestra.
All touring musicians who perform at the New Haven Symphony Orchestra have temporary roles at the orchestra.
All musicians performing at the New Haven Symphony Orchestra who have temporary roles at the orchestra are interesting soloists.
All musicians performing at New Haven Symphony Orchestra who are interesting soloists are capable of attracting audiences.
Ryan is performing at New Haven Symphony Orchestra.
If Ryan is an interesting soloist and has a temporary role at the orchestra, then he is capable of attracting large audiences if and only if he is a touring soloist musician. 

[PREMISE (FOL)]:
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ TouringMusician(x)) → ¬PermanentMemberOf(x, theOrchestra))
∀x (PerformAt(x, newHavenSymphonyOrchestra) → (PermanentMemberOf(x, theOrchestra) ∨ HaveTemporaryRoleAt(x, theOrchestra)))
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ TouringMusicians(x)) → HaveTemporaryRoleAt(x, theOrchestra))
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ HaveTemporaryRoleAt(x, theOrchestra)) → InterestingSoloist(x))
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ InterestingSoloist(x)) → CapableOfAttractingAudiences(x))
PerformAt(ryan, newHavenSymphonyOrchestra)
(InterestingSoloist(ryan) ∧ HaveTemporaryRoleAt(ryan, theOrchestra)) → ¬(TouringMusician(ryan) ⊕ CapableOfAttractingAudiences(ryan))

[PREMISE (GK)]:
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & TouringMusician(X)) => -PermanentMemberOf(X, theOrchestra)).
! [X] : (PerformAt(X, newHavenSymphonyOrchestra) => (PermanentMemberOf(X, theOrchestra) | HaveTemporaryRoleAt(X, theOrchestra))).
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & TouringMusicians(X)) => HaveTemporaryRoleAt(X, theOrchestra)).
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & HaveTemporaryRoleAt(X, theOrchestra)) => InterestingSoloist(X)).
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & InterestingSoloist(X)) => CapableOfAttractingAudiences(X)).
PerformAt(ryan, newHavenSymphonyOrchestra).
(InterestingSoloist(ryan) & HaveTemporaryRoleAt(ryan, theOrchestra)) => -(TouringMusician(ryan) <~> CapableOfAttractingAudiences(ryan)).

[CONCLUSION]:
Ryan is an interesting soloist.

[CONCLUSION (FOL)]:
InterestingSoloist(ryan)

[CONCLUSION (GK)]:
InterestingSoloist(ryan).


===

['x']
['x']
[PREMISE]:
No touring musicians who perform at the New Haven Symphony Orchestra are permanent members of the orchestra.
Musicians who perform at the New Haven Symphony Orchestra are permanent members of an orchestra, or they have temporary roles at the orchestra.
All touring musicians who perform at the New Haven Symphony Orchestra have temporary roles at the orchestra.
All musicians performing at the New Haven Symphony Orchestra who have temporary roles at the orchestra are interesting soloists.
All musicians performing at New Haven Symphony Orchestra who are interesting soloists are capable of attracting audiences.
Ryan is performing at New Haven Symphony Orchestra.
If Ryan is an interesting soloist and has a temporary role at the orchestra, then he is capable of attracting large audiences if and only if he is a touring soloist musician. 

[PREMISE (FOL)]:
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ TouringMusician(x)) → ¬PermanentMemberOf(x, theOrchestra))
∀x (PerformAt(x, newHavenSymphonyOrchestra) → (PermanentMemberOf(x, theOrchestra) ∨ HaveTemporaryRoleAt(x, theOrchestra)))
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ TouringMusicians(x)) → HaveTemporaryRoleAt(x, theOrchestra))
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ HaveTemporaryRoleAt(x, theOrchestra)) → InterestingSoloist(x))
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ InterestingSoloist(x)) → CapableOfAttractingAudiences(x))
PerformAt(ryan, newHavenSymphonyOrchestra)
(InterestingSoloist(ryan) ∧ HaveTemporaryRoleAt(ryan, theOrchestra)) → ¬(TouringMusician(ryan) ⊕ CapableOfAttractingAudiences(ryan))

[PREMISE (GK)]:
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & TouringMusician(X)) => -PermanentMemberOf(X, theOrchestra)).
! [X] : (PerformAt(X, newHavenSymphonyOrchestra) => (PermanentMemberOf(X, theOrchestra) | HaveTemporaryRoleAt(X, theOrchestra))).
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & TouringMusicians(X)) => HaveTemporaryRoleAt(X, theOrchestra)).
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & HaveTemporaryRoleAt(X, theOrchestra)) => InterestingSoloist(X)).
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & InterestingSoloist(X)) => CapableOfAttractingAudiences(X)).
PerformAt(ryan, newHavenSymphonyOrchestra).
(InterestingSoloist(ryan) & HaveTemporaryRoleAt(ryan, theOrchestra)) => -(TouringMusician(ryan) <~> CapableOfAttractingAudiences(ryan)).

[CONCLUSION]:
Ryan is either a permanent member of an orchestra or a touring soloist musician.

[CONCLUSION (FOL)]:
(PermanentMemberOf(ryan, orchestra) ⊕ TouringMusician(ryan))

[CONCLUSION (GK)]:
(PermanentMemberOf(ryan, orchestra) <~> TouringMusician(ryan)).


===

['x']
['x']
[PREMISE]:
No touring musicians who perform at the New Haven Symphony Orchestra are permanent members of the orchestra.
Musicians who perform at the New Haven Symphony Orchestra are permanent members of an orchestra, or they have temporary roles at the orchestra.
All touring musicians who perform at the New Haven Symphony Orchestra have temporary roles at the orchestra.
All musicians performing at the New Haven Symphony Orchestra who have temporary roles at the orchestra are interesting soloists.
All musicians performing at New Haven Symphony Orchestra who are interesting soloists are capable of attracting audiences.
Ryan is performing at New Haven Symphony Orchestra.
If Ryan is an interesting soloist and has a temporary role at the orchestra, then he is capable of attracting large audiences if and only if he is a touring soloist musician. 

[PREMISE (FOL)]:
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ TouringMusician(x)) → ¬PermanentMemberOf(x, theOrchestra))
∀x (PerformAt(x, newHavenSymphonyOrchestra) → (PermanentMemberOf(x, theOrchestra) ∨ HaveTemporaryRoleAt(x, theOrchestra)))
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ TouringMusicians(x)) → HaveTemporaryRoleAt(x, theOrchestra))
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ HaveTemporaryRoleAt(x, theOrchestra)) → InterestingSoloist(x))
∀x ((PerformAt(x, newHavenSymphonyOrchestra) ∧ InterestingSoloist(x)) → CapableOfAttractingAudiences(x))
PerformAt(ryan, newHavenSymphonyOrchestra)
(InterestingSoloist(ryan) ∧ HaveTemporaryRoleAt(ryan, theOrchestra)) → ¬(TouringMusician(ryan) ⊕ CapableOfAttractingAudiences(ryan))

[PREMISE (GK)]:
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & TouringMusician(X)) => -PermanentMemberOf(X, theOrchestra)).
! [X] : (PerformAt(X, newHavenSymphonyOrchestra) => (PermanentMemberOf(X, theOrchestra) | HaveTemporaryRoleAt(X, theOrchestra))).
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & TouringMusicians(X)) => HaveTemporaryRoleAt(X, theOrchestra)).
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & HaveTemporaryRoleAt(X, theOrchestra)) => InterestingSoloist(X)).
! [X] : ((PerformAt(X, newHavenSymphonyOrchestra) & InterestingSoloist(X)) => CapableOfAttractingAudiences(X)).
PerformAt(ryan, newHavenSymphonyOrchestra).
(InterestingSoloist(ryan) & HaveTemporaryRoleAt(ryan, theOrchestra)) => -(TouringMusician(ryan) <~> CapableOfAttractingAudiences(ryan)).

[CONCLUSION]:
Ryan is either a permanent member of an orchestra or has a temporary role at the orchestra.

[CONCLUSION (FOL)]:
(PermanentMemberOf(ryan, orchestra) ⊕ HaveTemporaryRoleAt(ryan, orchestra))

[CONCLUSION (GK)]:
(PermanentMemberOf(ryan, orchestra) <~> HaveTemporaryRoleAt(ryan, orchestra)).


===

['x']
['x']
[PREMISE]:
If someone in Potterville yells, then they are not cool.
If someone in Potterville is angry, then they yell.
If someone in Potterville flies, then they are cool.
Every person in Potterville that knows magic flies.
All wizards in Potterville know magic.
Harry, who lives in Potterville either yells or flies. 
Potter, who lives in Potterville, is a wizard and flies.

[PREMISE (FOL)]:
∀x (In(x, potterville) ∧ Yell(x) → ¬Cool(x))
∀x (In(x, potterville) ∧ Angry(x) → Yell(x))
∀x (In(x, potterville) ∧ Fly(x) → Cool(x))
∀x (In(x, potterville) ∧ Know(x, magic) → Fly(x))
∀x (In(x, potterville) ∧ Wizard(x) → Know(x, magic))
In(harry, potterville) ∧ (Yell(harry) ⊕ Fly(harry))
Wizard(potter) ∧ Fly(potter)

[PREMISE (GK)]:
! [X] : (In(X, potterville) & Yell(X) => -Cool(X)).
! [X] : (In(X, potterville) & Angry(X) => Yell(X)).
! [X] : (In(X, potterville) & Fly(X) => Cool(X)).
! [X] : (In(X, potterville) & Know(X, magic) => Fly(X)).
! [X] : (In(X, potterville) & Wizard(X) => Know(X, magic)).
In(harry, potterville) & (Yell(harry) <~> Fly(harry)).
Wizard(potter) & Fly(potter).

[CONCLUSION]:
Harry is cool.

[CONCLUSION (FOL)]:
Cool(harry)

[CONCLUSION (GK)]:
Cool(harry).


===

['x']
['x']
[PREMISE]:
If someone in Potterville yells, then they are not cool.
If someone in Potterville is angry, then they yell.
If someone in Potterville flies, then they are cool.
Every person in Potterville that knows magic flies.
All wizards in Potterville know magic.
Harry, who lives in Potterville either yells or flies. 
Potter, who lives in Potterville, is a wizard and flies.

[PREMISE (FOL)]:
∀x (In(x, potterville) ∧ Yell(x) → ¬Cool(x))
∀x (In(x, potterville) ∧ Angry(x) → Yell(x))
∀x (In(x, potterville) ∧ Fly(x) → Cool(x))
∀x (In(x, potterville) ∧ Know(x, magic) → Fly(x))
∀x (In(x, potterville) ∧ Wizard(x) → Know(x, magic))
In(harry, potterville) ∧ (Yell(harry) ⊕ Fly(harry))
Wizard(potter) ∧ Fly(potter)

[PREMISE (GK)]:
! [X] : (In(X, potterville) & Yell(X) => -Cool(X)).
! [X] : (In(X, potterville) & Angry(X) => Yell(X)).
! [X] : (In(X, potterville) & Fly(X) => Cool(X)).
! [X] : (In(X, potterville) & Know(X, magic) => Fly(X)).
! [X] : (In(X, potterville) & Wizard(X) => Know(X, magic)).
In(harry, potterville) & (Yell(harry) <~> Fly(harry)).
Wizard(potter) & Fly(potter).

[CONCLUSION]:
Harry is not cool.

[CONCLUSION (FOL)]:
¬Cool(harry)

[CONCLUSION (GK)]:
-Cool(harry).


===

['x']
['x']
[PREMISE]:
If someone in Potterville yells, then they are not cool.
If someone in Potterville is angry, then they yell.
If someone in Potterville flies, then they are cool.
Every person in Potterville that knows magic flies.
All wizards in Potterville know magic.
Harry, who lives in Potterville either yells or flies. 
Potter, who lives in Potterville, is a wizard and flies.

[PREMISE (FOL)]:
∀x (In(x, potterville) ∧ Yell(x) → ¬Cool(x))
∀x (In(x, potterville) ∧ Angry(x) → Yell(x))
∀x (In(x, potterville) ∧ Fly(x) → Cool(x))
∀x (In(x, potterville) ∧ Know(x, magic) → Fly(x))
∀x (In(x, potterville) ∧ Wizard(x) → Know(x, magic))
In(harry, potterville) ∧ (Yell(harry) ⊕ Fly(harry))
Wizard(potter) ∧ Fly(potter)

[PREMISE (GK)]:
! [X] : (In(X, potterville) & Yell(X) => -Cool(X)).
! [X] : (In(X, potterville) & Angry(X) => Yell(X)).
! [X] : (In(X, potterville) & Fly(X) => Cool(X)).
! [X] : (In(X, potterville) & Know(X, magic) => Fly(X)).
! [X] : (In(X, potterville) & Wizard(X) => Know(X, magic)).
In(harry, potterville) & (Yell(harry) <~> Fly(harry)).
Wizard(potter) & Fly(potter).

[CONCLUSION]:
Harry is a wizard or angry.

[CONCLUSION (FOL)]:
Wizard(harry) ∨ Angry(harry)

[CONCLUSION (GK)]:
Wizard(harry) | Angry(harry).


===

['x']
['x']
[PREMISE]:
If someone in Potterville yells, then they are not cool.
If someone in Potterville is angry, then they yell.
If someone in Potterville flies, then they are cool.
Every person in Potterville that knows magic flies.
All wizards in Potterville know magic.
Harry, who lives in Potterville either yells or flies. 
Potter, who lives in Potterville, is a wizard and flies.

[PREMISE (FOL)]:
∀x (In(x, potterville) ∧ Yell(x) → ¬Cool(x))
∀x (In(x, potterville) ∧ Angry(x) → Yell(x))
∀x (In(x, potterville) ∧ Fly(x) → Cool(x))
∀x (In(x, potterville) ∧ Know(x, magic) → Fly(x))
∀x (In(x, potterville) ∧ Wizard(x) → Know(x, magic))
In(harry, potterville) ∧ (Yell(harry) ⊕ Fly(harry))
Wizard(potter) ∧ Fly(potter)

[PREMISE (GK)]:
! [X] : (In(X, potterville) & Yell(X) => -Cool(X)).
! [X] : (In(X, potterville) & Angry(X) => Yell(X)).
! [X] : (In(X, potterville) & Fly(X) => Cool(X)).
! [X] : (In(X, potterville) & Know(X, magic) => Fly(X)).
! [X] : (In(X, potterville) & Wizard(X) => Know(X, magic)).
In(harry, potterville) & (Yell(harry) <~> Fly(harry)).
Wizard(potter) & Fly(potter).

[CONCLUSION]:
Harry is neither a wizard nor angry.

[CONCLUSION (FOL)]:
¬Wizard(harry) ∧ ¬Angry(harry)

[CONCLUSION (GK)]:
-Wizard(harry) & -Angry(harry).


===

['x']
['x']
[PREMISE]:
All of this brand's products are either produced in China or in the US. 
All of this brand's products produced in China are labeled. 
All of this brand's products produced in the US are sold in the US. 
The products of this brand that are labeled are cheaper.
All of this brand's products sold in the US are sold at Walmart. 
All products of this brand displayed on the homepage are sold at Walmart. 
None of this brand's products that are returned by customers are sold at Walmart. 
G-910 is a product of this brand, and it is either displayed on the homepage and is cheaper, or it is neither displayed on the homepage nor is it cheaper.

[PREMISE (FOL)]:
∀x (ThisBrand(x) ∧ Product(x) → (ProducedIn(x, china) ⊕ ProducedIn(x, uS)))
∀x ((ThisBrand(x) ∧ Product(x) ∧ ProducedIn(x, china)) → Labeled(x))
∀x ((ThisBrand(x) ∧ Product(x) ∧ ProducedIn(x, us)) → SoldIn(x, us))
∀x ((ThisBrand(x) ∧ Product(x) ∧ Labeled(x)) → Cheaper(x))
∀x ((ThisBrand(x) ∧ Product(x) ∧ SoldIn(x, us)) → SoldIn(x, walmart))
∀x (ThisBrand(x) ∧ Product(x) ∧ DisplayedIn(x, homepage) → SoldIn(x, walmart))
∀x (ThisBrand(x) ∧ Product(x) ∧ ReturnedBy(x, customer) → ¬SoldIn(x, walmart))
Product(g910) ∧ ThisBrand(g910) ∧ (¬(DisplayedIn(g910, homepage) ⊕ Cheaper(g910)))

[PREMISE (GK)]:
! [X] : (ThisBrand(X) & Product(X) => (ProducedIn(X, china) <~> ProducedIn(X, uS))).
! [X] : ((ThisBrand(X) & Product(X) & ProducedIn(X, china)) => Labeled(X)).
! [X] : ((ThisBrand(X) & Product(X) & ProducedIn(X, us)) => SoldIn(X, us)).
! [X] : ((ThisBrand(X) & Product(X) & Labeled(X)) => Cheaper(X)).
! [X] : ((ThisBrand(X) & Product(X) & SoldIn(X, us)) => SoldIn(X, walmart)).
! [X] : (ThisBrand(X) & Product(X) & DisplayedIn(X, homepage) => SoldIn(X, walmart)).
! [X] : (ThisBrand(X) & Product(X) & ReturnedBy(X, customer) => -SoldIn(X, walmart)).
Product(g910) & ThisBrand(g910) & (-(DisplayedIn(g910, homepage) <~> Cheaper(g910))).

[CONCLUSION]:
G-910 is displayed on the homepage.

[CONCLUSION (FOL)]:
DisplayedIn(g910, homepage)

[CONCLUSION (GK)]:
DisplayedIn(g910, homepage).


===

['x']
['x']
[PREMISE]:
All of this brand's products are either produced in China or in the US. 
All of this brand's products produced in China are labeled. 
All of this brand's products produced in the US are sold in the US. 
The products of this brand that are labeled are cheaper.
All of this brand's products sold in the US are sold at Walmart. 
All products of this brand displayed on the homepage are sold at Walmart. 
None of this brand's products that are returned by customers are sold at Walmart. 
G-910 is a product of this brand, and it is either displayed on the homepage and is cheaper, or it is neither displayed on the homepage nor is it cheaper.

[PREMISE (FOL)]:
∀x (ThisBrand(x) ∧ Product(x) → (ProducedIn(x, china) ⊕ ProducedIn(x, uS)))
∀x ((ThisBrand(x) ∧ Product(x) ∧ ProducedIn(x, china)) → Labeled(x))
∀x ((ThisBrand(x) ∧ Product(x) ∧ ProducedIn(x, us)) → SoldIn(x, us))
∀x ((ThisBrand(x) ∧ Product(x) ∧ Labeled(x)) → Cheaper(x))
∀x ((ThisBrand(x) ∧ Product(x) ∧ SoldIn(x, us)) → SoldIn(x, walmart))
∀x (ThisBrand(x) ∧ Product(x) ∧ DisplayedIn(x, homepage) → SoldIn(x, walmart))
∀x (ThisBrand(x) ∧ Product(x) ∧ ReturnedBy(x, customer) → ¬SoldIn(x, walmart))
Product(g910) ∧ ThisBrand(g910) ∧ (¬(DisplayedIn(g910, homepage) ⊕ Cheaper(g910)))

[PREMISE (GK)]:
! [X] : (ThisBrand(X) & Product(X) => (ProducedIn(X, china) <~> ProducedIn(X, uS))).
! [X] : ((ThisBrand(X) & Product(X) & ProducedIn(X, china)) => Labeled(X)).
! [X] : ((ThisBrand(X) & Product(X) & ProducedIn(X, us)) => SoldIn(X, us)).
! [X] : ((ThisBrand(X) & Product(X) & Labeled(X)) => Cheaper(X)).
! [X] : ((ThisBrand(X) & Product(X) & SoldIn(X, us)) => SoldIn(X, walmart)).
! [X] : (ThisBrand(X) & Product(X) & DisplayedIn(X, homepage) => SoldIn(X, walmart)).
! [X] : (ThisBrand(X) & Product(X) & ReturnedBy(X, customer) => -SoldIn(X, walmart)).
Product(g910) & ThisBrand(g910) & (-(DisplayedIn(g910, homepage) <~> Cheaper(g910))).

[CONCLUSION]:
G-910 is not displayed on the homepage.

[CONCLUSION (FOL)]:
¬DisplayedIn(g910, homepage)

[CONCLUSION (GK)]:
-DisplayedIn(g910, homepage).


===

['x']
['x']
[PREMISE]:
All of this brand's products are either produced in China or in the US. 
All of this brand's products produced in China are labeled. 
All of this brand's products produced in the US are sold in the US. 
The products of this brand that are labeled are cheaper.
All of this brand's products sold in the US are sold at Walmart. 
All products of this brand displayed on the homepage are sold at Walmart. 
None of this brand's products that are returned by customers are sold at Walmart. 
G-910 is a product of this brand, and it is either displayed on the homepage and is cheaper, or it is neither displayed on the homepage nor is it cheaper.

[PREMISE (FOL)]:
∀x (ThisBrand(x) ∧ Product(x) → (ProducedIn(x, china) ⊕ ProducedIn(x, uS)))
∀x ((ThisBrand(x) ∧ Product(x) ∧ ProducedIn(x, china)) → Labeled(x))
∀x ((ThisBrand(x) ∧ Product(x) ∧ ProducedIn(x, us)) → SoldIn(x, us))
∀x ((ThisBrand(x) ∧ Product(x) ∧ Labeled(x)) → Cheaper(x))
∀x ((ThisBrand(x) ∧ Product(x) ∧ SoldIn(x, us)) → SoldIn(x, walmart))
∀x (ThisBrand(x) ∧ Product(x) ∧ DisplayedIn(x, homepage) → SoldIn(x, walmart))
∀x (ThisBrand(x) ∧ Product(x) ∧ ReturnedBy(x, customer) → ¬SoldIn(x, walmart))
Product(g910) ∧ ThisBrand(g910) ∧ (¬(DisplayedIn(g910, homepage) ⊕ Cheaper(g910)))

[PREMISE (GK)]:
! [X] : (ThisBrand(X) & Product(X) => (ProducedIn(X, china) <~> ProducedIn(X, uS))).
! [X] : ((ThisBrand(X) & Product(X) & ProducedIn(X, china)) => Labeled(X)).
! [X] : ((ThisBrand(X) & Product(X) & ProducedIn(X, us)) => SoldIn(X, us)).
! [X] : ((ThisBrand(X) & Product(X) & Labeled(X)) => Cheaper(X)).
! [X] : ((ThisBrand(X) & Product(X) & SoldIn(X, us)) => SoldIn(X, walmart)).
! [X] : (ThisBrand(X) & Product(X) & DisplayedIn(X, homepage) => SoldIn(X, walmart)).
! [X] : (ThisBrand(X) & Product(X) & ReturnedBy(X, customer) => -SoldIn(X, walmart)).
Product(g910) & ThisBrand(g910) & (-(DisplayedIn(g910, homepage) <~> Cheaper(g910))).

[CONCLUSION]:
G-910 is a product returned by customers.

[CONCLUSION (FOL)]:
ThisBrand(g910) ∧ ReturnedBy(g910, customer)

[CONCLUSION (GK)]:
ThisBrand(g910) & ReturnedBy(g910, customer).


===

['x']
['x']
[PREMISE]:
All of this brand's products are either produced in China or in the US. 
All of this brand's products produced in China are labeled. 
All of this brand's products produced in the US are sold in the US. 
The products of this brand that are labeled are cheaper.
All of this brand's products sold in the US are sold at Walmart. 
All products of this brand displayed on the homepage are sold at Walmart. 
None of this brand's products that are returned by customers are sold at Walmart. 
G-910 is a product of this brand, and it is either displayed on the homepage and is cheaper, or it is neither displayed on the homepage nor is it cheaper.

[PREMISE (FOL)]:
∀x (ThisBrand(x) ∧ Product(x) → (ProducedIn(x, china) ⊕ ProducedIn(x, uS)))
∀x ((ThisBrand(x) ∧ Product(x) ∧ ProducedIn(x, china)) → Labeled(x))
∀x ((ThisBrand(x) ∧ Product(x) ∧ ProducedIn(x, us)) → SoldIn(x, us))
∀x ((ThisBrand(x) ∧ Product(x) ∧ Labeled(x)) → Cheaper(x))
∀x ((ThisBrand(x) ∧ Product(x) ∧ SoldIn(x, us)) → SoldIn(x, walmart))
∀x (ThisBrand(x) ∧ Product(x) ∧ DisplayedIn(x, homepage) → SoldIn(x, walmart))
∀x (ThisBrand(x) ∧ Product(x) ∧ ReturnedBy(x, customer) → ¬SoldIn(x, walmart))
Product(g910) ∧ ThisBrand(g910) ∧ (¬(DisplayedIn(g910, homepage) ⊕ Cheaper(g910)))

[PREMISE (GK)]:
! [X] : (ThisBrand(X) & Product(X) => (ProducedIn(X, china) <~> ProducedIn(X, uS))).
! [X] : ((ThisBrand(X) & Product(X) & ProducedIn(X, china)) => Labeled(X)).
! [X] : ((ThisBrand(X) & Product(X) & ProducedIn(X, us)) => SoldIn(X, us)).
! [X] : ((ThisBrand(X) & Product(X) & Labeled(X)) => Cheaper(X)).
! [X] : ((ThisBrand(X) & Product(X) & SoldIn(X, us)) => SoldIn(X, walmart)).
! [X] : (ThisBrand(X) & Product(X) & DisplayedIn(X, homepage) => SoldIn(X, walmart)).
! [X] : (ThisBrand(X) & Product(X) & ReturnedBy(X, customer) => -SoldIn(X, walmart)).
Product(g910) & ThisBrand(g910) & (-(DisplayedIn(g910, homepage) <~> Cheaper(g910))).

[CONCLUSION]:
G-910 is a product returned by customers or sold in Walmart.

[CONCLUSION (FOL)]:
ThisBrand(g910) ∧ (ReturnedBy(g910, customer) ∨ SoldIn(g910, walmart))

[CONCLUSION (GK)]:
ThisBrand(g910) & (ReturnedBy(g910, customer) | SoldIn(g910, walmart)).


===

['x']
['x']
[PREMISE]:
All of this brand's products are either produced in China or in the US. 
All of this brand's products produced in China are labeled. 
All of this brand's products produced in the US are sold in the US. 
The products of this brand that are labeled are cheaper.
All of this brand's products sold in the US are sold at Walmart. 
All products of this brand displayed on the homepage are sold at Walmart. 
None of this brand's products that are returned by customers are sold at Walmart. 
G-910 is a product of this brand, and it is either displayed on the homepage and is cheaper, or it is neither displayed on the homepage nor is it cheaper.

[PREMISE (FOL)]:
∀x (ThisBrand(x) ∧ Product(x) → (ProducedIn(x, china) ⊕ ProducedIn(x, uS)))
∀x ((ThisBrand(x) ∧ Product(x) ∧ ProducedIn(x, china)) → Labeled(x))
∀x ((ThisBrand(x) ∧ Product(x) ∧ ProducedIn(x, us)) → SoldIn(x, us))
∀x ((ThisBrand(x) ∧ Product(x) ∧ Labeled(x)) → Cheaper(x))
∀x ((ThisBrand(x) ∧ Product(x) ∧ SoldIn(x, us)) → SoldIn(x, walmart))
∀x (ThisBrand(x) ∧ Product(x) ∧ DisplayedIn(x, homepage) → SoldIn(x, walmart))
∀x (ThisBrand(x) ∧ Product(x) ∧ ReturnedBy(x, customer) → ¬SoldIn(x, walmart))
Product(g910) ∧ ThisBrand(g910) ∧ (¬(DisplayedIn(g910, homepage) ⊕ Cheaper(g910)))

[PREMISE (GK)]:
! [X] : (ThisBrand(X) & Product(X) => (ProducedIn(X, china) <~> ProducedIn(X, uS))).
! [X] : ((ThisBrand(X) & Product(X) & ProducedIn(X, china)) => Labeled(X)).
! [X] : ((ThisBrand(X) & Product(X) & ProducedIn(X, us)) => SoldIn(X, us)).
! [X] : ((ThisBrand(X) & Product(X) & Labeled(X)) => Cheaper(X)).
! [X] : ((ThisBrand(X) & Product(X) & SoldIn(X, us)) => SoldIn(X, walmart)).
! [X] : (ThisBrand(X) & Product(X) & DisplayedIn(X, homepage) => SoldIn(X, walmart)).
! [X] : (ThisBrand(X) & Product(X) & ReturnedBy(X, customer) => -SoldIn(X, walmart)).
Product(g910) & ThisBrand(g910) & (-(DisplayedIn(g910, homepage) <~> Cheaper(g910))).

[CONCLUSION]:
G-910 is either returned by customers or sold in Walmart.

[CONCLUSION (FOL)]:
ReturnedBy(g910, customer) ⊕ SoldIn(g910, walmart)

[CONCLUSION (GK)]:
ReturnedBy(g910, customer) <~> SoldIn(g910, walmart).


===

['x']
['x']
[PREMISE]:
People either believe in Santa Claus, or think he is made up.
People who believe in Santa Claus expect to get presents on Christmas morning.
People who think Santa Claus is made up, then they would be surprised to see him in their house.
People who expect presents on Christmas morning are excited for it to be Christmas.
If people would be surprised to see Santa Claus in their house, then they don't leave out cookies on Chrismtas Eve.
Mercy is not someone who expects presents Christmas morning, is excited for Chrismtas, and believes in Santa Claus.

[PREMISE (FOL)]:
∀x (BelieveIn(x, santaClaus) ⊕ ThinkMadeUp(x, santaClaus))
∀x (BelieveIn(x, santaClaus) → Expect(x, present, christmasMorning))
∀x (ThinkMadeUp(x, santaClaus) → WouldBeSurprisedToSeeIn(x, santaClaus, house))
∀x (Expect(x, present, christmasMorning) → ExcitedFor(x, christmas))
∀x (WouldBeSurprisedToSeeIn(x, santaClaus, house) → ¬LeaveOut(x, cookies))
¬(Expect(marcy, present, christmasMorning) ∧ ExcitedFor(marcy, christmas) ∧ BelieveIn(marcy, santaClaus))

[PREMISE (GK)]:
! [X] : (BelieveIn(X, santaClaus) <~> ThinkMadeUp(X, santaClaus)).
! [X] : (BelieveIn(X, santaClaus) => Expect(X, present, christmasMorning)).
! [X] : (ThinkMadeUp(X, santaClaus) => WouldBeSurprisedToSeeIn(X, santaClaus, house)).
! [X] : (Expect(X, present, christmasMorning) => ExcitedFor(X, christmas)).
! [X] : (WouldBeSurprisedToSeeIn(X, santaClaus, house) => -LeaveOut(X, cookies)).
-(Expect(marcy, present, christmasMorning) & ExcitedFor(marcy, christmas) & BelieveIn(marcy, santaClaus)).

[CONCLUSION]:
Marcy either believes in Santa Claus or doesn't leave cookies out on Christmas Eve.

[CONCLUSION (FOL)]:
BelieveIn(marcy, santaClaus) ⊕ LeaveOut(marcy, cookies)

[CONCLUSION (GK)]:
BelieveIn(marcy, santaClaus) <~> LeaveOut(marcy, cookies).


===

['x']
['x']
[PREMISE]:
People either believe in Santa Claus, or think he is made up.
People who believe in Santa Claus expect to get presents on Christmas morning.
People who think Santa Claus is made up, then they would be surprised to see him in their house.
People who expect presents on Christmas morning are excited for it to be Christmas.
If people would be surprised to see Santa Claus in their house, then they don't leave out cookies on Chrismtas Eve.
Mercy is not someone who expects presents Christmas morning, is excited for Chrismtas, and believes in Santa Claus.

[PREMISE (FOL)]:
∀x (BelieveIn(x, santaClaus) ⊕ ThinkMadeUp(x, santaClaus))
∀x (BelieveIn(x, santaClaus) → Expect(x, present, christmasMorning))
∀x (ThinkMadeUp(x, santaClaus) → WouldBeSurprisedToSeeIn(x, santaClaus, house))
∀x (Expect(x, present, christmasMorning) → ExcitedFor(x, christmas))
∀x (WouldBeSurprisedToSeeIn(x, santaClaus, house) → ¬LeaveOut(x, cookies))
¬(Expect(marcy, present, christmasMorning) ∧ ExcitedFor(marcy, christmas) ∧ BelieveIn(marcy, santaClaus))

[PREMISE (GK)]:
! [X] : (BelieveIn(X, santaClaus) <~> ThinkMadeUp(X, santaClaus)).
! [X] : (BelieveIn(X, santaClaus) => Expect(X, present, christmasMorning)).
! [X] : (ThinkMadeUp(X, santaClaus) => WouldBeSurprisedToSeeIn(X, santaClaus, house)).
! [X] : (Expect(X, present, christmasMorning) => ExcitedFor(X, christmas)).
! [X] : (WouldBeSurprisedToSeeIn(X, santaClaus, house) => -LeaveOut(X, cookies)).
-(Expect(marcy, present, christmasMorning) & ExcitedFor(marcy, christmas) & BelieveIn(marcy, santaClaus)).

[CONCLUSION]:
Marcy is not someone who both leaves out cookies on Chrismtas eve and thinks Santa Claus is made up, or Marcy believes in Santa Claus.

[CONCLUSION (FOL)]:
¬(LeaveOut(marcy, cookies) ∧ ThinkMadeUp(marcy, santaClaus)) ∨ BelieveIn(marcy, santaClaus)

[CONCLUSION (GK)]:
-(LeaveOut(marcy, cookies) & ThinkMadeUp(marcy, santaClaus)) | BelieveIn(marcy, santaClaus).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Indonesia is a country.
In Indonesia, the prosecutor only personally investigates cases of some special crimes.
Corruption is a type of crime.
Once the police complete crime investigations, the evidence is handed to the prosecutor. 
Evidence can be either satisfactory or unsatisfactory.
If the evidence is handed to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.

[PREMISE (FOL)]:
Country(indonesia)
∀x ∃y (In(indonesia) ∧ Prosecutor(x) ∧ SpecialCrime(y) → InvestigatePersonally(x, y))
Crime(corruption)
∀x ∀y ∀z (Crime(y) ∧ PoliceCompleteInvestigation(y) ∧ Prosecutor(x) → Evidence(z) ∧ HandedTo(z, x))
∀x (Evidence(x) ∧ (Satisfactory(x) ⊕ Unsatisfactory(x)))
∀x ∀y (Evidence(y) ∧ Prosecutor(x) ∧ HandedTo(x) ∧ Satisfactory(y) → ProsecuteInAppropriateCourt(x, theOffender))

[PREMISE (GK)]:
Country(indonesia).
! [X] : ? [Y] : (In(indonesia) & Prosecutor(X) & SpecialCrime(Y) => InvestigatePersonally(X, Y)).
Crime(corruption).
! [X] : ! [Y] : ! [Z] : (Crime(Y) & PoliceCompleteInvestigation(Y) & Prosecutor(X) => Evidence(Z) & HandedTo(Z, X)).
! [X] : (Evidence(X) & (Satisfactory(X) <~> Unsatisfactory(X))).
! [X] : ! [Y] : (Evidence(Y) & Prosecutor(X) & HandedTo(X) & Satisfactory(Y) => ProsecuteInAppropriateCourt(X, theOffender)).

[CONCLUSION]:
When the police complete investigations, the prosecutor will prosecute the offender at an appropriate court.

[CONCLUSION (FOL)]:
∀x ∀y (Crime(y) ∧ PoliceCompleteInvestigation(y) ∧ Prosecutor(x) → ProsecuteInAppropriateCourt(x, theOffender))

[CONCLUSION (GK)]:
! [X] : ! [Y] : (Crime(Y) & PoliceCompleteInvestigation(Y) & Prosecutor(X) => ProsecuteInAppropriateCourt(X, theOffender)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Indonesia is a country.
In Indonesia, the prosecutor only personally investigates cases of some special crimes.
Corruption is a type of crime.
Once the police complete crime investigations, the evidence is handed to the prosecutor. 
Evidence can be either satisfactory or unsatisfactory.
If the evidence is handed to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.

[PREMISE (FOL)]:
Country(indonesia)
∀x ∃y (In(indonesia) ∧ Prosecutor(x) ∧ SpecialCrime(y) → InvestigatePersonally(x, y))
Crime(corruption)
∀x ∀y ∀z (Crime(y) ∧ PoliceCompleteInvestigation(y) ∧ Prosecutor(x) → Evidence(z) ∧ HandedTo(z, x))
∀x (Evidence(x) ∧ (Satisfactory(x) ⊕ Unsatisfactory(x)))
∀x ∀y (Evidence(y) ∧ Prosecutor(x) ∧ HandedTo(x) ∧ Satisfactory(y) → ProsecuteInAppropriateCourt(x, theOffender))

[PREMISE (GK)]:
Country(indonesia).
! [X] : ? [Y] : (In(indonesia) & Prosecutor(X) & SpecialCrime(Y) => InvestigatePersonally(X, Y)).
Crime(corruption).
! [X] : ! [Y] : ! [Z] : (Crime(Y) & PoliceCompleteInvestigation(Y) & Prosecutor(X) => Evidence(Z) & HandedTo(Z, X)).
! [X] : (Evidence(X) & (Satisfactory(X) <~> Unsatisfactory(X))).
! [X] : ! [Y] : (Evidence(Y) & Prosecutor(X) & HandedTo(X) & Satisfactory(Y) => ProsecuteInAppropriateCourt(X, theOffender)).

[CONCLUSION]:
In Indonesia, the prosecutor personally investigates cases of corruption.

[CONCLUSION (FOL)]:
∀x (Country(indonesia) ∧ Prosecutor(x) ∧ Crime(corruption) → InvestigatePersonally(x, corruption))

[CONCLUSION (GK)]:
! [X] : (Country(indonesia) & Prosecutor(X) & Crime(corruption) => InvestigatePersonally(X, corruption)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Indonesia is a country.
In Indonesia, the prosecutor only personally investigates cases of some special crimes.
Corruption is a type of crime.
Once the police complete crime investigations, the evidence is handed to the prosecutor. 
Evidence can be either satisfactory or unsatisfactory.
If the evidence is handed to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.

[PREMISE (FOL)]:
Country(indonesia)
∀x ∃y (In(indonesia) ∧ Prosecutor(x) ∧ SpecialCrime(y) → InvestigatePersonally(x, y))
Crime(corruption)
∀x ∀y ∀z (Crime(y) ∧ PoliceCompleteInvestigation(y) ∧ Prosecutor(x) → Evidence(z) ∧ HandedTo(z, x))
∀x (Evidence(x) ∧ (Satisfactory(x) ⊕ Unsatisfactory(x)))
∀x ∀y (Evidence(y) ∧ Prosecutor(x) ∧ HandedTo(x) ∧ Satisfactory(y) → ProsecuteInAppropriateCourt(x, theOffender))

[PREMISE (GK)]:
Country(indonesia).
! [X] : ? [Y] : (In(indonesia) & Prosecutor(X) & SpecialCrime(Y) => InvestigatePersonally(X, Y)).
Crime(corruption).
! [X] : ! [Y] : ! [Z] : (Crime(Y) & PoliceCompleteInvestigation(Y) & Prosecutor(X) => Evidence(Z) & HandedTo(Z, X)).
! [X] : (Evidence(X) & (Satisfactory(X) <~> Unsatisfactory(X))).
! [X] : ! [Y] : (Evidence(Y) & Prosecutor(X) & HandedTo(X) & Satisfactory(Y) => ProsecuteInAppropriateCourt(X, theOffender)).

[CONCLUSION]:
When the police complete investigations, the prosecutor investigates personally.

[CONCLUSION (FOL)]:
∀x ∀y (Crime(y) ∧ PoliceCompleteInvestigation(y) ∧ Prosecutor(x) → InvestigatePersonally(x, y))

[CONCLUSION (GK)]:
! [X] : ! [Y] : (Crime(Y) & PoliceCompleteInvestigation(Y) & Prosecutor(X) => InvestigatePersonally(X, Y)).


===

['x']
['x']
[PREMISE]:
No battery-powered watch is automatic.
All digital watches are battery-powered.
Some mechanical watches are automatic.
All smart watches are digital.
Moonwatch is either a digital watch and an automatic, or it is neither.

[PREMISE (FOL)]:
∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))
∀x (DigitalWatch(x) → BatteryPoweredWatch(x))
∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))
∀x (SmartWatch(x) → DigitalWatch(x))
¬(DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch))

[PREMISE (GK)]:
! [X] : (BatteryPoweredWatch(X) => -AutomaticWatch(X)).
! [X] : (DigitalWatch(X) => BatteryPoweredWatch(X)).
? [X] : (MechanicalWatch(X) & AutomaticWatch(X)).
! [X] : (SmartWatch(X) => DigitalWatch(X)).
-(DigitalWatch(moonwatch) <~> AutomaticWatch(moonwatch)).

[CONCLUSION]:
Moonwatch is a mechanical watch.

[CONCLUSION (FOL)]:
MechanicalWatch(moonWatch)

[CONCLUSION (GK)]:
MechanicalWatch(moonWatch).


===

['x']
['x']
[PREMISE]:
No battery-powered watch is automatic.
All digital watches are battery-powered.
Some mechanical watches are automatic.
All smart watches are digital.
Moonwatch is either a digital watch and an automatic, or it is neither.

[PREMISE (FOL)]:
∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))
∀x (DigitalWatch(x) → BatteryPoweredWatch(x))
∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))
∀x (SmartWatch(x) → DigitalWatch(x))
¬(DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch))

[PREMISE (GK)]:
! [X] : (BatteryPoweredWatch(X) => -AutomaticWatch(X)).
! [X] : (DigitalWatch(X) => BatteryPoweredWatch(X)).
? [X] : (MechanicalWatch(X) & AutomaticWatch(X)).
! [X] : (SmartWatch(X) => DigitalWatch(X)).
-(DigitalWatch(moonwatch) <~> AutomaticWatch(moonwatch)).

[CONCLUSION]:
Moonwatch is a smartwatch and a mechanical watch.

[CONCLUSION (FOL)]:
SmartWatch(moonwatch) ∧ MechanicalWatch(moonwatch)

[CONCLUSION (GK)]:
SmartWatch(moonwatch) & MechanicalWatch(moonwatch).


===

['x']
['x']
[PREMISE]:
No battery-powered watch is automatic.
All digital watches are battery-powered.
Some mechanical watches are automatic.
All smart watches are digital.
Moonwatch is either a digital watch and an automatic, or it is neither.

[PREMISE (FOL)]:
∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))
∀x (DigitalWatch(x) → BatteryPoweredWatch(x))
∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))
∀x (SmartWatch(x) → DigitalWatch(x))
¬(DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch))

[PREMISE (GK)]:
! [X] : (BatteryPoweredWatch(X) => -AutomaticWatch(X)).
! [X] : (DigitalWatch(X) => BatteryPoweredWatch(X)).
? [X] : (MechanicalWatch(X) & AutomaticWatch(X)).
! [X] : (SmartWatch(X) => DigitalWatch(X)).
-(DigitalWatch(moonwatch) <~> AutomaticWatch(moonwatch)).

[CONCLUSION]:
If Moonwatch is a smartwatch and a mechanical watch, then Moonwatch is not a mechanical watch.

[CONCLUSION (FOL)]:
SmartWatch(moonwatch) ∧ MechanicalWatch(moonwatch) → ¬MechanicalWatch(moonwatch)

[CONCLUSION (GK)]:
SmartWatch(moonwatch) & MechanicalWatch(moonwatch) => -MechanicalWatch(moonwatch).


===

['x']
['x']
[PREMISE]:
No battery-powered watch is automatic.
All digital watches are battery-powered.
Some mechanical watches are automatic.
All smart watches are digital.
Moonwatch is either a digital watch and an automatic, or it is neither.

[PREMISE (FOL)]:
∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))
∀x (DigitalWatch(x) → BatteryPoweredWatch(x))
∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))
∀x (SmartWatch(x) → DigitalWatch(x))
¬(DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch))

[PREMISE (GK)]:
! [X] : (BatteryPoweredWatch(X) => -AutomaticWatch(X)).
! [X] : (DigitalWatch(X) => BatteryPoweredWatch(X)).
? [X] : (MechanicalWatch(X) & AutomaticWatch(X)).
! [X] : (SmartWatch(X) => DigitalWatch(X)).
-(DigitalWatch(moonwatch) <~> AutomaticWatch(moonwatch)).

[CONCLUSION]:
If Moonwatch is a mechanical or battery-powered watch, then Moonwatch is not a smartwatch.

[CONCLUSION (FOL)]:
MechanicalWatch(moonwatch)) ∨ BatteryPoweredWatch(moonwatch) → ¬SmartWatch(moonwatch)

[CONCLUSION (GK)]:
MechanicalWatch(moonwatch)) | BatteryPoweredWatch(moonwatch) => -SmartWatch(moonwatch).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If a person can distinguish the taste of different condiments, then they can also use different condiments for cooking.
People who have a talent of cooking can distinguish the taste of different condiments.
Only people with the talent of cooking can make delicious meals.
If the meal is popular at the party, then it is delicious.
John can make meals which are popular at the party.

[PREMISE (FOL)]:
∀x (Person(x) ∧ Can(x, distinguishTheTasteOfDifferentCondiments) → Can(x, useDifferentCondimentsToCook))
∀x (Person(x) ∧ Has(x, talentOfCooking) → Can(x, distinguishTheTasteOfDifferentCondiments))
∀x ∀y (CanMake(x, y) ∧ Meal(y) ∧ Delicious(y) ∧ Person(x) → Has(x, talentOfCooking)) 
∀x ∀y (Meal(y) ∧ PopularAt(y, party) → Delicious(y))
∃x (Person(john) ∧ MakeMeal(john, x) ∧ Meal(x) ∧ PopularAt(x, party))

[PREMISE (GK)]:
! [X] : (Person(X) & Can(X, distinguishTheTasteOfDifferentCondiments) => Can(X, useDifferentCondimentsToCook)).
! [X] : (Person(X) & Has(X, talentOfCooking) => Can(X, distinguishTheTasteOfDifferentCondiments)).
! [X] : ! [Y] : (CanMake(X, Y) & Meal(Y) & Delicious(Y) & Person(X) => Has(X, talentOfCooking)) .
! [X] : ! [Y] : (Meal(Y) & PopularAt(Y, party) => Delicious(Y)).
? [X] : (Person(john) & MakeMeal(john, X) & Meal(X) & PopularAt(X, party)).

[CONCLUSION]:
John cannot use different condiments for cooking.

[CONCLUSION (FOL)]:
¬Can(john, useDifferentCondimentsToCook)

[CONCLUSION (GK)]:
-Can(john, useDifferentCondimentsToCook).


===

['x']
['x']
[PREMISE]:
For a country, if effective monetary policy is possible, it must have successful inflation control and a strong national currency.
A country cannot simultaneously regulate the exchange rate and successfully control inflation.
The introduction of an embargo on foreign trade goods in a country leads to a sharp decrease in exports.
If exports fall sharply, this country's national currency cannot be strong.
Inflation control is required to have a strong national currency. 
There is an embargo on Russian foreign trade goods.

[PREMISE (FOL)]:
∀x (Country(x) ∧ PossibleEffectiveMonetaryPolicy(x) → SuccessfulInflationControl(x) ∧ StongNationalCurrency(x))
¬(∃x (Country(x) ∧ SuccessfulInflationControl(x) ∧ RegulateExchangeRate(x)))
∀x (IntroductionOfOn(x, embargo, foreightTradeGoods) → SharpDecreasesInExport(x))
∀x (SharpDecreasesInExport(x) → ¬StongNationalCurrency(x))
∀x (InflationControl(x) → StongNationalCurrency(x))
IntroductionOfOn(russia, embargo, foreightTradeGoods)

[PREMISE (GK)]:
! [X] : (Country(X) & PossibleEffectiveMonetaryPolicy(X) => SuccessfulInflationControl(X) & StongNationalCurrency(X)).
-(? [X] : (Country(X) & SuccessfulInflationControl(X) & RegulateExchangeRate(X))).
! [X] : (IntroductionOfOn(X, embargo, foreightTradeGoods) => SharpDecreasesInExport(X)).
! [X] : (SharpDecreasesInExport(X) => -StongNationalCurrency(X)).
! [X] : (InflationControl(X) => StongNationalCurrency(X)).
IntroductionOfOn(russia, embargo, foreightTradeGoods).

[CONCLUSION]:
In Russia, an effective monetary policy is possible.

[CONCLUSION (FOL)]:
PossibleEffectiveMonetaryPolicy(russia)

[CONCLUSION (GK)]:
PossibleEffectiveMonetaryPolicy(russia).


===

['x']
['x']
[PREMISE]:
Video Gag is a French television series that airs weekly.
Video Gag airs on the French broadcast channel TF1. 
If viewers send funny videos to the French broadcast channel TF1, then Video Gag airs them weekly.
All videos aired on Video Gag are in French.

[PREMISE (FOL)]:
FrenchTelevision(videoGag) ∧ AirWeekly(videoGag)
AirOn(videoGag, frenchBroadcastChannelTF1)
∀x (Funny(x) ∧ Video(x) ∧ SendIn(viewers, x, frenchBroadcastChannelTF1)  → AirWeekly(x) ) ∧ AirOn(videoGag, x))
∀x (Video(x) ∧ AirOn(videoGag, x) → In(x, french))

[PREMISE (GK)]:
FrenchTelevision(videoGag) & AirWeekly(videoGag).
AirOn(videoGag, frenchBroadcastChannelTF1).
! [X] : (Funny(X) & Video(X) & SendIn(viewers, X, frenchBroadcastChannelTF1)  => AirWeekly(X) ) & AirOn(videoGag, X)).
! [X] : (Video(X) & AirOn(videoGag, X) => In(X, french)).

[CONCLUSION]:
Viewers send funny videos to the French broadcast channel TF1 that are in French.

[CONCLUSION (FOL)]:
∃x (SendIn(viewers, x, frenchBroadcastChannelTF1) ∧ French(x))

[CONCLUSION (GK)]:
? [X] : (SendIn(viewers, X, frenchBroadcastChannelTF1) & French(X)).


===

['x']
['x']
[PREMISE]:
Video Gag is a French television series that airs weekly.
Video Gag airs on the French broadcast channel TF1. 
If viewers send funny videos to the French broadcast channel TF1, then Video Gag airs them weekly.
All videos aired on Video Gag are in French.

[PREMISE (FOL)]:
FrenchTelevision(videoGag) ∧ AirWeekly(videoGag)
AirOn(videoGag, frenchBroadcastChannelTF1)
∀x (Funny(x) ∧ Video(x) ∧ SendIn(viewers, x, frenchBroadcastChannelTF1)  → AirWeekly(x) ) ∧ AirOn(videoGag, x))
∀x (Video(x) ∧ AirOn(videoGag, x) → In(x, french))

[PREMISE (GK)]:
FrenchTelevision(videoGag) & AirWeekly(videoGag).
AirOn(videoGag, frenchBroadcastChannelTF1).
! [X] : (Funny(X) & Video(X) & SendIn(viewers, X, frenchBroadcastChannelTF1)  => AirWeekly(X) ) & AirOn(videoGag, X)).
! [X] : (Video(X) & AirOn(videoGag, X) => In(X, french)).

[CONCLUSION]:
Viewers send funny videos to the French broadcast channel that are in English.

[CONCLUSION (FOL)]:
∃x (SendIn(viewers, x, frenchBroadcastChannelTF1) ∧ English(x))

[CONCLUSION (GK)]:
? [X] : (SendIn(viewers, X, frenchBroadcastChannelTF1) & English(X)).


===

['x']
['x']
[PREMISE]:
All phones are things.
All cell phones are phones. 
All iPhones are cell phones. 
All employees are wage earners.
All wage earners are human. 
Jack is either an employee or a wage earner.
Jack is either a human or a phone.

[PREMISE (FOL)]:
∀x (Phone(x) → Thing(x))
∀x (Cellphone(x) → Phone(x))
∀x (Iphone(x) → Cellphone(x))
∀x (Employee(x) → WageEarner(x))
∀x (WageEarner(x) → Human(x))
Employee(jack) ⊕ WageEarner(jack) 
Human(jack) ⊕ Phone(jack)

[PREMISE (GK)]:
! [X] : (Phone(X) => Thing(X)).
! [X] : (Cellphone(X) => Phone(X)).
! [X] : (Iphone(X) => Cellphone(X)).
! [X] : (Employee(X) => WageEarner(X)).
! [X] : (WageEarner(X) => Human(X)).
Employee(jack) <~> WageEarner(jack) .
Human(jack) <~> Phone(jack).

[CONCLUSION]:
Jack is a thing.

[CONCLUSION (FOL)]:
Thing(jack)

[CONCLUSION (GK)]:
Thing(jack).


===

['x']
['x']
[PREMISE]:
All phones are things.
All cell phones are phones. 
All iPhones are cell phones. 
All employees are wage earners.
All wage earners are human. 
Jack is either an employee or a wage earner.
Jack is either a human or a phone.

[PREMISE (FOL)]:
∀x (Phone(x) → Thing(x))
∀x (Cellphone(x) → Phone(x))
∀x (Iphone(x) → Cellphone(x))
∀x (Employee(x) → WageEarner(x))
∀x (WageEarner(x) → Human(x))
Employee(jack) ⊕ WageEarner(jack) 
Human(jack) ⊕ Phone(jack)

[PREMISE (GK)]:
! [X] : (Phone(X) => Thing(X)).
! [X] : (Cellphone(X) => Phone(X)).
! [X] : (Iphone(X) => Cellphone(X)).
! [X] : (Employee(X) => WageEarner(X)).
! [X] : (WageEarner(X) => Human(X)).
Employee(jack) <~> WageEarner(jack) .
Human(jack) <~> Phone(jack).

[CONCLUSION]:
Jack is not a thing.

[CONCLUSION (FOL)]:
¬Thing(jack)

[CONCLUSION (GK)]:
-Thing(jack).


===

['x']
['x']
[PREMISE]:
All phones are things.
All cell phones are phones. 
All iPhones are cell phones. 
All employees are wage earners.
All wage earners are human. 
Jack is either an employee or a wage earner.
Jack is either a human or a phone.

[PREMISE (FOL)]:
∀x (Phone(x) → Thing(x))
∀x (Cellphone(x) → Phone(x))
∀x (Iphone(x) → Cellphone(x))
∀x (Employee(x) → WageEarner(x))
∀x (WageEarner(x) → Human(x))
Employee(jack) ⊕ WageEarner(jack) 
Human(jack) ⊕ Phone(jack)

[PREMISE (GK)]:
! [X] : (Phone(X) => Thing(X)).
! [X] : (Cellphone(X) => Phone(X)).
! [X] : (Iphone(X) => Cellphone(X)).
! [X] : (Employee(X) => WageEarner(X)).
! [X] : (WageEarner(X) => Human(X)).
Employee(jack) <~> WageEarner(jack) .
Human(jack) <~> Phone(jack).

[CONCLUSION]:
Jack is a thing and an iPhone.

[CONCLUSION (FOL)]:
Thing(jack) ∧ Iphone(jack)

[CONCLUSION (GK)]:
Thing(jack) & Iphone(jack).


===

['x']
['x']
[PREMISE]:
All phones are things.
All cell phones are phones. 
All iPhones are cell phones. 
All employees are wage earners.
All wage earners are human. 
Jack is either an employee or a wage earner.
Jack is either a human or a phone.

[PREMISE (FOL)]:
∀x (Phone(x) → Thing(x))
∀x (Cellphone(x) → Phone(x))
∀x (Iphone(x) → Cellphone(x))
∀x (Employee(x) → WageEarner(x))
∀x (WageEarner(x) → Human(x))
Employee(jack) ⊕ WageEarner(jack) 
Human(jack) ⊕ Phone(jack)

[PREMISE (GK)]:
! [X] : (Phone(X) => Thing(X)).
! [X] : (Cellphone(X) => Phone(X)).
! [X] : (Iphone(X) => Cellphone(X)).
! [X] : (Employee(X) => WageEarner(X)).
! [X] : (WageEarner(X) => Human(X)).
Employee(jack) <~> WageEarner(jack) .
Human(jack) <~> Phone(jack).

[CONCLUSION]:
Jack is not both a thing and an iPhone.

[CONCLUSION (FOL)]:
¬(Thing(jack) ∧ Iphone(jack))

[CONCLUSION (GK)]:
-(Thing(jack) & Iphone(jack)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All iPhones are electronic.
Some phones are iPhones.

[PREMISE (FOL)]:
∀x (IPhone(x) → Electronic(x))
∃x ∃y (Phone(x) ∧ Phone(y) ∧ IPhone(x) ∧ IPhone(y) ∧ ¬(x=y))

[PREMISE (GK)]:
! [X] : (IPhone(X) => Electronic(X)).
? [X] : ? [Y] : (Phone(X) & Phone(Y) & IPhone(X) & IPhone(Y) & -(X=Y)).

[CONCLUSION]:
No phones are electronic.

[CONCLUSION (FOL)]:
∀x (Phone(x) → ¬Electronic(x))

[CONCLUSION (GK)]:
! [X] : (Phone(X) => -Electronic(X)).


===

[]
['x']
[PREMISE]:
The Metropolitan Museum of Art is a museum in NYC.
Whitney Museum of American Art is a museum in NYC.
The Museum of Modern Art (MoMA) is a museum in NYC. 
The Metropolitan Museum of Art includes Byzantine and Islamic Art. 
Whitney Museum of American Art includes American art.

[PREMISE (FOL)]:
Museum(metropolitanMuseumOfArt) ∧ In(metropolitanMuseumOfArt, nYC)
Museum(whitneyMuseumOfAmericanArt) ∧ In(metropolitanMuseumOfArt, nYC)
Museum(museumOfModernArt) ∧ In(museumOfModernArt, nYC)
Include(metropolitanMuseumOfArt, byzantineArt) ∧ Include(metropolitanMuseumOfArt, islamicArt)
Include(whitneyMuseumOfAmericanArt, americanArt)

[PREMISE (GK)]:
Museum(metropolitanMuseumOfArt) & In(metropolitanMuseumOfArt, nYC).
Museum(whitneyMuseumOfAmericanArt) & In(metropolitanMuseumOfArt, nYC).
Museum(museumOfModernArt) & In(museumOfModernArt, nYC).
Include(metropolitanMuseumOfArt, byzantineArt) & Include(metropolitanMuseumOfArt, islamicArt).
Include(whitneyMuseumOfAmericanArt, americanArt).

[CONCLUSION]:
A museum in NYC includes Byzantine and Islamic Art.

[CONCLUSION (FOL)]:
∃x (Museum(x) ∧ In(x, nYC) ∧ Include(x, byzantineArt) ∧ Include(x, islamicArt))

[CONCLUSION (GK)]:
? [X] : (Museum(X) & In(X, nYC) & Include(X, byzantineArt) & Include(X, islamicArt)).


===

[]
['x']
[PREMISE]:
The Metropolitan Museum of Art is a museum in NYC.
Whitney Museum of American Art is a museum in NYC.
The Museum of Modern Art (MoMA) is a museum in NYC. 
The Metropolitan Museum of Art includes Byzantine and Islamic Art. 
Whitney Museum of American Art includes American art.

[PREMISE (FOL)]:
Museum(metropolitanMuseumOfArt) ∧ In(metropolitanMuseumOfArt, nYC)
Museum(whitneyMuseumOfAmericanArt) ∧ In(metropolitanMuseumOfArt, nYC)
Museum(museumOfModernArt) ∧ In(museumOfModernArt, nYC)
Include(metropolitanMuseumOfArt, byzantineArt) ∧ Include(metropolitanMuseumOfArt, islamicArt)
Include(whitneyMuseumOfAmericanArt, americanArt)

[PREMISE (GK)]:
Museum(metropolitanMuseumOfArt) & In(metropolitanMuseumOfArt, nYC).
Museum(whitneyMuseumOfAmericanArt) & In(metropolitanMuseumOfArt, nYC).
Museum(museumOfModernArt) & In(museumOfModernArt, nYC).
Include(metropolitanMuseumOfArt, byzantineArt) & Include(metropolitanMuseumOfArt, islamicArt).
Include(whitneyMuseumOfAmericanArt, americanArt).

[CONCLUSION]:
A museum in NYC includes American art.

[CONCLUSION (FOL)]:
∃x (Museum(x) ∧ In(x, nYC) ∧ Include(x, americanArt))

[CONCLUSION (GK)]:
? [X] : (Museum(X) & In(X, nYC) & Include(X, americanArt)).


===

[]
['x']
[PREMISE]:
The Metropolitan Museum of Art is a museum in NYC.
Whitney Museum of American Art is a museum in NYC.
The Museum of Modern Art (MoMA) is a museum in NYC. 
The Metropolitan Museum of Art includes Byzantine and Islamic Art. 
Whitney Museum of American Art includes American art.

[PREMISE (FOL)]:
Museum(metropolitanMuseumOfArt) ∧ In(metropolitanMuseumOfArt, nYC)
Museum(whitneyMuseumOfAmericanArt) ∧ In(metropolitanMuseumOfArt, nYC)
Museum(museumOfModernArt) ∧ In(museumOfModernArt, nYC)
Include(metropolitanMuseumOfArt, byzantineArt) ∧ Include(metropolitanMuseumOfArt, islamicArt)
Include(whitneyMuseumOfAmericanArt, americanArt)

[PREMISE (GK)]:
Museum(metropolitanMuseumOfArt) & In(metropolitanMuseumOfArt, nYC).
Museum(whitneyMuseumOfAmericanArt) & In(metropolitanMuseumOfArt, nYC).
Museum(museumOfModernArt) & In(museumOfModernArt, nYC).
Include(metropolitanMuseumOfArt, byzantineArt) & Include(metropolitanMuseumOfArt, islamicArt).
Include(whitneyMuseumOfAmericanArt, americanArt).

[CONCLUSION]:
A museum in NYC includes Greek art.

[CONCLUSION (FOL)]:
∃x (Museum(x) ∧ In(x, nYC) ∧ Include(x, greekArt))

[CONCLUSION (GK)]:
? [X] : (Museum(X) & In(X, nYC) & Include(X, greekArt)).


===

['x']
['x']
[PREMISE]:
There's a person in Benji's family who likes eating cheese or is a francophile.
There is no francophile in Benji's family whose favorite country is Spain.
There is a person in Benji's family who likes eating cheese or whose favorite country is Spain.
Fabien is in Benji's family and  does not both study Spanish and also like eating cheese.
Fabien studies Spanish.

[PREMISE (FOL)]:
∃x (InBenjiSFamily(x) → (LikeEating(x, cheese) ∨ Francophile(x)))
∀x ((InBenjiSFamily(x) ∧ Francophile(x)) → ¬Favor(x, spain))
∃x (InBenjiSFamily(x) ∧ (Favor(x, spain) ∨ LikeEating(x, cheese)))
InBenjiSFamily(fabien) ∧ (¬(LikeEating(fabien, cheese) ∧ Study(fabien, spanish)))
Study(fabien, spanish)

[PREMISE (GK)]:
? [X] : (InBenjiSFamily(X) => (LikeEating(X, cheese) | Francophile(X))).
! [X] : ((InBenjiSFamily(X) & Francophile(X)) => -Favor(X, spain)).
? [X] : (InBenjiSFamily(X) & (Favor(X, spain) | LikeEating(X, cheese))).
InBenjiSFamily(fabien) & (-(LikeEating(fabien, cheese) & Study(fabien, spanish))).
Study(fabien, spanish).

[CONCLUSION]:
Fabien is a person who likes eating cheese.

[CONCLUSION (FOL)]:
LikeEating(fabien, cheese)

[CONCLUSION (GK)]:
LikeEating(fabien, cheese).


===

['x']
['x']
[PREMISE]:
There's a person in Benji's family who likes eating cheese or is a francophile.
There is no francophile in Benji's family whose favorite country is Spain.
There is a person in Benji's family who likes eating cheese or whose favorite country is Spain.
Fabien is in Benji's family and  does not both study Spanish and also like eating cheese.
Fabien studies Spanish.

[PREMISE (FOL)]:
∃x (InBenjiSFamily(x) → (LikeEating(x, cheese) ∨ Francophile(x)))
∀x ((InBenjiSFamily(x) ∧ Francophile(x)) → ¬Favor(x, spain))
∃x (InBenjiSFamily(x) ∧ (Favor(x, spain) ∨ LikeEating(x, cheese)))
InBenjiSFamily(fabien) ∧ (¬(LikeEating(fabien, cheese) ∧ Study(fabien, spanish)))
Study(fabien, spanish)

[PREMISE (GK)]:
? [X] : (InBenjiSFamily(X) => (LikeEating(X, cheese) | Francophile(X))).
! [X] : ((InBenjiSFamily(X) & Francophile(X)) => -Favor(X, spain)).
? [X] : (InBenjiSFamily(X) & (Favor(X, spain) | LikeEating(X, cheese))).
InBenjiSFamily(fabien) & (-(LikeEating(fabien, cheese) & Study(fabien, spanish))).
Study(fabien, spanish).

[CONCLUSION]:
If Fabien is either a person who likes eating cheese or a francophile, then Fabien is neither a person who studies Spanish nor a person who is a francophile.

[CONCLUSION (FOL)]:
(LikeEating(fabien, cheese) ⊕ Francophile(fabien)) → (¬(Study(fabien, spanish) ∨ Francophile(fabien)))

[CONCLUSION (GK)]:
(LikeEating(fabien, cheese) <~> Francophile(fabien)) => (-(Study(fabien, spanish) | Francophile(fabien))).


===

['x']
['x']
[PREMISE]:
There's a person in Benji's family who likes eating cheese or is a francophile.
There is no francophile in Benji's family whose favorite country is Spain.
There is a person in Benji's family who likes eating cheese or whose favorite country is Spain.
Fabien is in Benji's family and  does not both study Spanish and also like eating cheese.
Fabien studies Spanish.

[PREMISE (FOL)]:
∃x (InBenjiSFamily(x) → (LikeEating(x, cheese) ∨ Francophile(x)))
∀x ((InBenjiSFamily(x) ∧ Francophile(x)) → ¬Favor(x, spain))
∃x (InBenjiSFamily(x) ∧ (Favor(x, spain) ∨ LikeEating(x, cheese)))
InBenjiSFamily(fabien) ∧ (¬(LikeEating(fabien, cheese) ∧ Study(fabien, spanish)))
Study(fabien, spanish)

[PREMISE (GK)]:
? [X] : (InBenjiSFamily(X) => (LikeEating(X, cheese) | Francophile(X))).
! [X] : ((InBenjiSFamily(X) & Francophile(X)) => -Favor(X, spain)).
? [X] : (InBenjiSFamily(X) & (Favor(X, spain) | LikeEating(X, cheese))).
InBenjiSFamily(fabien) & (-(LikeEating(fabien, cheese) & Study(fabien, spanish))).
Study(fabien, spanish).

[CONCLUSION]:
If Fabien is a person who likes Spain as their favorite country or is a francophile, then Fabien is either a person who studies Spanish or a person who likes Spain as their favorite country.

[CONCLUSION (FOL)]:
(Favor(fabien, spain) ∨ Francophile(fabien)) → (Study(fabien, spanish) ⊕ Favor(fabien, spain))

[CONCLUSION (GK)]:
(Favor(fabien, spain) | Francophile(fabien)) => (Study(fabien, spanish) <~> Favor(fabien, spain)).


===

['x']
['x']
[PREMISE]:
Gasteren is a village located in the province of Drenthe.
Drenthe is a Dutch province. 
No cities are villages.
The population of a village in Drenthe was 155 people.

[PREMISE (FOL)]:
Village(gasteren) ∧ Province(drenthe) ∧ In(gasteren, drenthe)
Province(drenthe) ∧ In(drenthe, netherlands)
∀x (City(x) → ¬Village(x))
∃x (Population(x, num155) ∧ Village(x) ∧ In(x, drenthe))

[PREMISE (GK)]:
Village(gasteren) & Province(drenthe) & In(gasteren, drenthe).
Province(drenthe) & In(drenthe, netherlands).
! [X] : (City(X) => -Village(X)).
? [X] : (Population(X, num155) & Village(X) & In(X, drenthe)).

[CONCLUSION]:
Gasteren is a Dutch village.

[CONCLUSION (FOL)]:
Village(gasteren) ∧ In(gasteren, netherlands)

[CONCLUSION (GK)]:
Village(gasteren) & In(gasteren, netherlands).


===

['x']
['x']
[PREMISE]:
Gasteren is a village located in the province of Drenthe.
Drenthe is a Dutch province. 
No cities are villages.
The population of a village in Drenthe was 155 people.

[PREMISE (FOL)]:
Village(gasteren) ∧ Province(drenthe) ∧ In(gasteren, drenthe)
Province(drenthe) ∧ In(drenthe, netherlands)
∀x (City(x) → ¬Village(x))
∃x (Population(x, num155) ∧ Village(x) ∧ In(x, drenthe))

[PREMISE (GK)]:
Village(gasteren) & Province(drenthe) & In(gasteren, drenthe).
Province(drenthe) & In(drenthe, netherlands).
! [X] : (City(X) => -Village(X)).
? [X] : (Population(X, num155) & Village(X) & In(X, drenthe)).

[CONCLUSION]:
Gasteren is a city.

[CONCLUSION (FOL)]:
City(gasteren)

[CONCLUSION (GK)]:
City(gasteren).


===

['x']
['x']
[PREMISE]:
Gasteren is a village located in the province of Drenthe.
Drenthe is a Dutch province. 
No cities are villages.
The population of a village in Drenthe was 155 people.

[PREMISE (FOL)]:
Village(gasteren) ∧ Province(drenthe) ∧ In(gasteren, drenthe)
Province(drenthe) ∧ In(drenthe, netherlands)
∀x (City(x) → ¬Village(x))
∃x (Population(x, num155) ∧ Village(x) ∧ In(x, drenthe))

[PREMISE (GK)]:
Village(gasteren) & Province(drenthe) & In(gasteren, drenthe).
Province(drenthe) & In(drenthe, netherlands).
! [X] : (City(X) => -Village(X)).
? [X] : (Population(X, num155) & Village(X) & In(X, drenthe)).

[CONCLUSION]:
Gasteren has a population of 155.

[CONCLUSION (FOL)]:
Population(gasteren, num155)

[CONCLUSION (GK)]:
Population(gasteren, num155).


===

['x']
['x']
[PREMISE]:
The only types of mammals that lay eggs are either platypuses or echidnas.
Platypuses are not hyrax.
Echidnas are not hyrax.
No mammals are invertebrates.
All animals are either vertebrates or invertebrates.
Mammals are animals.
Hyraxes are mammals.
Grebes lay eggs.
Grebes are not platypuses and also not echidnas.

[PREMISE (FOL)]:
∀x ((Mammal(x) ∧ LayEgg(x)) → (Platypus(x) ⊕ Echidna(x)))
∀x (Platypuses(x) → ¬Hyrax(x))
∀x (Echidnas(x) → ¬Hyrax(x))
∀x (Mammal(x) → ¬Invertebrate(x))
∀x (Animal(x) → (Vertebrate(x) ∨ Invertebrate(x)))
∀x (Mammal(x) → Animal(x))
∀x (Hyrax(x) → Mammal(x))
∀x (Grebes(x) → LayEgg(x))
∀x (Grebes(x) → (¬Platypuses(x) ∧ ¬Echidnas(x)))

[PREMISE (GK)]:
! [X] : ((Mammal(X) & LayEgg(X)) => (Platypus(X) <~> Echidna(X))).
! [X] : (Platypuses(X) => -Hyrax(X)).
! [X] : (Echidnas(X) => -Hyrax(X)).
! [X] : (Mammal(X) => -Invertebrate(X)).
! [X] : (Animal(X) => (Vertebrate(X) | Invertebrate(X))).
! [X] : (Mammal(X) => Animal(X)).
! [X] : (Hyrax(X) => Mammal(X)).
! [X] : (Grebes(X) => LayEgg(X)).
! [X] : (Grebes(X) => (-Platypuses(X) & -Echidnas(X))).

[CONCLUSION]:
Hyraxes lay eggs.

[CONCLUSION (FOL)]:
∃x (Hyrax(x) ∧ LayEgg(x))

[CONCLUSION (GK)]:
? [X] : (Hyrax(X) & LayEgg(X)).


===

['x']
['x']
[PREMISE]:
The only types of mammals that lay eggs are either platypuses or echidnas.
Platypuses are not hyrax.
Echidnas are not hyrax.
No mammals are invertebrates.
All animals are either vertebrates or invertebrates.
Mammals are animals.
Hyraxes are mammals.
Grebes lay eggs.
Grebes are not platypuses and also not echidnas.

[PREMISE (FOL)]:
∀x ((Mammal(x) ∧ LayEgg(x)) → (Platypus(x) ⊕ Echidna(x)))
∀x (Platypuses(x) → ¬Hyrax(x))
∀x (Echidnas(x) → ¬Hyrax(x))
∀x (Mammal(x) → ¬Invertebrate(x))
∀x (Animal(x) → (Vertebrate(x) ∨ Invertebrate(x)))
∀x (Mammal(x) → Animal(x))
∀x (Hyrax(x) → Mammal(x))
∀x (Grebes(x) → LayEgg(x))
∀x (Grebes(x) → (¬Platypuses(x) ∧ ¬Echidnas(x)))

[PREMISE (GK)]:
! [X] : ((Mammal(X) & LayEgg(X)) => (Platypus(X) <~> Echidna(X))).
! [X] : (Platypuses(X) => -Hyrax(X)).
! [X] : (Echidnas(X) => -Hyrax(X)).
! [X] : (Mammal(X) => -Invertebrate(X)).
! [X] : (Animal(X) => (Vertebrate(X) | Invertebrate(X))).
! [X] : (Mammal(X) => Animal(X)).
! [X] : (Hyrax(X) => Mammal(X)).
! [X] : (Grebes(X) => LayEgg(X)).
! [X] : (Grebes(X) => (-Platypuses(X) & -Echidnas(X))).

[CONCLUSION]:
Grebes are not mammals.

[CONCLUSION (FOL)]:
∀x (Grebes(x) → ¬Mammal(x))

[CONCLUSION (GK)]:
! [X] : (Grebes(X) => -Mammal(X)).


===

['x']
['x']
[PREMISE]:
The only types of mammals that lay eggs are either platypuses or echidnas.
Platypuses are not hyrax.
Echidnas are not hyrax.
No mammals are invertebrates.
All animals are either vertebrates or invertebrates.
Mammals are animals.
Hyraxes are mammals.
Grebes lay eggs.
Grebes are not platypuses and also not echidnas.

[PREMISE (FOL)]:
∀x ((Mammal(x) ∧ LayEgg(x)) → (Platypus(x) ⊕ Echidna(x)))
∀x (Platypuses(x) → ¬Hyrax(x))
∀x (Echidnas(x) → ¬Hyrax(x))
∀x (Mammal(x) → ¬Invertebrate(x))
∀x (Animal(x) → (Vertebrate(x) ∨ Invertebrate(x)))
∀x (Mammal(x) → Animal(x))
∀x (Hyrax(x) → Mammal(x))
∀x (Grebes(x) → LayEgg(x))
∀x (Grebes(x) → (¬Platypuses(x) ∧ ¬Echidnas(x)))

[PREMISE (GK)]:
! [X] : ((Mammal(X) & LayEgg(X)) => (Platypus(X) <~> Echidna(X))).
! [X] : (Platypuses(X) => -Hyrax(X)).
! [X] : (Echidnas(X) => -Hyrax(X)).
! [X] : (Mammal(X) => -Invertebrate(X)).
! [X] : (Animal(X) => (Vertebrate(X) | Invertebrate(X))).
! [X] : (Mammal(X) => Animal(X)).
! [X] : (Hyrax(X) => Mammal(X)).
! [X] : (Grebes(X) => LayEgg(X)).
! [X] : (Grebes(X) => (-Platypuses(X) & -Echidnas(X))).

[CONCLUSION]:
Platypuses are vertebrates.

[CONCLUSION (FOL)]:
∀x (Platypuses(x) → Vertebrate(x))

[CONCLUSION (GK)]:
! [X] : (Platypuses(X) => Vertebrate(X)).


===

['x']
['x']
[PREMISE]:
Bobby Flynn is a singer-songwriter. 
Bobby Flynn finished 7th while competing on Australian Idol.
Australian Idol competitors are Australian citizens.
The Omega Three band made a nationwide tour in 2007.
Bobby Flynn is a member of The Omega Three band.
Bobby Flynn was born in Queensland.

[PREMISE (FOL)]:
Singer(bobbyFlynn) ∧ SongWriter(bobbyFlynn)
FinishesIn(bobbyFlynn, number7) ∧ CompetesOnAustralianIdol(bobbyFlynn)
∀x (CompetesOnAustralianIdol(x) → AustralianCitizen(x))
NationWideTourIn(theOmegaThreeBand, year2007) 
Member(bobbyFlynn, theOmegaThreeBand)
BornIn(bobbyFlynn, queensland)

[PREMISE (GK)]:
Singer(bobbyFlynn) & SongWriter(bobbyFlynn).
FinishesIn(bobbyFlynn, number7) & CompetesOnAustralianIdol(bobbyFlynn).
! [X] : (CompetesOnAustralianIdol(X) => AustralianCitizen(X)).
NationWideTourIn(theOmegaThreeBand, year2007) .
Member(bobbyFlynn, theOmegaThreeBand).
BornIn(bobbyFlynn, queensland).

[CONCLUSION]:
Bobby Flynn is an Australian citizen.

[CONCLUSION (FOL)]:
AustralianCitizen(bobbyFlynn)

[CONCLUSION (GK)]:
AustralianCitizen(bobbyFlynn).


===

['x']
['x']
[PREMISE]:
Bobby Flynn is a singer-songwriter. 
Bobby Flynn finished 7th while competing on Australian Idol.
Australian Idol competitors are Australian citizens.
The Omega Three band made a nationwide tour in 2007.
Bobby Flynn is a member of The Omega Three band.
Bobby Flynn was born in Queensland.

[PREMISE (FOL)]:
Singer(bobbyFlynn) ∧ SongWriter(bobbyFlynn)
FinishesIn(bobbyFlynn, number7) ∧ CompetesOnAustralianIdol(bobbyFlynn)
∀x (CompetesOnAustralianIdol(x) → AustralianCitizen(x))
NationWideTourIn(theOmegaThreeBand, year2007) 
Member(bobbyFlynn, theOmegaThreeBand)
BornIn(bobbyFlynn, queensland)

[PREMISE (GK)]:
Singer(bobbyFlynn) & SongWriter(bobbyFlynn).
FinishesIn(bobbyFlynn, number7) & CompetesOnAustralianIdol(bobbyFlynn).
! [X] : (CompetesOnAustralianIdol(X) => AustralianCitizen(X)).
NationWideTourIn(theOmegaThreeBand, year2007) .
Member(bobbyFlynn, theOmegaThreeBand).
BornIn(bobbyFlynn, queensland).

[CONCLUSION]:
Bobby Flynn flew to America in 2007.

[CONCLUSION (FOL)]:
FlewToIn(bobbyFlynn, america, year2007)

[CONCLUSION (GK)]:
FlewToIn(bobbyFlynn, america, year2007).


===

['x']
['x']
[PREMISE]:
Bobby Flynn is a singer-songwriter. 
Bobby Flynn finished 7th while competing on Australian Idol.
Australian Idol competitors are Australian citizens.
The Omega Three band made a nationwide tour in 2007.
Bobby Flynn is a member of The Omega Three band.
Bobby Flynn was born in Queensland.

[PREMISE (FOL)]:
Singer(bobbyFlynn) ∧ SongWriter(bobbyFlynn)
FinishesIn(bobbyFlynn, number7) ∧ CompetesOnAustralianIdol(bobbyFlynn)
∀x (CompetesOnAustralianIdol(x) → AustralianCitizen(x))
NationWideTourIn(theOmegaThreeBand, year2007) 
Member(bobbyFlynn, theOmegaThreeBand)
BornIn(bobbyFlynn, queensland)

[PREMISE (GK)]:
Singer(bobbyFlynn) & SongWriter(bobbyFlynn).
FinishesIn(bobbyFlynn, number7) & CompetesOnAustralianIdol(bobbyFlynn).
! [X] : (CompetesOnAustralianIdol(X) => AustralianCitizen(X)).
NationWideTourIn(theOmegaThreeBand, year2007) .
Member(bobbyFlynn, theOmegaThreeBand).
BornIn(bobbyFlynn, queensland).

[CONCLUSION]:
Bobby Flynn was born in Queens.

[CONCLUSION (FOL)]:
BornIn(bobbyFlynn, queens)

[CONCLUSION (GK)]:
BornIn(bobbyFlynn, queens).


===

['x']
['x']
[PREMISE]:
All proteins are organic compounds.
All enzymes are organic compounds.

[PREMISE (FOL)]:
∀x (Protein(x) → OrganicCompound(x))
∀x (Enzyme(x) → OrganicCompound(x))

[PREMISE (GK)]:
! [X] : (Protein(X) => OrganicCompound(X)).
! [X] : (Enzyme(X) => OrganicCompound(X)).

[CONCLUSION]:
All enzymes are proteins.

[CONCLUSION (FOL)]:
∀x (Enzyme(x) → Protein(x))

[CONCLUSION (GK)]:
! [X] : (Enzyme(X) => Protein(X)).


===

[]
['x', 'y']
[PREMISE]:
Maggie Friedman is an American screenwriter and producer.
Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.
Witches of East End is a fantasy-drama series.
Maggie Friedman produced and developed Eastwick.
Eastwick is a series by ABC.

[PREMISE (FOL)]:
American(maggieFriedman) ∧ Screenwriter(maggieFriedman) ∧ Producer(maggieFriedman)
ShowRunnerOf(maggieFriedman, witchesOfEastEnd) ∧ ExecutiveProducerOf(maggieFriedman, witchesOfEastEnd) ∧ LifetimeTelevisionSeries(maggieFriedman)
FantasyDrama(witchesOfEastEnd) ∧ Series(witchesOfEastEnd)
Produces(maggieFriedman, eastwick) ∧ Develops(maggieFriedman, eastwick)
Series(eastwick) ∧ AiredOn(eastwick, aBC)

[PREMISE (GK)]:
American(maggieFriedman) & Screenwriter(maggieFriedman) & Producer(maggieFriedman).
ShowRunnerOf(maggieFriedman, witchesOfEastEnd) & ExecutiveProducerOf(maggieFriedman, witchesOfEastEnd) & LifetimeTelevisionSeries(maggieFriedman).
FantasyDrama(witchesOfEastEnd) & Series(witchesOfEastEnd).
Produces(maggieFriedman, eastwick) & Develops(maggieFriedman, eastwick).
Series(eastwick) & AiredOn(eastwick, aBC).

[CONCLUSION]:
There is a series by ABC that was developed by the showrunner of Witches of East End.

[CONCLUSION (FOL)]:
∃x ∃y (Series(x) ∧ AiredOn(x, aBC) ∧ Develops(y, x) ∧ ShowRunnerOf(y, witchesOfEastEnd))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Series(X) & AiredOn(X, aBC) & Develops(Y, X) & ShowRunnerOf(Y, witchesOfEastEnd)).


===

[]
['x', 'y']
[PREMISE]:
Maggie Friedman is an American screenwriter and producer.
Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.
Witches of East End is a fantasy-drama series.
Maggie Friedman produced and developed Eastwick.
Eastwick is a series by ABC.

[PREMISE (FOL)]:
American(maggieFriedman) ∧ Screenwriter(maggieFriedman) ∧ Producer(maggieFriedman)
ShowRunnerOf(maggieFriedman, witchesOfEastEnd) ∧ ExecutiveProducerOf(maggieFriedman, witchesOfEastEnd) ∧ LifetimeTelevisionSeries(maggieFriedman)
FantasyDrama(witchesOfEastEnd) ∧ Series(witchesOfEastEnd)
Produces(maggieFriedman, eastwick) ∧ Develops(maggieFriedman, eastwick)
Series(eastwick) ∧ AiredOn(eastwick, aBC)

[PREMISE (GK)]:
American(maggieFriedman) & Screenwriter(maggieFriedman) & Producer(maggieFriedman).
ShowRunnerOf(maggieFriedman, witchesOfEastEnd) & ExecutiveProducerOf(maggieFriedman, witchesOfEastEnd) & LifetimeTelevisionSeries(maggieFriedman).
FantasyDrama(witchesOfEastEnd) & Series(witchesOfEastEnd).
Produces(maggieFriedman, eastwick) & Develops(maggieFriedman, eastwick).
Series(eastwick) & AiredOn(eastwick, aBC).

[CONCLUSION]:
No series by ABC was developed by the showrunner of Witches of East End.

[CONCLUSION (FOL)]:
∀x (Series(x) ∧ AiredOn(x, aBC) ∧ ∃y(ShowRunnerOf(y, witchesOfEastEnd)) → ¬Develops(y, x))

[CONCLUSION (GK)]:
! [X] : (Series(X) & AiredOn(X, aBC) & ? [Y] :(ShowRunnerOf(Y, witchesOfEastEnd)) => -Develops(Y, X)).


===

[]
[]
[PREMISE]:
Maggie Friedman is an American screenwriter and producer.
Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.
Witches of East End is a fantasy-drama series.
Maggie Friedman produced and developed Eastwick.
Eastwick is a series by ABC.

[PREMISE (FOL)]:
American(maggieFriedman) ∧ Screenwriter(maggieFriedman) ∧ Producer(maggieFriedman)
ShowRunnerOf(maggieFriedman, witchesOfEastEnd) ∧ ExecutiveProducerOf(maggieFriedman, witchesOfEastEnd) ∧ LifetimeTelevisionSeries(maggieFriedman)
FantasyDrama(witchesOfEastEnd) ∧ Series(witchesOfEastEnd)
Produces(maggieFriedman, eastwick) ∧ Develops(maggieFriedman, eastwick)
Series(eastwick) ∧ AiredOn(eastwick, aBC)

[PREMISE (GK)]:
American(maggieFriedman) & Screenwriter(maggieFriedman) & Producer(maggieFriedman).
ShowRunnerOf(maggieFriedman, witchesOfEastEnd) & ExecutiveProducerOf(maggieFriedman, witchesOfEastEnd) & LifetimeTelevisionSeries(maggieFriedman).
FantasyDrama(witchesOfEastEnd) & Series(witchesOfEastEnd).
Produces(maggieFriedman, eastwick) & Develops(maggieFriedman, eastwick).
Series(eastwick) & AiredOn(eastwick, aBC).

[CONCLUSION]:
Maggie Friedman developed Witches of East End.

[CONCLUSION (FOL)]:
Develops(maggieFriedman, witchesOfEastEnd)

[CONCLUSION (GK)]:
Develops(maggieFriedman, witchesOfEastEnd).


===

['x', 'z']
['x', 'z']
[PREMISE]:
Evangelos Eleftheriou is a Greek electrical engineer.
Evangelos Eleftheriou worked for IBM in Zurich.
If a company has employees working for them somewhere, then they have an office there.
IBM is a company.

[PREMISE (FOL)]:
Greek(evangelosEleftheriou) ∧ ElectricalEngineer(evangelosEleftheriou)
WorkForIn(evangelosEleftheriou, iBM, zurich)
∀x ∀x ∀z (Company(x) ∧ WorkForIn(y, x, z) → HaveOfficeIn(x, z))
Company(ibm)

[PREMISE (GK)]:
Greek(evangelosEleftheriou) & ElectricalEngineer(evangelosEleftheriou).
WorkForIn(evangelosEleftheriou, iBM, zurich).
! [X] : ! [X] : ! [Z] : (Company(X) & WorkForIn(y, X, Z) => HaveOfficeIn(X, Z)).
Company(ibm).

[CONCLUSION]:
IBM has an office in London or Zurich or both.

[CONCLUSION (FOL)]:
HaveOfficeIn(ibm, london) ∨ HaveOfficeIn(ibm, zurich)

[CONCLUSION (GK)]:
HaveOfficeIn(ibm, london) | HaveOfficeIn(ibm, zurich).


===

['x', 'z']
['x', 'z']
[PREMISE]:
Evangelos Eleftheriou is a Greek electrical engineer.
Evangelos Eleftheriou worked for IBM in Zurich.
If a company has employees working for them somewhere, then they have an office there.
IBM is a company.

[PREMISE (FOL)]:
Greek(evangelosEleftheriou) ∧ ElectricalEngineer(evangelosEleftheriou)
WorkForIn(evangelosEleftheriou, iBM, zurich)
∀x ∀x ∀z (Company(x) ∧ WorkForIn(y, x, z) → HaveOfficeIn(x, z))
Company(ibm)

[PREMISE (GK)]:
Greek(evangelosEleftheriou) & ElectricalEngineer(evangelosEleftheriou).
WorkForIn(evangelosEleftheriou, iBM, zurich).
! [X] : ! [X] : ! [Z] : (Company(X) & WorkForIn(y, X, Z) => HaveOfficeIn(X, Z)).
Company(ibm).

[CONCLUSION]:
No Greeks have worked for IBM.

[CONCLUSION (FOL)]:
∀x (Greek(x) → ¬WorkFor(x, ibm))

[CONCLUSION (GK)]:
! [X] : (Greek(X) => -WorkFor(X, ibm)).


===

['x']
['x']
[PREMISE]:
Boney M. had several German #1 singles.
"Hooray! Hooray! It's a Holi-Holiday!" was a big hit all over Europe.
"Hooray! Hooray! It's a Holi-Holiday!" was not in German #1 singles.
A song that peaks below #1 on the german charts is also a song that is not the #1 single in Germany.

[PREMISE (FOL)]:
∃x (Song(x) ∧ By(x, boneym,) ∧ Number1GermanSingle(x))
Song(hoorayHoorayItsAHoliHoliday) ∧ HitAllOverEurope(hoorayHoorayItsAHoliHoliday)
Song(hoorayHoorayItsAHoliHoliday) ∧ ¬Number1GermanSingle(hoorayHoorayItsAHoliHoliday)
∀x (PeakBelowOn(x, number1, germanChart) → ¬Number1GermanSingle(x))

[PREMISE (GK)]:
? [X] : (Song(X) & By(X, boneym,) & Number1GermanSingle(X)).
Song(hoorayHoorayItsAHoliHoliday) & HitAllOverEurope(hoorayHoorayItsAHoliHoliday).
Song(hoorayHoorayItsAHoliHoliday) & -Number1GermanSingle(hoorayHoorayItsAHoliHoliday).
! [X] : (PeakBelowOn(X, number1, germanChart) => -Number1GermanSingle(X)).

[CONCLUSION]:
"Hooray! Hooray! It's a Holi-Holiday!" was the #1 hit in Germany.

[CONCLUSION (FOL)]:
Song(hoorayHoorayItsAHoliHoliday) ∧ Number1GermanSingle(hoorayHoorayItsAHoliHoliday)

[CONCLUSION (GK)]:
Song(hoorayHoorayItsAHoliHoliday) & Number1GermanSingle(hoorayHoorayItsAHoliHoliday).


===

['x']
['x']
[PREMISE]:
Boney M. had several German #1 singles.
"Hooray! Hooray! It's a Holi-Holiday!" was a big hit all over Europe.
"Hooray! Hooray! It's a Holi-Holiday!" was not in German #1 singles.
A song that peaks below #1 on the german charts is also a song that is not the #1 single in Germany.

[PREMISE (FOL)]:
∃x (Song(x) ∧ By(x, boneym,) ∧ Number1GermanSingle(x))
Song(hoorayHoorayItsAHoliHoliday) ∧ HitAllOverEurope(hoorayHoorayItsAHoliHoliday)
Song(hoorayHoorayItsAHoliHoliday) ∧ ¬Number1GermanSingle(hoorayHoorayItsAHoliHoliday)
∀x (PeakBelowOn(x, number1, germanChart) → ¬Number1GermanSingle(x))

[PREMISE (GK)]:
? [X] : (Song(X) & By(X, boneym,) & Number1GermanSingle(X)).
Song(hoorayHoorayItsAHoliHoliday) & HitAllOverEurope(hoorayHoorayItsAHoliHoliday).
Song(hoorayHoorayItsAHoliHoliday) & -Number1GermanSingle(hoorayHoorayItsAHoliHoliday).
! [X] : (PeakBelowOn(X, number1, germanChart) => -Number1GermanSingle(X)).

[CONCLUSION]:
"Hooray! Hooray! It's a Holi-Holiday!" peaked below #1 on the German charts.

[CONCLUSION (FOL)]:
PeaksBelowOn(hoorayHoorayItsAHoliHoliday, number1, germanChart)

[CONCLUSION (GK)]:
PeaksBelowOn(hoorayHoorayItsAHoliHoliday, number1, germanChart).


===

['x']
['x']
[PREMISE]:
Boney M. had several German #1 singles.
"Hooray! Hooray! It's a Holi-Holiday!" was a big hit all over Europe.
"Hooray! Hooray! It's a Holi-Holiday!" was not in German #1 singles.
A song that peaks below #1 on the german charts is also a song that is not the #1 single in Germany.

[PREMISE (FOL)]:
∃x (Song(x) ∧ By(x, boneym,) ∧ Number1GermanSingle(x))
Song(hoorayHoorayItsAHoliHoliday) ∧ HitAllOverEurope(hoorayHoorayItsAHoliHoliday)
Song(hoorayHoorayItsAHoliHoliday) ∧ ¬Number1GermanSingle(hoorayHoorayItsAHoliHoliday)
∀x (PeakBelowOn(x, number1, germanChart) → ¬Number1GermanSingle(x))

[PREMISE (GK)]:
? [X] : (Song(X) & By(X, boneym,) & Number1GermanSingle(X)).
Song(hoorayHoorayItsAHoliHoliday) & HitAllOverEurope(hoorayHoorayItsAHoliHoliday).
Song(hoorayHoorayItsAHoliHoliday) & -Number1GermanSingle(hoorayHoorayItsAHoliHoliday).
! [X] : (PeakBelowOn(X, number1, germanChart) => -Number1GermanSingle(X)).

[CONCLUSION]:
"Hooray! Hooray! It's a Holi-Holiday!" peaked at #3 on the UK charts.

[CONCLUSION (FOL)]:
PeaksAtOn(hoorayHoorayItsAHoliHoliday, number3, germanChart)

[CONCLUSION (GK)]:
PeaksAtOn(hoorayHoorayItsAHoliHoliday, number3, germanChart).


===

['x']
['x']
[PREMISE]:
Every chef can cook.
Some people who aren’t chefs can cook.
People who cook can make scrambled eggs and pasta.
If someone can make cookies and muffins, they are a baker.
Bakers who can also make scrambled eggs can make a good breakfast.
Luke can make cookies, scrambled eggs, and muffins, but not pasta.

[PREMISE (FOL)]:
∀x (Chef(x) → Can(x, cook))
∃x (¬Chef(x) ∧ Can(x, cook))
∀x (Can(x, cook) → (CanMake(x, scrambledEggs) ∧ CanMake(x, pasta)))
∀x (CanMake(x, cookies) ∧ CanMake(x, muffins) → Baker(x))
∀x ((Baker(x) ∧ CanMake(x, scrambledEggs)) → CanMake(x, goodBreakfast))
CanMake(luke, cookies) ∧ (CanMake(luke, scrambledEggs) ∧ CanMake(luke, muffins) ∧ ¬CanMake(luke, pasta)

[PREMISE (GK)]:
! [X] : (Chef(X) => Can(X, cook)).
? [X] : (-Chef(X) & Can(X, cook)).
! [X] : (Can(X, cook) => (CanMake(X, scrambledEggs) & CanMake(X, pasta))).
! [X] : (CanMake(X, cookies) & CanMake(X, muffins) => Baker(X)).
! [X] : ((Baker(X) & CanMake(X, scrambledEggs)) => CanMake(X, goodBreakfast)).
CanMake(luke, cookies) & (CanMake(luke, scrambledEggs) & CanMake(luke, muffins) & -CanMake(luke, pasta).

[CONCLUSION]:
Luke can make a good breakfast.

[CONCLUSION (FOL)]:
CanMake(luke, goodBreakfast)

[CONCLUSION (GK)]:
CanMake(luke, goodBreakfast).


===

['x']
['x']
[PREMISE]:
Every chef can cook.
Some people who aren’t chefs can cook.
People who cook can make scrambled eggs and pasta.
If someone can make cookies and muffins, they are a baker.
Bakers who can also make scrambled eggs can make a good breakfast.
Luke can make cookies, scrambled eggs, and muffins, but not pasta.

[PREMISE (FOL)]:
∀x (Chef(x) → Can(x, cook))
∃x (¬Chef(x) ∧ Can(x, cook))
∀x (Can(x, cook) → (CanMake(x, scrambledEggs) ∧ CanMake(x, pasta)))
∀x (CanMake(x, cookies) ∧ CanMake(x, muffins) → Baker(x))
∀x ((Baker(x) ∧ CanMake(x, scrambledEggs)) → CanMake(x, goodBreakfast))
CanMake(luke, cookies) ∧ (CanMake(luke, scrambledEggs) ∧ CanMake(luke, muffins) ∧ ¬CanMake(luke, pasta)

[PREMISE (GK)]:
! [X] : (Chef(X) => Can(X, cook)).
? [X] : (-Chef(X) & Can(X, cook)).
! [X] : (Can(X, cook) => (CanMake(X, scrambledEggs) & CanMake(X, pasta))).
! [X] : (CanMake(X, cookies) & CanMake(X, muffins) => Baker(X)).
! [X] : ((Baker(X) & CanMake(X, scrambledEggs)) => CanMake(X, goodBreakfast)).
CanMake(luke, cookies) & (CanMake(luke, scrambledEggs) & CanMake(luke, muffins) & -CanMake(luke, pasta).

[CONCLUSION]:
Luke is a chef.

[CONCLUSION (FOL)]:
Chef(luke)

[CONCLUSION (GK)]:
Chef(luke).


===

['x', 'y']
['x', 'y']
[PREMISE]:
ETS develops various standardized tests primarily in the United States for K-12 and higher education. 
ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions. 
ETS also develops K-12 statewide assessments used for accountability testing in many states.

[PREMISE (FOL)]:
∃x ∃y (Develop(eTS, x) ∧ Develop(eTS, y) ∧ StandardizedTest(x) ∧ StandardizedTest(y) ∧ In(x, unitedState) ∧ In(y, unitedState) ∧ For(x, k12AndHigherEducation) ∧ For(y, k12AndHigherEducation))
∃x (Administer(eTS, x) ∧ InternationalTest(x) ∧ (TOEFL(x) ∨ TOEIC(x) ∨ GRE(x) ∨ SubjectTest(x)))
∃x (Develop(eTS, x) ∧ AssociatedWith(x, entryToUSEducationInstitution))
∃x (Develop(eTS, x) ∧ StateWideAssesment(x) ∧ UsedFor(x, accountabilityTesting))

[PREMISE (GK)]:
? [X] : ? [Y] : (Develop(eTS, X) & Develop(eTS, Y) & StandardizedTest(X) & StandardizedTest(Y) & In(X, unitedState) & In(Y, unitedState) & For(X, k12AndHigherEducation) & For(Y, k12AndHigherEducation)).
? [X] : (Administer(eTS, X) & InternationalTest(X) & (TOEFL(X) | TOEIC(X) | GRE(X) | SubjectTest(X))).
? [X] : (Develop(eTS, X) & AssociatedWith(X, entryToUSEducationInstitution)).
? [X] : (Develop(eTS, X) & StateWideAssesment(X) & UsedFor(X, accountabilityTesting)).

[CONCLUSION]:
ETS develops assessments for K-12 statewide as well as entry to US tertiary and quaternary education institutions.

[CONCLUSION (FOL)]:
∃x ∃y (Develop(eTS, x) ∧ StateWideAssesment(x) ∧ Develop(eTS, y) ∧ AssociatedWith(y, entryToUSEducationInstitution))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Develop(eTS, X) & StateWideAssesment(X) & Develop(eTS, Y) & AssociatedWith(Y, entryToUSEducationInstitution)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
ETS develops various standardized tests primarily in the United States for K-12 and higher education. 
ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions. 
ETS also develops K-12 statewide assessments used for accountability testing in many states.

[PREMISE (FOL)]:
∃x ∃y (Develop(eTS, x) ∧ Develop(eTS, y) ∧ StandardizedTest(x) ∧ StandardizedTest(y) ∧ In(x, unitedState) ∧ In(y, unitedState) ∧ For(x, k12AndHigherEducation) ∧ For(y, k12AndHigherEducation))
∃x (Administer(eTS, x) ∧ InternationalTest(x) ∧ (TOEFL(x) ∨ TOEIC(x) ∨ GRE(x) ∨ SubjectTest(x)))
∃x (Develop(eTS, x) ∧ AssociatedWith(x, entryToUSEducationInstitution))
∃x (Develop(eTS, x) ∧ StateWideAssesment(x) ∧ UsedFor(x, accountabilityTesting))

[PREMISE (GK)]:
? [X] : ? [Y] : (Develop(eTS, X) & Develop(eTS, Y) & StandardizedTest(X) & StandardizedTest(Y) & In(X, unitedState) & In(Y, unitedState) & For(X, k12AndHigherEducation) & For(Y, k12AndHigherEducation)).
? [X] : (Administer(eTS, X) & InternationalTest(X) & (TOEFL(X) | TOEIC(X) | GRE(X) | SubjectTest(X))).
? [X] : (Develop(eTS, X) & AssociatedWith(X, entryToUSEducationInstitution)).
? [X] : (Develop(eTS, X) & StateWideAssesment(X) & UsedFor(X, accountabilityTesting)).

[CONCLUSION]:
ETS doesn't administer tests internationally.

[CONCLUSION (FOL)]:
∀x (Administer(eTS, x) → ¬InternationalTest(x))

[CONCLUSION (GK)]:
! [X] : (Administer(eTS, X) => -InternationalTest(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
ETS develops various standardized tests primarily in the United States for K-12 and higher education. 
ETS administers international tests, including the TOEFL, TOEIC, GRE, and subject tests.
Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions. 
ETS also develops K-12 statewide assessments used for accountability testing in many states.

[PREMISE (FOL)]:
∃x ∃y (Develop(eTS, x) ∧ Develop(eTS, y) ∧ StandardizedTest(x) ∧ StandardizedTest(y) ∧ In(x, unitedState) ∧ In(y, unitedState) ∧ For(x, k12AndHigherEducation) ∧ For(y, k12AndHigherEducation))
∃x (Administer(eTS, x) ∧ InternationalTest(x) ∧ (TOEFL(x) ∨ TOEIC(x) ∨ GRE(x) ∨ SubjectTest(x)))
∃x (Develop(eTS, x) ∧ AssociatedWith(x, entryToUSEducationInstitution))
∃x (Develop(eTS, x) ∧ StateWideAssesment(x) ∧ UsedFor(x, accountabilityTesting))

[PREMISE (GK)]:
? [X] : ? [Y] : (Develop(eTS, X) & Develop(eTS, Y) & StandardizedTest(X) & StandardizedTest(Y) & In(X, unitedState) & In(Y, unitedState) & For(X, k12AndHigherEducation) & For(Y, k12AndHigherEducation)).
? [X] : (Administer(eTS, X) & InternationalTest(X) & (TOEFL(X) | TOEIC(X) | GRE(X) | SubjectTest(X))).
? [X] : (Develop(eTS, X) & AssociatedWith(X, entryToUSEducationInstitution)).
? [X] : (Develop(eTS, X) & StateWideAssesment(X) & UsedFor(X, accountabilityTesting)).

[CONCLUSION]:
ETS administers international tests including the TOEFL, GRE and subject tests in China.

[CONCLUSION (FOL)]:
∃x (Administer(eTS, x) ∧ InChina(x) ∧ (TOEFL(x) ∨ TOEIC(x) ∨ GRE(x) ∨ SubjectTest(x)))

[CONCLUSION (GK)]:
? [X] : (Administer(eTS, X) & InChina(X) & (TOEFL(X) | TOEIC(X) | GRE(X) | SubjectTest(X))).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All hodophiles who enjoy eating gelato ice cream would enjoy a vacation to Italy.
No hodophiles can resist the hallmark delectable desserts famous in Italy.
Hodophiles enjoy eating gelato ice cream or love to travel and vacation often, or both.
No hodophiles who study abroad in Europe regret their college experiences.
If hodophiles love to travel and vacation often, then they study abroad in Europe.
Robert is a hodophile, and he either enjoys eating gelato ice cream and loves to travel and vacation often, or does not enjoy eating gelato ice cream and does not love to travel and vacation often.

[PREMISE (FOL)]:
∀x (Hodophiles(x) ∧ EnjoyEating(x, gelato) → Enjoy(x, vacationToItaly))
∀x (Hodophiles(x) ∧ ¬(∃y (Resist(x, y) ∧ Hallmark(y) ∧ Delectabl(y) ∧ Dessert(y) ∧ FamousIn(y, italy))))
∀x (Hodophiles(x) → (EnjoyEating(x, gelato) ∨ LoveToTravelOften(x))
∀x (Hodophiles(x) ∧ TakeIn(x, studyAbroadSemester, europe) → ¬Regret(x, collegeExperience))
∀x (Hodophiles(x) ∧ LoveToTravelOften(x) → TakeIn(x, studyAbroadSemester, europe))
Hodophiles(robert) ∧ ¬(EnjoyEating(robert, gelato) ⊕ LoveToTravelOften(robert))

[PREMISE (GK)]:
! [X] : (Hodophiles(X) & EnjoyEating(X, gelato) => Enjoy(X, vacationToItaly)).
! [X] : (Hodophiles(X) & -(? [Y] : (Resist(X, Y) & Hallmark(Y) & Delectabl(Y) & Dessert(Y) & FamousIn(Y, italy)))).
! [X] : (Hodophiles(X) => (EnjoyEating(X, gelato) | LoveToTravelOften(X)).
! [X] : (Hodophiles(X) & TakeIn(X, studyAbroadSemester, europe) => -Regret(X, collegeExperience)).
! [X] : (Hodophiles(X) & LoveToTravelOften(X) => TakeIn(X, studyAbroadSemester, europe)).
Hodophiles(robert) & -(EnjoyEating(robert, gelato) <~> LoveToTravelOften(robert)).

[CONCLUSION]:
Robert can resist the hallmark delectable desserts that are famous in Italy.

[CONCLUSION (FOL)]:
∃y (Resist(robert, y) ∧ Hallmark(y) ∧ Delectabl(y) ∧ Dessert(y) ∧ FamousIn(y, italy))

[CONCLUSION (GK)]:
? [Y] : (Resist(robert, Y) & Hallmark(Y) & Delectabl(Y) & Dessert(Y) & FamousIn(Y, italy)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All hodophiles who enjoy eating gelato ice cream would enjoy a vacation to Italy.
No hodophiles can resist the hallmark delectable desserts famous in Italy.
Hodophiles enjoy eating gelato ice cream or love to travel and vacation often, or both.
No hodophiles who study abroad in Europe regret their college experiences.
If hodophiles love to travel and vacation often, then they study abroad in Europe.
Robert is a hodophile, and he either enjoys eating gelato ice cream and loves to travel and vacation often, or does not enjoy eating gelato ice cream and does not love to travel and vacation often.

[PREMISE (FOL)]:
∀x (Hodophiles(x) ∧ EnjoyEating(x, gelato) → Enjoy(x, vacationToItaly))
∀x (Hodophiles(x) ∧ ¬(∃y (Resist(x, y) ∧ Hallmark(y) ∧ Delectabl(y) ∧ Dessert(y) ∧ FamousIn(y, italy))))
∀x (Hodophiles(x) → (EnjoyEating(x, gelato) ∨ LoveToTravelOften(x))
∀x (Hodophiles(x) ∧ TakeIn(x, studyAbroadSemester, europe) → ¬Regret(x, collegeExperience))
∀x (Hodophiles(x) ∧ LoveToTravelOften(x) → TakeIn(x, studyAbroadSemester, europe))
Hodophiles(robert) ∧ ¬(EnjoyEating(robert, gelato) ⊕ LoveToTravelOften(robert))

[PREMISE (GK)]:
! [X] : (Hodophiles(X) & EnjoyEating(X, gelato) => Enjoy(X, vacationToItaly)).
! [X] : (Hodophiles(X) & -(? [Y] : (Resist(X, Y) & Hallmark(Y) & Delectabl(Y) & Dessert(Y) & FamousIn(Y, italy)))).
! [X] : (Hodophiles(X) => (EnjoyEating(X, gelato) | LoveToTravelOften(X)).
! [X] : (Hodophiles(X) & TakeIn(X, studyAbroadSemester, europe) => -Regret(X, collegeExperience)).
! [X] : (Hodophiles(X) & LoveToTravelOften(X) => TakeIn(X, studyAbroadSemester, europe)).
Hodophiles(robert) & -(EnjoyEating(robert, gelato) <~> LoveToTravelOften(robert)).

[CONCLUSION]:
If Robert either would both enjoy a vacation to Italy and regrets his college experiences or neither would enjoy a vacation to Italy nor regrets his college experiences, then Robert would either enjoy a vacation to Italy or he can resist the hallmark delectable desserts that are famous in Italy.

[CONCLUSION (FOL)]:
¬((Enjoy(robert, vacation) ∧ In(vacation, italy)) ⊕ Regret(x, collegeExperiences)) → Enjoy(robert, vacation) ∧ In(vacation, italy) ⊕ (∃y (Resist(robert, y) ∧ Hallmark(y) ∧ Delectabl(y) ∧ Dessert(y) ∧ FamousIn(y, italy))

[CONCLUSION (GK)]:
-((Enjoy(robert, vacation) & In(vacation, italy)) <~> Regret(X, collegeExperiences)) => Enjoy(robert, vacation) & In(vacation, italy) <~> (? [Y] : (Resist(robert, Y) & Hallmark(Y) & Delectabl(Y) & Dessert(Y) & FamousIn(Y, italy)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All hodophiles who enjoy eating gelato ice cream would enjoy a vacation to Italy.
No hodophiles can resist the hallmark delectable desserts famous in Italy.
Hodophiles enjoy eating gelato ice cream or love to travel and vacation often, or both.
No hodophiles who study abroad in Europe regret their college experiences.
If hodophiles love to travel and vacation often, then they study abroad in Europe.
Robert is a hodophile, and he either enjoys eating gelato ice cream and loves to travel and vacation often, or does not enjoy eating gelato ice cream and does not love to travel and vacation often.

[PREMISE (FOL)]:
∀x (Hodophiles(x) ∧ EnjoyEating(x, gelato) → Enjoy(x, vacationToItaly))
∀x (Hodophiles(x) ∧ ¬(∃y (Resist(x, y) ∧ Hallmark(y) ∧ Delectabl(y) ∧ Dessert(y) ∧ FamousIn(y, italy))))
∀x (Hodophiles(x) → (EnjoyEating(x, gelato) ∨ LoveToTravelOften(x))
∀x (Hodophiles(x) ∧ TakeIn(x, studyAbroadSemester, europe) → ¬Regret(x, collegeExperience))
∀x (Hodophiles(x) ∧ LoveToTravelOften(x) → TakeIn(x, studyAbroadSemester, europe))
Hodophiles(robert) ∧ ¬(EnjoyEating(robert, gelato) ⊕ LoveToTravelOften(robert))

[PREMISE (GK)]:
! [X] : (Hodophiles(X) & EnjoyEating(X, gelato) => Enjoy(X, vacationToItaly)).
! [X] : (Hodophiles(X) & -(? [Y] : (Resist(X, Y) & Hallmark(Y) & Delectabl(Y) & Dessert(Y) & FamousIn(Y, italy)))).
! [X] : (Hodophiles(X) => (EnjoyEating(X, gelato) | LoveToTravelOften(X)).
! [X] : (Hodophiles(X) & TakeIn(X, studyAbroadSemester, europe) => -Regret(X, collegeExperience)).
! [X] : (Hodophiles(X) & LoveToTravelOften(X) => TakeIn(X, studyAbroadSemester, europe)).
Hodophiles(robert) & -(EnjoyEating(robert, gelato) <~> LoveToTravelOften(robert)).

[CONCLUSION]:
If Robert is not both a person who can resist the hallmark delectable desserts that are famous in Italy and regrets his college experiences, then Robert either enjoys eating gelato ice cream or would enjoy a vacation to Italy.

[CONCLUSION (FOL)]:
(∃y (Resist(robert, y) ∧ Hallmark(y) ∧ Delectabl(y) ∧ Dessert(y) ∧ FamousIn(y, italy))) ∧ Regret(robert, collegeExperience)) → (EnjoyEating(robert, gelato) ⊕ (Enjoy(robert, vacation) ∧ In(vacation, italy))

[CONCLUSION (GK)]:
(? [Y] : (Resist(robert, Y) & Hallmark(Y) & Delectabl(Y) & Dessert(Y) & FamousIn(Y, italy))) & Regret(robert, collegeExperience)) => (EnjoyEating(robert, gelato) <~> (Enjoy(robert, vacation) & In(vacation, italy)).


===

['x']
['x']
[PREMISE]:
To have the authorization to study in the United States as a foreigner, you must be enrolled in an academic program.
Those who are enrolled in an academic program can not work full-time.
Every who studies in the United States as a foreigner has the authorization to study in the U.S.
All PhD graduate can work full-time. 
If Tom does not study in the United States as a foreigner, he is enrolled in an academic program.

[PREMISE (FOL)]:
∀x (Have(x, authorization, studyIn, unitedStates) → EnrolledIn(x, academicProgram))
∀x (EnrolledIn(x, academicProgram) → ¬Work(x, fullTime))
∀x (StudyIn(x, unitedStates) → Have(x, authorization, studyIn, unitedStates))
∀x (PhDGraduate(x) → Work(x, fullTime))
¬StudyIn(x, unitedStates) → EnrolledIn(x, academicProgram)

[PREMISE (GK)]:
! [X] : (Have(X, authorization, studyIn, unitedStates) => EnrolledIn(X, academicProgram)).
! [X] : (EnrolledIn(X, academicProgram) => -Work(X, fullTime)).
! [X] : (StudyIn(X, unitedStates) => Have(X, authorization, studyIn, unitedStates)).
! [X] : (PhDGraduate(X) => Work(X, fullTime)).
-StudyIn(x, unitedStates) => EnrolledIn(x, academicProgram).

[CONCLUSION]:
Tom is a PhD graduate.

[CONCLUSION (FOL)]:
PhdGraduate(tom)

[CONCLUSION (GK)]:
PhdGraduate(tom).


===

['x']
['x']
[PREMISE]:
To have the authorization to study in the United States as a foreigner, you must be enrolled in an academic program.
Those who are enrolled in an academic program can not work full-time.
Every who studies in the United States as a foreigner has the authorization to study in the U.S.
All PhD graduate can work full-time. 
If Tom does not study in the United States as a foreigner, he is enrolled in an academic program.

[PREMISE (FOL)]:
∀x (Have(x, authorization, studyIn, unitedStates) → EnrolledIn(x, academicProgram))
∀x (EnrolledIn(x, academicProgram) → ¬Work(x, fullTime))
∀x (StudyIn(x, unitedStates) → Have(x, authorization, studyIn, unitedStates))
∀x (PhDGraduate(x) → Work(x, fullTime))
¬StudyIn(x, unitedStates) → EnrolledIn(x, academicProgram)

[PREMISE (GK)]:
! [X] : (Have(X, authorization, studyIn, unitedStates) => EnrolledIn(X, academicProgram)).
! [X] : (EnrolledIn(X, academicProgram) => -Work(X, fullTime)).
! [X] : (StudyIn(X, unitedStates) => Have(X, authorization, studyIn, unitedStates)).
! [X] : (PhDGraduate(X) => Work(X, fullTime)).
-StudyIn(x, unitedStates) => EnrolledIn(x, academicProgram).

[CONCLUSION]:
Tom is not a PhD graduate.

[CONCLUSION (FOL)]:
¬PhdGraduate(tom)

[CONCLUSION (GK)]:
-PhdGraduate(tom).


===

['x']
['x']
[PREMISE]:
To have the authorization to study in the United States as a foreigner, you must be enrolled in an academic program.
Those who are enrolled in an academic program can not work full-time.
Every who studies in the United States as a foreigner has the authorization to study in the U.S.
All PhD graduate can work full-time. 
If Tom does not study in the United States as a foreigner, he is enrolled in an academic program.

[PREMISE (FOL)]:
∀x (Have(x, authorization, studyIn, unitedStates) → EnrolledIn(x, academicProgram))
∀x (EnrolledIn(x, academicProgram) → ¬Work(x, fullTime))
∀x (StudyIn(x, unitedStates) → Have(x, authorization, studyIn, unitedStates))
∀x (PhDGraduate(x) → Work(x, fullTime))
¬StudyIn(x, unitedStates) → EnrolledIn(x, academicProgram)

[PREMISE (GK)]:
! [X] : (Have(X, authorization, studyIn, unitedStates) => EnrolledIn(X, academicProgram)).
! [X] : (EnrolledIn(X, academicProgram) => -Work(X, fullTime)).
! [X] : (StudyIn(X, unitedStates) => Have(X, authorization, studyIn, unitedStates)).
! [X] : (PhDGraduate(X) => Work(X, fullTime)).
-StudyIn(x, unitedStates) => EnrolledIn(x, academicProgram).

[CONCLUSION]:
Tom wants to study abroad.

[CONCLUSION (FOL)]:
StudyIn(tom, unitedStates)

[CONCLUSION (GK)]:
StudyIn(tom, unitedStates).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Islip Speedway is the smallest race track.
There was a demolition derby on the smallest race track.
Islip is either demolished or still being used.
Speedways that are still being used have races held at them.
Islip doesn't have races held at it.

[PREMISE (FOL)]:
Speedway(islip) ∧ SmallestRaceTrack(islip)
∃x ∃y (DemolitionDerby(x) ∧ SmallestRaceTrack(y) ∧ On(x, y))
Demolished(islip) ⊕ StillUsed(islip)
∀x (Speedway(x) ∧ StillUsed(x) → Have(races, heldAt, x))
¬Have(races, heldAt, islip)

[PREMISE (GK)]:
Speedway(islip) & SmallestRaceTrack(islip).
? [X] : ? [Y] : (DemolitionDerby(X) & SmallestRaceTrack(Y) & On(X, Y)).
Demolished(islip) <~> StillUsed(islip).
! [X] : (Speedway(X) & StillUsed(X) => Have(races, heldAt, X)).
-Have(races, heldAt, islip).

[CONCLUSION]:
There has been a demolition derby somewhere that has since been demolished.

[CONCLUSION (FOL)]:
∃x ∃y (DemolitionDerby(x) ∧ On(x, y) ∧ Demolished(y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (DemolitionDerby(X) & On(X, Y) & Demolished(Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Islip Speedway is the smallest race track.
There was a demolition derby on the smallest race track.
Islip is either demolished or still being used.
Speedways that are still being used have races held at them.
Islip doesn't have races held at it.

[PREMISE (FOL)]:
Speedway(islip) ∧ SmallestRaceTrack(islip)
∃x ∃y (DemolitionDerby(x) ∧ SmallestRaceTrack(y) ∧ On(x, y))
Demolished(islip) ⊕ StillUsed(islip)
∀x (Speedway(x) ∧ StillUsed(x) → Have(races, heldAt, x))
¬Have(races, heldAt, islip)

[PREMISE (GK)]:
Speedway(islip) & SmallestRaceTrack(islip).
? [X] : ? [Y] : (DemolitionDerby(X) & SmallestRaceTrack(Y) & On(X, Y)).
Demolished(islip) <~> StillUsed(islip).
! [X] : (Speedway(X) & StillUsed(X) => Have(races, heldAt, X)).
-Have(races, heldAt, islip).

[CONCLUSION]:
Islip was demolished.

[CONCLUSION (FOL)]:
Demolished(islip)

[CONCLUSION (GK)]:
Demolished(islip).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Islip Speedway is the smallest race track.
There was a demolition derby on the smallest race track.
Islip is either demolished or still being used.
Speedways that are still being used have races held at them.
Islip doesn't have races held at it.

[PREMISE (FOL)]:
Speedway(islip) ∧ SmallestRaceTrack(islip)
∃x ∃y (DemolitionDerby(x) ∧ SmallestRaceTrack(y) ∧ On(x, y))
Demolished(islip) ⊕ StillUsed(islip)
∀x (Speedway(x) ∧ StillUsed(x) → Have(races, heldAt, x))
¬Have(races, heldAt, islip)

[PREMISE (GK)]:
Speedway(islip) & SmallestRaceTrack(islip).
? [X] : ? [Y] : (DemolitionDerby(X) & SmallestRaceTrack(Y) & On(X, Y)).
Demolished(islip) <~> StillUsed(islip).
! [X] : (Speedway(X) & StillUsed(X) => Have(races, heldAt, X)).
-Have(races, heldAt, islip).

[CONCLUSION]:
Islip is still being used.

[CONCLUSION (FOL)]:
StillUsed(islip)

[CONCLUSION (GK)]:
StillUsed(islip).


===

['x']
['x']
[PREMISE]:
If a person pays their taxes, then they contribute to the country. 
Everyone who works for a government department pays a tax on their salary. 
Everyone in the army is an employee of a government department.
Everyone convicted of murder goes to prison. 
Everyone who has been to prison has a criminal record.
James was either once convicted of murder, or spent time in prison.
James either has a criminal record, or pays his taxes. 

[PREMISE (FOL)]:
∀x (Taxpayer(x) → ContributeTo(x, country))
∀x (WorkFor(x, governmentAgency) → Taxpayer(x))
∀x (ServesIn(x, theArmy) → WorkFor(x, governmentAgency))
∀x (SentencedForMurder(x) → Imprisoned(x))
∀x (Imprisoned((x) → Has(x, criminalRecord))
SentencedForMurder(james) ⊕ Imprisoned(james) 
Has(james, criminalRecord) ⊕ Taxpayer(james)

[PREMISE (GK)]:
! [X] : (Taxpayer(X) => ContributeTo(X, country)).
! [X] : (WorkFor(X, governmentAgency) => Taxpayer(X)).
! [X] : (ServesIn(X, theArmy) => WorkFor(X, governmentAgency)).
! [X] : (SentencedForMurder(X) => Imprisoned(X)).
! [X] : (Imprisoned((X) => Has(X, criminalRecord)).
SentencedForMurder(james) <~> Imprisoned(james) .
Has(james, criminalRecord) <~> Taxpayer(james).

[CONCLUSION]:
James contributes to the country.

[CONCLUSION (FOL)]:
ContributeToCountry(james)

[CONCLUSION (GK)]:
ContributeToCountry(james).


===

['x']
['x']
[PREMISE]:
If a person pays their taxes, then they contribute to the country. 
Everyone who works for a government department pays a tax on their salary. 
Everyone in the army is an employee of a government department.
Everyone convicted of murder goes to prison. 
Everyone who has been to prison has a criminal record.
James was either once convicted of murder, or spent time in prison.
James either has a criminal record, or pays his taxes. 

[PREMISE (FOL)]:
∀x (Taxpayer(x) → ContributeTo(x, country))
∀x (WorkFor(x, governmentAgency) → Taxpayer(x))
∀x (ServesIn(x, theArmy) → WorkFor(x, governmentAgency))
∀x (SentencedForMurder(x) → Imprisoned(x))
∀x (Imprisoned((x) → Has(x, criminalRecord))
SentencedForMurder(james) ⊕ Imprisoned(james) 
Has(james, criminalRecord) ⊕ Taxpayer(james)

[PREMISE (GK)]:
! [X] : (Taxpayer(X) => ContributeTo(X, country)).
! [X] : (WorkFor(X, governmentAgency) => Taxpayer(X)).
! [X] : (ServesIn(X, theArmy) => WorkFor(X, governmentAgency)).
! [X] : (SentencedForMurder(X) => Imprisoned(X)).
! [X] : (Imprisoned((X) => Has(X, criminalRecord)).
SentencedForMurder(james) <~> Imprisoned(james) .
Has(james, criminalRecord) <~> Taxpayer(james).

[CONCLUSION]:
James does not contribute to the country.

[CONCLUSION (FOL)]:
¬ContributeTo(james, country)

[CONCLUSION (GK)]:
-ContributeTo(james, country).


===

['x']
['x']
[PREMISE]:
If a person pays their taxes, then they contribute to the country. 
Everyone who works for a government department pays a tax on their salary. 
Everyone in the army is an employee of a government department.
Everyone convicted of murder goes to prison. 
Everyone who has been to prison has a criminal record.
James was either once convicted of murder, or spent time in prison.
James either has a criminal record, or pays his taxes. 

[PREMISE (FOL)]:
∀x (Taxpayer(x) → ContributeTo(x, country))
∀x (WorkFor(x, governmentAgency) → Taxpayer(x))
∀x (ServesIn(x, theArmy) → WorkFor(x, governmentAgency))
∀x (SentencedForMurder(x) → Imprisoned(x))
∀x (Imprisoned((x) → Has(x, criminalRecord))
SentencedForMurder(james) ⊕ Imprisoned(james) 
Has(james, criminalRecord) ⊕ Taxpayer(james)

[PREMISE (GK)]:
! [X] : (Taxpayer(X) => ContributeTo(X, country)).
! [X] : (WorkFor(X, governmentAgency) => Taxpayer(X)).
! [X] : (ServesIn(X, theArmy) => WorkFor(X, governmentAgency)).
! [X] : (SentencedForMurder(X) => Imprisoned(X)).
! [X] : (Imprisoned((X) => Has(X, criminalRecord)).
SentencedForMurder(james) <~> Imprisoned(james) .
Has(james, criminalRecord) <~> Taxpayer(james).

[CONCLUSION]:
James contributes to the country and he serves in the army.

[CONCLUSION (FOL)]:
ContributeTo(james, country) ∧ ServesIn(james, army)

[CONCLUSION (GK)]:
ContributeTo(james, country) & ServesIn(james, army).


===

['x']
['x']
[PREMISE]:
If a person pays their taxes, then they contribute to the country. 
Everyone who works for a government department pays a tax on their salary. 
Everyone in the army is an employee of a government department.
Everyone convicted of murder goes to prison. 
Everyone who has been to prison has a criminal record.
James was either once convicted of murder, or spent time in prison.
James either has a criminal record, or pays his taxes. 

[PREMISE (FOL)]:
∀x (Taxpayer(x) → ContributeTo(x, country))
∀x (WorkFor(x, governmentAgency) → Taxpayer(x))
∀x (ServesIn(x, theArmy) → WorkFor(x, governmentAgency))
∀x (SentencedForMurder(x) → Imprisoned(x))
∀x (Imprisoned((x) → Has(x, criminalRecord))
SentencedForMurder(james) ⊕ Imprisoned(james) 
Has(james, criminalRecord) ⊕ Taxpayer(james)

[PREMISE (GK)]:
! [X] : (Taxpayer(X) => ContributeTo(X, country)).
! [X] : (WorkFor(X, governmentAgency) => Taxpayer(X)).
! [X] : (ServesIn(X, theArmy) => WorkFor(X, governmentAgency)).
! [X] : (SentencedForMurder(X) => Imprisoned(X)).
! [X] : (Imprisoned((X) => Has(X, criminalRecord)).
SentencedForMurder(james) <~> Imprisoned(james) .
Has(james, criminalRecord) <~> Taxpayer(james).

[CONCLUSION]:
James does not contribute to the country and does not serve in the army.

[CONCLUSION (FOL)]:
¬(ContributeTo(james, country) ∧ ServesIn(james, army))

[CONCLUSION (GK)]:
-(ContributeTo(james, country) & ServesIn(james, army)).


===

['x']
['x', 'y']
[PREMISE]:
The Croton River watershed is the drainage basin of the Croton River.
The Croton River is in southwestern New York.
Water from the Croton River watershed flows to the Bronx.
The Bronx is in New York.

[PREMISE (FOL)]:
DrainageBasinOf(crotonRiverWatershed, crotonRiver)
In(crotonRiver, southwesternNewYork)
∀x ((Water(x) ∧ In(x, crotonRiverWatershed)) → FlowsTo(x, bronx))
In(bronx, newYork)

[PREMISE (GK)]:
DrainageBasinOf(crotonRiverWatershed, crotonRiver).
In(crotonRiver, southwesternNewYork).
! [X] : ((Water(X) & In(X, crotonRiverWatershed)) => FlowsTo(X, bronx)).
In(bronx, newYork).

[CONCLUSION]:
Water from the Croton River watershed flows to somewhere in New York.

[CONCLUSION (FOL)]:
∀x ((Water(x) ∧ From(x, crotonRiverWatershed)) → ∃y(FlowsTo(x, y) ∧ In(y, newYork)))

[CONCLUSION (GK)]:
! [X] : ((Water(X) & From(X, crotonRiverWatershed)) => ? [Y] :(FlowsTo(X, Y) & In(Y, newYork))).


===

['x']
['x']
[PREMISE]:
The Croton River watershed is the drainage basin of the Croton River.
The Croton River is in southwestern New York.
Water from the Croton River watershed flows to the Bronx.
The Bronx is in New York.

[PREMISE (FOL)]:
DrainageBasinOf(crotonRiverWatershed, crotonRiver)
In(crotonRiver, southwesternNewYork)
∀x ((Water(x) ∧ In(x, crotonRiverWatershed)) → FlowsTo(x, bronx))
In(bronx, newYork)

[PREMISE (GK)]:
DrainageBasinOf(crotonRiverWatershed, crotonRiver).
In(crotonRiver, southwesternNewYork).
! [X] : ((Water(X) & In(X, crotonRiverWatershed)) => FlowsTo(X, bronx)).
In(bronx, newYork).

[CONCLUSION]:
The Croton River watershed is in the Bronx.

[CONCLUSION (FOL)]:
In(crotonRiverWatershed, bronx)

[CONCLUSION (GK)]:
In(crotonRiverWatershed, bronx).


===

['x']
['x']
[PREMISE]:
The Croton River watershed is the drainage basin of the Croton River.
The Croton River is in southwestern New York.
Water from the Croton River watershed flows to the Bronx.
The Bronx is in New York.

[PREMISE (FOL)]:
DrainageBasinOf(crotonRiverWatershed, crotonRiver)
In(crotonRiver, southwesternNewYork)
∀x ((Water(x) ∧ In(x, crotonRiverWatershed)) → FlowsTo(x, bronx))
In(bronx, newYork)

[PREMISE (GK)]:
DrainageBasinOf(crotonRiverWatershed, crotonRiver).
In(crotonRiver, southwesternNewYork).
! [X] : ((Water(X) & In(X, crotonRiverWatershed)) => FlowsTo(X, bronx)).
In(bronx, newYork).

[CONCLUSION]:
Water from the Croton River flows to the Bronx.

[CONCLUSION (FOL)]:
∀x (Water(x) ∧ From(x, crotonRiver) → FlowsTo(x, bronx))

[CONCLUSION (GK)]:
! [X] : (Water(X) & From(X, crotonRiver) => FlowsTo(X, bronx)).


===

['x']
['x']
[PREMISE]:
All nuclear-powered submarines are warships.
No nuclear-powered submarines are commercial vessels.

[PREMISE (FOL)]:
∀x (NuclearPoweredSubmarine(x) → Warship(x))
∀x (NuclearPoweredSubmarine(x) → ¬CommercialVessel(x))

[PREMISE (GK)]:
! [X] : (NuclearPoweredSubmarine(X) => Warship(X)).
! [X] : (NuclearPoweredSubmarine(X) => -CommercialVessel(X)).

[CONCLUSION]:
No warships are commercial vessels.

[CONCLUSION (FOL)]:
∀x (Warship(x) → ¬CommercialVessel(x))

[CONCLUSION (GK)]:
! [X] : (Warship(X) => -CommercialVessel(X)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If an album is written by a rock band, then the genre of the album is rock.
If a band writes an album winning an award, then this band wins this award.
Trouble at the Henhouse is an album by The Tragically Hip.
The Tragically Hip is a Canadian rock band.
The song "Butts Wigglin'" is in Trouble at the Henhouse.
Trouble at the Henhouse won the Album of the Year award.
A song in Trouble at the Henhouse appeared in a film.

[PREMISE (FOL)]:
∀x ∀y ∀z (AlbumByBand(x, y) ∧ RockBand(y, z) → Genre(x, rock))
∀x ∀y ∀z (AlbumByBand(x, y) ∧ AlbumAward(x, z) → RockBandAward(y, z))
AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip)
RockBand(the_Tragically_Hip, canada)
SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse)
AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year)
∃x (SongInFilm(x) ∧ SongInAlbum(x, trouble_at_the_Henhouse))

[PREMISE (GK)]:
! [X] : ! [Y] : ! [Z] : (AlbumByBand(X, Y) & RockBand(Y, Z) => Genre(X, rock)).
! [X] : ! [Y] : ! [Z] : (AlbumByBand(X, Y) & AlbumAward(X, Z) => RockBandAward(Y, Z)).
AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip).
RockBand(the_Tragically_Hip, canada).
SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse).
AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year).
? [X] : (SongInFilm(X) & SongInAlbum(X, trouble_at_the_Henhouse)).

[CONCLUSION]:
The genre of Trouble at the Henhouse is rock.

[CONCLUSION (FOL)]:
Genre(troubleAtTheHenhouse, rock)

[CONCLUSION (GK)]:
Genre(troubleAtTheHenhouse, rock).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If an album is written by a rock band, then the genre of the album is rock.
If a band writes an album winning an award, then this band wins this award.
Trouble at the Henhouse is an album by The Tragically Hip.
The Tragically Hip is a Canadian rock band.
The song "Butts Wigglin'" is in Trouble at the Henhouse.
Trouble at the Henhouse won the Album of the Year award.
A song in Trouble at the Henhouse appeared in a film.

[PREMISE (FOL)]:
∀x ∀y ∀z (AlbumByBand(x, y) ∧ RockBand(y, z) → Genre(x, rock))
∀x ∀y ∀z (AlbumByBand(x, y) ∧ AlbumAward(x, z) → RockBandAward(y, z))
AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip)
RockBand(the_Tragically_Hip, canada)
SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse)
AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year)
∃x (SongInFilm(x) ∧ SongInAlbum(x, trouble_at_the_Henhouse))

[PREMISE (GK)]:
! [X] : ! [Y] : ! [Z] : (AlbumByBand(X, Y) & RockBand(Y, Z) => Genre(X, rock)).
! [X] : ! [Y] : ! [Z] : (AlbumByBand(X, Y) & AlbumAward(X, Z) => RockBandAward(Y, Z)).
AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip).
RockBand(the_Tragically_Hip, canada).
SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse).
AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year).
? [X] : (SongInFilm(X) & SongInAlbum(X, trouble_at_the_Henhouse)).

[CONCLUSION]:
No Canadian rock band has won the Album of the Year award.

[CONCLUSION (FOL)]:
¬∃x(RockBand(x, canada) ∧ Award(x, theAlbumOfTheYear))

[CONCLUSION (GK)]:
-? [X] :(RockBand(X, canada) & Award(X, theAlbumOfTheYear)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If an album is written by a rock band, then the genre of the album is rock.
If a band writes an album winning an award, then this band wins this award.
Trouble at the Henhouse is an album by The Tragically Hip.
The Tragically Hip is a Canadian rock band.
The song "Butts Wigglin'" is in Trouble at the Henhouse.
Trouble at the Henhouse won the Album of the Year award.
A song in Trouble at the Henhouse appeared in a film.

[PREMISE (FOL)]:
∀x ∀y ∀z (AlbumByBand(x, y) ∧ RockBand(y, z) → Genre(x, rock))
∀x ∀y ∀z (AlbumByBand(x, y) ∧ AlbumAward(x, z) → RockBandAward(y, z))
AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip)
RockBand(the_Tragically_Hip, canada)
SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse)
AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year)
∃x (SongInFilm(x) ∧ SongInAlbum(x, trouble_at_the_Henhouse))

[PREMISE (GK)]:
! [X] : ! [Y] : ! [Z] : (AlbumByBand(X, Y) & RockBand(Y, Z) => Genre(X, rock)).
! [X] : ! [Y] : ! [Z] : (AlbumByBand(X, Y) & AlbumAward(X, Z) => RockBandAward(Y, Z)).
AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip).
RockBand(the_Tragically_Hip, canada).
SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse).
AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year).
? [X] : (SongInFilm(X) & SongInAlbum(X, trouble_at_the_Henhouse)).

[CONCLUSION]:
"Butts Wigglin'" appeared in a film.

[CONCLUSION (FOL)]:
SongInFilm(buttsWigglin)

[CONCLUSION (GK)]:
SongInFilm(buttsWigglin).


===

[]
[]
[PREMISE]:
Daniel is a software engineer, and he works at Palantir Technologies.
Daniel studied bioengineering during his undergraduate at Rice University.
Daniel’s older sister works at Meta as a technical sourcer. 
Daniel’s dad and older sister both graduated from Stanford University.
Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis.

[PREMISE (FOL)]:
SoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies)
Studied(daniel, bioengineering) ∧ UndergraduateAt(daniel, riceUniversity)
WorksAtMeta(danielsOlderSister) ∧ TechnicalSourcer(danielsOlderSister)
 GraduatedFromStanfordUniversity(danielsOlderSister) ∧ GraduatedFromStanfordUniversity(danielsDad)
Doctor(danielsDad) ∧ Practicing(danielsDad, internalMedicine) ∧ PracticingAt(danielsDad, veteransHospital) ∧ In(veteransHospital, minneapolis)

[PREMISE (GK)]:
SoftwareEngineer(daniel) & WorksAt(daniel, palantirTechnologies).
Studied(daniel, bioengineering) & UndergraduateAt(daniel, riceUniversity).
WorksAtMeta(danielsOlderSister) & TechnicalSourcer(danielsOlderSister).
 GraduatedFromStanfordUniversity(danielsOlderSister) & GraduatedFromStanfordUniversity(danielsDad).
Doctor(danielsDad) & Practicing(danielsDad, internalMedicine) & PracticingAt(danielsDad, veteransHospital) & In(veteransHospital, minneapolis).

[CONCLUSION]:
Daniel once applied to Stanford University, but he couldn’t get in even though he has family members who are Stanford alumni.

[CONCLUSION (FOL)]:
AppliedTo(daniel, stanfordUniversity) ∧ ¬GotInto(daniel, stanfordUniversity) ∧ Alumni(danielsFamilyMembers, stanfordUniversity)

[CONCLUSION (GK)]:
AppliedTo(daniel, stanfordUniversity) & -GotInto(daniel, stanfordUniversity) & Alumni(danielsFamilyMembers, stanfordUniversity).


===

[]
[]
[PREMISE]:
Daniel is a software engineer, and he works at Palantir Technologies.
Daniel studied bioengineering during his undergraduate at Rice University.
Daniel’s older sister works at Meta as a technical sourcer. 
Daniel’s dad and older sister both graduated from Stanford University.
Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis.

[PREMISE (FOL)]:
SoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies)
Studied(daniel, bioengineering) ∧ UndergraduateAt(daniel, riceUniversity)
WorksAtMeta(danielsOlderSister) ∧ TechnicalSourcer(danielsOlderSister)
 GraduatedFromStanfordUniversity(danielsOlderSister) ∧ GraduatedFromStanfordUniversity(danielsDad)
Doctor(danielsDad) ∧ Practicing(danielsDad, internalMedicine) ∧ PracticingAt(danielsDad, veteransHospital) ∧ In(veteransHospital, minneapolis)

[PREMISE (GK)]:
SoftwareEngineer(daniel) & WorksAt(daniel, palantirTechnologies).
Studied(daniel, bioengineering) & UndergraduateAt(daniel, riceUniversity).
WorksAtMeta(danielsOlderSister) & TechnicalSourcer(danielsOlderSister).
 GraduatedFromStanfordUniversity(danielsOlderSister) & GraduatedFromStanfordUniversity(danielsDad).
Doctor(danielsDad) & Practicing(danielsDad, internalMedicine) & PracticingAt(danielsDad, veteransHospital) & In(veteransHospital, minneapolis).

[CONCLUSION]:
Daniel studied bioengineering as an undergraduate at Rice University.

[CONCLUSION (FOL)]:
Studied(daniel, bioengineering) ∧ UndergraduateAt(daniel, riceUniversity)

[CONCLUSION (GK)]:
Studied(daniel, bioengineering) & UndergraduateAt(daniel, riceUniversity).


===

[]
[]
[PREMISE]:
Daniel is a software engineer, and he works at Palantir Technologies.
Daniel studied bioengineering during his undergraduate at Rice University.
Daniel’s older sister works at Meta as a technical sourcer. 
Daniel’s dad and older sister both graduated from Stanford University.
Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis.

[PREMISE (FOL)]:
SoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies)
Studied(daniel, bioengineering) ∧ UndergraduateAt(daniel, riceUniversity)
WorksAtMeta(danielsOlderSister) ∧ TechnicalSourcer(danielsOlderSister)
 GraduatedFromStanfordUniversity(danielsOlderSister) ∧ GraduatedFromStanfordUniversity(danielsDad)
Doctor(danielsDad) ∧ Practicing(danielsDad, internalMedicine) ∧ PracticingAt(danielsDad, veteransHospital) ∧ In(veteransHospital, minneapolis)

[PREMISE (GK)]:
SoftwareEngineer(daniel) & WorksAt(daniel, palantirTechnologies).
Studied(daniel, bioengineering) & UndergraduateAt(daniel, riceUniversity).
WorksAtMeta(danielsOlderSister) & TechnicalSourcer(danielsOlderSister).
 GraduatedFromStanfordUniversity(danielsOlderSister) & GraduatedFromStanfordUniversity(danielsDad).
Doctor(danielsDad) & Practicing(danielsDad, internalMedicine) & PracticingAt(danielsDad, veteransHospital) & In(veteransHospital, minneapolis).

[CONCLUSION]:
Daniel and his sister grew up in Minneapolis, Minnesota.

[CONCLUSION (FOL)]:
GrewUpIn(daniel, minneapolis) ∧ GrewUpIn(danielsOlderSister, minneapolis)

[CONCLUSION (GK)]:
GrewUpIn(daniel, minneapolis) & GrewUpIn(danielsOlderSister, minneapolis).


===

['x']
['x']
[PREMISE]:
The world's only major large passenger aircraft manufacturers are Boeing and Airbus.
All American Airlines planes are from the world's major large passenger aircraft manufacturers. 
Airbus made more revenue than Boeing last year.

[PREMISE (FOL)]:
∀x (WorldMajorLargePassengerAircraftManufacturer(x) → x=boeing ⊕ x=airbus)
∀x (AmericanAirlinesAircraft(x) → WorldMajorLargePassengerAircraftManufacturer(x))
MoreInRevenue(airbus, boeing)

[PREMISE (GK)]:
! [X] : (WorldMajorLargePassengerAircraftManufacturer(X) => X=boeing <~> X=airbus).
! [X] : (AmericanAirlinesAircraft(X) => WorldMajorLargePassengerAircraftManufacturer(X)).
MoreInRevenue(airbus, boeing).

[CONCLUSION]:
An American Airlines plane is either a Boeing or Airbus plane.

[CONCLUSION (FOL)]:
∀x (AmericanAirlinesPlane(x) → x=boeing ⊕ x=airbus)

[CONCLUSION (GK)]:
! [X] : (AmericanAirlinesPlane(X) => X=boeing <~> X=airbus).


===

['x']
['x']
[PREMISE]:
The world's only major large passenger aircraft manufacturers are Boeing and Airbus.
All American Airlines planes are from the world's major large passenger aircraft manufacturers. 
Airbus made more revenue than Boeing last year.

[PREMISE (FOL)]:
∀x (WorldMajorLargePassengerAircraftManufacturer(x) → x=boeing ⊕ x=airbus)
∀x (AmericanAirlinesAircraft(x) → WorldMajorLargePassengerAircraftManufacturer(x))
MoreInRevenue(airbus, boeing)

[PREMISE (GK)]:
! [X] : (WorldMajorLargePassengerAircraftManufacturer(X) => X=boeing <~> X=airbus).
! [X] : (AmericanAirlinesAircraft(X) => WorldMajorLargePassengerAircraftManufacturer(X)).
MoreInRevenue(airbus, boeing).

[CONCLUSION]:
There exists a SpaceX commercial aircraft.

[CONCLUSION (FOL)]:
∃x (CommercialAircraft(x) ∧ x=spaceX)

[CONCLUSION (GK)]:
? [X] : (CommercialAircraft(X) & X=spaceX).


===

['x']
['x']
[PREMISE]:
The world's only major large passenger aircraft manufacturers are Boeing and Airbus.
All American Airlines planes are from the world's major large passenger aircraft manufacturers. 
Airbus made more revenue than Boeing last year.

[PREMISE (FOL)]:
∀x (WorldMajorLargePassengerAircraftManufacturer(x) → x=boeing ⊕ x=airbus)
∀x (AmericanAirlinesAircraft(x) → WorldMajorLargePassengerAircraftManufacturer(x))
MoreInRevenue(airbus, boeing)

[PREMISE (GK)]:
! [X] : (WorldMajorLargePassengerAircraftManufacturer(X) => X=boeing <~> X=airbus).
! [X] : (AmericanAirlinesAircraft(X) => WorldMajorLargePassengerAircraftManufacturer(X)).
MoreInRevenue(airbus, boeing).

[CONCLUSION]:
There does not exist a United Airlines plane produced by Boeing.

[CONCLUSION (FOL)]:
∀x (UnitedAirlinesAircraft(x) → ¬(x=boeing))

[CONCLUSION (GK)]:
! [X] : (UnitedAirlinesAircraft(X) => -(X=boeing)).


===

['x']
['x']
[PREMISE]:
The world's only major large passenger aircraft manufacturers are Boeing and Airbus.
All American Airlines planes are from the world's major large passenger aircraft manufacturers. 
Airbus made more revenue than Boeing last year.

[PREMISE (FOL)]:
∀x (WorldMajorLargePassengerAircraftManufacturer(x) → x=boeing ⊕ x=airbus)
∀x (AmericanAirlinesAircraft(x) → WorldMajorLargePassengerAircraftManufacturer(x))
MoreInRevenue(airbus, boeing)

[PREMISE (GK)]:
! [X] : (WorldMajorLargePassengerAircraftManufacturer(X) => X=boeing <~> X=airbus).
! [X] : (AmericanAirlinesAircraft(X) => WorldMajorLargePassengerAircraftManufacturer(X)).
MoreInRevenue(airbus, boeing).

[CONCLUSION]:
There is a commercial plane made by both Airbus and Boeing.

[CONCLUSION (FOL)]:
∃x (WorldMajorLargePassengerAircraftManufacturer(x) ∧ ProducedBy(x, airbus) ∧ ProducedBy(x, boeing))

[CONCLUSION (GK)]:
? [X] : (WorldMajorLargePassengerAircraftManufacturer(X) & ProducedBy(X, airbus) & ProducedBy(X, boeing)).


===

['x']
['x']
[PREMISE]:
Luzon is an island in the Philippines.
In December 1999, an earthquake struck Luzon.
People died in the December 1999 earthquake in Luzon.

[PREMISE (FOL)]:
Island(luzon) ∧ In(luzon, philippines)
∃x (Earthquake(x) ∧ StrikeInYr(x, year1999) ∧ StrikeInMo(x, december) ∧ StrikeInCity(x, luzon))
∃x (Earthquake(x) ∧ StrikeInYr(x, year1999) ∧ StrikeInMo(x, december) ∧ StrikeInCity(x, luzon) ∧ Deadly(x))

[PREMISE (GK)]:
Island(luzon) & In(luzon, philippines).
? [X] : (Earthquake(X) & StrikeInYr(X, year1999) & StrikeInMo(X, december) & StrikeInCity(X, luzon)).
? [X] : (Earthquake(X) & StrikeInYr(X, year1999) & StrikeInMo(X, december) & StrikeInCity(X, luzon) & Deadly(X)).

[CONCLUSION]:
Leyte is an island in the Philippines.

[CONCLUSION (FOL)]:
Island(leyte) ∧ In(leyte, philippines)

[CONCLUSION (GK)]:
Island(leyte) & In(leyte, philippines).


===

['x']
['x', 'y']
[PREMISE]:
Luzon is an island in the Philippines.
In December 1999, an earthquake struck Luzon.
People died in the December 1999 earthquake in Luzon.

[PREMISE (FOL)]:
Island(luzon) ∧ In(luzon, philippines)
∃x (Earthquake(x) ∧ StrikeInYr(x, year1999) ∧ StrikeInMo(x, december) ∧ StrikeInCity(x, luzon))
∃x (Earthquake(x) ∧ StrikeInYr(x, year1999) ∧ StrikeInMo(x, december) ∧ StrikeInCity(x, luzon) ∧ Deadly(x))

[PREMISE (GK)]:
Island(luzon) & In(luzon, philippines).
? [X] : (Earthquake(X) & StrikeInYr(X, year1999) & StrikeInMo(X, december) & StrikeInCity(X, luzon)).
? [X] : (Earthquake(X) & StrikeInYr(X, year1999) & StrikeInMo(X, december) & StrikeInCity(X, luzon) & Deadly(X)).

[CONCLUSION]:
No one has ever died in an earthquake that struck the Philippines.

[CONCLUSION (FOL)]:
∀x ∀y ((Earthquake(x) ∧ StrikeInCity(x, y) ∧ In(y, philippines)) → ¬Deadly(x))

[CONCLUSION (GK)]:
! [X] : ! [Y] : ((Earthquake(X) & StrikeInCity(X, Y) & In(Y, philippines)) => -Deadly(X)).


===

['x']
['x', 'y']
[PREMISE]:
Luzon is an island in the Philippines.
In December 1999, an earthquake struck Luzon.
People died in the December 1999 earthquake in Luzon.

[PREMISE (FOL)]:
Island(luzon) ∧ In(luzon, philippines)
∃x (Earthquake(x) ∧ StrikeInYr(x, year1999) ∧ StrikeInMo(x, december) ∧ StrikeInCity(x, luzon))
∃x (Earthquake(x) ∧ StrikeInYr(x, year1999) ∧ StrikeInMo(x, december) ∧ StrikeInCity(x, luzon) ∧ Deadly(x))

[PREMISE (GK)]:
Island(luzon) & In(luzon, philippines).
? [X] : (Earthquake(X) & StrikeInYr(X, year1999) & StrikeInMo(X, december) & StrikeInCity(X, luzon)).
? [X] : (Earthquake(X) & StrikeInYr(X, year1999) & StrikeInMo(X, december) & StrikeInCity(X, luzon) & Deadly(X)).

[CONCLUSION]:
In 1999, there was at least one earthquake in the Philippines.

[CONCLUSION (FOL)]:
∃x ∃y (Earthquake(x) ∧ StrikeInYr(x, year1999) ∧ StrikeInMo(x, december) ∧ StrikeInCity(x, y) ∧ In(y, philippines))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Earthquake(X) & StrikeInYr(X, year1999) & StrikeInMo(X, december) & StrikeInCity(X, Y) & In(Y, philippines)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
People who like financial risks invest in the public stock market regularly or enjoy gambling regularly.
If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.
All people who enjoy enjoy gambling regularly spend a lot of money at casinos or other betting games.
People who spend a lot of money at casinos and other betting games would enjoy visiting the Las Vegas Strip.
People who spend a lot of money at casinos and other betting games are at risk of gambling addiction.
Matt does not invest in the public stock market regularly. 
Matt likes financial risks.

[PREMISE (FOL)]:
∀x (Like(x, financialRisk) → InvestInRegularly(x, publicStockMarket) ∨ EnjoyRegularly(x, gambling))
∀x (InvestInRegularly(x, publicStockMarket) → ReadToKeepUpdatedOn(x, theWallStreetJournal, financialMetric) ∨ (∃y (¬(y=theWallStreetJournal) ∧ NewsPaper(y) ∧ ReadToKeepUpdatedOn(x, y, financialMetric))))
∀x (EnjoyRegularly(x, gambling) → SpendAt(x, alotOfMoney, casino) ∨ (∃y (¬(y=casino) ∧ BettingGame(y) ∧ SpendAt(x, aLotOfMoney, y)))
∀x (SpendAt(x, alotOfMoney, casino) ∨ (∃y (¬(y=casino) ∧ BettingGame(y) ∧ SpendAt(x, aLotOfMoney, y))) → EnjoyVisiting(x, theLasVegasStrip))
∀x (SpendAt(x, alotOfMoney, casino) ∨ (∃y (¬(y=casino) ∧ BettingGame(y) ∧ SpendAt(x, aLotOfMoney, y)) → AtRiskOf(x, gamblingAddiction))
InvestInRegularly(matt, publicStockMarket)
Like(matt, financialRisk)

[PREMISE (GK)]:
! [X] : (Like(X, financialRisk) => InvestInRegularly(X, publicStockMarket) | EnjoyRegularly(X, gambling)).
! [X] : (InvestInRegularly(X, publicStockMarket) => ReadToKeepUpdatedOn(X, theWallStreetJournal, financialMetric) | (? [Y] : (-(Y=theWallStreetJournal) & NewsPaper(Y) & ReadToKeepUpdatedOn(X, Y, financialMetric)))).
! [X] : (EnjoyRegularly(X, gambling) => SpendAt(X, alotOfMoney, casino) | (? [Y] : (-(Y=casino) & BettingGame(Y) & SpendAt(X, aLotOfMoney, Y))).
! [X] : (SpendAt(X, alotOfMoney, casino) | (? [Y] : (-(Y=casino) & BettingGame(Y) & SpendAt(X, aLotOfMoney, Y))) => EnjoyVisiting(X, theLasVegasStrip)).
! [X] : (SpendAt(X, alotOfMoney, casino) | (? [Y] : (-(Y=casino) & BettingGame(Y) & SpendAt(X, aLotOfMoney, Y)) => AtRiskOf(X, gamblingAddiction)).
InvestInRegularly(matt, publicStockMarket).
Like(matt, financialRisk).

[CONCLUSION]:
Matt reads the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.

[CONCLUSION (FOL)]:
Newspapers(matt)

[CONCLUSION (GK)]:
Newspapers(matt).


===

['x', 'y']
['x', 'y']
[PREMISE]:
People who like financial risks invest in the public stock market regularly or enjoy gambling regularly.
If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.
All people who enjoy enjoy gambling regularly spend a lot of money at casinos or other betting games.
People who spend a lot of money at casinos and other betting games would enjoy visiting the Las Vegas Strip.
People who spend a lot of money at casinos and other betting games are at risk of gambling addiction.
Matt does not invest in the public stock market regularly. 
Matt likes financial risks.

[PREMISE (FOL)]:
∀x (Like(x, financialRisk) → InvestInRegularly(x, publicStockMarket) ∨ EnjoyRegularly(x, gambling))
∀x (InvestInRegularly(x, publicStockMarket) → ReadToKeepUpdatedOn(x, theWallStreetJournal, financialMetric) ∨ (∃y (¬(y=theWallStreetJournal) ∧ NewsPaper(y) ∧ ReadToKeepUpdatedOn(x, y, financialMetric))))
∀x (EnjoyRegularly(x, gambling) → SpendAt(x, alotOfMoney, casino) ∨ (∃y (¬(y=casino) ∧ BettingGame(y) ∧ SpendAt(x, aLotOfMoney, y)))
∀x (SpendAt(x, alotOfMoney, casino) ∨ (∃y (¬(y=casino) ∧ BettingGame(y) ∧ SpendAt(x, aLotOfMoney, y))) → EnjoyVisiting(x, theLasVegasStrip))
∀x (SpendAt(x, alotOfMoney, casino) ∨ (∃y (¬(y=casino) ∧ BettingGame(y) ∧ SpendAt(x, aLotOfMoney, y)) → AtRiskOf(x, gamblingAddiction))
InvestInRegularly(matt, publicStockMarket)
Like(matt, financialRisk)

[PREMISE (GK)]:
! [X] : (Like(X, financialRisk) => InvestInRegularly(X, publicStockMarket) | EnjoyRegularly(X, gambling)).
! [X] : (InvestInRegularly(X, publicStockMarket) => ReadToKeepUpdatedOn(X, theWallStreetJournal, financialMetric) | (? [Y] : (-(Y=theWallStreetJournal) & NewsPaper(Y) & ReadToKeepUpdatedOn(X, Y, financialMetric)))).
! [X] : (EnjoyRegularly(X, gambling) => SpendAt(X, alotOfMoney, casino) | (? [Y] : (-(Y=casino) & BettingGame(Y) & SpendAt(X, aLotOfMoney, Y))).
! [X] : (SpendAt(X, alotOfMoney, casino) | (? [Y] : (-(Y=casino) & BettingGame(Y) & SpendAt(X, aLotOfMoney, Y))) => EnjoyVisiting(X, theLasVegasStrip)).
! [X] : (SpendAt(X, alotOfMoney, casino) | (? [Y] : (-(Y=casino) & BettingGame(Y) & SpendAt(X, aLotOfMoney, Y)) => AtRiskOf(X, gamblingAddiction)).
InvestInRegularly(matt, publicStockMarket).
Like(matt, financialRisk).

[CONCLUSION]:
If Matt is either both a person who is at risk of a gambling addiction and invests in the public stock market regularly, or neither is at risk of a gambling addiction nor invests in the public stock market regularly, then Matt neither visits the Las Vegas Strip regularly nor reads the Wall Street Journal and other newspapers regularly to keep updated on the financial metrics.

[CONCLUSION (FOL)]:
AtRiskOf(matt, gamblingAddiction) ⊕ InvestInRegularly(matt, publicStockMarket) → ¬EnjoyVisiting(matt, theLasVegasStrip) ∧  ¬(ReadToKeepUpdatedOn(matt, theWallStreetJournal, financialMetric) ∨  (∃y (¬(y=theWallStreetJournal) ∧ NewsPaper(y) ∧ ReadToKeepUpdatedOn(matt, y, financialMetric))))

[CONCLUSION (GK)]:
AtRiskOf(matt, gamblingAddiction) <~> InvestInRegularly(matt, publicStockMarket) => -EnjoyVisiting(matt, theLasVegasStrip) &  -(ReadToKeepUpdatedOn(matt, theWallStreetJournal, financialMetric) |  (? [Y] : (-(Y=theWallStreetJournal) & NewsPaper(Y) & ReadToKeepUpdatedOn(matt, Y, financialMetric)))).


===

['x', 'y']
['x', 'y']
[PREMISE]:
People who like financial risks invest in the public stock market regularly or enjoy gambling regularly.
If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.
All people who enjoy enjoy gambling regularly spend a lot of money at casinos or other betting games.
People who spend a lot of money at casinos and other betting games would enjoy visiting the Las Vegas Strip.
People who spend a lot of money at casinos and other betting games are at risk of gambling addiction.
Matt does not invest in the public stock market regularly. 
Matt likes financial risks.

[PREMISE (FOL)]:
∀x (Like(x, financialRisk) → InvestInRegularly(x, publicStockMarket) ∨ EnjoyRegularly(x, gambling))
∀x (InvestInRegularly(x, publicStockMarket) → ReadToKeepUpdatedOn(x, theWallStreetJournal, financialMetric) ∨ (∃y (¬(y=theWallStreetJournal) ∧ NewsPaper(y) ∧ ReadToKeepUpdatedOn(x, y, financialMetric))))
∀x (EnjoyRegularly(x, gambling) → SpendAt(x, alotOfMoney, casino) ∨ (∃y (¬(y=casino) ∧ BettingGame(y) ∧ SpendAt(x, aLotOfMoney, y)))
∀x (SpendAt(x, alotOfMoney, casino) ∨ (∃y (¬(y=casino) ∧ BettingGame(y) ∧ SpendAt(x, aLotOfMoney, y))) → EnjoyVisiting(x, theLasVegasStrip))
∀x (SpendAt(x, alotOfMoney, casino) ∨ (∃y (¬(y=casino) ∧ BettingGame(y) ∧ SpendAt(x, aLotOfMoney, y)) → AtRiskOf(x, gamblingAddiction))
InvestInRegularly(matt, publicStockMarket)
Like(matt, financialRisk)

[PREMISE (GK)]:
! [X] : (Like(X, financialRisk) => InvestInRegularly(X, publicStockMarket) | EnjoyRegularly(X, gambling)).
! [X] : (InvestInRegularly(X, publicStockMarket) => ReadToKeepUpdatedOn(X, theWallStreetJournal, financialMetric) | (? [Y] : (-(Y=theWallStreetJournal) & NewsPaper(Y) & ReadToKeepUpdatedOn(X, Y, financialMetric)))).
! [X] : (EnjoyRegularly(X, gambling) => SpendAt(X, alotOfMoney, casino) | (? [Y] : (-(Y=casino) & BettingGame(Y) & SpendAt(X, aLotOfMoney, Y))).
! [X] : (SpendAt(X, alotOfMoney, casino) | (? [Y] : (-(Y=casino) & BettingGame(Y) & SpendAt(X, aLotOfMoney, Y))) => EnjoyVisiting(X, theLasVegasStrip)).
! [X] : (SpendAt(X, alotOfMoney, casino) | (? [Y] : (-(Y=casino) & BettingGame(Y) & SpendAt(X, aLotOfMoney, Y)) => AtRiskOf(X, gamblingAddiction)).
InvestInRegularly(matt, publicStockMarket).
Like(matt, financialRisk).

[CONCLUSION]:
Matt is not at risk of a gambling addiction and Mike does not both read the Wall Street Journal and other newspapers regularly and visits the Las Vegas Strip regularly.

[CONCLUSION (FOL)]:
¬AtRiskOf(matt, gamblingAddiction) ∧ ¬(ReadToKeepUpdatedOn(x, theWallStreetJournal, financialMetric) ∨ (∃y (¬(y=theWallStreetJournal) ∧ NewsPaper(y) ∧ ReadToKeepUpdatedOn(x, y, financialMetric))) ∧ EnjoyVisiting(matt, theLasVegasStrip))

[CONCLUSION (GK)]:
-AtRiskOf(matt, gamblingAddiction) & -(ReadToKeepUpdatedOn(X, theWallStreetJournal, financialMetric) | (? [Y] : (-(Y=theWallStreetJournal) & NewsPaper(Y) & ReadToKeepUpdatedOn(X, Y, financialMetric))) & EnjoyVisiting(matt, theLasVegasStrip)).


===

['x']
['x']
[PREMISE]:
All students learning piano can strike the right notes. 
All students who can strike the right note can get the rhythms right. 
If a student can get the rhythms right, he will start working on coordination between the left and the right hands. 
Some students who start working on coordination between the left and the right hands become good at it, while other students find it challenging. 
If John can strike the right notes, get the rhythms right, and is good at coordination between right and left hands, then he puts emotions into his playing. 
John is a student learning piano. 
John does not find coordination between the left and the right hands challenging. 

[PREMISE (FOL)]:
∀x (Student(x) ∧ LearningPiano(x) → Can(x, strike, rightNote))
∀x (Student(x) ∧  Can(x, strike, rightNote) → Can(x, getTheRhythmRight))
∀x (Student(x) ∧ Can(x, getTheRhythmRight) → Start(x, workingOnCoordinationBetweenTheLeftAndRightHands))
∀x (Student(x) ∧ Start(x, workingOnCoordinationBetweenTheLeftAndRightHands) → Become(x, goodAtCoordination) ⊕ Find(x, coordinationChallenging))
(Can(john, getTheRhythmRight) ∧ Can(john, getTheRhythmRight)) ∧  Become(john, goodAtCoordination)  → PutEmotionInto(john, hisPlaying)
Student(john) ∧ LearningPiano(john)
¬Find(john, coordinationChallenging)

[PREMISE (GK)]:
! [X] : (Student(X) & LearningPiano(X) => Can(X, strike, rightNote)).
! [X] : (Student(X) &  Can(X, strike, rightNote) => Can(X, getTheRhythmRight)).
! [X] : (Student(X) & Can(X, getTheRhythmRight) => Start(X, workingOnCoordinationBetweenTheLeftAndRightHands)).
! [X] : (Student(X) & Start(X, workingOnCoordinationBetweenTheLeftAndRightHands) => Become(X, goodAtCoordination) <~> Find(X, coordinationChallenging)).
(Can(john, getTheRhythmRight) & Can(john, getTheRhythmRight)) &  Become(john, goodAtCoordination)  => PutEmotionInto(john, hisPlaying).
Student(john) & LearningPiano(john).
-Find(john, coordinationChallenging).

[CONCLUSION]:
John can get the rhythms right.

[CONCLUSION (FOL)]:
Can(john, getTheRhythmRight)

[CONCLUSION (GK)]:
Can(john, getTheRhythmRight).


===

['x']
['x']
[PREMISE]:
All students learning piano can strike the right notes. 
All students who can strike the right note can get the rhythms right. 
If a student can get the rhythms right, he will start working on coordination between the left and the right hands. 
Some students who start working on coordination between the left and the right hands become good at it, while other students find it challenging. 
If John can strike the right notes, get the rhythms right, and is good at coordination between right and left hands, then he puts emotions into his playing. 
John is a student learning piano. 
John does not find coordination between the left and the right hands challenging. 

[PREMISE (FOL)]:
∀x (Student(x) ∧ LearningPiano(x) → Can(x, strike, rightNote))
∀x (Student(x) ∧  Can(x, strike, rightNote) → Can(x, getTheRhythmRight))
∀x (Student(x) ∧ Can(x, getTheRhythmRight) → Start(x, workingOnCoordinationBetweenTheLeftAndRightHands))
∀x (Student(x) ∧ Start(x, workingOnCoordinationBetweenTheLeftAndRightHands) → Become(x, goodAtCoordination) ⊕ Find(x, coordinationChallenging))
(Can(john, getTheRhythmRight) ∧ Can(john, getTheRhythmRight)) ∧  Become(john, goodAtCoordination)  → PutEmotionInto(john, hisPlaying)
Student(john) ∧ LearningPiano(john)
¬Find(john, coordinationChallenging)

[PREMISE (GK)]:
! [X] : (Student(X) & LearningPiano(X) => Can(X, strike, rightNote)).
! [X] : (Student(X) &  Can(X, strike, rightNote) => Can(X, getTheRhythmRight)).
! [X] : (Student(X) & Can(X, getTheRhythmRight) => Start(X, workingOnCoordinationBetweenTheLeftAndRightHands)).
! [X] : (Student(X) & Start(X, workingOnCoordinationBetweenTheLeftAndRightHands) => Become(X, goodAtCoordination) <~> Find(X, coordinationChallenging)).
(Can(john, getTheRhythmRight) & Can(john, getTheRhythmRight)) &  Become(john, goodAtCoordination)  => PutEmotionInto(john, hisPlaying).
Student(john) & LearningPiano(john).
-Find(john, coordinationChallenging).

[CONCLUSION]:
John does not put emotions into his playing.

[CONCLUSION (FOL)]:
PutEmotionInto(john, hisPlaying)

[CONCLUSION (GK)]:
PutEmotionInto(john, hisPlaying).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Barbara Ann Marshall is a former swimmer and former world record-holder.
Barbara Ann Marshall participated in the 1972 Summer Olympics.
Barbara Ann Marshall's home country is the United States.
All people who competed in the 1972 Summer Olympics represented their home country.
Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.
Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.
Only relay swimmers who participated in the final event at the 1972 Summer Olympics received medals.

[PREMISE (FOL)]:
FormerSwimmer(barbaraAnnMarshall) ∧ FormerWorldRecordHolder(barbaraAnnMarshall)
ParticipatedIn(barbaraAnnMarshall, 1972SummerOlympics)
HomeCountry(barbaraAnnMarshall, unitedStates)
∀x ∃y (ParticipatedIn(x, 1972SummerOlympics) ∧ HomeCountry(x, y) → Represented(x, y))
ParticipatedIn(barbaraAnnMarshall, preliminaryHeatFreestyleRelay)
¬ParticipatedIn(barbaraAnnMarshall, finalHeatFreestyleRelay)
∀x ((ParticipatedIn(x, 1972SummerOlympics) ∧ RelaySwimmer(x) ∧ ¬ParticipatedIn(x, finalHeatFreestyleRelay)) ↔ ¬Recieved(x, medal)))

[PREMISE (GK)]:
FormerSwimmer(barbaraAnnMarshall) & FormerWorldRecordHolder(barbaraAnnMarshall).
ParticipatedIn(barbaraAnnMarshall, 1972SummerOlympics).
HomeCountry(barbaraAnnMarshall, unitedStates).
! [X] : ? [Y] : (ParticipatedIn(X, 1972SummerOlympics) & HomeCountry(X, Y) => Represented(X, Y)).
ParticipatedIn(barbaraAnnMarshall, preliminaryHeatFreestyleRelay).
-ParticipatedIn(barbaraAnnMarshall, finalHeatFreestyleRelay).
! [X] : ((ParticipatedIn(X, 1972SummerOlympics) & RelaySwimmer(X) & -ParticipatedIn(X, finalHeatFreestyleRelay)) ↔ -Recieved(X, medal))).

[CONCLUSION]:
Barbara Ann Marshall did not receive medals.

[CONCLUSION (FOL)]:
¬Recieved(barbaraAnnMarshall, medal)

[CONCLUSION (GK)]:
-Recieved(barbaraAnnMarshall, medal).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Barbara Ann Marshall is a former swimmer and former world record-holder.
Barbara Ann Marshall participated in the 1972 Summer Olympics.
Barbara Ann Marshall's home country is the United States.
All people who competed in the 1972 Summer Olympics represented their home country.
Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.
Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.
Only relay swimmers who participated in the final event at the 1972 Summer Olympics received medals.

[PREMISE (FOL)]:
FormerSwimmer(barbaraAnnMarshall) ∧ FormerWorldRecordHolder(barbaraAnnMarshall)
ParticipatedIn(barbaraAnnMarshall, 1972SummerOlympics)
HomeCountry(barbaraAnnMarshall, unitedStates)
∀x ∃y (ParticipatedIn(x, 1972SummerOlympics) ∧ HomeCountry(x, y) → Represented(x, y))
ParticipatedIn(barbaraAnnMarshall, preliminaryHeatFreestyleRelay)
¬ParticipatedIn(barbaraAnnMarshall, finalHeatFreestyleRelay)
∀x ((ParticipatedIn(x, 1972SummerOlympics) ∧ RelaySwimmer(x) ∧ ¬ParticipatedIn(x, finalHeatFreestyleRelay)) ↔ ¬Recieved(x, medal)))

[PREMISE (GK)]:
FormerSwimmer(barbaraAnnMarshall) & FormerWorldRecordHolder(barbaraAnnMarshall).
ParticipatedIn(barbaraAnnMarshall, 1972SummerOlympics).
HomeCountry(barbaraAnnMarshall, unitedStates).
! [X] : ? [Y] : (ParticipatedIn(X, 1972SummerOlympics) & HomeCountry(X, Y) => Represented(X, Y)).
ParticipatedIn(barbaraAnnMarshall, preliminaryHeatFreestyleRelay).
-ParticipatedIn(barbaraAnnMarshall, finalHeatFreestyleRelay).
! [X] : ((ParticipatedIn(X, 1972SummerOlympics) & RelaySwimmer(X) & -ParticipatedIn(X, finalHeatFreestyleRelay)) ↔ -Recieved(X, medal))).

[CONCLUSION]:
Barbara Ann Marshall represented the United States in the 1972 Summer Olympics.

[CONCLUSION (FOL)]:
Represented(barbaraAnnMarshall, unitedStates)

[CONCLUSION (GK)]:
Represented(barbaraAnnMarshall, unitedStates).


===

['w', 'x', 'y']
['w', 'x', 'y']
[PREMISE]:
A game is played with three stages: red stage, yellow stage, and green stage.
Each player begins at the red stage.
All players must reach the yellow stage before they can reach the green stage.
The yellow stage comes after the red stage.
All players must proceed one stage at a time.

[PREMISE (FOL)]:
∃x ∃y ∃y ∃w (Game(x) ∧ StageNumber(x,3) ∧ Stage(y) ∧ Stage(z) ∧ Stage(w) ∧ ¬(y=z) ∧ ¬(z=w) ∧ ¬(y=w) ∧ Red(y) ∧ Yellow(z) ∧ Green(w))
∀x (Player(x) → StartRed(x))
∀x (Player(x) ∧ ¬ReachYellow(x) → ¬ReachGreen(x))
∀x (Player(x) ∧ StartRed(x) → ReachYellow(x))
∀x (Player(x) ∧ StartRed(x) ∧ ¬ReachYellow(x) → ¬ReachGreen(x))

[PREMISE (GK)]:
? [X] : ? [Y] : ? [Y] : ? [W] : (Game(X) & StageNumber(X,3) & Stage(Y) & Stage(z) & Stage(W) & -(Y=z) & -(z=W) & -(Y=W) & Red(Y) & Yellow(z) & Green(W)).
! [X] : (Player(X) => StartRed(X)).
! [X] : (Player(X) & -ReachYellow(X) => -ReachGreen(X)).
! [X] : (Player(X) & StartRed(X) => ReachYellow(X)).
! [X] : (Player(X) & StartRed(X) & -ReachYellow(X) => -ReachGreen(X)).

[CONCLUSION]:
It is possible to move to the green stage without ever reaching the yellow stage.

[CONCLUSION (FOL)]:
∃x (Player(x) ∧ RedToGreen(x))

[CONCLUSION (GK)]:
? [X] : (Player(X) & RedToGreen(X)).


===

['w', 'x', 'y']
['w', 'x', 'y']
[PREMISE]:
A game is played with three stages: red stage, yellow stage, and green stage.
Each player begins at the red stage.
All players must reach the yellow stage before they can reach the green stage.
The yellow stage comes after the red stage.
All players must proceed one stage at a time.

[PREMISE (FOL)]:
∃x ∃y ∃y ∃w (Game(x) ∧ StageNumber(x,3) ∧ Stage(y) ∧ Stage(z) ∧ Stage(w) ∧ ¬(y=z) ∧ ¬(z=w) ∧ ¬(y=w) ∧ Red(y) ∧ Yellow(z) ∧ Green(w))
∀x (Player(x) → StartRed(x))
∀x (Player(x) ∧ ¬ReachYellow(x) → ¬ReachGreen(x))
∀x (Player(x) ∧ StartRed(x) → ReachYellow(x))
∀x (Player(x) ∧ StartRed(x) ∧ ¬ReachYellow(x) → ¬ReachGreen(x))

[PREMISE (GK)]:
? [X] : ? [Y] : ? [Y] : ? [W] : (Game(X) & StageNumber(X,3) & Stage(Y) & Stage(z) & Stage(W) & -(Y=z) & -(z=W) & -(Y=W) & Red(Y) & Yellow(z) & Green(W)).
! [X] : (Player(X) => StartRed(X)).
! [X] : (Player(X) & -ReachYellow(X) => -ReachGreen(X)).
! [X] : (Player(X) & StartRed(X) => ReachYellow(X)).
! [X] : (Player(X) & StartRed(X) & -ReachYellow(X) => -ReachGreen(X)).

[CONCLUSION]:
It is possible to reach the yellow stage without ever reaching the green stage.

[CONCLUSION (FOL)]:
∃x (Player(x) ∧ RedToYellow(x))

[CONCLUSION (GK)]:
? [X] : (Player(X) & RedToYellow(X)).


===

['w', 'x', 'y']
['w', 'x', 'y']
[PREMISE]:
A game is played with three stages: red stage, yellow stage, and green stage.
Each player begins at the red stage.
All players must reach the yellow stage before they can reach the green stage.
The yellow stage comes after the red stage.
All players must proceed one stage at a time.

[PREMISE (FOL)]:
∃x ∃y ∃y ∃w (Game(x) ∧ StageNumber(x,3) ∧ Stage(y) ∧ Stage(z) ∧ Stage(w) ∧ ¬(y=z) ∧ ¬(z=w) ∧ ¬(y=w) ∧ Red(y) ∧ Yellow(z) ∧ Green(w))
∀x (Player(x) → StartRed(x))
∀x (Player(x) ∧ ¬ReachYellow(x) → ¬ReachGreen(x))
∀x (Player(x) ∧ StartRed(x) → ReachYellow(x))
∀x (Player(x) ∧ StartRed(x) ∧ ¬ReachYellow(x) → ¬ReachGreen(x))

[PREMISE (GK)]:
? [X] : ? [Y] : ? [Y] : ? [W] : (Game(X) & StageNumber(X,3) & Stage(Y) & Stage(z) & Stage(W) & -(Y=z) & -(z=W) & -(Y=W) & Red(Y) & Yellow(z) & Green(W)).
! [X] : (Player(X) => StartRed(X)).
! [X] : (Player(X) & -ReachYellow(X) => -ReachGreen(X)).
! [X] : (Player(X) & StartRed(X) => ReachYellow(X)).
! [X] : (Player(X) & StartRed(X) & -ReachYellow(X) => -ReachGreen(X)).

[CONCLUSION]:
It is possible to complete the game without ever reaching the green stage.

[CONCLUSION (FOL)]:
∃x (Player(x) ∧ CompleteGame(x))

[CONCLUSION (GK)]:
? [X] : (Player(X) & CompleteGame(X)).


===

['x']
['x']
[PREMISE]:
In Love City, everyone considers physical touch or words of affirmation to be their most important love language.
If someone in Love City considers physical touch as their most important love language, then they are good with pets.
If someone in Love City is good with pets, then they are not scared of animals.
In Love City, everyone is scared of animals, or loves animals, or both.
Adam, who is in Love City, either values physical touch as his most important love language or loves animals.

[PREMISE (FOL)]:
∀x (In(x, loveCity) → (ConsidersMostImportantLoveLanguage(x, physicalTouch)  ∨ ConsidersMostImportantLoveLanguage(x, wordOfAffirmation))
∀x ((ConsidersMostImportantLoveLanguage(x, physicalTouch)  ∧ In(x, loveCity) → GoodWith(x, pet))
∀x ((GoodWith(x, pet) ∧ In(x, loveCity)) → ¬ScaredOf(x, animal))
∀x (In(x, loveCity) → (ScaredOf(x, animal) ∨ Loves(x, animal)))
(ConsidersMostImportantLoveLanguage(adam, physicalTouch) ⊕ Loves(adam, animal)) ∧ In(adam, loveCity)

[PREMISE (GK)]:
! [X] : (In(X, loveCity) => (ConsidersMostImportantLoveLanguage(X, physicalTouch)  | ConsidersMostImportantLoveLanguage(X, wordOfAffirmation)).
! [X] : ((ConsidersMostImportantLoveLanguage(X, physicalTouch)  & In(X, loveCity) => GoodWith(X, pet)).
! [X] : ((GoodWith(X, pet) & In(X, loveCity)) => -ScaredOf(X, animal)).
! [X] : (In(X, loveCity) => (ScaredOf(X, animal) | Loves(X, animal))).
(ConsidersMostImportantLoveLanguage(adam, physicalTouch) <~> Loves(adam, animal)) & In(adam, loveCity).

[CONCLUSION]:
Adam is scared of animals.

[CONCLUSION (FOL)]:
ScaredOf(adam, animal)

[CONCLUSION (GK)]:
ScaredOf(adam, animal).


===

['x']
['x']
[PREMISE]:
In Love City, everyone considers physical touch or words of affirmation to be their most important love language.
If someone in Love City considers physical touch as their most important love language, then they are good with pets.
If someone in Love City is good with pets, then they are not scared of animals.
In Love City, everyone is scared of animals, or loves animals, or both.
Adam, who is in Love City, either values physical touch as his most important love language or loves animals.

[PREMISE (FOL)]:
∀x (In(x, loveCity) → (ConsidersMostImportantLoveLanguage(x, physicalTouch)  ∨ ConsidersMostImportantLoveLanguage(x, wordOfAffirmation))
∀x ((ConsidersMostImportantLoveLanguage(x, physicalTouch)  ∧ In(x, loveCity) → GoodWith(x, pet))
∀x ((GoodWith(x, pet) ∧ In(x, loveCity)) → ¬ScaredOf(x, animal))
∀x (In(x, loveCity) → (ScaredOf(x, animal) ∨ Loves(x, animal)))
(ConsidersMostImportantLoveLanguage(adam, physicalTouch) ⊕ Loves(adam, animal)) ∧ In(adam, loveCity)

[PREMISE (GK)]:
! [X] : (In(X, loveCity) => (ConsidersMostImportantLoveLanguage(X, physicalTouch)  | ConsidersMostImportantLoveLanguage(X, wordOfAffirmation)).
! [X] : ((ConsidersMostImportantLoveLanguage(X, physicalTouch)  & In(X, loveCity) => GoodWith(X, pet)).
! [X] : ((GoodWith(X, pet) & In(X, loveCity)) => -ScaredOf(X, animal)).
! [X] : (In(X, loveCity) => (ScaredOf(X, animal) | Loves(X, animal))).
(ConsidersMostImportantLoveLanguage(adam, physicalTouch) <~> Loves(adam, animal)) & In(adam, loveCity).

[CONCLUSION]:
Adam considers words of affirmation to be the most important love language.

[CONCLUSION (FOL)]:
ConsidersMostImportantLoveLanguage(adam, wordOfAffirmation)

[CONCLUSION (GK)]:
ConsidersMostImportantLoveLanguage(adam, wordOfAffirmation).


===

['x']
['x']
[PREMISE]:
In Love City, everyone considers physical touch or words of affirmation to be their most important love language.
If someone in Love City considers physical touch as their most important love language, then they are good with pets.
If someone in Love City is good with pets, then they are not scared of animals.
In Love City, everyone is scared of animals, or loves animals, or both.
Adam, who is in Love City, either values physical touch as his most important love language or loves animals.

[PREMISE (FOL)]:
∀x (In(x, loveCity) → (ConsidersMostImportantLoveLanguage(x, physicalTouch)  ∨ ConsidersMostImportantLoveLanguage(x, wordOfAffirmation))
∀x ((ConsidersMostImportantLoveLanguage(x, physicalTouch)  ∧ In(x, loveCity) → GoodWith(x, pet))
∀x ((GoodWith(x, pet) ∧ In(x, loveCity)) → ¬ScaredOf(x, animal))
∀x (In(x, loveCity) → (ScaredOf(x, animal) ∨ Loves(x, animal)))
(ConsidersMostImportantLoveLanguage(adam, physicalTouch) ⊕ Loves(adam, animal)) ∧ In(adam, loveCity)

[PREMISE (GK)]:
! [X] : (In(X, loveCity) => (ConsidersMostImportantLoveLanguage(X, physicalTouch)  | ConsidersMostImportantLoveLanguage(X, wordOfAffirmation)).
! [X] : ((ConsidersMostImportantLoveLanguage(X, physicalTouch)  & In(X, loveCity) => GoodWith(X, pet)).
! [X] : ((GoodWith(X, pet) & In(X, loveCity)) => -ScaredOf(X, animal)).
! [X] : (In(X, loveCity) => (ScaredOf(X, animal) | Loves(X, animal))).
(ConsidersMostImportantLoveLanguage(adam, physicalTouch) <~> Loves(adam, animal)) & In(adam, loveCity).

[CONCLUSION]:
Adam considers physical touch as the most important love language and considers words of affirmation as the most important love language.

[CONCLUSION (FOL)]:
ConsidersMostImportantLoveLanguage(adam, physicalTouch) ∧ ConsidersMostImportantLoveLanguage(adam, wordOfAffirmation)

[CONCLUSION (GK)]:
ConsidersMostImportantLoveLanguage(adam, physicalTouch) & ConsidersMostImportantLoveLanguage(adam, wordOfAffirmation).


===

['x']
['x']
[PREMISE]:
In Love City, everyone considers physical touch or words of affirmation to be their most important love language.
If someone in Love City considers physical touch as their most important love language, then they are good with pets.
If someone in Love City is good with pets, then they are not scared of animals.
In Love City, everyone is scared of animals, or loves animals, or both.
Adam, who is in Love City, either values physical touch as his most important love language or loves animals.

[PREMISE (FOL)]:
∀x (In(x, loveCity) → (ConsidersMostImportantLoveLanguage(x, physicalTouch)  ∨ ConsidersMostImportantLoveLanguage(x, wordOfAffirmation))
∀x ((ConsidersMostImportantLoveLanguage(x, physicalTouch)  ∧ In(x, loveCity) → GoodWith(x, pet))
∀x ((GoodWith(x, pet) ∧ In(x, loveCity)) → ¬ScaredOf(x, animal))
∀x (In(x, loveCity) → (ScaredOf(x, animal) ∨ Loves(x, animal)))
(ConsidersMostImportantLoveLanguage(adam, physicalTouch) ⊕ Loves(adam, animal)) ∧ In(adam, loveCity)

[PREMISE (GK)]:
! [X] : (In(X, loveCity) => (ConsidersMostImportantLoveLanguage(X, physicalTouch)  | ConsidersMostImportantLoveLanguage(X, wordOfAffirmation)).
! [X] : ((ConsidersMostImportantLoveLanguage(X, physicalTouch)  & In(X, loveCity) => GoodWith(X, pet)).
! [X] : ((GoodWith(X, pet) & In(X, loveCity)) => -ScaredOf(X, animal)).
! [X] : (In(X, loveCity) => (ScaredOf(X, animal) | Loves(X, animal))).
(ConsidersMostImportantLoveLanguage(adam, physicalTouch) <~> Loves(adam, animal)) & In(adam, loveCity).

[CONCLUSION]:
Adam either values physical touch as an especially important love language or values words of affirmation as an especially important love language.

[CONCLUSION (FOL)]:
ConsidersMostImportantLoveLanguage(adam, physicalTouch) ⊕ ConsidersMostImportantLoveLanguage(adam, wordOfAffirmation)

[CONCLUSION (GK)]:
ConsidersMostImportantLoveLanguage(adam, physicalTouch) <~> ConsidersMostImportantLoveLanguage(adam, wordOfAffirmation).


===

['x']
['x']
[PREMISE]:
In Love City, everyone considers physical touch or words of affirmation to be their most important love language.
If someone in Love City considers physical touch as their most important love language, then they are good with pets.
If someone in Love City is good with pets, then they are not scared of animals.
In Love City, everyone is scared of animals, or loves animals, or both.
Adam, who is in Love City, either values physical touch as his most important love language or loves animals.

[PREMISE (FOL)]:
∀x (In(x, loveCity) → (ConsidersMostImportantLoveLanguage(x, physicalTouch)  ∨ ConsidersMostImportantLoveLanguage(x, wordOfAffirmation))
∀x ((ConsidersMostImportantLoveLanguage(x, physicalTouch)  ∧ In(x, loveCity) → GoodWith(x, pet))
∀x ((GoodWith(x, pet) ∧ In(x, loveCity)) → ¬ScaredOf(x, animal))
∀x (In(x, loveCity) → (ScaredOf(x, animal) ∨ Loves(x, animal)))
(ConsidersMostImportantLoveLanguage(adam, physicalTouch) ⊕ Loves(adam, animal)) ∧ In(adam, loveCity)

[PREMISE (GK)]:
! [X] : (In(X, loveCity) => (ConsidersMostImportantLoveLanguage(X, physicalTouch)  | ConsidersMostImportantLoveLanguage(X, wordOfAffirmation)).
! [X] : ((ConsidersMostImportantLoveLanguage(X, physicalTouch)  & In(X, loveCity) => GoodWith(X, pet)).
! [X] : ((GoodWith(X, pet) & In(X, loveCity)) => -ScaredOf(X, animal)).
! [X] : (In(X, loveCity) => (ScaredOf(X, animal) | Loves(X, animal))).
(ConsidersMostImportantLoveLanguage(adam, physicalTouch) <~> Loves(adam, animal)) & In(adam, loveCity).

[CONCLUSION]:
If Adam values physical touch as an especially important love language or is good with pets, then Adam values words of affirmation as an especially important love language.

[CONCLUSION (FOL)]:
(ConsidersMostImportantLoveLanguage(adam, physicalTouch, mostImportantLoveLanguage) ∨ GoodWith(x, pet)) → ConsidersMostImportantLoveLanguage(adam, wordOfAffirmation)

[CONCLUSION (GK)]:
(ConsidersMostImportantLoveLanguage(adam, physicalTouch, mostImportantLoveLanguage) | GoodWith(X, pet)) => ConsidersMostImportantLoveLanguage(adam, wordOfAffirmation).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
All birds have wings.
Animals with wings aren't reptiles.
Some animals that fly are birds.
If something is an iguana, then it is a reptile. Simeng: All iguanas are reptiles. 
John is either both an iguana and a bird, or he is neither. 
John is an animal. 

[PREMISE (FOL)]:
∀x (Bird(x) → ∃y ∃z (¬(y=z) ∧ Wing(y) ∧ Wing(z) ∧ Have(x, y) ∧ Have(x, z)))
∀x (Animal(x) ∧ (∃y ∃z (¬(y=z) ∧ Wing(y) ∧ Wing(z) ∧ Have(x, y) ∧ Have(x, z))) → ¬Reptile(x))
∃x (Animal(x) ∧ Fly(x) ∧ Bird(x))
∀x (Iguana(x) → Reptile(x))
¬(Iguana(john) ⊕ Bird(john))
Animal(john)

[PREMISE (GK)]:
! [X] : (Bird(X) => ? [Y] : ? [Z] : (-(Y=Z) & Wing(Y) & Wing(Z) & Have(X, Y) & Have(X, Z))).
! [X] : (Animal(X) & (? [Y] : ? [Z] : (-(Y=Z) & Wing(Y) & Wing(Z) & Have(X, Y) & Have(X, Z))) => -Reptile(X)).
? [X] : (Animal(X) & Fly(X) & Bird(X)).
! [X] : (Iguana(X) => Reptile(X)).
-(Iguana(john) <~> Bird(john)).
Animal(john).

[CONCLUSION]:
John is a reptile.

[CONCLUSION (FOL)]:
Reptile(john)

[CONCLUSION (GK)]:
Reptile(john).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
All birds have wings.
Animals with wings aren't reptiles.
Some animals that fly are birds.
If something is an iguana, then it is a reptile. Simeng: All iguanas are reptiles. 
John is either both an iguana and a bird, or he is neither. 
John is an animal. 

[PREMISE (FOL)]:
∀x (Bird(x) → ∃y ∃z (¬(y=z) ∧ Wing(y) ∧ Wing(z) ∧ Have(x, y) ∧ Have(x, z)))
∀x (Animal(x) ∧ (∃y ∃z (¬(y=z) ∧ Wing(y) ∧ Wing(z) ∧ Have(x, y) ∧ Have(x, z))) → ¬Reptile(x))
∃x (Animal(x) ∧ Fly(x) ∧ Bird(x))
∀x (Iguana(x) → Reptile(x))
¬(Iguana(john) ⊕ Bird(john))
Animal(john)

[PREMISE (GK)]:
! [X] : (Bird(X) => ? [Y] : ? [Z] : (-(Y=Z) & Wing(Y) & Wing(Z) & Have(X, Y) & Have(X, Z))).
! [X] : (Animal(X) & (? [Y] : ? [Z] : (-(Y=Z) & Wing(Y) & Wing(Z) & Have(X, Y) & Have(X, Z))) => -Reptile(X)).
? [X] : (Animal(X) & Fly(X) & Bird(X)).
! [X] : (Iguana(X) => Reptile(X)).
-(Iguana(john) <~> Bird(john)).
Animal(john).

[CONCLUSION]:
John is not both an iguana and an animal that can fly.

[CONCLUSION (FOL)]:
¬(Iguana(john) ∧ Fly(john))

[CONCLUSION (GK)]:
-(Iguana(john) & Fly(john)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
All birds have wings.
Animals with wings aren't reptiles.
Some animals that fly are birds.
If something is an iguana, then it is a reptile. Simeng: All iguanas are reptiles. 
John is either both an iguana and a bird, or he is neither. 
John is an animal. 

[PREMISE (FOL)]:
∀x (Bird(x) → ∃y ∃z (¬(y=z) ∧ Wing(y) ∧ Wing(z) ∧ Have(x, y) ∧ Have(x, z)))
∀x (Animal(x) ∧ (∃y ∃z (¬(y=z) ∧ Wing(y) ∧ Wing(z) ∧ Have(x, y) ∧ Have(x, z))) → ¬Reptile(x))
∃x (Animal(x) ∧ Fly(x) ∧ Bird(x))
∀x (Iguana(x) → Reptile(x))
¬(Iguana(john) ⊕ Bird(john))
Animal(john)

[PREMISE (GK)]:
! [X] : (Bird(X) => ? [Y] : ? [Z] : (-(Y=Z) & Wing(Y) & Wing(Z) & Have(X, Y) & Have(X, Z))).
! [X] : (Animal(X) & (? [Y] : ? [Z] : (-(Y=Z) & Wing(Y) & Wing(Z) & Have(X, Y) & Have(X, Z))) => -Reptile(X)).
? [X] : (Animal(X) & Fly(X) & Bird(X)).
! [X] : (Iguana(X) => Reptile(X)).
-(Iguana(john) <~> Bird(john)).
Animal(john).

[CONCLUSION]:
John is an animal that can fly and John is a bird.

[CONCLUSION (FOL)]:
Animal(john) ∧ Fly(john) ∧ Bird(john)

[CONCLUSION (GK)]:
Animal(john) & Fly(john) & Bird(john).


===

['x', 'y']
['x', 'y']
[PREMISE]:
EndGame is a movie released in 2006.
EndGame was set in Washington.
EndGame was filmed outside of Washington.
Some movies are filmed in New York.
Andy Chang directed EndGame.
Andy Chang is from Hong Kong.

[PREMISE (FOL)]:
Movie(endGame) ∧ Released(endGame, yr2006)
SetIn(endGame, washington)
¬(FilmedIn(endGame, washington))
∃x∃y(FilmedIn(x, newYork) ∧ (¬(x=y)) ∧ FilmedIn(y, newYork))
Directed(andyChang, endGame)
From(andyChang, hongKong)

[PREMISE (GK)]:
Movie(endGame) & Released(endGame, yr2006).
SetIn(endGame, washington).
-(FilmedIn(endGame, washington)).
? [X] :? [Y] :(FilmedIn(X, newYork) & (-(X=Y)) & FilmedIn(Y, newYork)).
Directed(andyChang, endGame).
From(andyChang, hongKong).

[CONCLUSION]:
EndGame was filmed in New York.

[CONCLUSION (FOL)]:
FilmedIn(endGame, newYork)

[CONCLUSION (GK)]:
FilmedIn(endGame, newYork).


===

['x', 'y']
['x', 'y']
[PREMISE]:
EndGame is a movie released in 2006.
EndGame was set in Washington.
EndGame was filmed outside of Washington.
Some movies are filmed in New York.
Andy Chang directed EndGame.
Andy Chang is from Hong Kong.

[PREMISE (FOL)]:
Movie(endGame) ∧ Released(endGame, yr2006)
SetIn(endGame, washington)
¬(FilmedIn(endGame, washington))
∃x∃y(FilmedIn(x, newYork) ∧ (¬(x=y)) ∧ FilmedIn(y, newYork))
Directed(andyChang, endGame)
From(andyChang, hongKong)

[PREMISE (GK)]:
Movie(endGame) & Released(endGame, yr2006).
SetIn(endGame, washington).
-(FilmedIn(endGame, washington)).
? [X] :? [Y] :(FilmedIn(X, newYork) & (-(X=Y)) & FilmedIn(Y, newYork)).
Directed(andyChang, endGame).
From(andyChang, hongKong).

[CONCLUSION]:
EndGame was not directed by someone from Hong Kong.

[CONCLUSION (FOL)]:
∀x (¬(Directed(x, endGame) ∧ From(x, hongKong)))

[CONCLUSION (GK)]:
! [X] : (-(Directed(X, endGame) & From(X, hongKong))).


===

['x', 'y']
['x', 'y']
[PREMISE]:
EndGame is a movie released in 2006.
EndGame was set in Washington.
EndGame was filmed outside of Washington.
Some movies are filmed in New York.
Andy Chang directed EndGame.
Andy Chang is from Hong Kong.

[PREMISE (FOL)]:
Movie(endGame) ∧ Released(endGame, yr2006)
SetIn(endGame, washington)
¬(FilmedIn(endGame, washington))
∃x∃y(FilmedIn(x, newYork) ∧ (¬(x=y)) ∧ FilmedIn(y, newYork))
Directed(andyChang, endGame)
From(andyChang, hongKong)

[PREMISE (GK)]:
Movie(endGame) & Released(endGame, yr2006).
SetIn(endGame, washington).
-(FilmedIn(endGame, washington)).
? [X] :? [Y] :(FilmedIn(X, newYork) & (-(X=Y)) & FilmedIn(Y, newYork)).
Directed(andyChang, endGame).
From(andyChang, hongKong).

[CONCLUSION]:
All of Andy Chang's movies are filmed outside of Washington.

[CONCLUSION (FOL)]:
∀x (Directed(andyChang, x) → ¬(FilmedIn(x, washington)))

[CONCLUSION (GK)]:
! [X] : (Directed(andyChang, X) => -(FilmedIn(X, washington))).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Six, seven and eight are real numbers.
If a real number equals another real number added by one, the first number is larger.
If the number x is larger than the number y, then y is not larger than x.
Seven equals six plus one.
Eight equals seven plus one.
Two is positive.
If a number is positive, then the double of it is also positive.
Eight is the double of four.
Four is the double of two.

[PREMISE (FOL)]:
RealNum(num6) ∧ RealNum(num7) ∧ RealNum(num8)
∀x ∀y ((RealNum(x) ∧ RealNum(y) ∧ IsSuccessorOf(x, y)) → Larger(x, y))
∀x ∀y (Larger(x, y) → ¬Larger(y, x))
∃y(IsSuccessorOf(y, num6) ∧ Equals(num7, y))
∃y(IsSuccessorOf(y, num7) ∧ Equals(num8, y))
Positive(num2)
∀x ∀y ((Positive(x) ∧ IsDouble(y, x)) → Positive(y))
IsDouble(num8, num4)
IsDouble(num4, num2)

[PREMISE (GK)]:
RealNum(num6) & RealNum(num7) & RealNum(num8).
! [X] : ! [Y] : ((RealNum(X) & RealNum(Y) & IsSuccessorOf(X, Y)) => Larger(X, Y)).
! [X] : ! [Y] : (Larger(X, Y) => -Larger(Y, X)).
? [Y] :(IsSuccessorOf(Y, num6) & Equals(num7, Y)).
? [Y] :(IsSuccessorOf(Y, num7) & Equals(num8, Y)).
Positive(num2).
! [X] : ! [Y] : ((Positive(X) & IsDouble(Y, X)) => Positive(Y)).
IsDouble(num8, num4).
IsDouble(num4, num2).

[CONCLUSION]:
Eight is larger than seven.

[CONCLUSION (FOL)]:
Larger(eight, seven)

[CONCLUSION (GK)]:
Larger(eight, seven).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Six, seven and eight are real numbers.
If a real number equals another real number added by one, the first number is larger.
If the number x is larger than the number y, then y is not larger than x.
Seven equals six plus one.
Eight equals seven plus one.
Two is positive.
If a number is positive, then the double of it is also positive.
Eight is the double of four.
Four is the double of two.

[PREMISE (FOL)]:
RealNum(num6) ∧ RealNum(num7) ∧ RealNum(num8)
∀x ∀y ((RealNum(x) ∧ RealNum(y) ∧ IsSuccessorOf(x, y)) → Larger(x, y))
∀x ∀y (Larger(x, y) → ¬Larger(y, x))
∃y(IsSuccessorOf(y, num6) ∧ Equals(num7, y))
∃y(IsSuccessorOf(y, num7) ∧ Equals(num8, y))
Positive(num2)
∀x ∀y ((Positive(x) ∧ IsDouble(y, x)) → Positive(y))
IsDouble(num8, num4)
IsDouble(num4, num2)

[PREMISE (GK)]:
RealNum(num6) & RealNum(num7) & RealNum(num8).
! [X] : ! [Y] : ((RealNum(X) & RealNum(Y) & IsSuccessorOf(X, Y)) => Larger(X, Y)).
! [X] : ! [Y] : (Larger(X, Y) => -Larger(Y, X)).
? [Y] :(IsSuccessorOf(Y, num6) & Equals(num7, Y)).
? [Y] :(IsSuccessorOf(Y, num7) & Equals(num8, Y)).
Positive(num2).
! [X] : ! [Y] : ((Positive(X) & IsDouble(Y, X)) => Positive(Y)).
IsDouble(num8, num4).
IsDouble(num4, num2).

[CONCLUSION]:
Eight is positive.

[CONCLUSION (FOL)]:
Positive(eight)

[CONCLUSION (GK)]:
Positive(eight).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Six, seven and eight are real numbers.
If a real number equals another real number added by one, the first number is larger.
If the number x is larger than the number y, then y is not larger than x.
Seven equals six plus one.
Eight equals seven plus one.
Two is positive.
If a number is positive, then the double of it is also positive.
Eight is the double of four.
Four is the double of two.

[PREMISE (FOL)]:
RealNum(num6) ∧ RealNum(num7) ∧ RealNum(num8)
∀x ∀y ((RealNum(x) ∧ RealNum(y) ∧ IsSuccessorOf(x, y)) → Larger(x, y))
∀x ∀y (Larger(x, y) → ¬Larger(y, x))
∃y(IsSuccessorOf(y, num6) ∧ Equals(num7, y))
∃y(IsSuccessorOf(y, num7) ∧ Equals(num8, y))
Positive(num2)
∀x ∀y ((Positive(x) ∧ IsDouble(y, x)) → Positive(y))
IsDouble(num8, num4)
IsDouble(num4, num2)

[PREMISE (GK)]:
RealNum(num6) & RealNum(num7) & RealNum(num8).
! [X] : ! [Y] : ((RealNum(X) & RealNum(Y) & IsSuccessorOf(X, Y)) => Larger(X, Y)).
! [X] : ! [Y] : (Larger(X, Y) => -Larger(Y, X)).
? [Y] :(IsSuccessorOf(Y, num6) & Equals(num7, Y)).
? [Y] :(IsSuccessorOf(Y, num7) & Equals(num8, Y)).
Positive(num2).
! [X] : ! [Y] : ((Positive(X) & IsDouble(Y, X)) => Positive(Y)).
IsDouble(num8, num4).
IsDouble(num4, num2).

[CONCLUSION]:
Six is larger than seven.

[CONCLUSION (FOL)]:
Larger(six, seven)

[CONCLUSION (GK)]:
Larger(six, seven).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All dogs sleep.
Some four-legged animals are dogs.

[PREMISE (FOL)]:
∀x (Dog(x) → Sleep(x))
∃x ∃y (FourLegged(x) ∧ Animal(x) ∧ Dog(x) ∧ FourLegged(y) ∧ Animal(y) ∧ Dog(y) ∧ ¬(x=y))

[PREMISE (GK)]:
! [X] : (Dog(X) => Sleep(X)).
? [X] : ? [Y] : (FourLegged(X) & Animal(X) & Dog(X) & FourLegged(Y) & Animal(Y) & Dog(Y) & -(X=Y)).

[CONCLUSION]:
Some four-legged animals sleep.

[CONCLUSION (FOL)]:
∃x ∃y (FourLegged(x) ∧ Animal(x) ∧ Sleeps(x) ∧ FourLegged(y) ∧ Animal(y) ∧ Sleeps(y) ∧ ¬(x=y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (FourLegged(X) & Animal(X) & Sleeps(X) & FourLegged(Y) & Animal(Y) & Sleeps(Y) & -(X=Y)).


===

['x']
['x']
[PREMISE]:
Everyone who is entitled to national social insurance coverage can have their medical bills partially covered. 
All PRC nationals are entitled to national social insurance coverage.
Everyone in the Franco-China diplomatic conference is either a PRC national or a French national, but not both. 
All French nationals are citizens of the European Union. 
All Spanish nationals are citizens of the European Union. 
No North Korean nationals are citizens of the European Union. 
Mei is at the Franco-China diplomatic conference. 
Either Mei is a North Korean and can have medical bills partially covered, or neither is true.

[PREMISE (FOL)]:
∀x (EntitledTo(x, nationalSocialInsuranceCoverage) → CanHavePartiallyCovered(x, medicalBills))
∀x (PRCNational(x) → EntitledTo(x, nationalSocialInsuranceCoverage))
∀x (In(x, franco-ChinaDiplomaticConference) → PRCNational(x) ⊕ FrenchNational(x))
∀x (FrenchNational(x) → CitizenOf(x, europeanUnion))
∀x (SpanishNational(x) → CitizenOf(x, europeanUnion))
∀x (NorthKoreanNational(x) → ¬CitizenOf(x, europeanUnion))
In(mei, franco-ChinaDiplomaticConference)
¬(NorthKoreanNational(mei) ⊕ CanHavePartiallyCovered(mei, medicalBills))

[PREMISE (GK)]:
! [X] : (EntitledTo(X, nationalSocialInsuranceCoverage) => CanHavePartiallyCovered(X, medicalBills)).
! [X] : (PRCNational(X) => EntitledTo(X, nationalSocialInsuranceCoverage)).
! [X] : (In(X, franco-ChinaDiplomaticConference) => PRCNational(X) <~> FrenchNational(X)).
! [X] : (FrenchNational(X) => CitizenOf(X, europeanUnion)).
! [X] : (SpanishNational(X) => CitizenOf(X, europeanUnion)).
! [X] : (NorthKoreanNational(X) => -CitizenOf(X, europeanUnion)).
In(mei, franco-ChinaDiplomaticConference).
-(NorthKoreanNational(mei) <~> CanHavePartiallyCovered(mei, medicalBills)).

[CONCLUSION]:
Mei is a PRC national.

[CONCLUSION (FOL)]:
PRCNational(mei)

[CONCLUSION (GK)]:
PRCNational(mei).


===

['x']
['x']
[PREMISE]:
Everyone who is entitled to national social insurance coverage can have their medical bills partially covered. 
All PRC nationals are entitled to national social insurance coverage.
Everyone in the Franco-China diplomatic conference is either a PRC national or a French national, but not both. 
All French nationals are citizens of the European Union. 
All Spanish nationals are citizens of the European Union. 
No North Korean nationals are citizens of the European Union. 
Mei is at the Franco-China diplomatic conference. 
Either Mei is a North Korean and can have medical bills partially covered, or neither is true.

[PREMISE (FOL)]:
∀x (EntitledTo(x, nationalSocialInsuranceCoverage) → CanHavePartiallyCovered(x, medicalBills))
∀x (PRCNational(x) → EntitledTo(x, nationalSocialInsuranceCoverage))
∀x (In(x, franco-ChinaDiplomaticConference) → PRCNational(x) ⊕ FrenchNational(x))
∀x (FrenchNational(x) → CitizenOf(x, europeanUnion))
∀x (SpanishNational(x) → CitizenOf(x, europeanUnion))
∀x (NorthKoreanNational(x) → ¬CitizenOf(x, europeanUnion))
In(mei, franco-ChinaDiplomaticConference)
¬(NorthKoreanNational(mei) ⊕ CanHavePartiallyCovered(mei, medicalBills))

[PREMISE (GK)]:
! [X] : (EntitledTo(X, nationalSocialInsuranceCoverage) => CanHavePartiallyCovered(X, medicalBills)).
! [X] : (PRCNational(X) => EntitledTo(X, nationalSocialInsuranceCoverage)).
! [X] : (In(X, franco-ChinaDiplomaticConference) => PRCNational(X) <~> FrenchNational(X)).
! [X] : (FrenchNational(X) => CitizenOf(X, europeanUnion)).
! [X] : (SpanishNational(X) => CitizenOf(X, europeanUnion)).
! [X] : (NorthKoreanNational(X) => -CitizenOf(X, europeanUnion)).
In(mei, franco-ChinaDiplomaticConference).
-(NorthKoreanNational(mei) <~> CanHavePartiallyCovered(mei, medicalBills)).

[CONCLUSION]:
Mei is not a PRC national.

[CONCLUSION (FOL)]:
¬PRCNational(mei)

[CONCLUSION (GK)]:
-PRCNational(mei).


===

['x']
['x']
[PREMISE]:
Everyone who is entitled to national social insurance coverage can have their medical bills partially covered. 
All PRC nationals are entitled to national social insurance coverage.
Everyone in the Franco-China diplomatic conference is either a PRC national or a French national, but not both. 
All French nationals are citizens of the European Union. 
All Spanish nationals are citizens of the European Union. 
No North Korean nationals are citizens of the European Union. 
Mei is at the Franco-China diplomatic conference. 
Either Mei is a North Korean and can have medical bills partially covered, or neither is true.

[PREMISE (FOL)]:
∀x (EntitledTo(x, nationalSocialInsuranceCoverage) → CanHavePartiallyCovered(x, medicalBills))
∀x (PRCNational(x) → EntitledTo(x, nationalSocialInsuranceCoverage))
∀x (In(x, franco-ChinaDiplomaticConference) → PRCNational(x) ⊕ FrenchNational(x))
∀x (FrenchNational(x) → CitizenOf(x, europeanUnion))
∀x (SpanishNational(x) → CitizenOf(x, europeanUnion))
∀x (NorthKoreanNational(x) → ¬CitizenOf(x, europeanUnion))
In(mei, franco-ChinaDiplomaticConference)
¬(NorthKoreanNational(mei) ⊕ CanHavePartiallyCovered(mei, medicalBills))

[PREMISE (GK)]:
! [X] : (EntitledTo(X, nationalSocialInsuranceCoverage) => CanHavePartiallyCovered(X, medicalBills)).
! [X] : (PRCNational(X) => EntitledTo(X, nationalSocialInsuranceCoverage)).
! [X] : (In(X, franco-ChinaDiplomaticConference) => PRCNational(X) <~> FrenchNational(X)).
! [X] : (FrenchNational(X) => CitizenOf(X, europeanUnion)).
! [X] : (SpanishNational(X) => CitizenOf(X, europeanUnion)).
! [X] : (NorthKoreanNational(X) => -CitizenOf(X, europeanUnion)).
In(mei, franco-ChinaDiplomaticConference).
-(NorthKoreanNational(mei) <~> CanHavePartiallyCovered(mei, medicalBills)).

[CONCLUSION]:
If Mei is either a North Korean or a Spanish national, then Mei is either both a French national and a citizen of the European Union, or neither a French national nor a citizen of the European Union.

[CONCLUSION (FOL)]:
NorthKoreanNational(mei) ⊕ SpanishNational(mei) → ¬(FrenchNational(mei) ⊕ European(mei))

[CONCLUSION (GK)]:
NorthKoreanNational(mei) <~> SpanishNational(mei) => -(FrenchNational(mei) <~> European(mei)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
No people who do not admit a mistake are good teachers.
Some well-informed people are people who do not admit a mistake.

[PREMISE (FOL)]:
∀x (¬Admit(x, mistake) → ¬GoodTeacher(x))
∃x ∃y (WellInformed(x) ∧ WellInformed(y) ∧ ¬Admit(x, mistake) ∧ ¬Admit(y, mistake) ∧ ¬(x=y))

[PREMISE (GK)]:
! [X] : (-Admit(X, mistake) => -GoodTeacher(X)).
? [X] : ? [Y] : (WellInformed(X) & WellInformed(Y) & -Admit(X, mistake) & -Admit(Y, mistake) & -(X=Y)).

[CONCLUSION]:
Some good teachers are not well-informed people.

[CONCLUSION (FOL)]:
∃x ∃y (GoodTeacher(x) ∧ GoodTeacher(y) ∧ ¬WellInformed(x) ∧ ¬WellInformed(y) ∧ ¬(x=y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (GoodTeacher(X) & GoodTeacher(Y) & -WellInformed(X) & -WellInformed(Y) & -(X=Y)).


===

['x']
['x']
[PREMISE]:
Philatelic literature is divided into the following categories: Stamp catalogs, Periodicals, Auction catalogs, Books, Bibliographies, and Background Material.
Mort is not a Stamp catalog.
Mort is not a periodical, auction catalog, bibliography, or background material.
Mort is a piece of Philatelic literature.

[PREMISE (FOL)]:
∀x (PhilatelicLit(x) → (Stamp(x) ∨ Periodical(x) ∨ Auction(x) ∨ Book(x) ∨ Bibliography(x) ∨ Background(x)))
¬Stamp(mort)
¬(Periodical(mort) ∨ Auction(mort) ∨ Bibliography(mort) ∨ Background(mort))
PhilatelicLit(mort)

[PREMISE (GK)]:
! [X] : (PhilatelicLit(X) => (Stamp(X) | Periodical(X) | Auction(X) | Book(X) | Bibliography(X) | Background(X))).
-Stamp(mort).
-(Periodical(mort) | Auction(mort) | Bibliography(mort) | Background(mort)).
PhilatelicLit(mort).

[CONCLUSION]:
Mort is background material.

[CONCLUSION (FOL)]:
Background(mort)

[CONCLUSION (GK)]:
Background(mort).


===

['x']
['x']
[PREMISE]:
Philatelic literature is divided into the following categories: Stamp catalogs, Periodicals, Auction catalogs, Books, Bibliographies, and Background Material.
Mort is not a Stamp catalog.
Mort is not a periodical, auction catalog, bibliography, or background material.
Mort is a piece of Philatelic literature.

[PREMISE (FOL)]:
∀x (PhilatelicLit(x) → (Stamp(x) ∨ Periodical(x) ∨ Auction(x) ∨ Book(x) ∨ Bibliography(x) ∨ Background(x)))
¬Stamp(mort)
¬(Periodical(mort) ∨ Auction(mort) ∨ Bibliography(mort) ∨ Background(mort))
PhilatelicLit(mort)

[PREMISE (GK)]:
! [X] : (PhilatelicLit(X) => (Stamp(X) | Periodical(X) | Auction(X) | Book(X) | Bibliography(X) | Background(X))).
-Stamp(mort).
-(Periodical(mort) | Auction(mort) | Bibliography(mort) | Background(mort)).
PhilatelicLit(mort).

[CONCLUSION]:
Eragon is a piece of Philatelic literature.

[CONCLUSION (FOL)]:
PhilatelicLit(eragon)

[CONCLUSION (GK)]:
PhilatelicLit(eragon).


===

[]
['x']
[PREMISE]:
Adventures of Rusty is a drama film and children's film.
Columbia Pictures produced Adventures of Rusty.
Tintin was produced by Paramount.
Tintin is an adventure film.

[PREMISE (FOL)]:
DramaFilm(adventuresOfRusty) ∧ ChildrensFilm(adventuresOfRusty)
Produces(columbiaPictures, adventuresOfRusty)
Produces(paramount, tintin)
AdventureFilm(tintin)

[PREMISE (GK)]:
DramaFilm(adventuresOfRusty) & ChildrensFilm(adventuresOfRusty).
Produces(columbiaPictures, adventuresOfRusty).
Produces(paramount, tintin).
AdventureFilm(tintin).

[CONCLUSION]:
Columbia pictures produced some drama film.

[CONCLUSION (FOL)]:
∃x (DramaFilm(x) ∧ Produces(columbiaPictures, x))

[CONCLUSION (GK)]:
? [X] : (DramaFilm(X) & Produces(columbiaPictures, X)).


===

[]
['x']
[PREMISE]:
Adventures of Rusty is a drama film and children's film.
Columbia Pictures produced Adventures of Rusty.
Tintin was produced by Paramount.
Tintin is an adventure film.

[PREMISE (FOL)]:
DramaFilm(adventuresOfRusty) ∧ ChildrensFilm(adventuresOfRusty)
Produces(columbiaPictures, adventuresOfRusty)
Produces(paramount, tintin)
AdventureFilm(tintin)

[PREMISE (GK)]:
DramaFilm(adventuresOfRusty) & ChildrensFilm(adventuresOfRusty).
Produces(columbiaPictures, adventuresOfRusty).
Produces(paramount, tintin).
AdventureFilm(tintin).

[CONCLUSION]:
Columbia pictures produced some adventure film.

[CONCLUSION (FOL)]:
∃x (AdventureFilm(x) ∧ Produces(columbiaPictures, x))

[CONCLUSION (GK)]:
? [X] : (AdventureFilm(X) & Produces(columbiaPictures, X)).


===

[]
['x']
[PREMISE]:
Adventures of Rusty is a drama film and children's film.
Columbia Pictures produced Adventures of Rusty.
Tintin was produced by Paramount.
Tintin is an adventure film.

[PREMISE (FOL)]:
DramaFilm(adventuresOfRusty) ∧ ChildrensFilm(adventuresOfRusty)
Produces(columbiaPictures, adventuresOfRusty)
Produces(paramount, tintin)
AdventureFilm(tintin)

[PREMISE (GK)]:
DramaFilm(adventuresOfRusty) & ChildrensFilm(adventuresOfRusty).
Produces(columbiaPictures, adventuresOfRusty).
Produces(paramount, tintin).
AdventureFilm(tintin).

[CONCLUSION]:
Paramount produces children's films.

[CONCLUSION (FOL)]:
∃x (ChildrensFilm(x) ∧ Produces(paramount, x))

[CONCLUSION (GK)]:
? [X] : (ChildrensFilm(X) & Produces(paramount, X)).


===

[]
['x']
[PREMISE]:
Adventures of Rusty is a drama film and children's film.
Columbia Pictures produced Adventures of Rusty.
Tintin was produced by Paramount.
Tintin is an adventure film.

[PREMISE (FOL)]:
DramaFilm(adventuresOfRusty) ∧ ChildrensFilm(adventuresOfRusty)
Produces(columbiaPictures, adventuresOfRusty)
Produces(paramount, tintin)
AdventureFilm(tintin)

[PREMISE (GK)]:
DramaFilm(adventuresOfRusty) & ChildrensFilm(adventuresOfRusty).
Produces(columbiaPictures, adventuresOfRusty).
Produces(paramount, tintin).
AdventureFilm(tintin).

[CONCLUSION]:
Paramount produces adventure films.

[CONCLUSION (FOL)]:
∃x (AdventureFilm(x) ∧ Produces(paramount, x))

[CONCLUSION (GK)]:
? [X] : (AdventureFilm(X) & Produces(paramount, X)).


===

[]
['x']
[PREMISE]:
Deng Xiaoping served as the paramount leader of the People's Republic of China.
Deng Xiaoping was praised for his reaffirmation of the reform program, as well as the reversion of Hong Kong to Chinese control and the return of Macau.
As the party's Secretary-General under Mao and Vice Premier in the 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.
Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward.
Mao Zedong died in 1976.
After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.

[PREMISE (FOL)]:
ParamountLeaderOf(dengXiaoping, peoplesRepublicOfChina)
PraisedFor(dengXiaoping, reaffirmationOfReformProgram) ∧ PraisedFor(dengXiaoping, reversionOfHongKong) ∧ PraisedFor(dengXiaoping, returnOfMacau)
PartysSecretaryGeneral(dengXiaoping) ∧ Under(dengXiaoping, mao) ∧ VicePremierInThe1950s(dengXiaoping) ∧ PresidedOver(dengXiaoping, antiRightistCampaign) ∧ LaunchedBy(antiRightistCampaign, mao)
InstrumentalIn(dengXiaoping, chinasEconomicReconstruction) ∧ Following(chinasEconomicReconstruction, greatLeapForward) ∧ Disastrous(greatLeapForward)
DiedIn(mao, year1976)
GraduallyRoseTo(dengXiaoping, supremePower)

[PREMISE (GK)]:
ParamountLeaderOf(dengXiaoping, peoplesRepublicOfChina).
PraisedFor(dengXiaoping, reaffirmationOfReformProgram) & PraisedFor(dengXiaoping, reversionOfHongKong) & PraisedFor(dengXiaoping, returnOfMacau).
PartysSecretaryGeneral(dengXiaoping) & Under(dengXiaoping, mao) & VicePremierInThe1950s(dengXiaoping) & PresidedOver(dengXiaoping, antiRightistCampaign) & LaunchedBy(antiRightistCampaign, mao).
InstrumentalIn(dengXiaoping, chinasEconomicReconstruction) & Following(chinasEconomicReconstruction, greatLeapForward) & Disastrous(greatLeapForward).
DiedIn(mao, year1976).
GraduallyRoseTo(dengXiaoping, supremePower).

[CONCLUSION]:
The paramount leader of the PRC was also the vice premier.

[CONCLUSION (FOL)]:
∃x (ParamountLeaderOf(x, prc) ∧ VicePremier(x))

[CONCLUSION (GK)]:
? [X] : (ParamountLeaderOf(X, prc) & VicePremier(X)).


===

[]
['x', 'y']
[PREMISE]:
Deng Xiaoping served as the paramount leader of the People's Republic of China.
Deng Xiaoping was praised for his reaffirmation of the reform program, as well as the reversion of Hong Kong to Chinese control and the return of Macau.
As the party's Secretary-General under Mao and Vice Premier in the 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.
Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward.
Mao Zedong died in 1976.
After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.

[PREMISE (FOL)]:
ParamountLeaderOf(dengXiaoping, peoplesRepublicOfChina)
PraisedFor(dengXiaoping, reaffirmationOfReformProgram) ∧ PraisedFor(dengXiaoping, reversionOfHongKong) ∧ PraisedFor(dengXiaoping, returnOfMacau)
PartysSecretaryGeneral(dengXiaoping) ∧ Under(dengXiaoping, mao) ∧ VicePremierInThe1950s(dengXiaoping) ∧ PresidedOver(dengXiaoping, antiRightistCampaign) ∧ LaunchedBy(antiRightistCampaign, mao)
InstrumentalIn(dengXiaoping, chinasEconomicReconstruction) ∧ Following(chinasEconomicReconstruction, greatLeapForward) ∧ Disastrous(greatLeapForward)
DiedIn(mao, year1976)
GraduallyRoseTo(dengXiaoping, supremePower)

[PREMISE (GK)]:
ParamountLeaderOf(dengXiaoping, peoplesRepublicOfChina).
PraisedFor(dengXiaoping, reaffirmationOfReformProgram) & PraisedFor(dengXiaoping, reversionOfHongKong) & PraisedFor(dengXiaoping, returnOfMacau).
PartysSecretaryGeneral(dengXiaoping) & Under(dengXiaoping, mao) & VicePremierInThe1950s(dengXiaoping) & PresidedOver(dengXiaoping, antiRightistCampaign) & LaunchedBy(antiRightistCampaign, mao).
InstrumentalIn(dengXiaoping, chinasEconomicReconstruction) & Following(chinasEconomicReconstruction, greatLeapForward) & Disastrous(greatLeapForward).
DiedIn(mao, year1976).
GraduallyRoseTo(dengXiaoping, supremePower).

[CONCLUSION]:
Deng Xiaoping presided over something launched by someone he was under.

[CONCLUSION (FOL)]:
∃x ∃y (PresidedOver(dengxiaoping, x) ∧ Under(dengxiaoping, y) ∧ LaunchedBy(x, y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (PresidedOver(dengxiaoping, X) & Under(dengxiaoping, Y) & LaunchedBy(X, Y)).


===

[]
['x']
[PREMISE]:
Deng Xiaoping served as the paramount leader of the People's Republic of China.
Deng Xiaoping was praised for his reaffirmation of the reform program, as well as the reversion of Hong Kong to Chinese control and the return of Macau.
As the party's Secretary-General under Mao and Vice Premier in the 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.
Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward.
Mao Zedong died in 1976.
After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.

[PREMISE (FOL)]:
ParamountLeaderOf(dengXiaoping, peoplesRepublicOfChina)
PraisedFor(dengXiaoping, reaffirmationOfReformProgram) ∧ PraisedFor(dengXiaoping, reversionOfHongKong) ∧ PraisedFor(dengXiaoping, returnOfMacau)
PartysSecretaryGeneral(dengXiaoping) ∧ Under(dengXiaoping, mao) ∧ VicePremierInThe1950s(dengXiaoping) ∧ PresidedOver(dengXiaoping, antiRightistCampaign) ∧ LaunchedBy(antiRightistCampaign, mao)
InstrumentalIn(dengXiaoping, chinasEconomicReconstruction) ∧ Following(chinasEconomicReconstruction, greatLeapForward) ∧ Disastrous(greatLeapForward)
DiedIn(mao, year1976)
GraduallyRoseTo(dengXiaoping, supremePower)

[PREMISE (GK)]:
ParamountLeaderOf(dengXiaoping, peoplesRepublicOfChina).
PraisedFor(dengXiaoping, reaffirmationOfReformProgram) & PraisedFor(dengXiaoping, reversionOfHongKong) & PraisedFor(dengXiaoping, returnOfMacau).
PartysSecretaryGeneral(dengXiaoping) & Under(dengXiaoping, mao) & VicePremierInThe1950s(dengXiaoping) & PresidedOver(dengXiaoping, antiRightistCampaign) & LaunchedBy(antiRightistCampaign, mao).
InstrumentalIn(dengXiaoping, chinasEconomicReconstruction) & Following(chinasEconomicReconstruction, greatLeapForward) & Disastrous(greatLeapForward).
DiedIn(mao, year1976).
GraduallyRoseTo(dengXiaoping, supremePower).

[CONCLUSION]:
The person instrumental in china's economic reconstruction gradually rose to supreme power.

[CONCLUSION (FOL)]:
∃x (InstrumentalIn(x, chinaseconomicreconstruction) ∧ GraduallyRoseTo(x, supremepower))

[CONCLUSION (GK)]:
? [X] : (InstrumentalIn(X, chinaseconomicreconstruction) & GraduallyRoseTo(X, supremepower)).


===

['x']
['x']
[PREMISE]:
All imaginative processes that Dan knows are results of creative processes.
All science fiction that Dan knows comes from an imaginative process.
Everthing that Dan knows comes from either science-fiction or realistic fiction.
No facts that Dan knows have proven to be false.
Dan knows that Dune is science fiction or has proven to be false.

[PREMISE (FOL)]:
∀x ((Knows(dan, x) ∧ ImaginativeProcess(x)) → ResultOf(x, creativeProcess))
∀x ((Knows(dan, x) ∧ ScienceFiction(x)) → ImaginativeProcess(x)) 
∀x (Knows(dan, x) → (ScienceFiction(x) ⊕ RealisticFiction(x)))
∀x ((Knows(dan, x) ∧ Fact(x)) → ¬ProvedToBe(x, false)) 
(Knows(dan, dune) ∧ ScienceFiction(dune)) ∨ ProvedToBe(dune, false))

[PREMISE (GK)]:
! [X] : ((Knows(dan, X) & ImaginativeProcess(X)) => ResultOf(X, creativeProcess)).
! [X] : ((Knows(dan, X) & ScienceFiction(X)) => ImaginativeProcess(X)) .
! [X] : (Knows(dan, X) => (ScienceFiction(X) <~> RealisticFiction(X))).
! [X] : ((Knows(dan, X) & Fact(X)) => -ProvedToBe(X, false)) .
(Knows(dan, dune) & ScienceFiction(dune)) | ProvedToBe(dune, false)).

[CONCLUSION]:
Dune is realistic fiction.

[CONCLUSION (FOL)]:
RealisticFiction(dune)

[CONCLUSION (GK)]:
RealisticFiction(dune).


===

['x']
['x']
[PREMISE]:
All imaginative processes that Dan knows are results of creative processes.
All science fiction that Dan knows comes from an imaginative process.
Everthing that Dan knows comes from either science-fiction or realistic fiction.
No facts that Dan knows have proven to be false.
Dan knows that Dune is science fiction or has proven to be false.

[PREMISE (FOL)]:
∀x ((Knows(dan, x) ∧ ImaginativeProcess(x)) → ResultOf(x, creativeProcess))
∀x ((Knows(dan, x) ∧ ScienceFiction(x)) → ImaginativeProcess(x)) 
∀x (Knows(dan, x) → (ScienceFiction(x) ⊕ RealisticFiction(x)))
∀x ((Knows(dan, x) ∧ Fact(x)) → ¬ProvedToBe(x, false)) 
(Knows(dan, dune) ∧ ScienceFiction(dune)) ∨ ProvedToBe(dune, false))

[PREMISE (GK)]:
! [X] : ((Knows(dan, X) & ImaginativeProcess(X)) => ResultOf(X, creativeProcess)).
! [X] : ((Knows(dan, X) & ScienceFiction(X)) => ImaginativeProcess(X)) .
! [X] : (Knows(dan, X) => (ScienceFiction(X) <~> RealisticFiction(X))).
! [X] : ((Knows(dan, X) & Fact(X)) => -ProvedToBe(X, false)) .
(Knows(dan, dune) & ScienceFiction(dune)) | ProvedToBe(dune, false)).

[CONCLUSION]:
Dune is a result of creative and imaginative process.

[CONCLUSION (FOL)]:
ResultOf(dune, creativeProcess) ∧ ImaginativeProcess(dune)

[CONCLUSION (GK)]:
ResultOf(dune, creativeProcess) & ImaginativeProcess(dune).


===

['x']
['x']
[PREMISE]:
All imaginative processes that Dan knows are results of creative processes.
All science fiction that Dan knows comes from an imaginative process.
Everthing that Dan knows comes from either science-fiction or realistic fiction.
No facts that Dan knows have proven to be false.
Dan knows that Dune is science fiction or has proven to be false.

[PREMISE (FOL)]:
∀x ((Knows(dan, x) ∧ ImaginativeProcess(x)) → ResultOf(x, creativeProcess))
∀x ((Knows(dan, x) ∧ ScienceFiction(x)) → ImaginativeProcess(x)) 
∀x (Knows(dan, x) → (ScienceFiction(x) ⊕ RealisticFiction(x)))
∀x ((Knows(dan, x) ∧ Fact(x)) → ¬ProvedToBe(x, false)) 
(Knows(dan, dune) ∧ ScienceFiction(dune)) ∨ ProvedToBe(dune, false))

[PREMISE (GK)]:
! [X] : ((Knows(dan, X) & ImaginativeProcess(X)) => ResultOf(X, creativeProcess)).
! [X] : ((Knows(dan, X) & ScienceFiction(X)) => ImaginativeProcess(X)) .
! [X] : (Knows(dan, X) => (ScienceFiction(X) <~> RealisticFiction(X))).
! [X] : ((Knows(dan, X) & Fact(X)) => -ProvedToBe(X, false)) .
(Knows(dan, dune) & ScienceFiction(dune)) | ProvedToBe(dune, false)).

[CONCLUSION]:
Dune is either a result of creative processes or came from an imaginative process.

[CONCLUSION (FOL)]:
ResultOf(dune, creativeProcess) ⊕ ImaginativeProcess(dune)

[CONCLUSION (GK)]:
ResultOf(dune, creativeProcess) <~> ImaginativeProcess(dune).


===

['x']
['x']
[PREMISE]:
All imaginative processes that Dan knows are results of creative processes.
All science fiction that Dan knows comes from an imaginative process.
Everthing that Dan knows comes from either science-fiction or realistic fiction.
No facts that Dan knows have proven to be false.
Dan knows that Dune is science fiction or has proven to be false.

[PREMISE (FOL)]:
∀x ((Knows(dan, x) ∧ ImaginativeProcess(x)) → ResultOf(x, creativeProcess))
∀x ((Knows(dan, x) ∧ ScienceFiction(x)) → ImaginativeProcess(x)) 
∀x (Knows(dan, x) → (ScienceFiction(x) ⊕ RealisticFiction(x)))
∀x ((Knows(dan, x) ∧ Fact(x)) → ¬ProvedToBe(x, false)) 
(Knows(dan, dune) ∧ ScienceFiction(dune)) ∨ ProvedToBe(dune, false))

[PREMISE (GK)]:
! [X] : ((Knows(dan, X) & ImaginativeProcess(X)) => ResultOf(X, creativeProcess)).
! [X] : ((Knows(dan, X) & ScienceFiction(X)) => ImaginativeProcess(X)) .
! [X] : (Knows(dan, X) => (ScienceFiction(X) <~> RealisticFiction(X))).
! [X] : ((Knows(dan, X) & Fact(X)) => -ProvedToBe(X, false)) .
(Knows(dan, dune) & ScienceFiction(dune)) | ProvedToBe(dune, false)).

[CONCLUSION]:
Dune is a result of creative processes and is science fiction.

[CONCLUSION (FOL)]:
ResultOf(dune, creativeProcess) ∧ ScienceFiction(dune))

[CONCLUSION (GK)]:
ResultOf(dune, creativeProcess) & ScienceFiction(dune)).


===

['x']
['x']
[PREMISE]:
All imaginative processes that Dan knows are results of creative processes.
All science fiction that Dan knows comes from an imaginative process.
Everthing that Dan knows comes from either science-fiction or realistic fiction.
No facts that Dan knows have proven to be false.
Dan knows that Dune is science fiction or has proven to be false.

[PREMISE (FOL)]:
∀x ((Knows(dan, x) ∧ ImaginativeProcess(x)) → ResultOf(x, creativeProcess))
∀x ((Knows(dan, x) ∧ ScienceFiction(x)) → ImaginativeProcess(x)) 
∀x (Knows(dan, x) → (ScienceFiction(x) ⊕ RealisticFiction(x)))
∀x ((Knows(dan, x) ∧ Fact(x)) → ¬ProvedToBe(x, false)) 
(Knows(dan, dune) ∧ ScienceFiction(dune)) ∨ ProvedToBe(dune, false))

[PREMISE (GK)]:
! [X] : ((Knows(dan, X) & ImaginativeProcess(X)) => ResultOf(X, creativeProcess)).
! [X] : ((Knows(dan, X) & ScienceFiction(X)) => ImaginativeProcess(X)) .
! [X] : (Knows(dan, X) => (ScienceFiction(X) <~> RealisticFiction(X))).
! [X] : ((Knows(dan, X) & Fact(X)) => -ProvedToBe(X, false)) .
(Knows(dan, dune) & ScienceFiction(dune)) | ProvedToBe(dune, false)).

[CONCLUSION]:
Dune is either a result of creative processes or is science fiction.

[CONCLUSION (FOL)]:
Knows(dan, dune) ∧ (ResultOf(dune, creativeProcess)  ⊕ ScienceFiction(dune))

[CONCLUSION (GK)]:
Knows(dan, dune) & (ResultOf(dune, creativeProcess)  <~> ScienceFiction(dune)).


===

['x']
['x']
[PREMISE]:
All imaginative processes that Dan knows are results of creative processes.
All science fiction that Dan knows comes from an imaginative process.
Everthing that Dan knows comes from either science-fiction or realistic fiction.
No facts that Dan knows have proven to be false.
Dan knows that Dune is science fiction or has proven to be false.

[PREMISE (FOL)]:
∀x ((Knows(dan, x) ∧ ImaginativeProcess(x)) → ResultOf(x, creativeProcess))
∀x ((Knows(dan, x) ∧ ScienceFiction(x)) → ImaginativeProcess(x)) 
∀x (Knows(dan, x) → (ScienceFiction(x) ⊕ RealisticFiction(x)))
∀x ((Knows(dan, x) ∧ Fact(x)) → ¬ProvedToBe(x, false)) 
(Knows(dan, dune) ∧ ScienceFiction(dune)) ∨ ProvedToBe(dune, false))

[PREMISE (GK)]:
! [X] : ((Knows(dan, X) & ImaginativeProcess(X)) => ResultOf(X, creativeProcess)).
! [X] : ((Knows(dan, X) & ScienceFiction(X)) => ImaginativeProcess(X)) .
! [X] : (Knows(dan, X) => (ScienceFiction(X) <~> RealisticFiction(X))).
! [X] : ((Knows(dan, X) & Fact(X)) => -ProvedToBe(X, false)) .
(Knows(dan, dune) & ScienceFiction(dune)) | ProvedToBe(dune, false)).

[CONCLUSION]:
If Dune is a result of creative and imaginative processes, then Dune is not a result of creative processes and science-fiction.

[CONCLUSION (FOL)]:
(ResultOf(dune, creativeProcess)  ∧ ImaginativeProcess(dune)) → (¬ResultOf(dune, creativeProcess) ∧ ¬ScienceFiction(dune))

[CONCLUSION (GK)]:
(ResultOf(dune, creativeProcess)  & ImaginativeProcess(dune)) => (-ResultOf(dune, creativeProcess) & -ScienceFiction(dune)).


===

['x']
['x']
[PREMISE]:
All imaginative processes that Dan knows are results of creative processes.
All science fiction that Dan knows comes from an imaginative process.
Everthing that Dan knows comes from either science-fiction or realistic fiction.
No facts that Dan knows have proven to be false.
Dan knows that Dune is science fiction or has proven to be false.

[PREMISE (FOL)]:
∀x ((Knows(dan, x) ∧ ImaginativeProcess(x)) → ResultOf(x, creativeProcess))
∀x ((Knows(dan, x) ∧ ScienceFiction(x)) → ImaginativeProcess(x)) 
∀x (Knows(dan, x) → (ScienceFiction(x) ⊕ RealisticFiction(x)))
∀x ((Knows(dan, x) ∧ Fact(x)) → ¬ProvedToBe(x, false)) 
(Knows(dan, dune) ∧ ScienceFiction(dune)) ∨ ProvedToBe(dune, false))

[PREMISE (GK)]:
! [X] : ((Knows(dan, X) & ImaginativeProcess(X)) => ResultOf(X, creativeProcess)).
! [X] : ((Knows(dan, X) & ScienceFiction(X)) => ImaginativeProcess(X)) .
! [X] : (Knows(dan, X) => (ScienceFiction(X) <~> RealisticFiction(X))).
! [X] : ((Knows(dan, X) & Fact(X)) => -ProvedToBe(X, false)) .
(Knows(dan, dune) & ScienceFiction(dune)) | ProvedToBe(dune, false)).

[CONCLUSION]:
If Dune is either a fact and a result of creative processes, or neither a fact nor a result of creative processes, then Dune is a result of creative processes and science-fiction.

[CONCLUSION (FOL)]:
Knows(dan, dune) ∧ (¬(Fact(dune) ⊕ ResultOf(dune, creativeProcess))) → (ResultOf(dune, creativeProcess) ∧ ScienceFiction(dune))

[CONCLUSION (GK)]:
Knows(dan, dune) & (-(Fact(dune) <~> ResultOf(dune, creativeProcess))) => (ResultOf(dune, creativeProcess) & ScienceFiction(dune)).


===

['x']
['x']
[PREMISE]:
All imaginative processes that Dan knows are results of creative processes.
All science fiction that Dan knows comes from an imaginative process.
Everthing that Dan knows comes from either science-fiction or realistic fiction.
No facts that Dan knows have proven to be false.
Dan knows that Dune is science fiction or has proven to be false.

[PREMISE (FOL)]:
∀x ((Knows(dan, x) ∧ ImaginativeProcess(x)) → ResultOf(x, creativeProcess))
∀x ((Knows(dan, x) ∧ ScienceFiction(x)) → ImaginativeProcess(x)) 
∀x (Knows(dan, x) → (ScienceFiction(x) ⊕ RealisticFiction(x)))
∀x ((Knows(dan, x) ∧ Fact(x)) → ¬ProvedToBe(x, false)) 
(Knows(dan, dune) ∧ ScienceFiction(dune)) ∨ ProvedToBe(dune, false))

[PREMISE (GK)]:
! [X] : ((Knows(dan, X) & ImaginativeProcess(X)) => ResultOf(X, creativeProcess)).
! [X] : ((Knows(dan, X) & ScienceFiction(X)) => ImaginativeProcess(X)) .
! [X] : (Knows(dan, X) => (ScienceFiction(X) <~> RealisticFiction(X))).
! [X] : ((Knows(dan, X) & Fact(X)) => -ProvedToBe(X, false)) .
(Knows(dan, dune) & ScienceFiction(dune)) | ProvedToBe(dune, false)).

[CONCLUSION]:
If Dune is science-fiction, then Dune is not a result of creative processes and science-fiction.

[CONCLUSION (FOL)]:
Knows(dan, dune) ∧ (ScienceFiction(dune)) → (¬(ResultOf(dune, creativeProcess)  ∧ ScienceFiction(dune)))

[CONCLUSION (GK)]:
Knows(dan, dune) & (ScienceFiction(dune)) => (-(ResultOf(dune, creativeProcess)  & ScienceFiction(dune))).


===

['x']
['x']
[PREMISE]:
All imaginative processes that Dan knows are results of creative processes.
All science fiction that Dan knows comes from an imaginative process.
Everthing that Dan knows comes from either science-fiction or realistic fiction.
No facts that Dan knows have proven to be false.
Dan knows that Dune is science fiction or has proven to be false.

[PREMISE (FOL)]:
∀x ((Knows(dan, x) ∧ ImaginativeProcess(x)) → ResultOf(x, creativeProcess))
∀x ((Knows(dan, x) ∧ ScienceFiction(x)) → ImaginativeProcess(x)) 
∀x (Knows(dan, x) → (ScienceFiction(x) ⊕ RealisticFiction(x)))
∀x ((Knows(dan, x) ∧ Fact(x)) → ¬ProvedToBe(x, false)) 
(Knows(dan, dune) ∧ ScienceFiction(dune)) ∨ ProvedToBe(dune, false))

[PREMISE (GK)]:
! [X] : ((Knows(dan, X) & ImaginativeProcess(X)) => ResultOf(X, creativeProcess)).
! [X] : ((Knows(dan, X) & ScienceFiction(X)) => ImaginativeProcess(X)) .
! [X] : (Knows(dan, X) => (ScienceFiction(X) <~> RealisticFiction(X))).
! [X] : ((Knows(dan, X) & Fact(X)) => -ProvedToBe(X, false)) .
(Knows(dan, dune) & ScienceFiction(dune)) | ProvedToBe(dune, false)).

[CONCLUSION]:
If Dune is not a result of creative processes and science-fiction, then Dune neither came from an imaginative process nor proved to be false.

[CONCLUSION (FOL)]:
Knows(dan, dune) ∧ (¬(ResultOf(dune, creativeProcess)  ∧ ScienceFiction(dune))) → (¬(ImaginativeProcess(dune) ∨ ProvedToBe(dune, false)))

[CONCLUSION (GK)]:
Knows(dan, dune) & (-(ResultOf(dune, creativeProcess)  & ScienceFiction(dune))) => (-(ImaginativeProcess(dune) | ProvedToBe(dune, false))).


===

['x']
['x']
[PREMISE]:
All imaginative processes that Dan knows are results of creative processes.
All science fiction that Dan knows comes from an imaginative process.
Everthing that Dan knows comes from either science-fiction or realistic fiction.
No facts that Dan knows have proven to be false.
Dan knows that Dune is science fiction or has proven to be false.

[PREMISE (FOL)]:
∀x ((Knows(dan, x) ∧ ImaginativeProcess(x)) → ResultOf(x, creativeProcess))
∀x ((Knows(dan, x) ∧ ScienceFiction(x)) → ImaginativeProcess(x)) 
∀x (Knows(dan, x) → (ScienceFiction(x) ⊕ RealisticFiction(x)))
∀x ((Knows(dan, x) ∧ Fact(x)) → ¬ProvedToBe(x, false)) 
(Knows(dan, dune) ∧ ScienceFiction(dune)) ∨ ProvedToBe(dune, false))

[PREMISE (GK)]:
! [X] : ((Knows(dan, X) & ImaginativeProcess(X)) => ResultOf(X, creativeProcess)).
! [X] : ((Knows(dan, X) & ScienceFiction(X)) => ImaginativeProcess(X)) .
! [X] : (Knows(dan, X) => (ScienceFiction(X) <~> RealisticFiction(X))).
! [X] : ((Knows(dan, X) & Fact(X)) => -ProvedToBe(X, false)) .
(Knows(dan, dune) & ScienceFiction(dune)) | ProvedToBe(dune, false)).

[CONCLUSION]:
If Dune is did not come from imaginative process and is not science-fiction, then Dune is neither a result of creative processes nor came from an imaginative process.

[CONCLUSION (FOL)]:
Knows(dan, dune) ∧ (¬(ImaginativeProcess(dune) ∧ ScienceFiction(dune))) → (¬(ResultOf(dune, creativeProcess)  ∨ ImaginativeProcess(dune)))

[CONCLUSION (GK)]:
Knows(dan, dune) & (-(ImaginativeProcess(dune) & ScienceFiction(dune))) => (-(ResultOf(dune, creativeProcess)  | ImaginativeProcess(dune))).


===

['x']
['x']
[PREMISE]:
American superheroes come from either the DC Universe or Marvel Universe.
Captain America is one of America's top-ten favorite superheroes
Captain America does not come from the DC Universe.
America's top-ten favorite superheroes speak English.
Some superheroes speak both English and Spanish. 

[PREMISE (FOL)]:
∀x (Superhero(x) ∧ American(x) → ComeFrom(x, dCUniverse) ⊕ ComeFrom(x, marvelUniverse)) 
American(captainAmerica) ∧ TopTenFavorite(captainAmerica) ∧ Superhero(captainAmerica) 
¬ComeFrom(captainAmerica, dCUniverse)
∀x (American(x) ∧ TopTenFavorite(x) ∧ Superhero(x)  → Speak(x, english)) 
∃x (Superhero(x) → (Speak(x, english) ∧ Speak(x, spanish)))

[PREMISE (GK)]:
! [X] : (Superhero(X) & American(X) => ComeFrom(X, dCUniverse) <~> ComeFrom(X, marvelUniverse)) .
American(captainAmerica) & TopTenFavorite(captainAmerica) & Superhero(captainAmerica) .
-ComeFrom(captainAmerica, dCUniverse).
! [X] : (American(X) & TopTenFavorite(X) & Superhero(X)  => Speak(X, english)) .
? [X] : (Superhero(X) => (Speak(X, english) & Speak(X, spanish))).

[CONCLUSION]:
Captain America does not speak English.

[CONCLUSION (FOL)]:
¬Speak(captainAmerica, english)

[CONCLUSION (GK)]:
-Speak(captainAmerica, english).


===

['x']
['x']
[PREMISE]:
American superheroes come from either the DC Universe or Marvel Universe.
Captain America is one of America's top-ten favorite superheroes
Captain America does not come from the DC Universe.
America's top-ten favorite superheroes speak English.
Some superheroes speak both English and Spanish. 

[PREMISE (FOL)]:
∀x (Superhero(x) ∧ American(x) → ComeFrom(x, dCUniverse) ⊕ ComeFrom(x, marvelUniverse)) 
American(captainAmerica) ∧ TopTenFavorite(captainAmerica) ∧ Superhero(captainAmerica) 
¬ComeFrom(captainAmerica, dCUniverse)
∀x (American(x) ∧ TopTenFavorite(x) ∧ Superhero(x)  → Speak(x, english)) 
∃x (Superhero(x) → (Speak(x, english) ∧ Speak(x, spanish)))

[PREMISE (GK)]:
! [X] : (Superhero(X) & American(X) => ComeFrom(X, dCUniverse) <~> ComeFrom(X, marvelUniverse)) .
American(captainAmerica) & TopTenFavorite(captainAmerica) & Superhero(captainAmerica) .
-ComeFrom(captainAmerica, dCUniverse).
! [X] : (American(X) & TopTenFavorite(X) & Superhero(X)  => Speak(X, english)) .
? [X] : (Superhero(X) => (Speak(X, english) & Speak(X, spanish))).

[CONCLUSION]:
Captain America comes from the Marvel universe.

[CONCLUSION (FOL)]:
ComeFrom(captainAmerica, marvelUniverse)

[CONCLUSION (GK)]:
ComeFrom(captainAmerica, marvelUniverse).


===

['x']
['x']
[PREMISE]:
American superheroes come from either the DC Universe or Marvel Universe.
Captain America is one of America's top-ten favorite superheroes
Captain America does not come from the DC Universe.
America's top-ten favorite superheroes speak English.
Some superheroes speak both English and Spanish. 

[PREMISE (FOL)]:
∀x (Superhero(x) ∧ American(x) → ComeFrom(x, dCUniverse) ⊕ ComeFrom(x, marvelUniverse)) 
American(captainAmerica) ∧ TopTenFavorite(captainAmerica) ∧ Superhero(captainAmerica) 
¬ComeFrom(captainAmerica, dCUniverse)
∀x (American(x) ∧ TopTenFavorite(x) ∧ Superhero(x)  → Speak(x, english)) 
∃x (Superhero(x) → (Speak(x, english) ∧ Speak(x, spanish)))

[PREMISE (GK)]:
! [X] : (Superhero(X) & American(X) => ComeFrom(X, dCUniverse) <~> ComeFrom(X, marvelUniverse)) .
American(captainAmerica) & TopTenFavorite(captainAmerica) & Superhero(captainAmerica) .
-ComeFrom(captainAmerica, dCUniverse).
! [X] : (American(X) & TopTenFavorite(X) & Superhero(X)  => Speak(X, english)) .
? [X] : (Superhero(X) => (Speak(X, english) & Speak(X, spanish))).

[CONCLUSION]:
Captain America speaks Spanish.

[CONCLUSION (FOL)]:
Speak(captainAmerica, spanish)

[CONCLUSION (GK)]:
Speak(captainAmerica, spanish).


===

['x']
['x']
[PREMISE]:
Robert Zimmer was a philosopher born in Germany.
Robert Zimmer is an essayist.
Robert Zimmer was born in 1953.
Every essayist is a writer.

[PREMISE (FOL)]:
BornIn(robertZimmer, germany) ∧ Philosopher(robertZimmer)
Essayist(robertZimmer)
BornIn(robertZimmer, yr1953)
∀x (Essayist(x) → Writer(x))

[PREMISE (GK)]:
BornIn(robertZimmer, germany) & Philosopher(robertZimmer).
Essayist(robertZimmer).
BornIn(robertZimmer, yr1953).
! [X] : (Essayist(X) => Writer(X)).

[CONCLUSION]:
Robert Zimmer is German.

[CONCLUSION (FOL)]:
BornIn(robertZimmer, germany)

[CONCLUSION (GK)]:
BornIn(robertZimmer, germany).


===

['x']
['x']
[PREMISE]:
Robert Zimmer was a philosopher born in Germany.
Robert Zimmer is an essayist.
Robert Zimmer was born in 1953.
Every essayist is a writer.

[PREMISE (FOL)]:
BornIn(robertZimmer, germany) ∧ Philosopher(robertZimmer)
Essayist(robertZimmer)
BornIn(robertZimmer, yr1953)
∀x (Essayist(x) → Writer(x))

[PREMISE (GK)]:
BornIn(robertZimmer, germany) & Philosopher(robertZimmer).
Essayist(robertZimmer).
BornIn(robertZimmer, yr1953).
! [X] : (Essayist(X) => Writer(X)).

[CONCLUSION]:
Robert Zimmer is not a writer.

[CONCLUSION (FOL)]:
¬Writer(robertZimmer)

[CONCLUSION (GK)]:
-Writer(robertZimmer).


===

['x']
['x']
[PREMISE]:
Robert Zimmer was a philosopher born in Germany.
Robert Zimmer is an essayist.
Robert Zimmer was born in 1953.
Every essayist is a writer.

[PREMISE (FOL)]:
BornIn(robertZimmer, germany) ∧ Philosopher(robertZimmer)
Essayist(robertZimmer)
BornIn(robertZimmer, yr1953)
∀x (Essayist(x) → Writer(x))

[PREMISE (GK)]:
BornIn(robertZimmer, germany) & Philosopher(robertZimmer).
Essayist(robertZimmer).
BornIn(robertZimmer, yr1953).
! [X] : (Essayist(X) => Writer(X)).

[CONCLUSION]:
Robert Zimmer is a biographer.

[CONCLUSION (FOL)]:
Biographer(robertZimmer)

[CONCLUSION (GK)]:
Biographer(robertZimmer).


===

['x']
['x']
[PREMISE]:
All people who repay their loans on time have a high credit score.
Some people with high credit scores and high salaries are approved for mortgages.
John has a high salary.

[PREMISE (FOL)]:
∀x (RepayOnTime(x) → Has(x, highCreditScore))
∃x ((Has(x, highCreditScore) ∧ Has(x, highSalary)) → ApprovedFor(x, mortgage))
Has(john, highSalary)

[PREMISE (GK)]:
! [X] : (RepayOnTime(X) => Has(X, highCreditScore)).
? [X] : ((Has(X, highCreditScore) & Has(X, highSalary)) => ApprovedFor(X, mortgage)).
Has(john, highSalary).

[CONCLUSION]:
If John repays his loans on time, he will be approved for a mortgage.

[CONCLUSION (FOL)]:
RepayOnTime(john) → ApprovedFor(john, mortgage)

[CONCLUSION (GK)]:
RepayOnTime(john) => ApprovedFor(john, mortgage).


===

['x']
['x']
[PREMISE]:
All students are members of the university.
All graduate students are students.
All PhD students are graduate students.
Some PhD students are Teaching Fellows.
If John is not a PhD student, then he is not a member of the university.
If John is a Teaching Fellow, then he is a PhD student or a graduate student.

[PREMISE (FOL)]:
∀x (Student(x) → MemberOf(x, university))
∀x (GraduateStudent(x) → Student(x))
∀x (PhDStudent(x) → GraduateStudent(x))
∃x (PhDStudent(x) ∧ TeachingFellow(x))
¬PhDStudent(john) → ¬MemberOf(john, university)
TeachingFellow(john) → PhDStudent(john) ⊕ GraduateStudent(john)

[PREMISE (GK)]:
! [X] : (Student(X) => MemberOf(X, university)).
! [X] : (GraduateStudent(X) => Student(X)).
! [X] : (PhDStudent(X) => GraduateStudent(X)).
? [X] : (PhDStudent(X) & TeachingFellow(X)).
-PhDStudent(john) => -MemberOf(john, university).
TeachingFellow(john) => PhDStudent(john) <~> GraduateStudent(john).

[CONCLUSION]:
John is a Teaching Fellow

[CONCLUSION (FOL)]:
TF(john)

[CONCLUSION (GK)]:
TF(john).


===

['x']
['x']
[PREMISE]:
All students are members of the university.
All graduate students are students.
All PhD students are graduate students.
Some PhD students are Teaching Fellows.
If John is not a PhD student, then he is not a member of the university.
If John is a Teaching Fellow, then he is a PhD student or a graduate student.

[PREMISE (FOL)]:
∀x (Student(x) → MemberOf(x, university))
∀x (GraduateStudent(x) → Student(x))
∀x (PhDStudent(x) → GraduateStudent(x))
∃x (PhDStudent(x) ∧ TeachingFellow(x))
¬PhDStudent(john) → ¬MemberOf(john, university)
TeachingFellow(john) → PhDStudent(john) ⊕ GraduateStudent(john)

[PREMISE (GK)]:
! [X] : (Student(X) => MemberOf(X, university)).
! [X] : (GraduateStudent(X) => Student(X)).
! [X] : (PhDStudent(X) => GraduateStudent(X)).
? [X] : (PhDStudent(X) & TeachingFellow(X)).
-PhDStudent(john) => -MemberOf(john, university).
TeachingFellow(john) => PhDStudent(john) <~> GraduateStudent(john).

[CONCLUSION]:
John is not a Teaching Fellow.

[CONCLUSION (FOL)]:
¬TF(john)

[CONCLUSION (GK)]:
-TF(john).


===

['x']
['x']
[PREMISE]:
All students are members of the university.
All graduate students are students.
All PhD students are graduate students.
Some PhD students are Teaching Fellows.
If John is not a PhD student, then he is not a member of the university.
If John is a Teaching Fellow, then he is a PhD student or a graduate student.

[PREMISE (FOL)]:
∀x (Student(x) → MemberOf(x, university))
∀x (GraduateStudent(x) → Student(x))
∀x (PhDStudent(x) → GraduateStudent(x))
∃x (PhDStudent(x) ∧ TeachingFellow(x))
¬PhDStudent(john) → ¬MemberOf(john, university)
TeachingFellow(john) → PhDStudent(john) ⊕ GraduateStudent(john)

[PREMISE (GK)]:
! [X] : (Student(X) => MemberOf(X, university)).
! [X] : (GraduateStudent(X) => Student(X)).
! [X] : (PhDStudent(X) => GraduateStudent(X)).
? [X] : (PhDStudent(X) & TeachingFellow(X)).
-PhDStudent(john) => -MemberOf(john, university).
TeachingFellow(john) => PhDStudent(john) <~> GraduateStudent(john).

[CONCLUSION]:
John is a PhD student.

[CONCLUSION (FOL)]:
PhDStudent(john)

[CONCLUSION (GK)]:
PhDStudent(john).


===

['x']
['x']
[PREMISE]:
Belgium, France, and Germany are European countries.
Paris is the capital of France.
The Eiffel Tower is one of the main tourist attractions located in Paris.
Some people who live in Belgium speak French.
If John goes to Europe, he will see some tourist attractions.
John speaks French.

[PREMISE (FOL)]:
EuropeanCountry(belgium) ∧ EuropeanCountry(france) ∧ EuropeanCountry(germany)
CapitalOf(paris, france)
TouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris)
∃x (LiveIn(x, belgium) → Speak(x, french))
∃x (GoTo(john, europe) → (See(john, x) ∧ TouristAttraction(x)))
Speak(john, french)

[PREMISE (GK)]:
EuropeanCountry(belgium) & EuropeanCountry(france) & EuropeanCountry(germany).
CapitalOf(paris, france).
TouristAttraction(eiffelTower) & LocatedIn(eiffelTower, paris).
? [X] : (LiveIn(X, belgium) => Speak(X, french)).
? [X] : (GoTo(john, europe) => (See(john, X) & TouristAttraction(X))).
Speak(john, french).

[CONCLUSION]:
If John goes to Europe, he will see the Eiffel Tower.

[CONCLUSION (FOL)]:
GoTo(john, europe) → See(john, eiffelTower)

[CONCLUSION (GK)]:
GoTo(john, europe) => See(john, eiffelTower).


===

['x']
['x']
[PREMISE]:
Belgium, France, and Germany are European countries.
Paris is the capital of France.
The Eiffel Tower is one of the main tourist attractions located in Paris.
Some people who live in Belgium speak French.
If John goes to Europe, he will see some tourist attractions.
John speaks French.

[PREMISE (FOL)]:
EuropeanCountry(belgium) ∧ EuropeanCountry(france) ∧ EuropeanCountry(germany)
CapitalOf(paris, france)
TouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris)
∃x (LiveIn(x, belgium) → Speak(x, french))
∃x (GoTo(john, europe) → (See(john, x) ∧ TouristAttraction(x)))
Speak(john, french)

[PREMISE (GK)]:
EuropeanCountry(belgium) & EuropeanCountry(france) & EuropeanCountry(germany).
CapitalOf(paris, france).
TouristAttraction(eiffelTower) & LocatedIn(eiffelTower, paris).
? [X] : (LiveIn(X, belgium) => Speak(X, french)).
? [X] : (GoTo(john, europe) => (See(john, X) & TouristAttraction(X))).
Speak(john, french).

[CONCLUSION]:
The Eiffel Tower is located in the capital of France.

[CONCLUSION (FOL)]:
∃x (CapitalOf(x, france) ∧ LocatedIn(eiffelTower, x))

[CONCLUSION (GK)]:
? [X] : (CapitalOf(X, france) & LocatedIn(eiffelTower, X)).


===

['x']
['x']
[PREMISE]:
Belgium, France, and Germany are European countries.
Paris is the capital of France.
The Eiffel Tower is one of the main tourist attractions located in Paris.
Some people who live in Belgium speak French.
If John goes to Europe, he will see some tourist attractions.
John speaks French.

[PREMISE (FOL)]:
EuropeanCountry(belgium) ∧ EuropeanCountry(france) ∧ EuropeanCountry(germany)
CapitalOf(paris, france)
TouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris)
∃x (LiveIn(x, belgium) → Speak(x, french))
∃x (GoTo(john, europe) → (See(john, x) ∧ TouristAttraction(x)))
Speak(john, french)

[PREMISE (GK)]:
EuropeanCountry(belgium) & EuropeanCountry(france) & EuropeanCountry(germany).
CapitalOf(paris, france).
TouristAttraction(eiffelTower) & LocatedIn(eiffelTower, paris).
? [X] : (LiveIn(X, belgium) => Speak(X, french)).
? [X] : (GoTo(john, europe) => (See(john, X) & TouristAttraction(X))).
Speak(john, french).

[CONCLUSION]:
John lives in Belgium.

[CONCLUSION (FOL)]:
LiveIn(john, belgium)

[CONCLUSION (GK)]:
LiveIn(john, belgium).


===

['x']
['x']
[PREMISE]:
All sports cars are loud.
No loud cars are electric.
If a car is a Ferrari, then it is a sports car.
All cars made in Maranello are Ferraris.
The Toyota Prius is made in Maranello or is a loud car, or both.

[PREMISE (FOL)]:
∀x (SportsCar(x) → LoudCar(x))
∀x (LoudCar(x) → ¬ElectricCar(x))
∀x (Ferrari(x) → SportsCar(x))
∀x ((Car(x) ∧ MadeIn(x, maranello)) → Ferrari(x))
(Car(toyotaPrius) ∧ MadeIn(toyotaPrius, maranello)) ∨ LoudCar(toyotaPrius)

[PREMISE (GK)]:
! [X] : (SportsCar(X) => LoudCar(X)).
! [X] : (LoudCar(X) => -ElectricCar(X)).
! [X] : (Ferrari(X) => SportsCar(X)).
! [X] : ((Car(X) & MadeIn(X, maranello)) => Ferrari(X)).
(Car(toyotaPrius) & MadeIn(toyotaPrius, maranello)) | LoudCar(toyotaPrius).

[CONCLUSION]:
Prius is an electric car.

[CONCLUSION (FOL)]:
ElectricCar(toyotaPrius)

[CONCLUSION (GK)]:
ElectricCar(toyotaPrius).


===

['x']
['x']
[PREMISE]:
All sports cars are loud.
No loud cars are electric.
If a car is a Ferrari, then it is a sports car.
All cars made in Maranello are Ferraris.
The Toyota Prius is made in Maranello or is a loud car, or both.

[PREMISE (FOL)]:
∀x (SportsCar(x) → LoudCar(x))
∀x (LoudCar(x) → ¬ElectricCar(x))
∀x (Ferrari(x) → SportsCar(x))
∀x ((Car(x) ∧ MadeIn(x, maranello)) → Ferrari(x))
(Car(toyotaPrius) ∧ MadeIn(toyotaPrius, maranello)) ∨ LoudCar(toyotaPrius)

[PREMISE (GK)]:
! [X] : (SportsCar(X) => LoudCar(X)).
! [X] : (LoudCar(X) => -ElectricCar(X)).
! [X] : (Ferrari(X) => SportsCar(X)).
! [X] : ((Car(X) & MadeIn(X, maranello)) => Ferrari(X)).
(Car(toyotaPrius) & MadeIn(toyotaPrius, maranello)) | LoudCar(toyotaPrius).

[CONCLUSION]:
The Toyota Prius is not an electric car.

[CONCLUSION (FOL)]:
¬ElectricCar(toyotaPrius)

[CONCLUSION (GK)]:
-ElectricCar(toyotaPrius).


===

['x']
['x']
[PREMISE]:
All sports cars are loud.
No loud cars are electric.
If a car is a Ferrari, then it is a sports car.
All cars made in Maranello are Ferraris.
The Toyota Prius is made in Maranello or is a loud car, or both.

[PREMISE (FOL)]:
∀x (SportsCar(x) → LoudCar(x))
∀x (LoudCar(x) → ¬ElectricCar(x))
∀x (Ferrari(x) → SportsCar(x))
∀x ((Car(x) ∧ MadeIn(x, maranello)) → Ferrari(x))
(Car(toyotaPrius) ∧ MadeIn(toyotaPrius, maranello)) ∨ LoudCar(toyotaPrius)

[PREMISE (GK)]:
! [X] : (SportsCar(X) => LoudCar(X)).
! [X] : (LoudCar(X) => -ElectricCar(X)).
! [X] : (Ferrari(X) => SportsCar(X)).
! [X] : ((Car(X) & MadeIn(X, maranello)) => Ferrari(X)).
(Car(toyotaPrius) & MadeIn(toyotaPrius, maranello)) | LoudCar(toyotaPrius).

[CONCLUSION]:
The Toyota Prius is a equipped with a Ferrari V12 engine.

[CONCLUSION (FOL)]:
MadeIn(toyotaPrius, maranello)

[CONCLUSION (GK)]:
MadeIn(toyotaPrius, maranello).


===

['x']
['x']
[PREMISE]:
All sports cars are loud.
No loud cars are electric.
If a car is a Ferrari, then it is a sports car.
All cars made in Maranello are Ferraris.
The Toyota Prius is made in Maranello or is a loud car, or both.

[PREMISE (FOL)]:
∀x (SportsCar(x) → LoudCar(x))
∀x (LoudCar(x) → ¬ElectricCar(x))
∀x (Ferrari(x) → SportsCar(x))
∀x ((Car(x) ∧ MadeIn(x, maranello)) → Ferrari(x))
(Car(toyotaPrius) ∧ MadeIn(toyotaPrius, maranello)) ∨ LoudCar(toyotaPrius)

[PREMISE (GK)]:
! [X] : (SportsCar(X) => LoudCar(X)).
! [X] : (LoudCar(X) => -ElectricCar(X)).
! [X] : (Ferrari(X) => SportsCar(X)).
! [X] : ((Car(X) & MadeIn(X, maranello)) => Ferrari(X)).
(Car(toyotaPrius) & MadeIn(toyotaPrius, maranello)) | LoudCar(toyotaPrius).

[CONCLUSION]:
If The Toyota Prius is a Ferrari or a loud car, then The Toyota Prius is an electric car.

[CONCLUSION (FOL)]:
Ferrari(toyotaPrius) ∨ LoudCar(toyotaPrius) → ElectricCar(toyotaPrius)

[CONCLUSION (GK)]:
Ferrari(toyotaPrius) | LoudCar(toyotaPrius) => ElectricCar(toyotaPrius).


===

['x']
['x']
[PREMISE]:
If something is a plant, then it is not a cute animal. Simeng: All plants are not cute animals. 
All flowers are plants.
Every kitten is a cute animal.
If something is grown in a garden, then it is a flower.
Piper is a kitten or a cute animal.

[PREMISE (FOL)]:
∀x (Plant(x) → ¬CuteAnimal(x))
∀x (Flower(x) → Plant(x))
∀x (Kitten(x) → CuteAnimal(x))
∀x (GrownIn(x, garden) → Flower(x))
Kitten(piper) ∨ CuteAnimal(piper)

[PREMISE (GK)]:
! [X] : (Plant(X) => -CuteAnimal(X)).
! [X] : (Flower(X) => Plant(X)).
! [X] : (Kitten(X) => CuteAnimal(X)).
! [X] : (GrownIn(X, garden) => Flower(X)).
Kitten(piper) | CuteAnimal(piper).

[CONCLUSION]:
Piper was grown in a garden.

[CONCLUSION (FOL)]:
GrownIn(piper, garden)

[CONCLUSION (GK)]:
GrownIn(piper, garden).


===

['x']
['x']
[PREMISE]:
If something is a plant, then it is not a cute animal. Simeng: All plants are not cute animals. 
All flowers are plants.
Every kitten is a cute animal.
If something is grown in a garden, then it is a flower.
Piper is a kitten or a cute animal.

[PREMISE (FOL)]:
∀x (Plant(x) → ¬CuteAnimal(x))
∀x (Flower(x) → Plant(x))
∀x (Kitten(x) → CuteAnimal(x))
∀x (GrownIn(x, garden) → Flower(x))
Kitten(piper) ∨ CuteAnimal(piper)

[PREMISE (GK)]:
! [X] : (Plant(X) => -CuteAnimal(X)).
! [X] : (Flower(X) => Plant(X)).
! [X] : (Kitten(X) => CuteAnimal(X)).
! [X] : (GrownIn(X, garden) => Flower(X)).
Kitten(piper) | CuteAnimal(piper).

[CONCLUSION]:
Piper was not grown in a garden.

[CONCLUSION (FOL)]:
¬GrownIn(piper, garden)

[CONCLUSION (GK)]:
-GrownIn(piper, garden).


===

['x']
['x']
[PREMISE]:
If something is a plant, then it is not a cute animal. Simeng: All plants are not cute animals. 
All flowers are plants.
Every kitten is a cute animal.
If something is grown in a garden, then it is a flower.
Piper is a kitten or a cute animal.

[PREMISE (FOL)]:
∀x (Plant(x) → ¬CuteAnimal(x))
∀x (Flower(x) → Plant(x))
∀x (Kitten(x) → CuteAnimal(x))
∀x (GrownIn(x, garden) → Flower(x))
Kitten(piper) ∨ CuteAnimal(piper)

[PREMISE (GK)]:
! [X] : (Plant(X) => -CuteAnimal(X)).
! [X] : (Flower(X) => Plant(X)).
! [X] : (Kitten(X) => CuteAnimal(X)).
! [X] : (GrownIn(X, garden) => Flower(X)).
Kitten(piper) | CuteAnimal(piper).

[CONCLUSION]:
Piper is a kitten.

[CONCLUSION (FOL)]:
Kitten(piper)

[CONCLUSION (GK)]:
Kitten(piper).


===

['x', 'y']
['x', 'y']
[PREMISE]:

Guam sent an athlete to the Calgary Winter Olympics.
If Guan sent an athlete to the Calgary Winter Olympics, then the athelete participated in the Olympics in 1988.
Judd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics.

[PREMISE (FOL)]:

∃x (Send(guam, athlete, calgaryWinterOlympics))
∀x (Athlete(x) ∧ SendTo(guam, x, calgaryWinterOlympics) → ParticipatedIn(x, winterOlympics, year1988))
∀x ∀y (Athlete(x) ∧ From(x, guam) ∧ ParticipatedIn(x, winterOlympics, y) → x=juddBankert)

[PREMISE (GK)]:
.
? [X] : (Send(guam, athlete, calgaryWinterOlympics)).
! [X] : (Athlete(X) & SendTo(guam, X, calgaryWinterOlympics) => ParticipatedIn(X, winterOlympics, year1988)).
! [X] : ! [Y] : (Athlete(X) & From(X, guam) & ParticipatedIn(X, winterOlympics, Y) => X=juddBankert).

[CONCLUSION]:
Judd Bankert competed in the 1988 Winter Olympics.

[CONCLUSION (FOL)]:
ParticipatedIn(juddBankert, winterOlympics, year1988)

[CONCLUSION (GK)]:
ParticipatedIn(juddBankert, winterOlympics, year1988).


===

['x', 'y']
['x', 'y']
[PREMISE]:

Guam sent an athlete to the Calgary Winter Olympics.
If Guan sent an athlete to the Calgary Winter Olympics, then the athelete participated in the Olympics in 1988.
Judd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics.

[PREMISE (FOL)]:

∃x (Send(guam, athlete, calgaryWinterOlympics))
∀x (Athlete(x) ∧ SendTo(guam, x, calgaryWinterOlympics) → ParticipatedIn(x, winterOlympics, year1988))
∀x ∀y (Athlete(x) ∧ From(x, guam) ∧ ParticipatedIn(x, winterOlympics, y) → x=juddBankert)

[PREMISE (GK)]:
.
? [X] : (Send(guam, athlete, calgaryWinterOlympics)).
! [X] : (Athlete(X) & SendTo(guam, X, calgaryWinterOlympics) => ParticipatedIn(X, winterOlympics, year1988)).
! [X] : ! [Y] : (Athlete(X) & From(X, guam) & ParticipatedIn(X, winterOlympics, Y) => X=juddBankert).

[CONCLUSION]:
Guam has participated in the Summer Olympics at least once.

[CONCLUSION (FOL)]:
∃x (ParticipatedIn(guam, summerOlympics, x))

[CONCLUSION (GK)]:
? [X] : (ParticipatedIn(guam, summerOlympics, X)).


===

['x']
['x', 'y']
[PREMISE]:
Michael O'Donnell is a British physician, journalist, author, and broadcaster.
One of the word-setters of My Word! was Michael O'Donnell.
The magazine World Medicine was edited by Michael O'Donnell.
Michael O'Donnell was born in Yorkshire as the son of a general practitioner.

[PREMISE (FOL)]:
British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)
WordSetter(michael)
Magazine(worldMedicine) ∧ EditedBy(worldMedicine, michael)
BornIn(michael, yorkshire) ∧ ∃x(SonOf(michael, x) ∧ GeneralPractitioner(x))

[PREMISE (GK)]:
British(michael) & Physician(michael) & Journalist(michael) & Author(michael) & Broadcaster(michael).
WordSetter(michael).
Magazine(worldMedicine) & EditedBy(worldMedicine, michael).
BornIn(michael, yorkshire) & ? [X] :(SonOf(michael, X) & GeneralPractitioner(X)).

[CONCLUSION]:
The son of a general practitioner was a word-setter of My Word!.

[CONCLUSION (FOL)]:
∃x ∃y (SonOf(x, y) ∧ GeneralPractitioner(y) ∧ WordSetter(x))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (SonOf(X, Y) & GeneralPractitioner(Y) & WordSetter(X)).


===

['x']
['x']
[PREMISE]:
Michael O'Donnell is a British physician, journalist, author, and broadcaster.
One of the word-setters of My Word! was Michael O'Donnell.
The magazine World Medicine was edited by Michael O'Donnell.
Michael O'Donnell was born in Yorkshire as the son of a general practitioner.

[PREMISE (FOL)]:
British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)
WordSetter(michael)
Magazine(worldMedicine) ∧ EditedBy(worldMedicine, michael)
BornIn(michael, yorkshire) ∧ ∃x(SonOf(michael, x) ∧ GeneralPractitioner(x))

[PREMISE (GK)]:
British(michael) & Physician(michael) & Journalist(michael) & Author(michael) & Broadcaster(michael).
WordSetter(michael).
Magazine(worldMedicine) & EditedBy(worldMedicine, michael).
BornIn(michael, yorkshire) & ? [X] :(SonOf(michael, X) & GeneralPractitioner(X)).

[CONCLUSION]:
World Medicine is not a magazine.

[CONCLUSION (FOL)]:
¬Magazine(worldmedicine)

[CONCLUSION (GK)]:
-Magazine(worldmedicine).


===

['x']
['x']
[PREMISE]:
Michael O'Donnell is a British physician, journalist, author, and broadcaster.
One of the word-setters of My Word! was Michael O'Donnell.
The magazine World Medicine was edited by Michael O'Donnell.
Michael O'Donnell was born in Yorkshire as the son of a general practitioner.

[PREMISE (FOL)]:
British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)
WordSetter(michael)
Magazine(worldMedicine) ∧ EditedBy(worldMedicine, michael)
BornIn(michael, yorkshire) ∧ ∃x(SonOf(michael, x) ∧ GeneralPractitioner(x))

[PREMISE (GK)]:
British(michael) & Physician(michael) & Journalist(michael) & Author(michael) & Broadcaster(michael).
WordSetter(michael).
Magazine(worldMedicine) & EditedBy(worldMedicine, michael).
BornIn(michael, yorkshire) & ? [X] :(SonOf(michael, X) & GeneralPractitioner(X)).

[CONCLUSION]:
There are no British authors.

[CONCLUSION (FOL)]:
∀x (British(x) → ¬Author(x))

[CONCLUSION (GK)]:
! [X] : (British(X) => -Author(X)).


===

['x']
['x']
[PREMISE]:
Michael O'Donnell is a British physician, journalist, author, and broadcaster.
One of the word-setters of My Word! was Michael O'Donnell.
The magazine World Medicine was edited by Michael O'Donnell.
Michael O'Donnell was born in Yorkshire as the son of a general practitioner.

[PREMISE (FOL)]:
British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)
WordSetter(michael)
Magazine(worldMedicine) ∧ EditedBy(worldMedicine, michael)
BornIn(michael, yorkshire) ∧ ∃x(SonOf(michael, x) ∧ GeneralPractitioner(x))

[PREMISE (GK)]:
British(michael) & Physician(michael) & Journalist(michael) & Author(michael) & Broadcaster(michael).
WordSetter(michael).
Magazine(worldMedicine) & EditedBy(worldMedicine, michael).
BornIn(michael, yorkshire) & ? [X] :(SonOf(michael, X) & GeneralPractitioner(X)).

[CONCLUSION]:
There are no journalists that were born in Yorkshire.

[CONCLUSION (FOL)]:
∀x (Journalist(x) → ¬BornIn(x, yorkshire))

[CONCLUSION (GK)]:
! [X] : (Journalist(X) => -BornIn(X, yorkshire)).


===

['x']
['x', 'y']
[PREMISE]:
Michael O'Donnell is a British physician, journalist, author, and broadcaster.
One of the word-setters of My Word! was Michael O'Donnell.
The magazine World Medicine was edited by Michael O'Donnell.
Michael O'Donnell was born in Yorkshire as the son of a general practitioner.

[PREMISE (FOL)]:
British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)
WordSetter(michael)
Magazine(worldMedicine) ∧ EditedBy(worldMedicine, michael)
BornIn(michael, yorkshire) ∧ ∃x(SonOf(michael, x) ∧ GeneralPractitioner(x))

[PREMISE (GK)]:
British(michael) & Physician(michael) & Journalist(michael) & Author(michael) & Broadcaster(michael).
WordSetter(michael).
Magazine(worldMedicine) & EditedBy(worldMedicine, michael).
BornIn(michael, yorkshire) & ? [X] :(SonOf(michael, X) & GeneralPractitioner(X)).

[CONCLUSION]:
There is a son of a general practitioner that is not an author.

[CONCLUSION (FOL)]:
∃x ∃y (Son(x, y) ∧ GeneralPractitioner(y) ∧ ¬Author(x))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Son(X, Y) & GeneralPractitioner(Y) & -Author(X)).


===

['x']
['x']
[PREMISE]:
No homework is fun.
Some reading is homework.

[PREMISE (FOL)]:
∀x (Homework(x) → ¬Fun(x))
∃x (Reading(x) ∧ Homework(x))

[PREMISE (GK)]:
! [X] : (Homework(X) => -Fun(X)).
? [X] : (Reading(X) & Homework(X)).

[CONCLUSION]:
Some reading is fun.

[CONCLUSION (FOL)]:
∃x (Reading(x) ∧ Fun(x))

[CONCLUSION (GK)]:
? [X] : (Reading(X) & Fun(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
The handbrake of a car is either up or down.
The handbrake is down when a car is parked.

[PREMISE (FOL)]:
∀x ∀y (HandbrakeOf(x, y) ∧ Car(y) → Up(x) ⊕ Down(x))
∀x ∀y (HandbrakeOf(x, y) ∧ Parked(y) ∧ Car(y) → Down(x))

[PREMISE (GK)]:
! [X] : ! [Y] : (HandbrakeOf(X, Y) & Car(Y) => Up(X) <~> Down(X)).
! [X] : ! [Y] : (HandbrakeOf(X, Y) & Parked(Y) & Car(Y) => Down(X)).

[CONCLUSION]:
The handbrake is up when some cars are parked.

[CONCLUSION (FOL)]:
∃x ∃y (HandbrakeOf(x, y) ∧ Parked(y) ∧ Car(y) ∧ Up(x))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (HandbrakeOf(X, Y) & Parked(Y) & Car(Y) & Up(X)).


===

['x']
['x']
[PREMISE]:
All people in this midwest town who own horse ranches regularly ride horses for pleasure and sport.
All people in this midwest town with a lot of disposable income have a horse ranch.
If people in this midwest town compete in horse dressage shows, then they have a lot of disposable income.
If people in this midwest town compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.
If people in this midwest town regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.
Manny is in this midwest town, and she either has a horse ranch and lives in a cramped residential building, or she does neither.

[PREMISE (FOL)]:
∀x (InThisMidwestTown(x) ∧ Have(x, horseRanch) → RegularlyRideHorseForPleasure(x))
∀x (InThisMidwestTown(x) ∧ Have(x, disposableIncome) → Have(x, horseRank))
∀x (InThisMidwestTown(x) ∧ CompeteIn(x, horseDressageShow) → Have(x, disposableIncome))
∀x (InThisMidwestTown(x) ∧ CompeteIn(x, horseDressageShow) → InvestedIn(x, equestrianGearAndEquipment))
∀x (InThisMidwestTown(x) ∧ RegularlyRideHorseForPleasure(x) → ¬LiveIn(x, crampedBuilding))
InThisMidwestTown(manny) ∧ ¬(Have(manny, horseRanch) ⊕ LiveIn(manny, crampedBuilding))

[PREMISE (GK)]:
! [X] : (InThisMidwestTown(X) & Have(X, horseRanch) => RegularlyRideHorseForPleasure(X)).
! [X] : (InThisMidwestTown(X) & Have(X, disposableIncome) => Have(X, horseRank)).
! [X] : (InThisMidwestTown(X) & CompeteIn(X, horseDressageShow) => Have(X, disposableIncome)).
! [X] : (InThisMidwestTown(X) & CompeteIn(X, horseDressageShow) => InvestedIn(X, equestrianGearAndEquipment)).
! [X] : (InThisMidwestTown(X) & RegularlyRideHorseForPleasure(X) => -LiveIn(X, crampedBuilding)).
InThisMidwestTown(manny) & -(Have(manny, horseRanch) <~> LiveIn(manny, crampedBuilding)).

[CONCLUSION]:
Manny regularly rides horses for pleasure and sport.

[CONCLUSION (FOL)]:
RegularlyRideHorsesForPleasure(manny)

[CONCLUSION (GK)]:
RegularlyRideHorsesForPleasure(manny).


===

['x']
['x']
[PREMISE]:
All people in this midwest town who own horse ranches regularly ride horses for pleasure and sport.
All people in this midwest town with a lot of disposable income have a horse ranch.
If people in this midwest town compete in horse dressage shows, then they have a lot of disposable income.
If people in this midwest town compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.
If people in this midwest town regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.
Manny is in this midwest town, and she either has a horse ranch and lives in a cramped residential building, or she does neither.

[PREMISE (FOL)]:
∀x (InThisMidwestTown(x) ∧ Have(x, horseRanch) → RegularlyRideHorseForPleasure(x))
∀x (InThisMidwestTown(x) ∧ Have(x, disposableIncome) → Have(x, horseRank))
∀x (InThisMidwestTown(x) ∧ CompeteIn(x, horseDressageShow) → Have(x, disposableIncome))
∀x (InThisMidwestTown(x) ∧ CompeteIn(x, horseDressageShow) → InvestedIn(x, equestrianGearAndEquipment))
∀x (InThisMidwestTown(x) ∧ RegularlyRideHorseForPleasure(x) → ¬LiveIn(x, crampedBuilding))
InThisMidwestTown(manny) ∧ ¬(Have(manny, horseRanch) ⊕ LiveIn(manny, crampedBuilding))

[PREMISE (GK)]:
! [X] : (InThisMidwestTown(X) & Have(X, horseRanch) => RegularlyRideHorseForPleasure(X)).
! [X] : (InThisMidwestTown(X) & Have(X, disposableIncome) => Have(X, horseRank)).
! [X] : (InThisMidwestTown(X) & CompeteIn(X, horseDressageShow) => Have(X, disposableIncome)).
! [X] : (InThisMidwestTown(X) & CompeteIn(X, horseDressageShow) => InvestedIn(X, equestrianGearAndEquipment)).
! [X] : (InThisMidwestTown(X) & RegularlyRideHorseForPleasure(X) => -LiveIn(X, crampedBuilding)).
InThisMidwestTown(manny) & -(Have(manny, horseRanch) <~> LiveIn(manny, crampedBuilding)).

[CONCLUSION]:
Manny competes in horse dressage shows and has invested in high-quality equestrian equipment and gear.

[CONCLUSION (FOL)]:
CompeteIn(manny, horseDressageShow) ∧ InvestedIn(manny, equestrianGearAndEquipment)

[CONCLUSION (GK)]:
CompeteIn(manny, horseDressageShow) & InvestedIn(manny, equestrianGearAndEquipment).


===

['x']
['x']
[PREMISE]:
All people in this midwest town who own horse ranches regularly ride horses for pleasure and sport.
All people in this midwest town with a lot of disposable income have a horse ranch.
If people in this midwest town compete in horse dressage shows, then they have a lot of disposable income.
If people in this midwest town compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.
If people in this midwest town regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.
Manny is in this midwest town, and she either has a horse ranch and lives in a cramped residential building, or she does neither.

[PREMISE (FOL)]:
∀x (InThisMidwestTown(x) ∧ Have(x, horseRanch) → RegularlyRideHorseForPleasure(x))
∀x (InThisMidwestTown(x) ∧ Have(x, disposableIncome) → Have(x, horseRank))
∀x (InThisMidwestTown(x) ∧ CompeteIn(x, horseDressageShow) → Have(x, disposableIncome))
∀x (InThisMidwestTown(x) ∧ CompeteIn(x, horseDressageShow) → InvestedIn(x, equestrianGearAndEquipment))
∀x (InThisMidwestTown(x) ∧ RegularlyRideHorseForPleasure(x) → ¬LiveIn(x, crampedBuilding))
InThisMidwestTown(manny) ∧ ¬(Have(manny, horseRanch) ⊕ LiveIn(manny, crampedBuilding))

[PREMISE (GK)]:
! [X] : (InThisMidwestTown(X) & Have(X, horseRanch) => RegularlyRideHorseForPleasure(X)).
! [X] : (InThisMidwestTown(X) & Have(X, disposableIncome) => Have(X, horseRank)).
! [X] : (InThisMidwestTown(X) & CompeteIn(X, horseDressageShow) => Have(X, disposableIncome)).
! [X] : (InThisMidwestTown(X) & CompeteIn(X, horseDressageShow) => InvestedIn(X, equestrianGearAndEquipment)).
! [X] : (InThisMidwestTown(X) & RegularlyRideHorseForPleasure(X) => -LiveIn(X, crampedBuilding)).
InThisMidwestTown(manny) & -(Have(manny, horseRanch) <~> LiveIn(manny, crampedBuilding)).

[CONCLUSION]:
If Manny either has a horse ranch or competes in horse dressage shows, then Manny has not invested in high-quality equestrian equipment and gear.

[CONCLUSION (FOL)]:
¬(HaveAHorseRanch(manny) ⊕ CompeteIn(manny, horseDressageShow)) → ¬InvestedIn(manny, equestrianGearAndEquipment)

[CONCLUSION (GK)]:
-(HaveAHorseRanch(manny) <~> CompeteIn(manny, horseDressageShow)) => -InvestedIn(manny, equestrianGearAndEquipment).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A roundel is a rounded artillery fortification.
A roundel is not higher than adjacent walls. 
Cannons can be deployed on artillery fortifications. 
Roundels are the oldest artillery fortifications.
Battery towers are artillery fortifications.

[PREMISE (FOL)]:
∀x (Roundel(x) → (Rounded(x) ∧ ArtilleryFortification(x)))
∀x ∀y ((Roundel(x) ∧ AdjacentWalls(x,y)) → ¬Higher(x, y))
∀x (ArtilleryFortification(x) → DeployCannons(x))
∀x ∀y ((Roundel(x) ∧ ArtilleryFortification(y)) → Older(x, y))
∀x (BatteryTower(x) → ArtilleryFortification(x))

[PREMISE (GK)]:
! [X] : (Roundel(X) => (Rounded(X) & ArtilleryFortification(X))).
! [X] : ! [Y] : ((Roundel(X) & AdjacentWalls(X,Y)) => -Higher(X, Y)).
! [X] : (ArtilleryFortification(X) => DeployCannons(X)).
! [X] : ! [Y] : ((Roundel(X) & ArtilleryFortification(Y)) => Older(X, Y)).
! [X] : (BatteryTower(X) => ArtilleryFortification(X)).

[CONCLUSION]:
Cannons can be deployed on battery towers.

[CONCLUSION (FOL)]:
∀x (BatteryTower(x) → DeployCannons(x))

[CONCLUSION (GK)]:
! [X] : (BatteryTower(X) => DeployCannons(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A roundel is a rounded artillery fortification.
A roundel is not higher than adjacent walls. 
Cannons can be deployed on artillery fortifications. 
Roundels are the oldest artillery fortifications.
Battery towers are artillery fortifications.

[PREMISE (FOL)]:
∀x (Roundel(x) → (Rounded(x) ∧ ArtilleryFortification(x)))
∀x ∀y ((Roundel(x) ∧ AdjacentWalls(x,y)) → ¬Higher(x, y))
∀x (ArtilleryFortification(x) → DeployCannons(x))
∀x ∀y ((Roundel(x) ∧ ArtilleryFortification(y)) → Older(x, y))
∀x (BatteryTower(x) → ArtilleryFortification(x))

[PREMISE (GK)]:
! [X] : (Roundel(X) => (Rounded(X) & ArtilleryFortification(X))).
! [X] : ! [Y] : ((Roundel(X) & AdjacentWalls(X,Y)) => -Higher(X, Y)).
! [X] : (ArtilleryFortification(X) => DeployCannons(X)).
! [X] : ! [Y] : ((Roundel(X) & ArtilleryFortification(Y)) => Older(X, Y)).
! [X] : (BatteryTower(X) => ArtilleryFortification(X)).

[CONCLUSION]:
Roundels are older than battery towers.

[CONCLUSION (FOL)]:
∀x ∀y ((Roundel(x) ∧ BatteryTower(y)) → Older(x, y))

[CONCLUSION (GK)]:
! [X] : ! [Y] : ((Roundel(X) & BatteryTower(Y)) => Older(X, Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A roundel is a rounded artillery fortification.
A roundel is not higher than adjacent walls. 
Cannons can be deployed on artillery fortifications. 
Roundels are the oldest artillery fortifications.
Battery towers are artillery fortifications.

[PREMISE (FOL)]:
∀x (Roundel(x) → (Rounded(x) ∧ ArtilleryFortification(x)))
∀x ∀y ((Roundel(x) ∧ AdjacentWalls(x,y)) → ¬Higher(x, y))
∀x (ArtilleryFortification(x) → DeployCannons(x))
∀x ∀y ((Roundel(x) ∧ ArtilleryFortification(y)) → Older(x, y))
∀x (BatteryTower(x) → ArtilleryFortification(x))

[PREMISE (GK)]:
! [X] : (Roundel(X) => (Rounded(X) & ArtilleryFortification(X))).
! [X] : ! [Y] : ((Roundel(X) & AdjacentWalls(X,Y)) => -Higher(X, Y)).
! [X] : (ArtilleryFortification(X) => DeployCannons(X)).
! [X] : ! [Y] : ((Roundel(X) & ArtilleryFortification(Y)) => Older(X, Y)).
! [X] : (BatteryTower(X) => ArtilleryFortification(X)).

[CONCLUSION]:
Battery towers are higher than adjacent walls.

[CONCLUSION (FOL)]:
∀x ∀y ((BatteryTower(x) ∧ AdjacentWall(x,y)) → Higher(x, y))

[CONCLUSION (GK)]:
! [X] : ! [Y] : ((BatteryTower(X) & AdjacentWall(X,Y)) => Higher(X, Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A roundel is a rounded artillery fortification.
A roundel is not higher than adjacent walls. 
Cannons can be deployed on artillery fortifications. 
Roundels are the oldest artillery fortifications.
Battery towers are artillery fortifications.

[PREMISE (FOL)]:
∀x (Roundel(x) → (Rounded(x) ∧ ArtilleryFortification(x)))
∀x ∀y ((Roundel(x) ∧ AdjacentWalls(x,y)) → ¬Higher(x, y))
∀x (ArtilleryFortification(x) → DeployCannons(x))
∀x ∀y ((Roundel(x) ∧ ArtilleryFortification(y)) → Older(x, y))
∀x (BatteryTower(x) → ArtilleryFortification(x))

[PREMISE (GK)]:
! [X] : (Roundel(X) => (Rounded(X) & ArtilleryFortification(X))).
! [X] : ! [Y] : ((Roundel(X) & AdjacentWalls(X,Y)) => -Higher(X, Y)).
! [X] : (ArtilleryFortification(X) => DeployCannons(X)).
! [X] : ! [Y] : ((Roundel(X) & ArtilleryFortification(Y)) => Older(X, Y)).
! [X] : (BatteryTower(X) => ArtilleryFortification(X)).

[CONCLUSION]:
Cannons can be deployed on roundels.

[CONCLUSION (FOL)]:
∀x (Roundel(x) → DeployCannons(x))

[CONCLUSION (GK)]:
! [X] : (Roundel(X) => DeployCannons(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Tissues are soft.
Some papers are tissues.

[PREMISE (FOL)]:
∀x (Tissue(x) → Soft(x))
∃x ∃y (Paper(x) ∧ Paper(x) ∧ Tissue(x) ∧ Tissue(y) ∧ ¬(x=y))

[PREMISE (GK)]:
! [X] : (Tissue(X) => Soft(X)).
? [X] : ? [Y] : (Paper(X) & Paper(X) & Tissue(X) & Tissue(Y) & -(X=Y)).

[CONCLUSION]:
Some papers are hard.

[CONCLUSION (FOL)]:
∃x ∃y (Paper(x) ∧ Paper(y) ∧ Hard(x) ∧ Hard(y) ∧ ¬(x=y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Paper(X) & Paper(Y) & Hard(X) & Hard(Y) & -(X=Y)).


===

['x']
['x']
[PREMISE]:
All volunteers receive intangible benefits for their work.
Volunteers work regularly or on an as-needed basis.
Some volunteers are trained.
Volunteers work in groups or individually.
Environmental volunteers contribute toward environmental management or conservation.
Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.

[PREMISE (FOL)]:
∀x (Volunteer(x) → Receive(x, intangibleBenefit))
∀x (Volunteer(x) → WorkRegularly(x) ⊕ WorkAsNeeded(x))
∃x (Volunteer(x) → Trained(x))
∀x (Volunteer(x) → (WorkInGroup(x) ∨ WorkIndividually(x)))
∀x (Volunteer(x) ∧ Environmental(x) → (ContributeTo(x, environmentalManagement) ∨ ContributeTo(x, environmentalConservation)))
∃x (Volunteer(x) ∧ ContributeTo(x, naturalDisasterResponse) → WorkInGroup(x) ∧ WorkAsNeeded(x))

[PREMISE (GK)]:
! [X] : (Volunteer(X) => Receive(X, intangibleBenefit)).
! [X] : (Volunteer(X) => WorkRegularly(X) <~> WorkAsNeeded(X)).
? [X] : (Volunteer(X) => Trained(X)).
! [X] : (Volunteer(X) => (WorkInGroup(X) | WorkIndividually(X))).
! [X] : (Volunteer(X) & Environmental(X) => (ContributeTo(X, environmentalManagement) | ContributeTo(X, environmentalConservation))).
? [X] : (Volunteer(X) & ContributeTo(X, naturalDisasterResponse) => WorkInGroup(X) & WorkAsNeeded(X)).

[CONCLUSION]:
Volunteers who participate in natural disaster response receive intangible benefits for their work.

[CONCLUSION (FOL)]:
∀x (Volunteer(x) ∧ ContributeTo(x, naturalDisasterResponse) → Receive(x, intangibleBenefit))

[CONCLUSION (GK)]:
! [X] : (Volunteer(X) & ContributeTo(X, naturalDisasterResponse) => Receive(X, intangibleBenefit)).


===

['x']
['x']
[PREMISE]:
All volunteers receive intangible benefits for their work.
Volunteers work regularly or on an as-needed basis.
Some volunteers are trained.
Volunteers work in groups or individually.
Environmental volunteers contribute toward environmental management or conservation.
Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.

[PREMISE (FOL)]:
∀x (Volunteer(x) → Receive(x, intangibleBenefit))
∀x (Volunteer(x) → WorkRegularly(x) ⊕ WorkAsNeeded(x))
∃x (Volunteer(x) → Trained(x))
∀x (Volunteer(x) → (WorkInGroup(x) ∨ WorkIndividually(x)))
∀x (Volunteer(x) ∧ Environmental(x) → (ContributeTo(x, environmentalManagement) ∨ ContributeTo(x, environmentalConservation)))
∃x (Volunteer(x) ∧ ContributeTo(x, naturalDisasterResponse) → WorkInGroup(x) ∧ WorkAsNeeded(x))

[PREMISE (GK)]:
! [X] : (Volunteer(X) => Receive(X, intangibleBenefit)).
! [X] : (Volunteer(X) => WorkRegularly(X) <~> WorkAsNeeded(X)).
? [X] : (Volunteer(X) => Trained(X)).
! [X] : (Volunteer(X) => (WorkInGroup(X) | WorkIndividually(X))).
! [X] : (Volunteer(X) & Environmental(X) => (ContributeTo(X, environmentalManagement) | ContributeTo(X, environmentalConservation))).
? [X] : (Volunteer(X) & ContributeTo(X, naturalDisasterResponse) => WorkInGroup(X) & WorkAsNeeded(X)).

[CONCLUSION]:
Environmental volunteers work in groups.

[CONCLUSION (FOL)]:
∀x (Volunteer(x) ∧ Environmental(x) → WorkInGroup(x))

[CONCLUSION (GK)]:
! [X] : (Volunteer(X) & Environmental(X) => WorkInGroup(X)).


===

['x']
['x']
[PREMISE]:
All volunteers receive intangible benefits for their work.
Volunteers work regularly or on an as-needed basis.
Some volunteers are trained.
Volunteers work in groups or individually.
Environmental volunteers contribute toward environmental management or conservation.
Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.

[PREMISE (FOL)]:
∀x (Volunteer(x) → Receive(x, intangibleBenefit))
∀x (Volunteer(x) → WorkRegularly(x) ⊕ WorkAsNeeded(x))
∃x (Volunteer(x) → Trained(x))
∀x (Volunteer(x) → (WorkInGroup(x) ∨ WorkIndividually(x)))
∀x (Volunteer(x) ∧ Environmental(x) → (ContributeTo(x, environmentalManagement) ∨ ContributeTo(x, environmentalConservation)))
∃x (Volunteer(x) ∧ ContributeTo(x, naturalDisasterResponse) → WorkInGroup(x) ∧ WorkAsNeeded(x))

[PREMISE (GK)]:
! [X] : (Volunteer(X) => Receive(X, intangibleBenefit)).
! [X] : (Volunteer(X) => WorkRegularly(X) <~> WorkAsNeeded(X)).
? [X] : (Volunteer(X) => Trained(X)).
! [X] : (Volunteer(X) => (WorkInGroup(X) | WorkIndividually(X))).
! [X] : (Volunteer(X) & Environmental(X) => (ContributeTo(X, environmentalManagement) | ContributeTo(X, environmentalConservation))).
? [X] : (Volunteer(X) & ContributeTo(X, naturalDisasterResponse) => WorkInGroup(X) & WorkAsNeeded(X)).

[CONCLUSION]:
To be a volunteer, you must be trained.

[CONCLUSION (FOL)]:
∀x (Volunteer(x) → Trained(x))

[CONCLUSION (GK)]:
! [X] : (Volunteer(X) => Trained(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All people in this tech company who are consistent and enjoy sticking to their regular routines do not like surprises.
People in this tech company who wear the same flannel shirts every day are consistent and enjoy sticking to their regular routines.
People in this tech company who do not like shopping for clothes wear the same flannel shirts every day.
Old people living in stable homes do not like surprises.
People in this tech company who have very high energy and are impulsive like surprises.
Mike works in this tech company.
If Mike is not a person who wears the same flannel shirts every day, has very high energy, and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.

[PREMISE (FOL)]:
∀x (InThisTechCompany(x) ∧ Consistent(x) ∧ StickTo(x, theirRegularRoutine) → ¬Like(x, surprise))
∀x (InThisTechCompany(x) ∧ ∃y (flannelShirt(y) ∧ WearEveryday(x, y)) → Consistent(x) ∧ StickTo(x, theirRegularRoutine))
∀x (InThisTechCompany(x) ∧ ¬LikeShoppingFor(x, clothes) → ∃y (flannelShirt(y) ∧ WearEveryday(x, y)))
∀x (InThisTechCompany(x) ∧ Old(x) ∧ LiveIn(x, stableHome) → ¬Like(x, surprise))
∀x (InThisTechCompany(x) ∧ Have(x, highEnergy) ∧ Impulsive(x) → ¬Like(x, surprise))
InThisTechCompany(mike)
¬(∃y (flannelShirt(y) ∧ WearEveryday(x, y)) ∧ Have(mike, highEnergy) ∧ Impulsive(mike)) → (Consistent(mike) ∧ StickTo(mike, theirRegularRoutine)) ⊕ ¬Like(mike, surprise)

[PREMISE (GK)]:
! [X] : (InThisTechCompany(X) & Consistent(X) & StickTo(X, theirRegularRoutine) => -Like(X, surprise)).
! [X] : (InThisTechCompany(X) & ? [Y] : (flannelShirt(Y) & WearEveryday(X, Y)) => Consistent(X) & StickTo(X, theirRegularRoutine)).
! [X] : (InThisTechCompany(X) & -LikeShoppingFor(X, clothes) => ? [Y] : (flannelShirt(Y) & WearEveryday(X, Y))).
! [X] : (InThisTechCompany(X) & Old(X) & LiveIn(X, stableHome) => -Like(X, surprise)).
! [X] : (InThisTechCompany(X) & Have(X, highEnergy) & Impulsive(X) => -Like(X, surprise)).
InThisTechCompany(mike).
-(? [Y] : (flannelShirt(Y) & WearEveryday(x, Y)) & Have(mike, highEnergy) & Impulsive(mike)) => (Consistent(mike) & StickTo(mike, theirRegularRoutine)) <~> -Like(mike, surprise).

[CONCLUSION]:
Mike is an old person living in a stable home.

[CONCLUSION (FOL)]:
Old(mike) ∧ LiveIn(mike, stableHome)

[CONCLUSION (GK)]:
Old(mike) & LiveIn(mike, stableHome).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All people in this tech company who are consistent and enjoy sticking to their regular routines do not like surprises.
People in this tech company who wear the same flannel shirts every day are consistent and enjoy sticking to their regular routines.
People in this tech company who do not like shopping for clothes wear the same flannel shirts every day.
Old people living in stable homes do not like surprises.
People in this tech company who have very high energy and are impulsive like surprises.
Mike works in this tech company.
If Mike is not a person who wears the same flannel shirts every day, has very high energy, and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.

[PREMISE (FOL)]:
∀x (InThisTechCompany(x) ∧ Consistent(x) ∧ StickTo(x, theirRegularRoutine) → ¬Like(x, surprise))
∀x (InThisTechCompany(x) ∧ ∃y (flannelShirt(y) ∧ WearEveryday(x, y)) → Consistent(x) ∧ StickTo(x, theirRegularRoutine))
∀x (InThisTechCompany(x) ∧ ¬LikeShoppingFor(x, clothes) → ∃y (flannelShirt(y) ∧ WearEveryday(x, y)))
∀x (InThisTechCompany(x) ∧ Old(x) ∧ LiveIn(x, stableHome) → ¬Like(x, surprise))
∀x (InThisTechCompany(x) ∧ Have(x, highEnergy) ∧ Impulsive(x) → ¬Like(x, surprise))
InThisTechCompany(mike)
¬(∃y (flannelShirt(y) ∧ WearEveryday(x, y)) ∧ Have(mike, highEnergy) ∧ Impulsive(mike)) → (Consistent(mike) ∧ StickTo(mike, theirRegularRoutine)) ⊕ ¬Like(mike, surprise)

[PREMISE (GK)]:
! [X] : (InThisTechCompany(X) & Consistent(X) & StickTo(X, theirRegularRoutine) => -Like(X, surprise)).
! [X] : (InThisTechCompany(X) & ? [Y] : (flannelShirt(Y) & WearEveryday(X, Y)) => Consistent(X) & StickTo(X, theirRegularRoutine)).
! [X] : (InThisTechCompany(X) & -LikeShoppingFor(X, clothes) => ? [Y] : (flannelShirt(Y) & WearEveryday(X, Y))).
! [X] : (InThisTechCompany(X) & Old(X) & LiveIn(X, stableHome) => -Like(X, surprise)).
! [X] : (InThisTechCompany(X) & Have(X, highEnergy) & Impulsive(X) => -Like(X, surprise)).
InThisTechCompany(mike).
-(? [Y] : (flannelShirt(Y) & WearEveryday(x, Y)) & Have(mike, highEnergy) & Impulsive(mike)) => (Consistent(mike) & StickTo(mike, theirRegularRoutine)) <~> -Like(mike, surprise).

[CONCLUSION]:
If Mike wears the same flannel shirts every day or does not like shopping for clothes, then Mike is neither an old person living in a stable home nor does he like shopping for clothes.

[CONCLUSION (FOL)]:
(∃y (flannelShirt(y) ∧ WearEveryday(mike, y)) ∨ ¬LikeShoppingFor(mike, clothes)) → ¬(Old(mike) ∧ LiveIn(mike, stableHome)) ∧ ¬LikeShoppingFor(mike, clothes)

[CONCLUSION (GK)]:
(? [Y] : (flannelShirt(Y) & WearEveryday(mike, Y)) | -LikeShoppingFor(mike, clothes)) => -(Old(mike) & LiveIn(mike, stableHome)) & -LikeShoppingFor(mike, clothes).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All people in this tech company who are consistent and enjoy sticking to their regular routines do not like surprises.
People in this tech company who wear the same flannel shirts every day are consistent and enjoy sticking to their regular routines.
People in this tech company who do not like shopping for clothes wear the same flannel shirts every day.
Old people living in stable homes do not like surprises.
People in this tech company who have very high energy and are impulsive like surprises.
Mike works in this tech company.
If Mike is not a person who wears the same flannel shirts every day, has very high energy, and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.

[PREMISE (FOL)]:
∀x (InThisTechCompany(x) ∧ Consistent(x) ∧ StickTo(x, theirRegularRoutine) → ¬Like(x, surprise))
∀x (InThisTechCompany(x) ∧ ∃y (flannelShirt(y) ∧ WearEveryday(x, y)) → Consistent(x) ∧ StickTo(x, theirRegularRoutine))
∀x (InThisTechCompany(x) ∧ ¬LikeShoppingFor(x, clothes) → ∃y (flannelShirt(y) ∧ WearEveryday(x, y)))
∀x (InThisTechCompany(x) ∧ Old(x) ∧ LiveIn(x, stableHome) → ¬Like(x, surprise))
∀x (InThisTechCompany(x) ∧ Have(x, highEnergy) ∧ Impulsive(x) → ¬Like(x, surprise))
InThisTechCompany(mike)
¬(∃y (flannelShirt(y) ∧ WearEveryday(x, y)) ∧ Have(mike, highEnergy) ∧ Impulsive(mike)) → (Consistent(mike) ∧ StickTo(mike, theirRegularRoutine)) ⊕ ¬Like(mike, surprise)

[PREMISE (GK)]:
! [X] : (InThisTechCompany(X) & Consistent(X) & StickTo(X, theirRegularRoutine) => -Like(X, surprise)).
! [X] : (InThisTechCompany(X) & ? [Y] : (flannelShirt(Y) & WearEveryday(X, Y)) => Consistent(X) & StickTo(X, theirRegularRoutine)).
! [X] : (InThisTechCompany(X) & -LikeShoppingFor(X, clothes) => ? [Y] : (flannelShirt(Y) & WearEveryday(X, Y))).
! [X] : (InThisTechCompany(X) & Old(X) & LiveIn(X, stableHome) => -Like(X, surprise)).
! [X] : (InThisTechCompany(X) & Have(X, highEnergy) & Impulsive(X) => -Like(X, surprise)).
InThisTechCompany(mike).
-(? [Y] : (flannelShirt(Y) & WearEveryday(x, Y)) & Have(mike, highEnergy) & Impulsive(mike)) => (Consistent(mike) & StickTo(mike, theirRegularRoutine)) <~> -Like(mike, surprise).

[CONCLUSION]:
If Mike is not an old person living in a stable home and does not like shopping for clothes, then Mike does not like shopping for clothes.

[CONCLUSION (FOL)]:
¬(Old(mike) ∧ LiveIn(mike, stableHome)) ∧ ¬LikeShoppingFor(mike, clothes)) → ¬LikeShoppingFor(mike, clothes)

[CONCLUSION (GK)]:
-(Old(mike) & LiveIn(mike, stableHome)) & -LikeShoppingFor(mike, clothes)) => -LikeShoppingFor(mike, clothes).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Adam owns cars.
Adam has a favorite car.
Among the cars he owns, Adam's favorite car is European.
Adam broke his favorite car.

[PREMISE (FOL)]:
∃x∃y (Car(x) ∧ Car(y) ∧ (x≠y) ∧ Owns(adam, x)) 
∃x (Car(x) ∧ Favorite(adam, x))
∀x ((Car(x) ∧ Owns(adam, x) ∧ Favorite(adam, x)) → European(x))
∀x ((Car(x) ∧ Owns(adam, x) ∧ Favorite(adam, x)) → Broke(adam, x))

[PREMISE (GK)]:
? [X] :? [Y] : (Car(X) & Car(Y) & (X≠Y) & Owns(adam, X)) .
? [X] : (Car(X) & Favorite(adam, X)).
! [X] : ((Car(X) & Owns(adam, X) & Favorite(adam, X)) => European(X)).
! [X] : ((Car(X) & Owns(adam, X) & Favorite(adam, X)) => Broke(adam, X)).

[CONCLUSION]:
Adam owns a Japanese car.

[CONCLUSION (FOL)]:
∃x (Japanese(x) ∧ Owns(adam, x))

[CONCLUSION (GK)]:
? [X] : (Japanese(X) & Owns(adam, X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Adam owns cars.
Adam has a favorite car.
Among the cars he owns, Adam's favorite car is European.
Adam broke his favorite car.

[PREMISE (FOL)]:
∃x∃y (Car(x) ∧ Car(y) ∧ (x≠y) ∧ Owns(adam, x)) 
∃x (Car(x) ∧ Favorite(adam, x))
∀x ((Car(x) ∧ Owns(adam, x) ∧ Favorite(adam, x)) → European(x))
∀x ((Car(x) ∧ Owns(adam, x) ∧ Favorite(adam, x)) → Broke(adam, x))

[PREMISE (GK)]:
? [X] :? [Y] : (Car(X) & Car(Y) & (X≠Y) & Owns(adam, X)) .
? [X] : (Car(X) & Favorite(adam, X)).
! [X] : ((Car(X) & Owns(adam, X) & Favorite(adam, X)) => European(X)).
! [X] : ((Car(X) & Owns(adam, X) & Favorite(adam, X)) => Broke(adam, X)).

[CONCLUSION]:
Adam broke a European car.

[CONCLUSION (FOL)]:
∃x (European(x) ∧ Broke(adam, x))

[CONCLUSION (GK)]:
? [X] : (European(X) & Broke(adam, X)).


===

['x']
['x']
[PREMISE]:
There are no buildings in New Haven higher than 400 meters. 
All buildings managed by Yale Housing are in New Haven. 
All Manhattan skyscrapers are higher than 400 meters. 
All buildings owned by Bloomberg are in Manhattan. 
All buildings with the Bloomberg logo are buildings owned by Bloomberg. 
Tower A is neither a building in New Haven nor a skyscraper in Manhattan.
Tower B is a skyscraper building in Manhattan with a Bloomberg logo. 

[PREMISE (FOL)]:
∀x ((Buildings(x) ∧ In(x, newHaven)) → ¬HigherThan(x, num400))
∀x ((Buildings(x) ∧ ManagedBy(x, yaleHousing)) → In(x, newHaven))
∀x ((Buildings(x) ∧ Skyscraper(x) ∧ In(x, manhattan)) → HigherThan(x, num400))
∀x ((Buildings(x) ∧ OwnedBy(x, bloomberg)) → Skyscraper(x) ∧ In(x, manhattan))
∀x ((Buildings(x) ∧ HasLogo(x, bloomberg)) → OwnedBy(x, bloomberg))
Buildings(towerA) ∧ (¬InNewHaven(towerA)) ∧ (¬ManhattanSkyscraper(towerA))
Buildings(towerB) ∧ HasLogo(towerB, bloomberg) ∧ Skyscraper(towerB) ∧ In(towerB, manhattan)

[PREMISE (GK)]:
! [X] : ((Buildings(X) & In(X, newHaven)) => -HigherThan(X, num400)).
! [X] : ((Buildings(X) & ManagedBy(X, yaleHousing)) => In(X, newHaven)).
! [X] : ((Buildings(X) & Skyscraper(X) & In(X, manhattan)) => HigherThan(X, num400)).
! [X] : ((Buildings(X) & OwnedBy(X, bloomberg)) => Skyscraper(X) & In(X, manhattan)).
! [X] : ((Buildings(X) & HasLogo(X, bloomberg)) => OwnedBy(X, bloomberg)).
Buildings(towerA) & (-InNewHaven(towerA)) & (-ManhattanSkyscraper(towerA)).
Buildings(towerB) & HasLogo(towerB, bloomberg) & Skyscraper(towerB) & In(towerB, manhattan).

[CONCLUSION]:
Tower A is higher than 400 meters.

[CONCLUSION (FOL)]:
HigherThan(towerA, num400)

[CONCLUSION (GK)]:
HigherThan(towerA, num400).


===

['x']
['x']
[PREMISE]:
There are no buildings in New Haven higher than 400 meters. 
All buildings managed by Yale Housing are in New Haven. 
All Manhattan skyscrapers are higher than 400 meters. 
All buildings owned by Bloomberg are in Manhattan. 
All buildings with the Bloomberg logo are buildings owned by Bloomberg. 
Tower A is neither a building in New Haven nor a skyscraper in Manhattan.
Tower B is a skyscraper building in Manhattan with a Bloomberg logo. 

[PREMISE (FOL)]:
∀x ((Buildings(x) ∧ In(x, newHaven)) → ¬HigherThan(x, num400))
∀x ((Buildings(x) ∧ ManagedBy(x, yaleHousing)) → In(x, newHaven))
∀x ((Buildings(x) ∧ Skyscraper(x) ∧ In(x, manhattan)) → HigherThan(x, num400))
∀x ((Buildings(x) ∧ OwnedBy(x, bloomberg)) → Skyscraper(x) ∧ In(x, manhattan))
∀x ((Buildings(x) ∧ HasLogo(x, bloomberg)) → OwnedBy(x, bloomberg))
Buildings(towerA) ∧ (¬InNewHaven(towerA)) ∧ (¬ManhattanSkyscraper(towerA))
Buildings(towerB) ∧ HasLogo(towerB, bloomberg) ∧ Skyscraper(towerB) ∧ In(towerB, manhattan)

[PREMISE (GK)]:
! [X] : ((Buildings(X) & In(X, newHaven)) => -HigherThan(X, num400)).
! [X] : ((Buildings(X) & ManagedBy(X, yaleHousing)) => In(X, newHaven)).
! [X] : ((Buildings(X) & Skyscraper(X) & In(X, manhattan)) => HigherThan(X, num400)).
! [X] : ((Buildings(X) & OwnedBy(X, bloomberg)) => Skyscraper(X) & In(X, manhattan)).
! [X] : ((Buildings(X) & HasLogo(X, bloomberg)) => OwnedBy(X, bloomberg)).
Buildings(towerA) & (-InNewHaven(towerA)) & (-ManhattanSkyscraper(towerA)).
Buildings(towerB) & HasLogo(towerB, bloomberg) & Skyscraper(towerB) & In(towerB, manhattan).

[CONCLUSION]:
Tower A is not higher than 400 meters.

[CONCLUSION (FOL)]:
¬HigherThan(towerA, num400)

[CONCLUSION (GK)]:
-HigherThan(towerA, num400).


===

['x']
['x']
[PREMISE]:
There are no buildings in New Haven higher than 400 meters. 
All buildings managed by Yale Housing are in New Haven. 
All Manhattan skyscrapers are higher than 400 meters. 
All buildings owned by Bloomberg are in Manhattan. 
All buildings with the Bloomberg logo are buildings owned by Bloomberg. 
Tower A is neither a building in New Haven nor a skyscraper in Manhattan.
Tower B is a skyscraper building in Manhattan with a Bloomberg logo. 

[PREMISE (FOL)]:
∀x ((Buildings(x) ∧ In(x, newHaven)) → ¬HigherThan(x, num400))
∀x ((Buildings(x) ∧ ManagedBy(x, yaleHousing)) → In(x, newHaven))
∀x ((Buildings(x) ∧ Skyscraper(x) ∧ In(x, manhattan)) → HigherThan(x, num400))
∀x ((Buildings(x) ∧ OwnedBy(x, bloomberg)) → Skyscraper(x) ∧ In(x, manhattan))
∀x ((Buildings(x) ∧ HasLogo(x, bloomberg)) → OwnedBy(x, bloomberg))
Buildings(towerA) ∧ (¬InNewHaven(towerA)) ∧ (¬ManhattanSkyscraper(towerA))
Buildings(towerB) ∧ HasLogo(towerB, bloomberg) ∧ Skyscraper(towerB) ∧ In(towerB, manhattan)

[PREMISE (GK)]:
! [X] : ((Buildings(X) & In(X, newHaven)) => -HigherThan(X, num400)).
! [X] : ((Buildings(X) & ManagedBy(X, yaleHousing)) => In(X, newHaven)).
! [X] : ((Buildings(X) & Skyscraper(X) & In(X, manhattan)) => HigherThan(X, num400)).
! [X] : ((Buildings(X) & OwnedBy(X, bloomberg)) => Skyscraper(X) & In(X, manhattan)).
! [X] : ((Buildings(X) & HasLogo(X, bloomberg)) => OwnedBy(X, bloomberg)).
Buildings(towerA) & (-InNewHaven(towerA)) & (-ManhattanSkyscraper(towerA)).
Buildings(towerB) & HasLogo(towerB, bloomberg) & Skyscraper(towerB) & In(towerB, manhattan).

[CONCLUSION]:
Tower A is a building with the Bloomberg logo or it is managed by Yale Housing.

[CONCLUSION (FOL)]:
HasLogo(towerB, bloomberg) ∨ ManagedBy(x, yaleHousing)

[CONCLUSION (GK)]:
HasLogo(towerB, bloomberg) | ManagedBy(X, yaleHousing).


===

['x']
['x']
[PREMISE]:
There are no buildings in New Haven higher than 400 meters. 
All buildings managed by Yale Housing are in New Haven. 
All Manhattan skyscrapers are higher than 400 meters. 
All buildings owned by Bloomberg are in Manhattan. 
All buildings with the Bloomberg logo are buildings owned by Bloomberg. 
Tower A is neither a building in New Haven nor a skyscraper in Manhattan.
Tower B is a skyscraper building in Manhattan with a Bloomberg logo. 

[PREMISE (FOL)]:
∀x ((Buildings(x) ∧ In(x, newHaven)) → ¬HigherThan(x, num400))
∀x ((Buildings(x) ∧ ManagedBy(x, yaleHousing)) → In(x, newHaven))
∀x ((Buildings(x) ∧ Skyscraper(x) ∧ In(x, manhattan)) → HigherThan(x, num400))
∀x ((Buildings(x) ∧ OwnedBy(x, bloomberg)) → Skyscraper(x) ∧ In(x, manhattan))
∀x ((Buildings(x) ∧ HasLogo(x, bloomberg)) → OwnedBy(x, bloomberg))
Buildings(towerA) ∧ (¬InNewHaven(towerA)) ∧ (¬ManhattanSkyscraper(towerA))
Buildings(towerB) ∧ HasLogo(towerB, bloomberg) ∧ Skyscraper(towerB) ∧ In(towerB, manhattan)

[PREMISE (GK)]:
! [X] : ((Buildings(X) & In(X, newHaven)) => -HigherThan(X, num400)).
! [X] : ((Buildings(X) & ManagedBy(X, yaleHousing)) => In(X, newHaven)).
! [X] : ((Buildings(X) & Skyscraper(X) & In(X, manhattan)) => HigherThan(X, num400)).
! [X] : ((Buildings(X) & OwnedBy(X, bloomberg)) => Skyscraper(X) & In(X, manhattan)).
! [X] : ((Buildings(X) & HasLogo(X, bloomberg)) => OwnedBy(X, bloomberg)).
Buildings(towerA) & (-InNewHaven(towerA)) & (-ManhattanSkyscraper(towerA)).
Buildings(towerB) & HasLogo(towerB, bloomberg) & Skyscraper(towerB) & In(towerB, manhattan).

[CONCLUSION]:
Tower A is neither a building with the Bloomberg logo nor managed by Yale Housing.

[CONCLUSION (FOL)]:
¬HasLogo(towerB, bloomberg) ∧ (¬ManagedBy(x, yaleHousing))

[CONCLUSION (GK)]:
-HasLogo(towerB, bloomberg) & (-ManagedBy(X, yaleHousing)).


===

['x']
['x']
[PREMISE]:
No fish are birds.
An osprey is a bird.
A carp is a fish.
All goldfish are carp.
If Bubbles is either an osprey or a goldfish, then Bubbles is not also a fish.

[PREMISE (FOL)]:
∀x (Fish(x) → ¬Bird(x))
∀x (Osprey(x) → Bird(x))
∀x (Carp(x) → Fish(x))
∀x (Goldfish(x) → Carp(x))
Osprey(bubbles) ⊕ Goldfish(bubbles) → ¬Fish(bubbles)

[PREMISE (GK)]:
! [X] : (Fish(X) => -Bird(X)).
! [X] : (Osprey(X) => Bird(X)).
! [X] : (Carp(X) => Fish(X)).
! [X] : (Goldfish(X) => Carp(X)).
Osprey(bubbles) <~> Goldfish(bubbles) => -Fish(bubbles).

[CONCLUSION]:
Bubbles is an Osprey.

[CONCLUSION (FOL)]:
Osprey(bubbles)

[CONCLUSION (GK)]:
Osprey(bubbles).


===

['x']
['x']
[PREMISE]:
No fish are birds.
An osprey is a bird.
A carp is a fish.
All goldfish are carp.
If Bubbles is either an osprey or a goldfish, then Bubbles is not also a fish.

[PREMISE (FOL)]:
∀x (Fish(x) → ¬Bird(x))
∀x (Osprey(x) → Bird(x))
∀x (Carp(x) → Fish(x))
∀x (Goldfish(x) → Carp(x))
Osprey(bubbles) ⊕ Goldfish(bubbles) → ¬Fish(bubbles)

[PREMISE (GK)]:
! [X] : (Fish(X) => -Bird(X)).
! [X] : (Osprey(X) => Bird(X)).
! [X] : (Carp(X) => Fish(X)).
! [X] : (Goldfish(X) => Carp(X)).
Osprey(bubbles) <~> Goldfish(bubbles) => -Fish(bubbles).

[CONCLUSION]:
Bubbles is a goldfish.

[CONCLUSION (FOL)]:
Goldfish(bubbles)

[CONCLUSION (GK)]:
Goldfish(bubbles).


===

['x']
['x']
[PREMISE]:
No fish are birds.
An osprey is a bird.
A carp is a fish.
All goldfish are carp.
If Bubbles is either an osprey or a goldfish, then Bubbles is not also a fish.

[PREMISE (FOL)]:
∀x (Fish(x) → ¬Bird(x))
∀x (Osprey(x) → Bird(x))
∀x (Carp(x) → Fish(x))
∀x (Goldfish(x) → Carp(x))
Osprey(bubbles) ⊕ Goldfish(bubbles) → ¬Fish(bubbles)

[PREMISE (GK)]:
! [X] : (Fish(X) => -Bird(X)).
! [X] : (Osprey(X) => Bird(X)).
! [X] : (Carp(X) => Fish(X)).
! [X] : (Goldfish(X) => Carp(X)).
Osprey(bubbles) <~> Goldfish(bubbles) => -Fish(bubbles).

[CONCLUSION]:
Bubbles is not a goldfish.

[CONCLUSION (FOL)]:
¬Goldfish(bubbles)

[CONCLUSION (GK)]:
-Goldfish(bubbles).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Mr. and Mrs. Smith make a travel plan: they want to go to a city in California or Florida where neither of them has ever been.
The cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.
Cities in Florida that they are interested in are Orlando and Miami.
Mr. Smith has been to two cities in California.
Mrs. Smith has been to one city in Florida.

[PREMISE (FOL)]:
∀x (WantToGoTo(mr.AndMrs.Smith, x) ∧ City(x) → (California(x) ∨ Florida(x)) ∧ NeverGo(x))
City(sanFrancisco) ∧ California(sanFrancisco) ∧ WantToGoTo(mr.AndMrs.Smith, sanFrancisco) ∧ City(losAngeles) ∧ California(losAngeles) ∧ WantToGoTo(mr.AndMrs.Smith, losAngeles) ∧ City(sanDiego) ∧ California(sanDiego) ∧ WantToGoTo(mr.AndMrs.Smith, sanDiego)
City(orlando) ∧ Florida(orlando) ∧ WantToGo(mr.AndMrs.Smith, orlando) ∧ City(miami) ∧ Florida(miami) ∧ WantToGo(mr.AndMrs.Smith, miami)
∃x ∃y ∀z (¬(x=z) ∧ ¬(y=z) ∧ ¬(x=y) ∧ City(x) ∧ City(y) ∧ City(z) ∧ California(x) ∧ California(y) ∧ California(z) → Visit(mr.smith, x) ∧ Visit(mr.smith, y) ∧ ¬Visit(mr.smith, z))
∃x ∀y (¬(x=y) ∧ City(x) ∧ City(y) ∧ Florida(x) ∧ Florida(y) → Visit(mrs.smith, x) ∧ ¬Visit(mrs.smith, y))

[PREMISE (GK)]:
! [X] : (WantToGoTo(mr.AndMrs.Smith, X) & City(X) => (California(X) | Florida(X)) & NeverGo(X)).
City(sanFrancisco) & California(sanFrancisco) & WantToGoTo(mr.AndMrs.Smith, sanFrancisco) & City(losAngeles) & California(losAngeles) & WantToGoTo(mr.AndMrs.Smith, losAngeles) & City(sanDiego) & California(sanDiego) & WantToGoTo(mr.AndMrs.Smith, sanDiego).
City(orlando) & Florida(orlando) & WantToGo(mr.AndMrs.Smith, orlando) & City(miami) & Florida(miami) & WantToGo(mr.AndMrs.Smith, miami).
? [X] : ? [Y] : ! [Z] : (-(X=Z) & -(Y=Z) & -(X=Y) & City(X) & City(Y) & City(Z) & California(X) & California(Y) & California(Z) => Visit(mr.smith, X) & Visit(mr.smith, Y) & -Visit(mr.smith, Z)).
? [X] : ! [Y] : (-(X=Y) & City(X) & City(Y) & Florida(X) & Florida(Y) => Visit(mrs.smith, X) & -Visit(mrs.smith, Y)).

[CONCLUSION]:
Mr. Smith has been to San Francisco.

[CONCLUSION (FOL)]:
∃x (City(x) ∧ Visit(mr.smith, sanFrancisco))

[CONCLUSION (GK)]:
? [X] : (City(X) & Visit(mr.smith, sanFrancisco)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Mr. and Mrs. Smith make a travel plan: they want to go to a city in California or Florida where neither of them has ever been.
The cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.
Cities in Florida that they are interested in are Orlando and Miami.
Mr. Smith has been to two cities in California.
Mrs. Smith has been to one city in Florida.

[PREMISE (FOL)]:
∀x (WantToGoTo(mr.AndMrs.Smith, x) ∧ City(x) → (California(x) ∨ Florida(x)) ∧ NeverGo(x))
City(sanFrancisco) ∧ California(sanFrancisco) ∧ WantToGoTo(mr.AndMrs.Smith, sanFrancisco) ∧ City(losAngeles) ∧ California(losAngeles) ∧ WantToGoTo(mr.AndMrs.Smith, losAngeles) ∧ City(sanDiego) ∧ California(sanDiego) ∧ WantToGoTo(mr.AndMrs.Smith, sanDiego)
City(orlando) ∧ Florida(orlando) ∧ WantToGo(mr.AndMrs.Smith, orlando) ∧ City(miami) ∧ Florida(miami) ∧ WantToGo(mr.AndMrs.Smith, miami)
∃x ∃y ∀z (¬(x=z) ∧ ¬(y=z) ∧ ¬(x=y) ∧ City(x) ∧ City(y) ∧ City(z) ∧ California(x) ∧ California(y) ∧ California(z) → Visit(mr.smith, x) ∧ Visit(mr.smith, y) ∧ ¬Visit(mr.smith, z))
∃x ∀y (¬(x=y) ∧ City(x) ∧ City(y) ∧ Florida(x) ∧ Florida(y) → Visit(mrs.smith, x) ∧ ¬Visit(mrs.smith, y))

[PREMISE (GK)]:
! [X] : (WantToGoTo(mr.AndMrs.Smith, X) & City(X) => (California(X) | Florida(X)) & NeverGo(X)).
City(sanFrancisco) & California(sanFrancisco) & WantToGoTo(mr.AndMrs.Smith, sanFrancisco) & City(losAngeles) & California(losAngeles) & WantToGoTo(mr.AndMrs.Smith, losAngeles) & City(sanDiego) & California(sanDiego) & WantToGoTo(mr.AndMrs.Smith, sanDiego).
City(orlando) & Florida(orlando) & WantToGo(mr.AndMrs.Smith, orlando) & City(miami) & Florida(miami) & WantToGo(mr.AndMrs.Smith, miami).
? [X] : ? [Y] : ! [Z] : (-(X=Z) & -(Y=Z) & -(X=Y) & City(X) & City(Y) & City(Z) & California(X) & California(Y) & California(Z) => Visit(mr.smith, X) & Visit(mr.smith, Y) & -Visit(mr.smith, Z)).
? [X] : ! [Y] : (-(X=Y) & City(X) & City(Y) & Florida(X) & Florida(Y) => Visit(mrs.smith, X) & -Visit(mrs.smith, Y)).

[CONCLUSION]:
They have at leat one candidate city in Florida to visit.

[CONCLUSION (FOL)]:
∃x (WantToGoTo(x) ∧ City(x) ∧ Florida(x))

[CONCLUSION (GK)]:
? [X] : (WantToGoTo(X) & City(X) & Florida(X)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Mr. and Mrs. Smith make a travel plan: they want to go to a city in California or Florida where neither of them has ever been.
The cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.
Cities in Florida that they are interested in are Orlando and Miami.
Mr. Smith has been to two cities in California.
Mrs. Smith has been to one city in Florida.

[PREMISE (FOL)]:
∀x (WantToGoTo(mr.AndMrs.Smith, x) ∧ City(x) → (California(x) ∨ Florida(x)) ∧ NeverGo(x))
City(sanFrancisco) ∧ California(sanFrancisco) ∧ WantToGoTo(mr.AndMrs.Smith, sanFrancisco) ∧ City(losAngeles) ∧ California(losAngeles) ∧ WantToGoTo(mr.AndMrs.Smith, losAngeles) ∧ City(sanDiego) ∧ California(sanDiego) ∧ WantToGoTo(mr.AndMrs.Smith, sanDiego)
City(orlando) ∧ Florida(orlando) ∧ WantToGo(mr.AndMrs.Smith, orlando) ∧ City(miami) ∧ Florida(miami) ∧ WantToGo(mr.AndMrs.Smith, miami)
∃x ∃y ∀z (¬(x=z) ∧ ¬(y=z) ∧ ¬(x=y) ∧ City(x) ∧ City(y) ∧ City(z) ∧ California(x) ∧ California(y) ∧ California(z) → Visit(mr.smith, x) ∧ Visit(mr.smith, y) ∧ ¬Visit(mr.smith, z))
∃x ∀y (¬(x=y) ∧ City(x) ∧ City(y) ∧ Florida(x) ∧ Florida(y) → Visit(mrs.smith, x) ∧ ¬Visit(mrs.smith, y))

[PREMISE (GK)]:
! [X] : (WantToGoTo(mr.AndMrs.Smith, X) & City(X) => (California(X) | Florida(X)) & NeverGo(X)).
City(sanFrancisco) & California(sanFrancisco) & WantToGoTo(mr.AndMrs.Smith, sanFrancisco) & City(losAngeles) & California(losAngeles) & WantToGoTo(mr.AndMrs.Smith, losAngeles) & City(sanDiego) & California(sanDiego) & WantToGoTo(mr.AndMrs.Smith, sanDiego).
City(orlando) & Florida(orlando) & WantToGo(mr.AndMrs.Smith, orlando) & City(miami) & Florida(miami) & WantToGo(mr.AndMrs.Smith, miami).
? [X] : ? [Y] : ! [Z] : (-(X=Z) & -(Y=Z) & -(X=Y) & City(X) & City(Y) & City(Z) & California(X) & California(Y) & California(Z) => Visit(mr.smith, X) & Visit(mr.smith, Y) & -Visit(mr.smith, Z)).
? [X] : ! [Y] : (-(X=Y) & City(X) & City(Y) & Florida(X) & Florida(Y) => Visit(mrs.smith, X) & -Visit(mrs.smith, Y)).

[CONCLUSION]:
They have at least two candidate cities in California to visit.

[CONCLUSION (FOL)]:
∃x ∃y (¬(x=y) ∧ City(x) ∧ City(y) ∧ WantToGoTo(mr.AndMrs.Smith, x) ∧ California(x) ∧ WantToGoTo(mr.AndMrs.Smith, y) ∧ California(y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (-(X=Y) & City(X) & City(Y) & WantToGoTo(mr.AndMrs.Smith, X) & California(X) & WantToGoTo(mr.AndMrs.Smith, Y) & California(Y)).


===

['x']
['x']
[PREMISE]:
Everything in Size Town is big or small.
All big things in Size Town are heavy.
All small things in Size Town are light.
All heavy things in Size Town are still.
All light things in Size Town are unstable.
All unstable things in Size Town are changing.
All unstable things in Size Town are unpredictable.
The bird is in Size Town and it is not both heavy and still.

[PREMISE (FOL)]:
∀x (In(x, sizeTown) → (Big(x) ∨ Small(x)))
∀x (Big(x) ∧ In(x, sizeTown) → Heavy(x))
∀x (Small(x) ∧ In(x, sizeTown) → Light(x))
∀x (Heavy(x) ∧ In(x, sizeTown) → Still(x))
∀x (Light(x) ∧ In(x, sizeTown) → Unstable(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Changing(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Unpredictable(x))
In(bird, sizeTown) ∧ ¬(Heavy(bird) ∧ Still(bird))

[PREMISE (GK)]:
! [X] : (In(X, sizeTown) => (Big(X) | Small(X))).
! [X] : (Big(X) & In(X, sizeTown) => Heavy(X)).
! [X] : (Small(X) & In(X, sizeTown) => Light(X)).
! [X] : (Heavy(X) & In(X, sizeTown) => Still(X)).
! [X] : (Light(X) & In(X, sizeTown) => Unstable(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Changing(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Unpredictable(X)).
In(bird, sizeTown) & -(Heavy(bird) & Still(bird)).

[CONCLUSION]:
The bird is still.

[CONCLUSION (FOL)]:
Still(bird)

[CONCLUSION (GK)]:
Still(bird).


===

['x']
['x']
[PREMISE]:
Everything in Size Town is big or small.
All big things in Size Town are heavy.
All small things in Size Town are light.
All heavy things in Size Town are still.
All light things in Size Town are unstable.
All unstable things in Size Town are changing.
All unstable things in Size Town are unpredictable.
The bird is in Size Town and it is not both heavy and still.

[PREMISE (FOL)]:
∀x (In(x, sizeTown) → (Big(x) ∨ Small(x)))
∀x (Big(x) ∧ In(x, sizeTown) → Heavy(x))
∀x (Small(x) ∧ In(x, sizeTown) → Light(x))
∀x (Heavy(x) ∧ In(x, sizeTown) → Still(x))
∀x (Light(x) ∧ In(x, sizeTown) → Unstable(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Changing(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Unpredictable(x))
In(bird, sizeTown) ∧ ¬(Heavy(bird) ∧ Still(bird))

[PREMISE (GK)]:
! [X] : (In(X, sizeTown) => (Big(X) | Small(X))).
! [X] : (Big(X) & In(X, sizeTown) => Heavy(X)).
! [X] : (Small(X) & In(X, sizeTown) => Light(X)).
! [X] : (Heavy(X) & In(X, sizeTown) => Still(X)).
! [X] : (Light(X) & In(X, sizeTown) => Unstable(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Changing(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Unpredictable(X)).
In(bird, sizeTown) & -(Heavy(bird) & Still(bird)).

[CONCLUSION]:
The bird is not still.

[CONCLUSION (FOL)]:
¬Still(bird)

[CONCLUSION (GK)]:
-Still(bird).


===

['x']
['x']
[PREMISE]:
Everything in Size Town is big or small.
All big things in Size Town are heavy.
All small things in Size Town are light.
All heavy things in Size Town are still.
All light things in Size Town are unstable.
All unstable things in Size Town are changing.
All unstable things in Size Town are unpredictable.
The bird is in Size Town and it is not both heavy and still.

[PREMISE (FOL)]:
∀x (In(x, sizeTown) → (Big(x) ∨ Small(x)))
∀x (Big(x) ∧ In(x, sizeTown) → Heavy(x))
∀x (Small(x) ∧ In(x, sizeTown) → Light(x))
∀x (Heavy(x) ∧ In(x, sizeTown) → Still(x))
∀x (Light(x) ∧ In(x, sizeTown) → Unstable(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Changing(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Unpredictable(x))
In(bird, sizeTown) ∧ ¬(Heavy(bird) ∧ Still(bird))

[PREMISE (GK)]:
! [X] : (In(X, sizeTown) => (Big(X) | Small(X))).
! [X] : (Big(X) & In(X, sizeTown) => Heavy(X)).
! [X] : (Small(X) & In(X, sizeTown) => Light(X)).
! [X] : (Heavy(X) & In(X, sizeTown) => Still(X)).
! [X] : (Light(X) & In(X, sizeTown) => Unstable(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Changing(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Unpredictable(X)).
In(bird, sizeTown) & -(Heavy(bird) & Still(bird)).

[CONCLUSION]:
The bird is unpredictable and changing.

[CONCLUSION (FOL)]:
Unpredictable(bird) ∧ Changing(bird)

[CONCLUSION (GK)]:
Unpredictable(bird) & Changing(bird).


===

['x']
['x']
[PREMISE]:
Everything in Size Town is big or small.
All big things in Size Town are heavy.
All small things in Size Town are light.
All heavy things in Size Town are still.
All light things in Size Town are unstable.
All unstable things in Size Town are changing.
All unstable things in Size Town are unpredictable.
The bird is in Size Town and it is not both heavy and still.

[PREMISE (FOL)]:
∀x (In(x, sizeTown) → (Big(x) ∨ Small(x)))
∀x (Big(x) ∧ In(x, sizeTown) → Heavy(x))
∀x (Small(x) ∧ In(x, sizeTown) → Light(x))
∀x (Heavy(x) ∧ In(x, sizeTown) → Still(x))
∀x (Light(x) ∧ In(x, sizeTown) → Unstable(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Changing(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Unpredictable(x))
In(bird, sizeTown) ∧ ¬(Heavy(bird) ∧ Still(bird))

[PREMISE (GK)]:
! [X] : (In(X, sizeTown) => (Big(X) | Small(X))).
! [X] : (Big(X) & In(X, sizeTown) => Heavy(X)).
! [X] : (Small(X) & In(X, sizeTown) => Light(X)).
! [X] : (Heavy(X) & In(X, sizeTown) => Still(X)).
! [X] : (Light(X) & In(X, sizeTown) => Unstable(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Changing(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Unpredictable(X)).
In(bird, sizeTown) & -(Heavy(bird) & Still(bird)).

[CONCLUSION]:
The bird is unpredictable or changing.

[CONCLUSION (FOL)]:
Unpredictable(bird) ∨ Changing(bird)

[CONCLUSION (GK)]:
Unpredictable(bird) | Changing(bird).


===

['x']
['x']
[PREMISE]:
Everything in Size Town is big or small.
All big things in Size Town are heavy.
All small things in Size Town are light.
All heavy things in Size Town are still.
All light things in Size Town are unstable.
All unstable things in Size Town are changing.
All unstable things in Size Town are unpredictable.
The bird is in Size Town and it is not both heavy and still.

[PREMISE (FOL)]:
∀x (In(x, sizeTown) → (Big(x) ∨ Small(x)))
∀x (Big(x) ∧ In(x, sizeTown) → Heavy(x))
∀x (Small(x) ∧ In(x, sizeTown) → Light(x))
∀x (Heavy(x) ∧ In(x, sizeTown) → Still(x))
∀x (Light(x) ∧ In(x, sizeTown) → Unstable(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Changing(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Unpredictable(x))
In(bird, sizeTown) ∧ ¬(Heavy(bird) ∧ Still(bird))

[PREMISE (GK)]:
! [X] : (In(X, sizeTown) => (Big(X) | Small(X))).
! [X] : (Big(X) & In(X, sizeTown) => Heavy(X)).
! [X] : (Small(X) & In(X, sizeTown) => Light(X)).
! [X] : (Heavy(X) & In(X, sizeTown) => Still(X)).
! [X] : (Light(X) & In(X, sizeTown) => Unstable(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Changing(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Unpredictable(X)).
In(bird, sizeTown) & -(Heavy(bird) & Still(bird)).

[CONCLUSION]:
The bird is either unpredictable or changing.

[CONCLUSION (FOL)]:
Unpredictable(bird) ⊕ Changing(bird)

[CONCLUSION (GK)]:
Unpredictable(bird) <~> Changing(bird).


===

['x']
['x']
[PREMISE]:
Everything in Size Town is big or small.
All big things in Size Town are heavy.
All small things in Size Town are light.
All heavy things in Size Town are still.
All light things in Size Town are unstable.
All unstable things in Size Town are changing.
All unstable things in Size Town are unpredictable.
The bird is in Size Town and it is not both heavy and still.

[PREMISE (FOL)]:
∀x (In(x, sizeTown) → (Big(x) ∨ Small(x)))
∀x (Big(x) ∧ In(x, sizeTown) → Heavy(x))
∀x (Small(x) ∧ In(x, sizeTown) → Light(x))
∀x (Heavy(x) ∧ In(x, sizeTown) → Still(x))
∀x (Light(x) ∧ In(x, sizeTown) → Unstable(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Changing(x))
∀x (Unstable(x) ∧ In(x, sizeTown) → Unpredictable(x))
In(bird, sizeTown) ∧ ¬(Heavy(bird) ∧ Still(bird))

[PREMISE (GK)]:
! [X] : (In(X, sizeTown) => (Big(X) | Small(X))).
! [X] : (Big(X) & In(X, sizeTown) => Heavy(X)).
! [X] : (Small(X) & In(X, sizeTown) => Light(X)).
! [X] : (Heavy(X) & In(X, sizeTown) => Still(X)).
! [X] : (Light(X) & In(X, sizeTown) => Unstable(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Changing(X)).
! [X] : (Unstable(X) & In(X, sizeTown) => Unpredictable(X)).
In(bird, sizeTown) & -(Heavy(bird) & Still(bird)).

[CONCLUSION]:
If the bird is small or still, then it is either unpredictable or changing.

[CONCLUSION (FOL)]:
Small(bird) ∨ Still(bird) → Unpredictable(bird) ⊕ Changing(bird)

[CONCLUSION (GK)]:
Small(bird) | Still(bird) => Unpredictable(bird) <~> Changing(bird).


===

[]
['x']
[PREMISE]:
DI Ray is a police procedural television series.
DI Ray was created and written by Maya Sondhi.
DI Ray was produced by Jed Mercurio.
Maya Sondhi and Jed Mercurio are both British.

[PREMISE (FOL)]:
TelevisionSeries(dIRay) ∧ PoliceProcedural(dIRay)
Creates(maya, dIRay) ∧ Writes(maya, dIRay)
Produces(jed, dIRay)
British(maya) ∧ British(jed) 

[PREMISE (GK)]:
TelevisionSeries(dIRay) & PoliceProcedural(dIRay).
Creates(maya, dIRay) & Writes(maya, dIRay).
Produces(jed, dIRay).
British(maya) & British(jed) .

[CONCLUSION]:
DI Ray was created by a Brit.

[CONCLUSION (FOL)]:
∃x (British(x) ∧ Creates(x, dIRay))

[CONCLUSION (GK)]:
? [X] : (British(X) & Creates(X, dIRay)).


===

[]
['x', 'y']
[PREMISE]:
DI Ray is a police procedural television series.
DI Ray was created and written by Maya Sondhi.
DI Ray was produced by Jed Mercurio.
Maya Sondhi and Jed Mercurio are both British.

[PREMISE (FOL)]:
TelevisionSeries(dIRay) ∧ PoliceProcedural(dIRay)
Creates(maya, dIRay) ∧ Writes(maya, dIRay)
Produces(jed, dIRay)
British(maya) ∧ British(jed) 

[PREMISE (GK)]:
TelevisionSeries(dIRay) & PoliceProcedural(dIRay).
Creates(maya, dIRay) & Writes(maya, dIRay).
Produces(jed, dIRay).
British(maya) & British(jed) .

[CONCLUSION]:
Some Brit produced a television series.

[CONCLUSION (FOL)]:
∃x ∃y(British(x) ∧ TelevisionSeries(y) ∧ Produces(x, y))

[CONCLUSION (GK)]:
? [X] : ? [Y] :(British(X) & TelevisionSeries(Y) & Produces(X, Y)).


===

['x']
['x']
[PREMISE]:
Everyone who took the bar exam can read. 
All lawyers took the bar exam. 
Everyone who took the bar exam is knowledgeable about criminal procedures. 
All people who got a score of 180 on the LSAT can read. 
No elephants can read. 
If Mike can not read or is not an elephant, then Mike either took the bar exam or can read. 

[PREMISE (FOL)]:
∀x (Take(x, barExam) → CanRead(x))
∀x (Lawyer(x) → Take(x, barExam))
∀x (Take(x, barExam) → KnowledgeableAbout(x, criminalProceeder))
∀x (GetOn(x, scoreOf180, lSAT) → CanRead(x))
∀x (Elephant(x) → ¬CanRead(x))
¬(CanRead(mike) ∧ Elephant(mike)) → Take(mike, barExam) ⊕ CanRead(mike)

[PREMISE (GK)]:
! [X] : (Take(X, barExam) => CanRead(X)).
! [X] : (Lawyer(X) => Take(X, barExam)).
! [X] : (Take(X, barExam) => KnowledgeableAbout(X, criminalProceeder)).
! [X] : (GetOn(X, scoreOf180, lSAT) => CanRead(X)).
! [X] : (Elephant(X) => -CanRead(X)).
-(CanRead(mike) & Elephant(mike)) => Take(mike, barExam) <~> CanRead(mike).

[CONCLUSION]:
Mike got 180 on the LSAT.

[CONCLUSION (FOL)]:
GetOn(mike, 180, lSAT)

[CONCLUSION (GK)]:
GetOn(mike, 180, lSAT).


===

['x']
['x']
[PREMISE]:
Everyone who took the bar exam can read. 
All lawyers took the bar exam. 
Everyone who took the bar exam is knowledgeable about criminal procedures. 
All people who got a score of 180 on the LSAT can read. 
No elephants can read. 
If Mike can not read or is not an elephant, then Mike either took the bar exam or can read. 

[PREMISE (FOL)]:
∀x (Take(x, barExam) → CanRead(x))
∀x (Lawyer(x) → Take(x, barExam))
∀x (Take(x, barExam) → KnowledgeableAbout(x, criminalProceeder))
∀x (GetOn(x, scoreOf180, lSAT) → CanRead(x))
∀x (Elephant(x) → ¬CanRead(x))
¬(CanRead(mike) ∧ Elephant(mike)) → Take(mike, barExam) ⊕ CanRead(mike)

[PREMISE (GK)]:
! [X] : (Take(X, barExam) => CanRead(X)).
! [X] : (Lawyer(X) => Take(X, barExam)).
! [X] : (Take(X, barExam) => KnowledgeableAbout(X, criminalProceeder)).
! [X] : (GetOn(X, scoreOf180, lSAT) => CanRead(X)).
! [X] : (Elephant(X) => -CanRead(X)).
-(CanRead(mike) & Elephant(mike)) => Take(mike, barExam) <~> CanRead(mike).

[CONCLUSION]:
Mike did not take the bar exam and is not both knowledgeable about criminal procedures and someone who got 180 on the LSAT.

[CONCLUSION (FOL)]:
¬Take(mike, barExam) ∧ ¬(KnowledgeableAbout(mike, criminalProcedures)∧ GetOn(mike, 180, lSAT))

[CONCLUSION (GK)]:
-Take(mike, barExam) & -(KnowledgeableAbout(mike, criminalProcedures)& GetOn(mike, 180, lSAT)).


===

['x']
['x']
[PREMISE]:
Everyone who took the bar exam can read. 
All lawyers took the bar exam. 
Everyone who took the bar exam is knowledgeable about criminal procedures. 
All people who got a score of 180 on the LSAT can read. 
No elephants can read. 
If Mike can not read or is not an elephant, then Mike either took the bar exam or can read. 

[PREMISE (FOL)]:
∀x (Take(x, barExam) → CanRead(x))
∀x (Lawyer(x) → Take(x, barExam))
∀x (Take(x, barExam) → KnowledgeableAbout(x, criminalProceeder))
∀x (GetOn(x, scoreOf180, lSAT) → CanRead(x))
∀x (Elephant(x) → ¬CanRead(x))
¬(CanRead(mike) ∧ Elephant(mike)) → Take(mike, barExam) ⊕ CanRead(mike)

[PREMISE (GK)]:
! [X] : (Take(X, barExam) => CanRead(X)).
! [X] : (Lawyer(X) => Take(X, barExam)).
! [X] : (Take(X, barExam) => KnowledgeableAbout(X, criminalProceeder)).
! [X] : (GetOn(X, scoreOf180, lSAT) => CanRead(X)).
! [X] : (Elephant(X) => -CanRead(X)).
-(CanRead(mike) & Elephant(mike)) => Take(mike, barExam) <~> CanRead(mike).

[CONCLUSION]:
Mike took the bar exam.

[CONCLUSION (FOL)]:
Take(mike, barExam)

[CONCLUSION (GK)]:
Take(mike, barExam).


===

['x']
['x']
[PREMISE]:
Some soccer defenders are center-backs.
All soccer defenders are soccer players.
No soccer players are professional basketball players.
All NBA players are professional basketball players.
Stephen Curry is an NBA player.

[PREMISE (FOL)]:
∃x (ProfessionalSoccerDefender(x) ∧ ProfessionalCenterback(x))
∀x (ProfessionalSoccerDefender(x) → ProfessionalSoccerPlayer(x))
∀x (ProfessionalSoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x)))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
NBAPlayer(stephencurry)

[PREMISE (GK)]:
? [X] : (ProfessionalSoccerDefender(X) & ProfessionalCenterback(X)).
! [X] : (ProfessionalSoccerDefender(X) => ProfessionalSoccerPlayer(X)).
! [X] : (ProfessionalSoccerPlayer(X) => -ProfessionalBasketballPlayer(X))).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
NBAPlayer(stephencurry).

[CONCLUSION]:
Stephen Curry is a center-back.

[CONCLUSION (FOL)]:
ProfessionalCenterback(stephenCurry)

[CONCLUSION (GK)]:
ProfessionalCenterback(stephenCurry).


===

['x']
['x']
[PREMISE]:
Some soccer defenders are center-backs.
All soccer defenders are soccer players.
No soccer players are professional basketball players.
All NBA players are professional basketball players.
Stephen Curry is an NBA player.

[PREMISE (FOL)]:
∃x (ProfessionalSoccerDefender(x) ∧ ProfessionalCenterback(x))
∀x (ProfessionalSoccerDefender(x) → ProfessionalSoccerPlayer(x))
∀x (ProfessionalSoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x)))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
NBAPlayer(stephencurry)

[PREMISE (GK)]:
? [X] : (ProfessionalSoccerDefender(X) & ProfessionalCenterback(X)).
! [X] : (ProfessionalSoccerDefender(X) => ProfessionalSoccerPlayer(X)).
! [X] : (ProfessionalSoccerPlayer(X) => -ProfessionalBasketballPlayer(X))).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
NBAPlayer(stephencurry).

[CONCLUSION]:
Stephen Curry is not both a centerback and a soccer defender.

[CONCLUSION (FOL)]:
¬(ProfessionalCenterback(stephenCurry) ∧ ProfessionalSoccerDefender(stephenCurry))

[CONCLUSION (GK)]:
-(ProfessionalCenterback(stephenCurry) & ProfessionalSoccerDefender(stephenCurry)).


===

['x']
['x']
[PREMISE]:
Some soccer defenders are center-backs.
All soccer defenders are soccer players.
No soccer players are professional basketball players.
All NBA players are professional basketball players.
Stephen Curry is an NBA player.

[PREMISE (FOL)]:
∃x (ProfessionalSoccerDefender(x) ∧ ProfessionalCenterback(x))
∀x (ProfessionalSoccerDefender(x) → ProfessionalSoccerPlayer(x))
∀x (ProfessionalSoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x)))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
NBAPlayer(stephencurry)

[PREMISE (GK)]:
? [X] : (ProfessionalSoccerDefender(X) & ProfessionalCenterback(X)).
! [X] : (ProfessionalSoccerDefender(X) => ProfessionalSoccerPlayer(X)).
! [X] : (ProfessionalSoccerPlayer(X) => -ProfessionalBasketballPlayer(X))).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
NBAPlayer(stephencurry).

[CONCLUSION]:
If Stephen Curry is not both a centerback and a soccer defender, then Stephen Curry is neither a soccer player nor a professional basketball player.

[CONCLUSION (FOL)]:
¬(Centerback(stephenCurry) ∧ SoccerDefender(stephenCurry)) → ¬(SoccerPlayer(stephenCurry) ∨ ProfessionalBasketballPlayer(stephenCurry))

[CONCLUSION (GK)]:
-(Centerback(stephenCurry) & SoccerDefender(stephenCurry)) => -(SoccerPlayer(stephenCurry) | ProfessionalBasketballPlayer(stephenCurry)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If a person doesn't have enough money to buy a product, then that person can't buy it.
Monitors are products.
4k monitors are more expensive than 1080 monitors and 2k monitors.
John is a person.
John doesn't have enough money to buy a 2k monitor.

[PREMISE (FOL)]:
∀x ∀y (Person(x) ∧ Product(y) ∧ ¬HaveEnoughMoneyFor(x, y) → ¬Buy(x, y))
∀x (Monitor(x) → Product(x))
∀x ∀y ∀z (Monitor(x) ∧ Monitor(y) ∧ Monitor(z) ∧ FourK(x) ∧ OneOEightO(y) ∧ TwoK(z) → MoreExpensive(x, y) ∧ MoreExpensive(x, z))
Person(john)
∀x (Monitor(x) ∧ TwoK(x) → ¬HaveEnoughMoneyFor(john, x))

[PREMISE (GK)]:
! [X] : ! [Y] : (Person(X) & Product(Y) & -HaveEnoughMoneyFor(X, Y) => -Buy(X, Y)).
! [X] : (Monitor(X) => Product(X)).
! [X] : ! [Y] : ! [Z] : (Monitor(X) & Monitor(Y) & Monitor(Z) & FourK(X) & OneOEightO(Y) & TwoK(Z) => MoreExpensive(X, Y) & MoreExpensive(X, Z)).
Person(john).
! [X] : (Monitor(X) & TwoK(X) => -HaveEnoughMoneyFor(john, X)).

[CONCLUSION]:
John can't buy a 1080 monitor.

[CONCLUSION (FOL)]:
∀x (Monitor(x) ∧ OneOEightO(x) → ¬Buy(john, x))

[CONCLUSION (GK)]:
! [X] : (Monitor(X) & OneOEightO(X) => -Buy(john, X)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If a person doesn't have enough money to buy a product, then that person can't buy it.
Monitors are products.
4k monitors are more expensive than 1080 monitors and 2k monitors.
John is a person.
John doesn't have enough money to buy a 2k monitor.

[PREMISE (FOL)]:
∀x ∀y (Person(x) ∧ Product(y) ∧ ¬HaveEnoughMoneyFor(x, y) → ¬Buy(x, y))
∀x (Monitor(x) → Product(x))
∀x ∀y ∀z (Monitor(x) ∧ Monitor(y) ∧ Monitor(z) ∧ FourK(x) ∧ OneOEightO(y) ∧ TwoK(z) → MoreExpensive(x, y) ∧ MoreExpensive(x, z))
Person(john)
∀x (Monitor(x) ∧ TwoK(x) → ¬HaveEnoughMoneyFor(john, x))

[PREMISE (GK)]:
! [X] : ! [Y] : (Person(X) & Product(Y) & -HaveEnoughMoneyFor(X, Y) => -Buy(X, Y)).
! [X] : (Monitor(X) => Product(X)).
! [X] : ! [Y] : ! [Z] : (Monitor(X) & Monitor(Y) & Monitor(Z) & FourK(X) & OneOEightO(Y) & TwoK(Z) => MoreExpensive(X, Y) & MoreExpensive(X, Z)).
Person(john).
! [X] : (Monitor(X) & TwoK(X) => -HaveEnoughMoneyFor(john, X)).

[CONCLUSION]:
John can't buy a 2k monitor.

[CONCLUSION (FOL)]:
∀x (Monitor(x) ∧ TwoK(x) → ¬Buy(john, x))

[CONCLUSION (GK)]:
! [X] : (Monitor(X) & TwoK(X) => -Buy(john, X)).


===

['x']
['x']
[PREMISE]:
All artificial satellites are important scientific achievements.
Some artificial satellites are not U.S. inventions.

[PREMISE (FOL)]:
∀x (ArtificialSatellite(x) → ImportantScientificAchievement(x))
∃x (ArtificialSatellite(x) ∧ ¬USInvention(x))

[PREMISE (GK)]:
! [X] : (ArtificialSatellite(X) => ImportantScientificAchievement(X)).
? [X] : (ArtificialSatellite(X) & -USInvention(X)).

[CONCLUSION]:
All important scientific achievements are U.S. inventions.

[CONCLUSION (FOL)]:
∀x (ImportantScientificAchievement(x) ∧ USInvention(x))

[CONCLUSION (GK)]:
! [X] : (ImportantScientificAchievement(X) & USInvention(X)).


===

['x']
['x', 'y']
[PREMISE]:
Some cats are not pets.
All cats are mammals.

[PREMISE (FOL)]:
∃x (Cat(x) ∧ ¬Pet(x))
∀x (Cat(x) → Mammal(x))

[PREMISE (GK)]:
? [X] : (Cat(X) & -Pet(X)).
! [X] : (Cat(X) => Mammal(X)).

[CONCLUSION]:
Some mammals are not pets.

[CONCLUSION (FOL)]:
∃x ∃y (Mammal(x) ∧ Mammal(y) ∧ ¬Pet(x) ∧ ¬Pet(y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Mammal(X) & Mammal(Y) & -Pet(X) & -Pet(Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If people in this neighborhood visit a coffee shop regularly, then they are addicted to coffee. 
People in this neighborhood visit a coffee shop regularly or order takeout at least once a day.
If people in this neighborhood make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.
If people in this neighborhood own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.
All people in this neighborhood who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.
Sam is living in this neighborhood, and he is either addicted to coffee or other caffeinated drinks and leads a very busy life that include 12-hour work hours, or is not addicted to coffee and does not lead a very busy life that include 12-hour work hours

[PREMISE (FOL)]:
∀x (In(x, thisNeighborhood) ∧ VisitRegularly(x, coffeeShop) → AddictedTo(x, coffee))
∀x (In(x, thisNeighborhood) → (VisitRegularly(x, coffeeShop) ∨ (∃y (TakeOut(y) ∧ Order(x, y, aDay))))
∀x (In(x, thisNeighborhood) ∧ MakeAtUsing(x, home, ownFood, recipe) → ∃y (TakeOut(y) ∧ Order(x, y)))
∀x (In(x, thisNeighborhood) ∧ ∃y (CoffeemakerAndBlender(y) ∧ Own(x, y)) → ¬OrderAtLeastOnceADay(x, takeout))
∀x (In(x, thisNeighborhood) ∧ BusyWith(x, 12HourWorkHour) → MakeAtUsing(x, home, ownFood, recipe))
In(sam, thisNeighborhood) ∧ ¬(AddictedTo(sam, coffee) ⊕ BusyWith(sam, 12HourWorkHour))

[PREMISE (GK)]:
! [X] : (In(X, thisNeighborhood) & VisitRegularly(X, coffeeShop) => AddictedTo(X, coffee)).
! [X] : (In(X, thisNeighborhood) => (VisitRegularly(X, coffeeShop) | (? [Y] : (TakeOut(Y) & Order(X, Y, aDay)))).
! [X] : (In(X, thisNeighborhood) & MakeAtUsing(X, home, ownFood, recipe) => ? [Y] : (TakeOut(Y) & Order(X, Y))).
! [X] : (In(X, thisNeighborhood) & ? [Y] : (CoffeemakerAndBlender(Y) & Own(X, Y)) => -OrderAtLeastOnceADay(X, takeout)).
! [X] : (In(X, thisNeighborhood) & BusyWith(X, 12HourWorkHour) => MakeAtUsing(X, home, ownFood, recipe)).
In(sam, thisNeighborhood) & -(AddictedTo(sam, coffee) <~> BusyWith(sam, 12HourWorkHour)).

[CONCLUSION]:
Sam is living in this neighborhood and he is addicted to coffee.

[CONCLUSION (FOL)]:
InThisNeighborhood(sam) ∧ AddictedTo(sam, coffee)

[CONCLUSION (GK)]:
InThisNeighborhood(sam) & AddictedTo(sam, coffee).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If people in this neighborhood visit a coffee shop regularly, then they are addicted to coffee. 
People in this neighborhood visit a coffee shop regularly or order takeout at least once a day.
If people in this neighborhood make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.
If people in this neighborhood own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.
All people in this neighborhood who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.
Sam is living in this neighborhood, and he is either addicted to coffee or other caffeinated drinks and leads a very busy life that include 12-hour work hours, or is not addicted to coffee and does not lead a very busy life that include 12-hour work hours

[PREMISE (FOL)]:
∀x (In(x, thisNeighborhood) ∧ VisitRegularly(x, coffeeShop) → AddictedTo(x, coffee))
∀x (In(x, thisNeighborhood) → (VisitRegularly(x, coffeeShop) ∨ (∃y (TakeOut(y) ∧ Order(x, y, aDay))))
∀x (In(x, thisNeighborhood) ∧ MakeAtUsing(x, home, ownFood, recipe) → ∃y (TakeOut(y) ∧ Order(x, y)))
∀x (In(x, thisNeighborhood) ∧ ∃y (CoffeemakerAndBlender(y) ∧ Own(x, y)) → ¬OrderAtLeastOnceADay(x, takeout))
∀x (In(x, thisNeighborhood) ∧ BusyWith(x, 12HourWorkHour) → MakeAtUsing(x, home, ownFood, recipe))
In(sam, thisNeighborhood) ∧ ¬(AddictedTo(sam, coffee) ⊕ BusyWith(sam, 12HourWorkHour))

[PREMISE (GK)]:
! [X] : (In(X, thisNeighborhood) & VisitRegularly(X, coffeeShop) => AddictedTo(X, coffee)).
! [X] : (In(X, thisNeighborhood) => (VisitRegularly(X, coffeeShop) | (? [Y] : (TakeOut(Y) & Order(X, Y, aDay)))).
! [X] : (In(X, thisNeighborhood) & MakeAtUsing(X, home, ownFood, recipe) => ? [Y] : (TakeOut(Y) & Order(X, Y))).
! [X] : (In(X, thisNeighborhood) & ? [Y] : (CoffeemakerAndBlender(Y) & Own(X, Y)) => -OrderAtLeastOnceADay(X, takeout)).
! [X] : (In(X, thisNeighborhood) & BusyWith(X, 12HourWorkHour) => MakeAtUsing(X, home, ownFood, recipe)).
In(sam, thisNeighborhood) & -(AddictedTo(sam, coffee) <~> BusyWith(sam, 12HourWorkHour)).

[CONCLUSION]:
Sam is living in this neighborhood and he owns at least one coffeemaker and one blender in his home.

[CONCLUSION (FOL)]:
∃y (CoffeemakerAndBlender(y) ∧ Own(sam, y))

[CONCLUSION (GK)]:
? [Y] : (CoffeemakerAndBlender(Y) & Own(sam, Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If people in this neighborhood visit a coffee shop regularly, then they are addicted to coffee. 
People in this neighborhood visit a coffee shop regularly or order takeout at least once a day.
If people in this neighborhood make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.
If people in this neighborhood own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.
All people in this neighborhood who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.
Sam is living in this neighborhood, and he is either addicted to coffee or other caffeinated drinks and leads a very busy life that include 12-hour work hours, or is not addicted to coffee and does not lead a very busy life that include 12-hour work hours

[PREMISE (FOL)]:
∀x (In(x, thisNeighborhood) ∧ VisitRegularly(x, coffeeShop) → AddictedTo(x, coffee))
∀x (In(x, thisNeighborhood) → (VisitRegularly(x, coffeeShop) ∨ (∃y (TakeOut(y) ∧ Order(x, y, aDay))))
∀x (In(x, thisNeighborhood) ∧ MakeAtUsing(x, home, ownFood, recipe) → ∃y (TakeOut(y) ∧ Order(x, y)))
∀x (In(x, thisNeighborhood) ∧ ∃y (CoffeemakerAndBlender(y) ∧ Own(x, y)) → ¬OrderAtLeastOnceADay(x, takeout))
∀x (In(x, thisNeighborhood) ∧ BusyWith(x, 12HourWorkHour) → MakeAtUsing(x, home, ownFood, recipe))
In(sam, thisNeighborhood) ∧ ¬(AddictedTo(sam, coffee) ⊕ BusyWith(sam, 12HourWorkHour))

[PREMISE (GK)]:
! [X] : (In(X, thisNeighborhood) & VisitRegularly(X, coffeeShop) => AddictedTo(X, coffee)).
! [X] : (In(X, thisNeighborhood) => (VisitRegularly(X, coffeeShop) | (? [Y] : (TakeOut(Y) & Order(X, Y, aDay)))).
! [X] : (In(X, thisNeighborhood) & MakeAtUsing(X, home, ownFood, recipe) => ? [Y] : (TakeOut(Y) & Order(X, Y))).
! [X] : (In(X, thisNeighborhood) & ? [Y] : (CoffeemakerAndBlender(Y) & Own(X, Y)) => -OrderAtLeastOnceADay(X, takeout)).
! [X] : (In(X, thisNeighborhood) & BusyWith(X, 12HourWorkHour) => MakeAtUsing(X, home, ownFood, recipe)).
In(sam, thisNeighborhood) & -(AddictedTo(sam, coffee) <~> BusyWith(sam, 12HourWorkHour)).

[CONCLUSION]:
Sam is living in this neighborhood and he owns at least one coffeemaker and one blender in his home or orders takeout at least once a day.

[CONCLUSION (FOL)]:
(∃y (CoffeemakerAndBlender(y) ∧ Own(sam, y)) ∨ (∃y (TakeOut(y) ∧ Order(sam, y, aDay)))

[CONCLUSION (GK)]:
(? [Y] : (CoffeemakerAndBlender(Y) & Own(sam, Y)) | (? [Y] : (TakeOut(Y) & Order(sam, Y, aDay))).


===

['x']
['x']
[PREMISE]:
No professional basketball players are soccer players.
All NBA players are professional basketball players.
All soccer defenders are soccer players.
All centerbacks are soccer defenders.
Roger Federer is either both an NBA player and a soccer defender, or neither.

[PREMISE (FOL)]:
∀x (ProfessionalBasketballPlayer(x) → ¬ProfessionalSoccerPlayer(x))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
∀x (ProfessionalSoccerDefender(x) → ProfessionalSoccerPlayer(x))
∀x (ProfessionalCenterback(x) → ProfessionalSoccerDefender(x))
¬(NBAPlayer(rogerfederer) ⊕ ProfessionalSoccerDefender(rogerfederer))

[PREMISE (GK)]:
! [X] : (ProfessionalBasketballPlayer(X) => -ProfessionalSoccerPlayer(X)).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
! [X] : (ProfessionalSoccerDefender(X) => ProfessionalSoccerPlayer(X)).
! [X] : (ProfessionalCenterback(X) => ProfessionalSoccerDefender(X)).
-(NBAPlayer(rogerfederer) <~> ProfessionalSoccerDefender(rogerfederer)).

[CONCLUSION]:
Roger Federer is a centerback.

[CONCLUSION (FOL)]:
ProfessionalCenterback(rogerFederer)

[CONCLUSION (GK)]:
ProfessionalCenterback(rogerFederer).


===

['x']
['x']
[PREMISE]:
No professional basketball players are soccer players.
All NBA players are professional basketball players.
All soccer defenders are soccer players.
All centerbacks are soccer defenders.
Roger Federer is either both an NBA player and a soccer defender, or neither.

[PREMISE (FOL)]:
∀x (ProfessionalBasketballPlayer(x) → ¬ProfessionalSoccerPlayer(x))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
∀x (ProfessionalSoccerDefender(x) → ProfessionalSoccerPlayer(x))
∀x (ProfessionalCenterback(x) → ProfessionalSoccerDefender(x))
¬(NBAPlayer(rogerfederer) ⊕ ProfessionalSoccerDefender(rogerfederer))

[PREMISE (GK)]:
! [X] : (ProfessionalBasketballPlayer(X) => -ProfessionalSoccerPlayer(X)).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
! [X] : (ProfessionalSoccerDefender(X) => ProfessionalSoccerPlayer(X)).
! [X] : (ProfessionalCenterback(X) => ProfessionalSoccerDefender(X)).
-(NBAPlayer(rogerfederer) <~> ProfessionalSoccerDefender(rogerfederer)).

[CONCLUSION]:
Roger Federer is not a centerback.

[CONCLUSION (FOL)]:
¬ProfessionalCenterback(rogerFederer)

[CONCLUSION (GK)]:
-ProfessionalCenterback(rogerFederer).


===

['x']
['x']
[PREMISE]:
No professional basketball players are soccer players.
All NBA players are professional basketball players.
All soccer defenders are soccer players.
All centerbacks are soccer defenders.
Roger Federer is either both an NBA player and a soccer defender, or neither.

[PREMISE (FOL)]:
∀x (ProfessionalBasketballPlayer(x) → ¬ProfessionalSoccerPlayer(x))
∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))
∀x (ProfessionalSoccerDefender(x) → ProfessionalSoccerPlayer(x))
∀x (ProfessionalCenterback(x) → ProfessionalSoccerDefender(x))
¬(NBAPlayer(rogerfederer) ⊕ ProfessionalSoccerDefender(rogerfederer))

[PREMISE (GK)]:
! [X] : (ProfessionalBasketballPlayer(X) => -ProfessionalSoccerPlayer(X)).
! [X] : (NBAPlayer(X) => ProfessionalBasketballPlayer(X)).
! [X] : (ProfessionalSoccerDefender(X) => ProfessionalSoccerPlayer(X)).
! [X] : (ProfessionalCenterback(X) => ProfessionalSoccerDefender(X)).
-(NBAPlayer(rogerfederer) <~> ProfessionalSoccerDefender(rogerfederer)).

[CONCLUSION]:
Roger Federer is a soccer player.

[CONCLUSION (FOL)]:
ProfessionalSoccerPlayer(rogerFederer)

[CONCLUSION (GK)]:
ProfessionalSoccerPlayer(rogerFederer).


===

['x']
['x']
[PREMISE]:
Some teachers who work at pools are not nice.
All teachers working at pools are pool managers.
All pool managers are lifeguards.
If someone is a lifeguard, then they work at a pool.
Mary does not work at a pool.

[PREMISE (FOL)]:
∃x (Teacher(x) ∧ WorkAt(x, pool) ∧ ¬Nice(x))
∀x (Teacher(x) ∧ WorkAt(x, pool) → PoolManager(x))
∀x (PoolManager(x) → Lifeguard(x))
∀x (Lifeguard(x) → WorkAt(x, pool))
¬WorkAt(mary, pool)

[PREMISE (GK)]:
? [X] : (Teacher(X) & WorkAt(X, pool) & -Nice(X)).
! [X] : (Teacher(X) & WorkAt(X, pool) => PoolManager(X)).
! [X] : (PoolManager(X) => Lifeguard(X)).
! [X] : (Lifeguard(X) => WorkAt(X, pool)).
-WorkAt(mary, pool).

[CONCLUSION]:
Mary is nice.

[CONCLUSION (FOL)]:
Nice(mary)

[CONCLUSION (GK)]:
Nice(mary).


===

['x']
['x']
[PREMISE]:
Some teachers who work at pools are not nice.
All teachers working at pools are pool managers.
All pool managers are lifeguards.
If someone is a lifeguard, then they work at a pool.
Mary does not work at a pool.

[PREMISE (FOL)]:
∃x (Teacher(x) ∧ WorkAt(x, pool) ∧ ¬Nice(x))
∀x (Teacher(x) ∧ WorkAt(x, pool) → PoolManager(x))
∀x (PoolManager(x) → Lifeguard(x))
∀x (Lifeguard(x) → WorkAt(x, pool))
¬WorkAt(mary, pool)

[PREMISE (GK)]:
? [X] : (Teacher(X) & WorkAt(X, pool) & -Nice(X)).
! [X] : (Teacher(X) & WorkAt(X, pool) => PoolManager(X)).
! [X] : (PoolManager(X) => Lifeguard(X)).
! [X] : (Lifeguard(X) => WorkAt(X, pool)).
-WorkAt(mary, pool).

[CONCLUSION]:
Mary is not a nice teacher working at a pool.

[CONCLUSION (FOL)]:
¬(Nice(mary) ∧ Teacher(mary) ∧ WorkAt(mary, pool))

[CONCLUSION (GK)]:
-(Nice(mary) & Teacher(mary) & WorkAt(mary, pool)).


===

['x']
['x']
[PREMISE]:
Some teachers who work at pools are not nice.
All teachers working at pools are pool managers.
All pool managers are lifeguards.
If someone is a lifeguard, then they work at a pool.
Mary does not work at a pool.

[PREMISE (FOL)]:
∃x (Teacher(x) ∧ WorkAt(x, pool) ∧ ¬Nice(x))
∀x (Teacher(x) ∧ WorkAt(x, pool) → PoolManager(x))
∀x (PoolManager(x) → Lifeguard(x))
∀x (Lifeguard(x) → WorkAt(x, pool))
¬WorkAt(mary, pool)

[PREMISE (GK)]:
? [X] : (Teacher(X) & WorkAt(X, pool) & -Nice(X)).
! [X] : (Teacher(X) & WorkAt(X, pool) => PoolManager(X)).
! [X] : (PoolManager(X) => Lifeguard(X)).
! [X] : (Lifeguard(X) => WorkAt(X, pool)).
-WorkAt(mary, pool).

[CONCLUSION]:
Mary is is a nice teacher working at a pool.

[CONCLUSION (FOL)]:
Nice(mary) ∧ Teacher(mary) ∧ WorkAt(mary, pool)

[CONCLUSION (GK)]:
Nice(mary) & Teacher(mary) & WorkAt(mary, pool).


===

['x']
['x', 'y']
[PREMISE]:
Not all art pieces require talent.
Everything that requires talent requires practice.

[PREMISE (FOL)]:
∃x (ArtPiece(x) ∧ ¬Require(x, talent))
∀x (Require(x, talent) → Require(x, practice))

[PREMISE (GK)]:
? [X] : (ArtPiece(X) & -Require(X, talent)).
! [X] : (Require(X, talent) => Require(X, practice)).

[CONCLUSION]:
There exist art pieces that do not require practice.

[CONCLUSION (FOL)]:
∃x ∃y (ArtPiece(x) ∧ ¬Require(x, practice) ∧ ArtPiece(y) ∧ ¬Require(y, practice) ∧ ¬(x=y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (ArtPiece(X) & -Require(X, practice) & ArtPiece(Y) & -Require(Y, practice) & -(X=Y)).


===

['x']
['x']
[PREMISE]:
Bernarda Bryson Shahn was a painter and lithographer.
Bernarda Bryson Shahn was born in Athens, Ohio. 
Bernarda Bryson Shahn was married to Ben Shahn.
People born in Athens, Ohio, are Americans.

[PREMISE (FOL)]:
Painter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) 
BornIn(bernardaBrysonShahn, athensOhio)
MarriedTo(bernardaBrysonShahn, benShahn)
∀x (BornIn(x, athensOhio) → American(x))

[PREMISE (GK)]:
Painter(bernardaBrysonShahn) & Lithographer(bernardaBrysonShahn) .
BornIn(bernardaBrysonShahn, athensOhio).
MarriedTo(bernardaBrysonShahn, benShahn).
! [X] : (BornIn(X, athensOhio) => American(X)).

[CONCLUSION]:
Bernarda Bryson Shahn was born in Greece.

[CONCLUSION (FOL)]:
BornIn(bernardaBrysonShahn, greece)

[CONCLUSION (GK)]:
BornIn(bernardaBrysonShahn, greece).


===

['x']
['x']
[PREMISE]:
Bernarda Bryson Shahn was a painter and lithographer.
Bernarda Bryson Shahn was born in Athens, Ohio. 
Bernarda Bryson Shahn was married to Ben Shahn.
People born in Athens, Ohio, are Americans.

[PREMISE (FOL)]:
Painter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) 
BornIn(bernardaBrysonShahn, athensOhio)
MarriedTo(bernardaBrysonShahn, benShahn)
∀x (BornIn(x, athensOhio) → American(x))

[PREMISE (GK)]:
Painter(bernardaBrysonShahn) & Lithographer(bernardaBrysonShahn) .
BornIn(bernardaBrysonShahn, athensOhio).
MarriedTo(bernardaBrysonShahn, benShahn).
! [X] : (BornIn(X, athensOhio) => American(X)).

[CONCLUSION]:
Bernarda Bryson Shahn was American.

[CONCLUSION (FOL)]:
American(bernardaBrysonShahn)

[CONCLUSION (GK)]:
American(bernardaBrysonShahn).


===

['x']
['x']
[PREMISE]:
Bernarda Bryson Shahn was a painter and lithographer.
Bernarda Bryson Shahn was born in Athens, Ohio. 
Bernarda Bryson Shahn was married to Ben Shahn.
People born in Athens, Ohio, are Americans.

[PREMISE (FOL)]:
Painter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) 
BornIn(bernardaBrysonShahn, athensOhio)
MarriedTo(bernardaBrysonShahn, benShahn)
∀x (BornIn(x, athensOhio) → American(x))

[PREMISE (GK)]:
Painter(bernardaBrysonShahn) & Lithographer(bernardaBrysonShahn) .
BornIn(bernardaBrysonShahn, athensOhio).
MarriedTo(bernardaBrysonShahn, benShahn).
! [X] : (BornIn(X, athensOhio) => American(X)).

[CONCLUSION]:
Bernarda Bryson Shahn had been divorced once.

[CONCLUSION (FOL)]:
Divorced(bernardaBrysonShahn)

[CONCLUSION (GK)]:
Divorced(bernardaBrysonShahn).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Everybody in Emma's family who upgrade to the newest iPhone model every year, are not saving money for a down payment on a new house.
Everybody in Emma's family who enjoy reading about tech specs and keeping up to date on the latest technology upgrade to the newest iPhone model every year.
Everybody in Emma's family is saving money for a down payment on a new house, or lives in an apartment in a big metropolitan cities.
Everybody in Emma's family live with at least one roommate, does not own any pets.
Everybody in Emma's family who owns at least one pet lives with at least one roommate.
Emily is in Emma's family.
If Emily does not both own at least one pet and lives in apartments in big metropolitan cities, then Emily either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities. 

[PREMISE (FOL)]:
∀x (InEmmasFamily(x) ∧ UpgradeToEveryYear(x, newestIphoneModel) → ¬SavingMoneyForOn(x, downPayment, newHouse))
∀x (InEmmasFamily(x) ∧ EnjoyReading(x, techSpec) ∧ KeepUpdatedOn(x, latestTechnology) → UpgradeToEveryYear(x, newestIphoneModel))
∀x (InEmmasFamily(x) ∧ (SavingMoneyForOn(x, downPayment, newHouse) ∨ LiveIn(x, apartment, bigMetropolitanCity)))
∀x (InEmmasFamily(x) ∧ (∃y (LiveWith(x, y) ∧ Roommate(y))) → ¬(∃y (Own(x, y) ∧ Pet(y))))
∀x (InEmmasFamily(x) ∧ (∃y (Own(x, y) ∧ Pet(y))) → (∃y (LiveWith(x, y) ∧ Roommate(y))))
InEmmasFamily(emily)
((∃y (Own(emily, y) ∧ Roommate(y))) ∧ LiveIn(emily, apartment, bigMetropolitanCity)) → ((∃y (Own(emily, y) ∧ Pet(y))) ∧ LiveIn(emily, apartment, bigMetropolitanCity)) ⊕ ¬((∃y (Own(emily, y) ∧ Roommate(y))) ∨ LiveIn(emily, apartment, bigMetropolitanCity))

[PREMISE (GK)]:
! [X] : (InEmmasFamily(X) & UpgradeToEveryYear(X, newestIphoneModel) => -SavingMoneyForOn(X, downPayment, newHouse)).
! [X] : (InEmmasFamily(X) & EnjoyReading(X, techSpec) & KeepUpdatedOn(X, latestTechnology) => UpgradeToEveryYear(X, newestIphoneModel)).
! [X] : (InEmmasFamily(X) & (SavingMoneyForOn(X, downPayment, newHouse) | LiveIn(X, apartment, bigMetropolitanCity))).
! [X] : (InEmmasFamily(X) & (? [Y] : (LiveWith(X, Y) & Roommate(Y))) => -(? [Y] : (Own(X, Y) & Pet(Y)))).
! [X] : (InEmmasFamily(X) & (? [Y] : (Own(X, Y) & Pet(Y))) => (? [Y] : (LiveWith(X, Y) & Roommate(Y)))).
InEmmasFamily(emily).
((? [Y] : (Own(emily, Y) & Roommate(Y))) & LiveIn(emily, apartment, bigMetropolitanCity)) => ((? [Y] : (Own(emily, Y) & Pet(Y))) & LiveIn(emily, apartment, bigMetropolitanCity)) <~> -((? [Y] : (Own(emily, Y) & Roommate(Y))) | LiveIn(emily, apartment, bigMetropolitanCity)).

[CONCLUSION]:
Emily is in Emma's family and she lives with at least one roommate.

[CONCLUSION (FOL)]:
∃y (LiveWith(emily, y) ∧ Roommate(y))

[CONCLUSION (GK)]:
? [Y] : (LiveWith(emily, Y) & Roommate(Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Everybody in Emma's family who upgrade to the newest iPhone model every year, are not saving money for a down payment on a new house.
Everybody in Emma's family who enjoy reading about tech specs and keeping up to date on the latest technology upgrade to the newest iPhone model every year.
Everybody in Emma's family is saving money for a down payment on a new house, or lives in an apartment in a big metropolitan cities.
Everybody in Emma's family live with at least one roommate, does not own any pets.
Everybody in Emma's family who owns at least one pet lives with at least one roommate.
Emily is in Emma's family.
If Emily does not both own at least one pet and lives in apartments in big metropolitan cities, then Emily either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities. 

[PREMISE (FOL)]:
∀x (InEmmasFamily(x) ∧ UpgradeToEveryYear(x, newestIphoneModel) → ¬SavingMoneyForOn(x, downPayment, newHouse))
∀x (InEmmasFamily(x) ∧ EnjoyReading(x, techSpec) ∧ KeepUpdatedOn(x, latestTechnology) → UpgradeToEveryYear(x, newestIphoneModel))
∀x (InEmmasFamily(x) ∧ (SavingMoneyForOn(x, downPayment, newHouse) ∨ LiveIn(x, apartment, bigMetropolitanCity)))
∀x (InEmmasFamily(x) ∧ (∃y (LiveWith(x, y) ∧ Roommate(y))) → ¬(∃y (Own(x, y) ∧ Pet(y))))
∀x (InEmmasFamily(x) ∧ (∃y (Own(x, y) ∧ Pet(y))) → (∃y (LiveWith(x, y) ∧ Roommate(y))))
InEmmasFamily(emily)
((∃y (Own(emily, y) ∧ Roommate(y))) ∧ LiveIn(emily, apartment, bigMetropolitanCity)) → ((∃y (Own(emily, y) ∧ Pet(y))) ∧ LiveIn(emily, apartment, bigMetropolitanCity)) ⊕ ¬((∃y (Own(emily, y) ∧ Roommate(y))) ∨ LiveIn(emily, apartment, bigMetropolitanCity))

[PREMISE (GK)]:
! [X] : (InEmmasFamily(X) & UpgradeToEveryYear(X, newestIphoneModel) => -SavingMoneyForOn(X, downPayment, newHouse)).
! [X] : (InEmmasFamily(X) & EnjoyReading(X, techSpec) & KeepUpdatedOn(X, latestTechnology) => UpgradeToEveryYear(X, newestIphoneModel)).
! [X] : (InEmmasFamily(X) & (SavingMoneyForOn(X, downPayment, newHouse) | LiveIn(X, apartment, bigMetropolitanCity))).
! [X] : (InEmmasFamily(X) & (? [Y] : (LiveWith(X, Y) & Roommate(Y))) => -(? [Y] : (Own(X, Y) & Pet(Y)))).
! [X] : (InEmmasFamily(X) & (? [Y] : (Own(X, Y) & Pet(Y))) => (? [Y] : (LiveWith(X, Y) & Roommate(Y)))).
InEmmasFamily(emily).
((? [Y] : (Own(emily, Y) & Roommate(Y))) & LiveIn(emily, apartment, bigMetropolitanCity)) => ((? [Y] : (Own(emily, Y) & Pet(Y))) & LiveIn(emily, apartment, bigMetropolitanCity)) <~> -((? [Y] : (Own(emily, Y) & Roommate(Y))) | LiveIn(emily, apartment, bigMetropolitanCity)).

[CONCLUSION]:
Emily enjoys reading about tech specs and keeping up to date on the latest technology.

[CONCLUSION (FOL)]:
EnjoyReading(emily, techSpec) ∧ KeepUpdatedOn(emily, latestTechnology)

[CONCLUSION (GK)]:
EnjoyReading(emily, techSpec) & KeepUpdatedOn(emily, latestTechnology).


===

['x']
['x']
[PREMISE]:
People on the payroll are being paid by the school.
If someone has a job at a school, then they are on the payroll.
All faculty members have a job at a school.
If someone teaches students, they are a faculty member or a teacher.
Every teacher has students.
If Nancy is a teacher, then they are on the payroll.
If Nancy is not a teacher, then they are not paid by the school.
Nancy teaches students.

[PREMISE (FOL)]:
∀x (OnPayroll(x) → PaidBy(x, school))
∀x (HaveJobAt(x, school) → OnPayroll(x))
∀x (FacultyMember(x) → HaveJobAt(x, school))
∀x (Teach(x, student) → FacultyMember(x) ∨ Teacher(x))
∀x (Teacher(x) → Have(x, student))
Teacher(nancy) → OnPayroll(nancy)
¬Teacher(nancy) → ¬OnPayroll(nancy)
Teach(nancy, student)

[PREMISE (GK)]:
! [X] : (OnPayroll(X) => PaidBy(X, school)).
! [X] : (HaveJobAt(X, school) => OnPayroll(X)).
! [X] : (FacultyMember(X) => HaveJobAt(X, school)).
! [X] : (Teach(X, student) => FacultyMember(X) | Teacher(X)).
! [X] : (Teacher(X) => Have(X, student)).
Teacher(nancy) => OnPayroll(nancy).
-Teacher(nancy) => -OnPayroll(nancy).
Teach(nancy, student).

[CONCLUSION]:
Nancy is a faculty member.

[CONCLUSION (FOL)]:
FacultyMember(nancy)

[CONCLUSION (GK)]:
FacultyMember(nancy).


===

['x']
['x']
[PREMISE]:
People on the payroll are being paid by the school.
If someone has a job at a school, then they are on the payroll.
All faculty members have a job at a school.
If someone teaches students, they are a faculty member or a teacher.
Every teacher has students.
If Nancy is a teacher, then they are on the payroll.
If Nancy is not a teacher, then they are not paid by the school.
Nancy teaches students.

[PREMISE (FOL)]:
∀x (OnPayroll(x) → PaidBy(x, school))
∀x (HaveJobAt(x, school) → OnPayroll(x))
∀x (FacultyMember(x) → HaveJobAt(x, school))
∀x (Teach(x, student) → FacultyMember(x) ∨ Teacher(x))
∀x (Teacher(x) → Have(x, student))
Teacher(nancy) → OnPayroll(nancy)
¬Teacher(nancy) → ¬OnPayroll(nancy)
Teach(nancy, student)

[PREMISE (GK)]:
! [X] : (OnPayroll(X) => PaidBy(X, school)).
! [X] : (HaveJobAt(X, school) => OnPayroll(X)).
! [X] : (FacultyMember(X) => HaveJobAt(X, school)).
! [X] : (Teach(X, student) => FacultyMember(X) | Teacher(X)).
! [X] : (Teacher(X) => Have(X, student)).
Teacher(nancy) => OnPayroll(nancy).
-Teacher(nancy) => -OnPayroll(nancy).
Teach(nancy, student).

[CONCLUSION]:
Nancy is paid by the school and has students.

[CONCLUSION (FOL)]:
PaidBy(nancy, school) ∧ Have(nancy, student)

[CONCLUSION (GK)]:
PaidBy(nancy, school) & Have(nancy, student).


===

['x']
['x']
[PREMISE]:
People on the payroll are being paid by the school.
If someone has a job at a school, then they are on the payroll.
All faculty members have a job at a school.
If someone teaches students, they are a faculty member or a teacher.
Every teacher has students.
If Nancy is a teacher, then they are on the payroll.
If Nancy is not a teacher, then they are not paid by the school.
Nancy teaches students.

[PREMISE (FOL)]:
∀x (OnPayroll(x) → PaidBy(x, school))
∀x (HaveJobAt(x, school) → OnPayroll(x))
∀x (FacultyMember(x) → HaveJobAt(x, school))
∀x (Teach(x, student) → FacultyMember(x) ∨ Teacher(x))
∀x (Teacher(x) → Have(x, student))
Teacher(nancy) → OnPayroll(nancy)
¬Teacher(nancy) → ¬OnPayroll(nancy)
Teach(nancy, student)

[PREMISE (GK)]:
! [X] : (OnPayroll(X) => PaidBy(X, school)).
! [X] : (HaveJobAt(X, school) => OnPayroll(X)).
! [X] : (FacultyMember(X) => HaveJobAt(X, school)).
! [X] : (Teach(X, student) => FacultyMember(X) | Teacher(X)).
! [X] : (Teacher(X) => Have(X, student)).
Teacher(nancy) => OnPayroll(nancy).
-Teacher(nancy) => -OnPayroll(nancy).
Teach(nancy, student).

[CONCLUSION]:
Nancy is not paid by the school or does not have students.

[CONCLUSION (FOL)]:
¬PaidBy(nancy, school) ∨ ¬Have(nancy, student))

[CONCLUSION (GK)]:
-PaidBy(nancy, school) | -Have(nancy, student)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Kangaroos are an animal.
No Kangaroos live in Germany.
Jane will fly to Germany if she saves enough money for the summer.
If Jane flies to Germany, she will go to the Berlin Zoo.
If someone goes to the Berlin Zoo, they will see some of the animals in Germany.

[PREMISE (FOL)]:
∀x (Kangaroo(x) → Animal(x))
∀x (Kangaroo(x) → ¬LiveIn(x, germany))
SavesFor(jane, enoughMoney, theSummer) → FlyTo(jane, germany)
FlyTo(jane, germany) → GoTo(jane, berlinzoo) 
∀x ∃y (GoTo(x, berlinzoo) ∧ LiveIn(x, germany) ∧ Animal(y) → WillSee(y, x, berlinzoo))

[PREMISE (GK)]:
! [X] : (Kangaroo(X) => Animal(X)).
! [X] : (Kangaroo(X) => -LiveIn(X, germany)).
SavesFor(jane, enoughMoney, theSummer) => FlyTo(jane, germany).
FlyTo(jane, germany) => GoTo(jane, berlinzoo) .
! [X] : ? [Y] : (GoTo(X, berlinzoo) & LiveIn(X, germany) & Animal(Y) => WillSee(Y, X, berlinzoo)).

[CONCLUSION]:
Jane will see a kangaroo if she saves enough money for the summer.

[CONCLUSION (FOL)]:
∃x (SavesFor(jane, enoughMoney, theSummer)  ∧ Kangaroo(x) → WillSee(x, jane, berlinzoo))

[CONCLUSION (GK)]:
? [X] : (SavesFor(jane, enoughMoney, theSummer)  & Kangaroo(X) => WillSee(X, jane, berlinzoo)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If a class has prerequisites, the student must take the prerequisites to take the class.
If a class has no prerequisites, then the student can take the class
CPSC 201 and CPSC 223 are prerequisites for CPSC 323.
Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.
Intro Geology has no prerequisites.

[PREMISE (FOL)]:
∀x ∀y ∀z (Class(x) ∧ Student(y) ∧ Prereq(z,x) ∧ ¬Take(y, z) → ¬CanTake(y, x))
∀x ∀y ((Class(x) ∧ Student(y) ∧ ¬∃z Prereq(z,x)) → CanTake(y, x))
Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)
∀x (Prereq(x,intermediateMicro) → x=introMicroeconomics)
¬(∃x (Prereq(x, introGeology)))

[PREMISE (GK)]:
! [X] : ! [Y] : ! [Z] : (Class(X) & Student(Y) & Prereq(Z,X) & -Take(Y, Z) => -CanTake(Y, X)).
! [X] : ! [Y] : ((Class(X) & Student(Y) & -? [Z] : Prereq(Z,X)) => CanTake(Y, X)).
Prereq(cpsc201, cpsc323) & Prereq(cpsc223, cpsc323).
! [X] : (Prereq(X,intermediateMicro) => X=introMicroeconomics).
-(? [X] : (Prereq(X, introGeology))).

[CONCLUSION]:
CPSC 201 has no prerequisites.

[CONCLUSION (FOL)]:
∀x (¬Prereq(x, cpsc201))

[CONCLUSION (GK)]:
! [X] : (-Prereq(X, cpsc201)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If a class has prerequisites, the student must take the prerequisites to take the class.
If a class has no prerequisites, then the student can take the class
CPSC 201 and CPSC 223 are prerequisites for CPSC 323.
Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.
Intro Geology has no prerequisites.

[PREMISE (FOL)]:
∀x ∀y ∀z (Class(x) ∧ Student(y) ∧ Prereq(z,x) ∧ ¬Take(y, z) → ¬CanTake(y, x))
∀x ∀y ((Class(x) ∧ Student(y) ∧ ¬∃z Prereq(z,x)) → CanTake(y, x))
Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)
∀x (Prereq(x,intermediateMicro) → x=introMicroeconomics)
¬(∃x (Prereq(x, introGeology)))

[PREMISE (GK)]:
! [X] : ! [Y] : ! [Z] : (Class(X) & Student(Y) & Prereq(Z,X) & -Take(Y, Z) => -CanTake(Y, X)).
! [X] : ! [Y] : ((Class(X) & Student(Y) & -? [Z] : Prereq(Z,X)) => CanTake(Y, X)).
Prereq(cpsc201, cpsc323) & Prereq(cpsc223, cpsc323).
! [X] : (Prereq(X,intermediateMicro) => X=introMicroeconomics).
-(? [X] : (Prereq(X, introGeology))).

[CONCLUSION]:
If a student took CPSC 201 but did not take CPSC 223, they can take CPSC 323.

[CONCLUSION (FOL)]:
Taken(cpsc201) ∧ ¬Taken(cpsc223) ∧ CanTake(cpsc323)

[CONCLUSION (GK)]:
Taken(cpsc201) & -Taken(cpsc223) & CanTake(cpsc323).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If a class has prerequisites, the student must take the prerequisites to take the class.
If a class has no prerequisites, then the student can take the class
CPSC 201 and CPSC 223 are prerequisites for CPSC 323.
Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.
Intro Geology has no prerequisites.

[PREMISE (FOL)]:
∀x ∀y ∀z (Class(x) ∧ Student(y) ∧ Prereq(z,x) ∧ ¬Take(y, z) → ¬CanTake(y, x))
∀x ∀y ((Class(x) ∧ Student(y) ∧ ¬∃z Prereq(z,x)) → CanTake(y, x))
Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)
∀x (Prereq(x,intermediateMicro) → x=introMicroeconomics)
¬(∃x (Prereq(x, introGeology)))

[PREMISE (GK)]:
! [X] : ! [Y] : ! [Z] : (Class(X) & Student(Y) & Prereq(Z,X) & -Take(Y, Z) => -CanTake(Y, X)).
! [X] : ! [Y] : ((Class(X) & Student(Y) & -? [Z] : Prereq(Z,X)) => CanTake(Y, X)).
Prereq(cpsc201, cpsc323) & Prereq(cpsc223, cpsc323).
! [X] : (Prereq(X,intermediateMicro) => X=introMicroeconomics).
-(? [X] : (Prereq(X, introGeology))).

[CONCLUSION]:
A student cannot take Intro Geology.

[CONCLUSION (FOL)]:
¬CanTake(introgeology)

[CONCLUSION (GK)]:
-CanTake(introgeology).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If a class has prerequisites, the student must take the prerequisites to take the class.
If a class has no prerequisites, then the student can take the class
CPSC 201 and CPSC 223 are prerequisites for CPSC 323.
Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.
Intro Geology has no prerequisites.

[PREMISE (FOL)]:
∀x ∀y ∀z (Class(x) ∧ Student(y) ∧ Prereq(z,x) ∧ ¬Take(y, z) → ¬CanTake(y, x))
∀x ∀y ((Class(x) ∧ Student(y) ∧ ¬∃z Prereq(z,x)) → CanTake(y, x))
Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)
∀x (Prereq(x,intermediateMicro) → x=introMicroeconomics)
¬(∃x (Prereq(x, introGeology)))

[PREMISE (GK)]:
! [X] : ! [Y] : ! [Z] : (Class(X) & Student(Y) & Prereq(Z,X) & -Take(Y, Z) => -CanTake(Y, X)).
! [X] : ! [Y] : ((Class(X) & Student(Y) & -? [Z] : Prereq(Z,X)) => CanTake(Y, X)).
Prereq(cpsc201, cpsc323) & Prereq(cpsc223, cpsc323).
! [X] : (Prereq(X,intermediateMicro) => X=introMicroeconomics).
-(? [X] : (Prereq(X, introGeology))).

[CONCLUSION]:
Intermediate Microeconomics has one prerequisite.

[CONCLUSION (FOL)]:
∃x (Taken(x) → CanTake(intermediatemicro))

[CONCLUSION (GK)]:
? [X] : (Taken(X) => CanTake(intermediatemicro)).


===

['x']
['x']
[PREMISE]:
Heptalogyy is a compound literary or narrative work that is made up of seven distinct works.
The Harry Potter series consists of 7 distinct works.
The Chronicles of Narnia consists of 7 distinct works.

[PREMISE (FOL)]:
∀x (SevenDistinctWorks(x) → Heptalogy(x))
SevenDistinctWorks(harryPotter)
SevenDistinctWorks(chroniclesOfNarnia)

[PREMISE (GK)]:
! [X] : (SevenDistinctWorks(X) => Heptalogy(X)).
SevenDistinctWorks(harryPotter).
SevenDistinctWorks(chroniclesOfNarnia).

[CONCLUSION]:
The Harry Potter series of books is Heptalogy.

[CONCLUSION (FOL)]:
Heptalogy(harryPotter)

[CONCLUSION (GK)]:
Heptalogy(harryPotter).


===

['x']
['x']
[PREMISE]:
Heptalogyy is a compound literary or narrative work that is made up of seven distinct works.
The Harry Potter series consists of 7 distinct works.
The Chronicles of Narnia consists of 7 distinct works.

[PREMISE (FOL)]:
∀x (SevenDistinctWorks(x) → Heptalogy(x))
SevenDistinctWorks(harryPotter)
SevenDistinctWorks(chroniclesOfNarnia)

[PREMISE (GK)]:
! [X] : (SevenDistinctWorks(X) => Heptalogy(X)).
SevenDistinctWorks(harryPotter).
SevenDistinctWorks(chroniclesOfNarnia).

[CONCLUSION]:
The Chronicles of Narnia series of books is not Heptalogy.

[CONCLUSION (FOL)]:
¬Heptalogy(chroniclesOfNarnia)

[CONCLUSION (GK)]:
-Heptalogy(chroniclesOfNarnia).


===

['x']
['x']
[PREMISE]:
Heptalogyy is a compound literary or narrative work that is made up of seven distinct works.
The Harry Potter series consists of 7 distinct works.
The Chronicles of Narnia consists of 7 distinct works.

[PREMISE (FOL)]:
∀x (SevenDistinctWorks(x) → Heptalogy(x))
SevenDistinctWorks(harryPotter)
SevenDistinctWorks(chroniclesOfNarnia)

[PREMISE (GK)]:
! [X] : (SevenDistinctWorks(X) => Heptalogy(X)).
SevenDistinctWorks(harryPotter).
SevenDistinctWorks(chroniclesOfNarnia).

[CONCLUSION]:
The Lord of the Rings is Heptalogy.

[CONCLUSION (FOL)]:
Heptalogy(lordOfRings)

[CONCLUSION (GK)]:
Heptalogy(lordOfRings).


===

['x']
['x']
[PREMISE]:
All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.
If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.
People are fascinated by the history of the Renaissance and other past eras, or they are contemporary academics who enjoy learning.
People who are focused on futuristic and vocational subjects are contemporary academics who enjoy learning.
If people are professors who take a historical approach, then they are not contemporary academics who enjoy learning.
If Clyde is not focused on futuristic and voctional subjects, then he is neither focused on futuristic and vocational subjects nor enjoys dressing up in old-fashioned and historical period clothing.

[PREMISE (FOL)]:
∀x (AttendRegularly(x, renaissanceFair) → Enjoy(x, dressingUp, oldFashionedClothing) ∧ Enjoy(x, dressingUp, historicalPeriodClothing))
∀x (FascinatedBy(x, historyOfRenaissance) → AttendRegularly(x, renaissanceFair))
∀x (FascinatedBy(x, historyOfRenaissance) ⊕ (ContemporaryAcademic(x) ∧ Enjoy(x, learning)))
∀x (FocusedOn(x, futuristicSubject) ∧ FocusedOn(x, vocationalSubject) → ContemporaryAcademic(x) ∧ Enjoy(x, learning))
∀x (Professor(x) ∧ Take(x, historicalApproach) → ¬(ContemporaryAcademic(x) ∧ Enjoy(x, learning)))
¬(FocusedOn(clyde, futuristicSubject) ∧ FocusedOn(clyde, vocationalSubject))→ ¬(FocusedOn(clyde, futuristicSubject) ∧ FocusedOn(clyde, vocationalSubject) ∨ (Enjoy(clyde, dressingUp, oldFashionedClothing) ∧ Enjoy(clyde, dressingUp, historicalPeriodClothing)))

[PREMISE (GK)]:
! [X] : (AttendRegularly(X, renaissanceFair) => Enjoy(X, dressingUp, oldFashionedClothing) & Enjoy(X, dressingUp, historicalPeriodClothing)).
! [X] : (FascinatedBy(X, historyOfRenaissance) => AttendRegularly(X, renaissanceFair)).
! [X] : (FascinatedBy(X, historyOfRenaissance) <~> (ContemporaryAcademic(X) & Enjoy(X, learning))).
! [X] : (FocusedOn(X, futuristicSubject) & FocusedOn(X, vocationalSubject) => ContemporaryAcademic(X) & Enjoy(X, learning)).
! [X] : (Professor(X) & Take(X, historicalApproach) => -(ContemporaryAcademic(X) & Enjoy(X, learning))).
-(FocusedOn(clyde, futuristicSubject) & FocusedOn(clyde, vocationalSubject))=> -(FocusedOn(clyde, futuristicSubject) & FocusedOn(clyde, vocationalSubject) | (Enjoy(clyde, dressingUp, oldFashionedClothing) & Enjoy(clyde, dressingUp, historicalPeriodClothing))).

[CONCLUSION]:
Clyde attends Renaissance fairs regularly.

[CONCLUSION (FOL)]:
AttendRegularly(clyde, renaissanceFair)

[CONCLUSION (GK)]:
AttendRegularly(clyde, renaissanceFair).


===

['x']
['x']
[PREMISE]:
All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.
If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.
People are fascinated by the history of the Renaissance and other past eras, or they are contemporary academics who enjoy learning.
People who are focused on futuristic and vocational subjects are contemporary academics who enjoy learning.
If people are professors who take a historical approach, then they are not contemporary academics who enjoy learning.
If Clyde is not focused on futuristic and voctional subjects, then he is neither focused on futuristic and vocational subjects nor enjoys dressing up in old-fashioned and historical period clothing.

[PREMISE (FOL)]:
∀x (AttendRegularly(x, renaissanceFair) → Enjoy(x, dressingUp, oldFashionedClothing) ∧ Enjoy(x, dressingUp, historicalPeriodClothing))
∀x (FascinatedBy(x, historyOfRenaissance) → AttendRegularly(x, renaissanceFair))
∀x (FascinatedBy(x, historyOfRenaissance) ⊕ (ContemporaryAcademic(x) ∧ Enjoy(x, learning)))
∀x (FocusedOn(x, futuristicSubject) ∧ FocusedOn(x, vocationalSubject) → ContemporaryAcademic(x) ∧ Enjoy(x, learning))
∀x (Professor(x) ∧ Take(x, historicalApproach) → ¬(ContemporaryAcademic(x) ∧ Enjoy(x, learning)))
¬(FocusedOn(clyde, futuristicSubject) ∧ FocusedOn(clyde, vocationalSubject))→ ¬(FocusedOn(clyde, futuristicSubject) ∧ FocusedOn(clyde, vocationalSubject) ∨ (Enjoy(clyde, dressingUp, oldFashionedClothing) ∧ Enjoy(clyde, dressingUp, historicalPeriodClothing)))

[PREMISE (GK)]:
! [X] : (AttendRegularly(X, renaissanceFair) => Enjoy(X, dressingUp, oldFashionedClothing) & Enjoy(X, dressingUp, historicalPeriodClothing)).
! [X] : (FascinatedBy(X, historyOfRenaissance) => AttendRegularly(X, renaissanceFair)).
! [X] : (FascinatedBy(X, historyOfRenaissance) <~> (ContemporaryAcademic(X) & Enjoy(X, learning))).
! [X] : (FocusedOn(X, futuristicSubject) & FocusedOn(X, vocationalSubject) => ContemporaryAcademic(X) & Enjoy(X, learning)).
! [X] : (Professor(X) & Take(X, historicalApproach) => -(ContemporaryAcademic(X) & Enjoy(X, learning))).
-(FocusedOn(clyde, futuristicSubject) & FocusedOn(clyde, vocationalSubject))=> -(FocusedOn(clyde, futuristicSubject) & FocusedOn(clyde, vocationalSubject) | (Enjoy(clyde, dressingUp, oldFashionedClothing) & Enjoy(clyde, dressingUp, historicalPeriodClothing))).

[CONCLUSION]:
Clyde is a professor who takes a historical approach.

[CONCLUSION (FOL)]:
Professor(clyde) ∧ Take(clyde, historicalApproach)

[CONCLUSION (GK)]:
Professor(clyde) & Take(clyde, historicalApproach).


===

['x']
['x']
[PREMISE]:
All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.
If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.
People are fascinated by the history of the Renaissance and other past eras, or they are contemporary academics who enjoy learning.
People who are focused on futuristic and vocational subjects are contemporary academics who enjoy learning.
If people are professors who take a historical approach, then they are not contemporary academics who enjoy learning.
If Clyde is not focused on futuristic and voctional subjects, then he is neither focused on futuristic and vocational subjects nor enjoys dressing up in old-fashioned and historical period clothing.

[PREMISE (FOL)]:
∀x (AttendRegularly(x, renaissanceFair) → Enjoy(x, dressingUp, oldFashionedClothing) ∧ Enjoy(x, dressingUp, historicalPeriodClothing))
∀x (FascinatedBy(x, historyOfRenaissance) → AttendRegularly(x, renaissanceFair))
∀x (FascinatedBy(x, historyOfRenaissance) ⊕ (ContemporaryAcademic(x) ∧ Enjoy(x, learning)))
∀x (FocusedOn(x, futuristicSubject) ∧ FocusedOn(x, vocationalSubject) → ContemporaryAcademic(x) ∧ Enjoy(x, learning))
∀x (Professor(x) ∧ Take(x, historicalApproach) → ¬(ContemporaryAcademic(x) ∧ Enjoy(x, learning)))
¬(FocusedOn(clyde, futuristicSubject) ∧ FocusedOn(clyde, vocationalSubject))→ ¬(FocusedOn(clyde, futuristicSubject) ∧ FocusedOn(clyde, vocationalSubject) ∨ (Enjoy(clyde, dressingUp, oldFashionedClothing) ∧ Enjoy(clyde, dressingUp, historicalPeriodClothing)))

[PREMISE (GK)]:
! [X] : (AttendRegularly(X, renaissanceFair) => Enjoy(X, dressingUp, oldFashionedClothing) & Enjoy(X, dressingUp, historicalPeriodClothing)).
! [X] : (FascinatedBy(X, historyOfRenaissance) => AttendRegularly(X, renaissanceFair)).
! [X] : (FascinatedBy(X, historyOfRenaissance) <~> (ContemporaryAcademic(X) & Enjoy(X, learning))).
! [X] : (FocusedOn(X, futuristicSubject) & FocusedOn(X, vocationalSubject) => ContemporaryAcademic(X) & Enjoy(X, learning)).
! [X] : (Professor(X) & Take(X, historicalApproach) => -(ContemporaryAcademic(X) & Enjoy(X, learning))).
-(FocusedOn(clyde, futuristicSubject) & FocusedOn(clyde, vocationalSubject))=> -(FocusedOn(clyde, futuristicSubject) & FocusedOn(clyde, vocationalSubject) | (Enjoy(clyde, dressingUp, oldFashionedClothing) & Enjoy(clyde, dressingUp, historicalPeriodClothing))).

[CONCLUSION]:
Clyde is a professor who takes a historical approach, or is a contemporary academic.

[CONCLUSION (FOL)]:
(Professor(clyde) ∧ Take(clyde, historicalApproach)) ∨ (ContemporaryAcademic(clyde) ∧ Enjoy(clyde, learning))

[CONCLUSION (GK)]:
(Professor(clyde) & Take(clyde, historicalApproach)) | (ContemporaryAcademic(clyde) & Enjoy(clyde, learning)).


===

['x']
['x']
[PREMISE]:
No sports cars are vehicles intended to be driven at moderate speeds.
All automobiles designed for family use are vehicles intended to be driven at moderate speeds.

[PREMISE (FOL)]:
∀x (SportsCar(x) → ¬IntendedToBeDrivenAt(x, moderateSpeed))
∀x (DesignedFor(x, familyUse) → IntendedToBeDrivenAt(x, moderateSpeed))

[PREMISE (GK)]:
! [X] : (SportsCar(X) => -IntendedToBeDrivenAt(X, moderateSpeed)).
! [X] : (DesignedFor(X, familyUse) => IntendedToBeDrivenAt(X, moderateSpeed)).

[CONCLUSION]:
No sports cars are automobiles designed for family use.

[CONCLUSION (FOL)]:
∀x (SportsCar(x) → ¬For(x, familyUse))

[CONCLUSION (GK)]:
! [X] : (SportsCar(X) => -For(X, familyUse)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If people work well in teams in the workplace, then they get along with all their colleagues at their work.
If people come to work every day with a positive attitude, then they work well in teams in the workplace.
People either come to work every day with a positive attitude or are always tired every morning.
If people are always tired in the morning, then they are criticized by their boss.
If people are criticized by their boss, then they do not receive positive feedback from teams at work.
Kat either is a person who works well in teams in the workplac and is always tired every morning, or she is neither.

[PREMISE (FOL)]:
∀x (WorkWellInTeamsIn(x, workPlace) → ∀y (Colleague(y) ∧ GetAlongWithAtWork(x, y)))
∀x (ComeToWorkWithEveryDay(x, positiveAttitude) → WorkWellInTeamsIn(x, workPlace))
∀x (ComeToWorkWithEveryDay(x, positiveAttitude) ⊕ AlwaysTiredInMorning(x))
∀x (AlwaysTiredInMorning(x) → CriticizedBy(x, boss))
∀x (CriticizedBy(x, boss) → ¬ReceiveFromAtWork(x, positiveFeedback, team))
¬(WorkWellInTeamsIn(kat, workPlace) ⊕ Tired(kat))

[PREMISE (GK)]:
! [X] : (WorkWellInTeamsIn(X, workPlace) => ! [Y] : (Colleague(Y) & GetAlongWithAtWork(X, Y))).
! [X] : (ComeToWorkWithEveryDay(X, positiveAttitude) => WorkWellInTeamsIn(X, workPlace)).
! [X] : (ComeToWorkWithEveryDay(X, positiveAttitude) <~> AlwaysTiredInMorning(X)).
! [X] : (AlwaysTiredInMorning(X) => CriticizedBy(X, boss)).
! [X] : (CriticizedBy(X, boss) => -ReceiveFromAtWork(X, positiveFeedback, team)).
-(WorkWellInTeamsIn(kat, workPlace) <~> Tired(kat)).

[CONCLUSION]:
Kat is a person who comes to work every day with a positive attitude.

[CONCLUSION (FOL)]:
ComeToWorkWithEveryDay(kat, positiveAttitude)

[CONCLUSION (GK)]:
ComeToWorkWithEveryDay(kat, positiveAttitude).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If people work well in teams in the workplace, then they get along with all their colleagues at their work.
If people come to work every day with a positive attitude, then they work well in teams in the workplace.
People either come to work every day with a positive attitude or are always tired every morning.
If people are always tired in the morning, then they are criticized by their boss.
If people are criticized by their boss, then they do not receive positive feedback from teams at work.
Kat either is a person who works well in teams in the workplac and is always tired every morning, or she is neither.

[PREMISE (FOL)]:
∀x (WorkWellInTeamsIn(x, workPlace) → ∀y (Colleague(y) ∧ GetAlongWithAtWork(x, y)))
∀x (ComeToWorkWithEveryDay(x, positiveAttitude) → WorkWellInTeamsIn(x, workPlace))
∀x (ComeToWorkWithEveryDay(x, positiveAttitude) ⊕ AlwaysTiredInMorning(x))
∀x (AlwaysTiredInMorning(x) → CriticizedBy(x, boss))
∀x (CriticizedBy(x, boss) → ¬ReceiveFromAtWork(x, positiveFeedback, team))
¬(WorkWellInTeamsIn(kat, workPlace) ⊕ Tired(kat))

[PREMISE (GK)]:
! [X] : (WorkWellInTeamsIn(X, workPlace) => ! [Y] : (Colleague(Y) & GetAlongWithAtWork(X, Y))).
! [X] : (ComeToWorkWithEveryDay(X, positiveAttitude) => WorkWellInTeamsIn(X, workPlace)).
! [X] : (ComeToWorkWithEveryDay(X, positiveAttitude) <~> AlwaysTiredInMorning(X)).
! [X] : (AlwaysTiredInMorning(X) => CriticizedBy(X, boss)).
! [X] : (CriticizedBy(X, boss) => -ReceiveFromAtWork(X, positiveFeedback, team)).
-(WorkWellInTeamsIn(kat, workPlace) <~> Tired(kat)).

[CONCLUSION]:
Kat gets along with her colleagues at her work and receives positive feedback from teams at her work.

[CONCLUSION (FOL)]:
(∀y (Colleague(y) ∧ GetAlongWithAtWork(kat, y))) ∧ ReceiveFromAtWork(kat, positiveFeedback, team)

[CONCLUSION (GK)]:
(! [Y] : (Colleague(Y) & GetAlongWithAtWork(kat, Y))) & ReceiveFromAtWork(kat, positiveFeedback, team).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If people work well in teams in the workplace, then they get along with all their colleagues at their work.
If people come to work every day with a positive attitude, then they work well in teams in the workplace.
People either come to work every day with a positive attitude or are always tired every morning.
If people are always tired in the morning, then they are criticized by their boss.
If people are criticized by their boss, then they do not receive positive feedback from teams at work.
Kat either is a person who works well in teams in the workplac and is always tired every morning, or she is neither.

[PREMISE (FOL)]:
∀x (WorkWellInTeamsIn(x, workPlace) → ∀y (Colleague(y) ∧ GetAlongWithAtWork(x, y)))
∀x (ComeToWorkWithEveryDay(x, positiveAttitude) → WorkWellInTeamsIn(x, workPlace))
∀x (ComeToWorkWithEveryDay(x, positiveAttitude) ⊕ AlwaysTiredInMorning(x))
∀x (AlwaysTiredInMorning(x) → CriticizedBy(x, boss))
∀x (CriticizedBy(x, boss) → ¬ReceiveFromAtWork(x, positiveFeedback, team))
¬(WorkWellInTeamsIn(kat, workPlace) ⊕ Tired(kat))

[PREMISE (GK)]:
! [X] : (WorkWellInTeamsIn(X, workPlace) => ! [Y] : (Colleague(Y) & GetAlongWithAtWork(X, Y))).
! [X] : (ComeToWorkWithEveryDay(X, positiveAttitude) => WorkWellInTeamsIn(X, workPlace)).
! [X] : (ComeToWorkWithEveryDay(X, positiveAttitude) <~> AlwaysTiredInMorning(X)).
! [X] : (AlwaysTiredInMorning(X) => CriticizedBy(X, boss)).
! [X] : (CriticizedBy(X, boss) => -ReceiveFromAtWork(X, positiveFeedback, team)).
-(WorkWellInTeamsIn(kat, workPlace) <~> Tired(kat)).

[CONCLUSION]:
Kat either gets along with her colleagues at her work or receives positive feedback from teams at her work.

[CONCLUSION (FOL)]:
(∀y (Colleague(y) ∧ GetAlongWithAtWork(kat, y))) ⊕ ReceiveFromAtWork(kat, positiveFeedback, team)

[CONCLUSION (GK)]:
(! [Y] : (Colleague(Y) & GetAlongWithAtWork(kat, Y))) <~> ReceiveFromAtWork(kat, positiveFeedback, team).


===

['x']
['x']
[PREMISE]:
Drishti is an open-source software.
Open-source software is free to modify.

[PREMISE (FOL)]:
OpenSourceSoftware(drishti)
∀x (OpenSourceSoftware(x) → FreeToModify(x))

[PREMISE (GK)]:
OpenSourceSoftware(drishti).
! [X] : (OpenSourceSoftware(X) => FreeToModify(X)).

[CONCLUSION]:
Drishti is free to modify.

[CONCLUSION (FOL)]:
FreeToModify(drishti)

[CONCLUSION (GK)]:
FreeToModify(drishti).


===

['x', 'y']
['x', 'y']
[PREMISE]:
There are five grades in English class: A+, A, B+, B, and C. 
If a student gets an A+ in English class, then his score is greater than 95.
If a student gets an A in English class, then his score is greater than 90 but lower than 95.
Zhang got an A in English class.
Wang's English class score is better than Zhang's.
Wu's English class score is lower than 90.
If a student's English class score is lower than 90, then it is not greater than 95 or 90, and lower than 95.

[PREMISE (FOL)]:
GradeIn(aPlus, englishClass) ∨ GradeIn(a, englishClass) ∨ GradeIn(bPlus, englishClass) ∨ GradeIn(b, englishClass) ∨ GradeIn(c, englishClass) ∧ (GradeIn(aPlus, englishClass) → ¬GradeIn(a, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(b, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(a, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(b, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(bPlus, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(a, englishClass) ∧ ¬GradeIn(b, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(b, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(a, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(c, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(a, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(b, englishClass)) 
∀x ∀y (Student(x) ∧ GetGradeIn(x, aPlus, englishClass) → EnglishClassScore(x, y) ∧ GreaterThan95(y))
∀x ∀y (Student(x) ∧ GetGradeIn(x, a, englishClass) → EnglishClassScore(x, y) ∧ GreaterThan90(y) ∧ LowerThan95(y)) 
Student(zhang) ∧ GetGradeIn(zhang, a, englishClass)
∀x ∀y (Student(zhang) ∧ Student(wang) ∧ EnglishScore(zhang, x) ∧ EnglishScore(wang, y) ∧ Better(y, x))
∀x (Student(wu) ∧ EnglishScore(wu, x) ∧ LowerThan90(x))
∀x ∀y (Student(x) ∧ EnglishScore(x, y) ∧ LowerThan90(y) → ¬GreaterThan95(y) ∧ ¬GreaterThan90(y) ∧ LowerThan95(y))

[PREMISE (GK)]:
GradeIn(aPlus, englishClass) | GradeIn(a, englishClass) | GradeIn(bPlus, englishClass) | GradeIn(b, englishClass) | GradeIn(c, englishClass) & (GradeIn(aPlus, englishClass) => -GradeIn(a, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(b, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(a, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(b, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(bPlus, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(a, englishClass) & -GradeIn(b, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(b, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(a, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(c, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(a, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(b, englishClass)) .
! [X] : ! [Y] : (Student(X) & GetGradeIn(X, aPlus, englishClass) => EnglishClassScore(X, Y) & GreaterThan95(Y)).
! [X] : ! [Y] : (Student(X) & GetGradeIn(X, a, englishClass) => EnglishClassScore(X, Y) & GreaterThan90(Y) & LowerThan95(Y)) .
Student(zhang) & GetGradeIn(zhang, a, englishClass).
! [X] : ! [Y] : (Student(zhang) & Student(wang) & EnglishScore(zhang, X) & EnglishScore(wang, Y) & Better(Y, X)).
! [X] : (Student(wu) & EnglishScore(wu, X) & LowerThan90(X)).
! [X] : ! [Y] : (Student(X) & EnglishScore(X, Y) & LowerThan90(Y) => -GreaterThan95(Y) & -GreaterThan90(Y) & LowerThan95(Y)).

[CONCLUSION]:
Zhang's English class score is lower than 95.

[CONCLUSION (FOL)]:
∀x (EnglishScore(zhang, x) ∧ LowerThan95(x))

[CONCLUSION (GK)]:
! [X] : (EnglishScore(zhang, X) & LowerThan95(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
There are five grades in English class: A+, A, B+, B, and C. 
If a student gets an A+ in English class, then his score is greater than 95.
If a student gets an A in English class, then his score is greater than 90 but lower than 95.
Zhang got an A in English class.
Wang's English class score is better than Zhang's.
Wu's English class score is lower than 90.
If a student's English class score is lower than 90, then it is not greater than 95 or 90, and lower than 95.

[PREMISE (FOL)]:
GradeIn(aPlus, englishClass) ∨ GradeIn(a, englishClass) ∨ GradeIn(bPlus, englishClass) ∨ GradeIn(b, englishClass) ∨ GradeIn(c, englishClass) ∧ (GradeIn(aPlus, englishClass) → ¬GradeIn(a, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(b, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(a, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(b, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(bPlus, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(a, englishClass) ∧ ¬GradeIn(b, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(b, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(a, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(c, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(a, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(b, englishClass)) 
∀x ∀y (Student(x) ∧ GetGradeIn(x, aPlus, englishClass) → EnglishClassScore(x, y) ∧ GreaterThan95(y))
∀x ∀y (Student(x) ∧ GetGradeIn(x, a, englishClass) → EnglishClassScore(x, y) ∧ GreaterThan90(y) ∧ LowerThan95(y)) 
Student(zhang) ∧ GetGradeIn(zhang, a, englishClass)
∀x ∀y (Student(zhang) ∧ Student(wang) ∧ EnglishScore(zhang, x) ∧ EnglishScore(wang, y) ∧ Better(y, x))
∀x (Student(wu) ∧ EnglishScore(wu, x) ∧ LowerThan90(x))
∀x ∀y (Student(x) ∧ EnglishScore(x, y) ∧ LowerThan90(y) → ¬GreaterThan95(y) ∧ ¬GreaterThan90(y) ∧ LowerThan95(y))

[PREMISE (GK)]:
GradeIn(aPlus, englishClass) | GradeIn(a, englishClass) | GradeIn(bPlus, englishClass) | GradeIn(b, englishClass) | GradeIn(c, englishClass) & (GradeIn(aPlus, englishClass) => -GradeIn(a, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(b, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(a, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(b, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(bPlus, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(a, englishClass) & -GradeIn(b, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(b, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(a, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(c, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(a, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(b, englishClass)) .
! [X] : ! [Y] : (Student(X) & GetGradeIn(X, aPlus, englishClass) => EnglishClassScore(X, Y) & GreaterThan95(Y)).
! [X] : ! [Y] : (Student(X) & GetGradeIn(X, a, englishClass) => EnglishClassScore(X, Y) & GreaterThan90(Y) & LowerThan95(Y)) .
Student(zhang) & GetGradeIn(zhang, a, englishClass).
! [X] : ! [Y] : (Student(zhang) & Student(wang) & EnglishScore(zhang, X) & EnglishScore(wang, Y) & Better(Y, X)).
! [X] : (Student(wu) & EnglishScore(wu, X) & LowerThan90(X)).
! [X] : ! [Y] : (Student(X) & EnglishScore(X, Y) & LowerThan90(Y) => -GreaterThan95(Y) & -GreaterThan90(Y) & LowerThan95(Y)).

[CONCLUSION]:
Wang got an A+ in English class.

[CONCLUSION (FOL)]:
GetGradeIn(wang, aPlus, englishClass)

[CONCLUSION (GK)]:
GetGradeIn(wang, aPlus, englishClass).


===

['x', 'y']
['x', 'y']
[PREMISE]:
There are five grades in English class: A+, A, B+, B, and C. 
If a student gets an A+ in English class, then his score is greater than 95.
If a student gets an A in English class, then his score is greater than 90 but lower than 95.
Zhang got an A in English class.
Wang's English class score is better than Zhang's.
Wu's English class score is lower than 90.
If a student's English class score is lower than 90, then it is not greater than 95 or 90, and lower than 95.

[PREMISE (FOL)]:
GradeIn(aPlus, englishClass) ∨ GradeIn(a, englishClass) ∨ GradeIn(bPlus, englishClass) ∨ GradeIn(b, englishClass) ∨ GradeIn(c, englishClass) ∧ (GradeIn(aPlus, englishClass) → ¬GradeIn(a, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(b, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(a, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(b, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(bPlus, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(a, englishClass) ∧ ¬GradeIn(b, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(b, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(a, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(c, englishClass)) ∧ (GradeIn(c, englishClass) → ¬GradeIn(aPlus, englishClass) ∧ ¬GradeIn(a, englishClass) ∧ ¬GradeIn(bPlus, englishClass) ∧ ¬GradeIn(b, englishClass)) 
∀x ∀y (Student(x) ∧ GetGradeIn(x, aPlus, englishClass) → EnglishClassScore(x, y) ∧ GreaterThan95(y))
∀x ∀y (Student(x) ∧ GetGradeIn(x, a, englishClass) → EnglishClassScore(x, y) ∧ GreaterThan90(y) ∧ LowerThan95(y)) 
Student(zhang) ∧ GetGradeIn(zhang, a, englishClass)
∀x ∀y (Student(zhang) ∧ Student(wang) ∧ EnglishScore(zhang, x) ∧ EnglishScore(wang, y) ∧ Better(y, x))
∀x (Student(wu) ∧ EnglishScore(wu, x) ∧ LowerThan90(x))
∀x ∀y (Student(x) ∧ EnglishScore(x, y) ∧ LowerThan90(y) → ¬GreaterThan95(y) ∧ ¬GreaterThan90(y) ∧ LowerThan95(y))

[PREMISE (GK)]:
GradeIn(aPlus, englishClass) | GradeIn(a, englishClass) | GradeIn(bPlus, englishClass) | GradeIn(b, englishClass) | GradeIn(c, englishClass) & (GradeIn(aPlus, englishClass) => -GradeIn(a, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(b, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(a, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(b, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(bPlus, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(a, englishClass) & -GradeIn(b, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(b, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(a, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(c, englishClass)) & (GradeIn(c, englishClass) => -GradeIn(aPlus, englishClass) & -GradeIn(a, englishClass) & -GradeIn(bPlus, englishClass) & -GradeIn(b, englishClass)) .
! [X] : ! [Y] : (Student(X) & GetGradeIn(X, aPlus, englishClass) => EnglishClassScore(X, Y) & GreaterThan95(Y)).
! [X] : ! [Y] : (Student(X) & GetGradeIn(X, a, englishClass) => EnglishClassScore(X, Y) & GreaterThan90(Y) & LowerThan95(Y)) .
Student(zhang) & GetGradeIn(zhang, a, englishClass).
! [X] : ! [Y] : (Student(zhang) & Student(wang) & EnglishScore(zhang, X) & EnglishScore(wang, Y) & Better(Y, X)).
! [X] : (Student(wu) & EnglishScore(wu, X) & LowerThan90(X)).
! [X] : ! [Y] : (Student(X) & EnglishScore(X, Y) & LowerThan90(Y) => -GreaterThan95(Y) & -GreaterThan90(Y) & LowerThan95(Y)).

[CONCLUSION]:
Wu does not get an A or A+ in English class.

[CONCLUSION (FOL)]:
¬GetGradeIn(wu, aPlus, englishClass) ∧¬GetGradeIn(wu, a, englishClass)

[CONCLUSION (GK)]:
-GetGradeIn(wu, aPlus, englishClass) &-GetGradeIn(wu, a, englishClass).


===

['x']
['x']
[PREMISE]:
Olivia doesn't prefer warm temperatures during the day.
When Olivia sleeps, she prefers a cool temperature.
Olivia sleeps during the night.
Olivia works during the day.
Olivia either works or sleeps.
It is either the day or the night.
Olivia either prefers warm temperatures or prefers cool temperatures.

[PREMISE (FOL)]:
∀x (Day(x) → ¬Prefer(olivia, warmTemperature, x))
∀x (Sleep(olivia, x) → Prefer(olivia, coolTemperature, x))
∀x (Night(x) → Sleep(olivia, x))
∀x (Day(x) → Work(olivia, x))
Work(olivia) ⊕ Sleep(olivia)
∀x (Day(x) ⊕ Night(x))
∀x (Prefer(olivia, warmTemperature, x) ⊕ Prefer(olivia, coolTemperature, x))

[PREMISE (GK)]:
! [X] : (Day(X) => -Prefer(olivia, warmTemperature, X)).
! [X] : (Sleep(olivia, X) => Prefer(olivia, coolTemperature, X)).
! [X] : (Night(X) => Sleep(olivia, X)).
! [X] : (Day(X) => Work(olivia, X)).
Work(olivia) <~> Sleep(olivia).
! [X] : (Day(X) <~> Night(X)).
! [X] : (Prefer(olivia, warmTemperature, X) <~> Prefer(olivia, coolTemperature, X)).

[CONCLUSION]:
At all times, Olivia prefers a cool temperature.

[CONCLUSION (FOL)]:
∀x (Prefer(olivia, coolTemperature, x))

[CONCLUSION (GK)]:
! [X] : (Prefer(olivia, coolTemperature, X)).


===

['x']
['x']
[PREMISE]:
TOra is a GUI.
GUIs are software.
Software can be free or paid.
Paid Software is not under the GNU General Public License.
TOra is under the GNU General Public License.

[PREMISE (FOL)]:
GUI(tora)
∀x (GUI(x) → Software(x))
∀x (Software(x) → Free(x) ⊕ Paid(x))
∀x (Paid(x) ∧ Software(x) → ¬UnderGNULicense(x))
UnderGNULicense(tora)

[PREMISE (GK)]:
GUI(tora).
! [X] : (GUI(X) => Software(X)).
! [X] : (Software(X) => Free(X) <~> Paid(X)).
! [X] : (Paid(X) & Software(X) => -UnderGNULicense(X)).
UnderGNULicense(tora).

[CONCLUSION]:
TOra is a paid software.

[CONCLUSION (FOL)]:
Paid(tora) ∧ Software(tora)

[CONCLUSION (GK)]:
Paid(tora) & Software(tora).


===

['x']
['x']
[PREMISE]:
TOra is a GUI.
GUIs are software.
Software can be free or paid.
Paid Software is not under the GNU General Public License.
TOra is under the GNU General Public License.

[PREMISE (FOL)]:
GUI(tora)
∀x (GUI(x) → Software(x))
∀x (Software(x) → Free(x) ⊕ Paid(x))
∀x (Paid(x) ∧ Software(x) → ¬UnderGNULicense(x))
UnderGNULicense(tora)

[PREMISE (GK)]:
GUI(tora).
! [X] : (GUI(X) => Software(X)).
! [X] : (Software(X) => Free(X) <~> Paid(X)).
! [X] : (Paid(X) & Software(X) => -UnderGNULicense(X)).
UnderGNULicense(tora).

[CONCLUSION]:
TOra is a free software.

[CONCLUSION (FOL)]:
Free(tora) ∧ Software(tora)

[CONCLUSION (GK)]:
Free(tora) & Software(tora).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Customers choose a Prime Video plan or an HBO Max Plan, or both. 
All customers who choose a Prime Video Plan are rewarded with a $30 gift card. 
There are no customers who do not choose any plan. 
None of the customers who are rewarded with a $30 gift card are older than 80.
All the customers are either older than 80 or between the ages of 60 and 80.
James is a customer who is not between the ages of 60 and 80. 

[PREMISE (FOL)]:
∀x (Customer(x) → (Choose(x, primeVideoPlan) ∨ Choose(x, hBOMaxPlan)))
∀x ((Customer(x) ∧ Choose(x, hBOMaxPlan)) → RewardWith(x, giftCard))
∀x (Customer(x) → (∃y(Plan(y) ∧ Choose(x, y))))
∀x ((Customer(x) ∧ RewardWith(x, giftCard)) → (¬OlderThan(x, num80)))
∀x (Customer(x) → (∃y(GreaterThan(y, num80) ∧ Age(james,y)) ⊕ (∃y(Between(y, num60, num80) ∧ Age(james, y)))))
Customer(james) ∧ (¬∃y(Between(y, num60, num80) ∧ Age(james, y)))

[PREMISE (GK)]:
! [X] : (Customer(X) => (Choose(X, primeVideoPlan) | Choose(X, hBOMaxPlan))).
! [X] : ((Customer(X) & Choose(X, hBOMaxPlan)) => RewardWith(X, giftCard)).
! [X] : (Customer(X) => (? [Y] :(Plan(Y) & Choose(X, Y)))).
! [X] : ((Customer(X) & RewardWith(X, giftCard)) => (-OlderThan(X, num80))).
! [X] : (Customer(X) => (? [Y] :(GreaterThan(Y, num80) & Age(james,Y)) <~> (? [Y] :(Between(Y, num60, num80) & Age(james, Y))))).
Customer(james) & (-? [Y] :(Between(Y, num60, num80) & Age(james, Y))).

[CONCLUSION]:
James is a customer who does not choose any plans.

[CONCLUSION (FOL)]:
Choose(james, noPlan)

[CONCLUSION (GK)]:
Choose(james, noPlan).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Customers choose a Prime Video plan or an HBO Max Plan, or both. 
All customers who choose a Prime Video Plan are rewarded with a $30 gift card. 
There are no customers who do not choose any plan. 
None of the customers who are rewarded with a $30 gift card are older than 80.
All the customers are either older than 80 or between the ages of 60 and 80.
James is a customer who is not between the ages of 60 and 80. 

[PREMISE (FOL)]:
∀x (Customer(x) → (Choose(x, primeVideoPlan) ∨ Choose(x, hBOMaxPlan)))
∀x ((Customer(x) ∧ Choose(x, hBOMaxPlan)) → RewardWith(x, giftCard))
∀x (Customer(x) → (∃y(Plan(y) ∧ Choose(x, y))))
∀x ((Customer(x) ∧ RewardWith(x, giftCard)) → (¬OlderThan(x, num80)))
∀x (Customer(x) → (∃y(GreaterThan(y, num80) ∧ Age(james,y)) ⊕ (∃y(Between(y, num60, num80) ∧ Age(james, y)))))
Customer(james) ∧ (¬∃y(Between(y, num60, num80) ∧ Age(james, y)))

[PREMISE (GK)]:
! [X] : (Customer(X) => (Choose(X, primeVideoPlan) | Choose(X, hBOMaxPlan))).
! [X] : ((Customer(X) & Choose(X, hBOMaxPlan)) => RewardWith(X, giftCard)).
! [X] : (Customer(X) => (? [Y] :(Plan(Y) & Choose(X, Y)))).
! [X] : ((Customer(X) & RewardWith(X, giftCard)) => (-OlderThan(X, num80))).
! [X] : (Customer(X) => (? [Y] :(GreaterThan(Y, num80) & Age(james,Y)) <~> (? [Y] :(Between(Y, num60, num80) & Age(james, Y))))).
Customer(james) & (-? [Y] :(Between(Y, num60, num80) & Age(james, Y))).

[CONCLUSION]:
James is a customer who chooses a Prime Video plan or does not choose any plans.

[CONCLUSION (FOL)]:
Choose(james, planA) ∨ Choose(james, noPlan)

[CONCLUSION (GK)]:
Choose(james, planA) | Choose(james, noPlan).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Customers choose a Prime Video plan or an HBO Max Plan, or both. 
All customers who choose a Prime Video Plan are rewarded with a $30 gift card. 
There are no customers who do not choose any plan. 
None of the customers who are rewarded with a $30 gift card are older than 80.
All the customers are either older than 80 or between the ages of 60 and 80.
James is a customer who is not between the ages of 60 and 80. 

[PREMISE (FOL)]:
∀x (Customer(x) → (Choose(x, primeVideoPlan) ∨ Choose(x, hBOMaxPlan)))
∀x ((Customer(x) ∧ Choose(x, hBOMaxPlan)) → RewardWith(x, giftCard))
∀x (Customer(x) → (∃y(Plan(y) ∧ Choose(x, y))))
∀x ((Customer(x) ∧ RewardWith(x, giftCard)) → (¬OlderThan(x, num80)))
∀x (Customer(x) → (∃y(GreaterThan(y, num80) ∧ Age(james,y)) ⊕ (∃y(Between(y, num60, num80) ∧ Age(james, y)))))
Customer(james) ∧ (¬∃y(Between(y, num60, num80) ∧ Age(james, y)))

[PREMISE (GK)]:
! [X] : (Customer(X) => (Choose(X, primeVideoPlan) | Choose(X, hBOMaxPlan))).
! [X] : ((Customer(X) & Choose(X, hBOMaxPlan)) => RewardWith(X, giftCard)).
! [X] : (Customer(X) => (? [Y] :(Plan(Y) & Choose(X, Y)))).
! [X] : ((Customer(X) & RewardWith(X, giftCard)) => (-OlderThan(X, num80))).
! [X] : (Customer(X) => (? [Y] :(GreaterThan(Y, num80) & Age(james,Y)) <~> (? [Y] :(Between(Y, num60, num80) & Age(james, Y))))).
Customer(james) & (-? [Y] :(Between(Y, num60, num80) & Age(james, Y))).

[CONCLUSION]:
Suppose James is a customer who chooses the Prime Video plan or does not choose any plans, then he is either rewarded a $30 gift card or chooses the HBO Max plan.

[CONCLUSION (FOL)]:
Choose(james, planA) ∨ Choose(james, noPlan) → RewardWith(james, giftCard) ⊕ Choose(james, planB)

[CONCLUSION (GK)]:
Choose(james, planA) | Choose(james, noPlan) => RewardWith(james, giftCard) <~> Choose(james, planB).


===

['x']
['x']
[PREMISE]:
Detroit City is a horse.
Some horses are racehorses.
If a horse falls in a race, it poses risks to its rider.
Detroit City fell in a race.
A horse is a racehorse if it is in a race.

[PREMISE (FOL)]:
Horse(detroitcity)
∃x (Horse(x) ∧ Racehorse(x))
∀x (Horse(x) ∧ InRace(x) ∧ Falls(x) → PoseRiskTo(x, rider))
InRace(detroitcity) ∧ Fall(detroitcity)
∀x (Horse(x) ∧ InRace(x) → Racehorse(x))

[PREMISE (GK)]:
Horse(detroitcity).
? [X] : (Horse(X) & Racehorse(X)).
! [X] : (Horse(X) & InRace(X) & Falls(X) => PoseRiskTo(X, rider)).
InRace(detroitcity) & Fall(detroitcity).
! [X] : (Horse(X) & InRace(X) => Racehorse(X)).

[CONCLUSION]:
Detroit City has been in multiple races.

[CONCLUSION (FOL)]:
MultipleRace(detroitcity)

[CONCLUSION (GK)]:
MultipleRace(detroitcity).


===

['x']
['x']
[PREMISE]:
Detroit City is a horse.
Some horses are racehorses.
If a horse falls in a race, it poses risks to its rider.
Detroit City fell in a race.
A horse is a racehorse if it is in a race.

[PREMISE (FOL)]:
Horse(detroitcity)
∃x (Horse(x) ∧ Racehorse(x))
∀x (Horse(x) ∧ InRace(x) ∧ Falls(x) → PoseRiskTo(x, rider))
InRace(detroitcity) ∧ Fall(detroitcity)
∀x (Horse(x) ∧ InRace(x) → Racehorse(x))

[PREMISE (GK)]:
Horse(detroitcity).
? [X] : (Horse(X) & Racehorse(X)).
! [X] : (Horse(X) & InRace(X) & Falls(X) => PoseRiskTo(X, rider)).
InRace(detroitcity) & Fall(detroitcity).
! [X] : (Horse(X) & InRace(X) => Racehorse(X)).

[CONCLUSION]:
Detroit City poses risks to its rider.

[CONCLUSION (FOL)]:
PoseRiskTo(detroitcity, rider)

[CONCLUSION (GK)]:
PoseRiskTo(detroitcity, rider).


===

['x']
['x']
[PREMISE]:
Detroit City is a horse.
Some horses are racehorses.
If a horse falls in a race, it poses risks to its rider.
Detroit City fell in a race.
A horse is a racehorse if it is in a race.

[PREMISE (FOL)]:
Horse(detroitcity)
∃x (Horse(x) ∧ Racehorse(x))
∀x (Horse(x) ∧ InRace(x) ∧ Falls(x) → PoseRiskTo(x, rider))
InRace(detroitcity) ∧ Fall(detroitcity)
∀x (Horse(x) ∧ InRace(x) → Racehorse(x))

[PREMISE (GK)]:
Horse(detroitcity).
? [X] : (Horse(X) & Racehorse(X)).
! [X] : (Horse(X) & InRace(X) & Falls(X) => PoseRiskTo(X, rider)).
InRace(detroitcity) & Fall(detroitcity).
! [X] : (Horse(X) & InRace(X) => Racehorse(X)).

[CONCLUSION]:
Detroit City is a racehorse.

[CONCLUSION (FOL)]:
Racehorse(detroitcity)

[CONCLUSION (GK)]:
Racehorse(detroitcity).


===

['x']
['x']
[PREMISE]:
Frederick Monhoff was an architect, artist, and illustrator.
Frederick Monhoff was an American.
An artist is good at physical or conceptual art.
All Americans are American citizens.

[PREMISE (FOL)]:
Architect(monhoff) ∧ Artist(monhoff) ∧ Illustrator(monhoff)
American(monhoff)
∀x (Artist(x) → GoodAt(x, physicalArt) ∨ GoodAt(x, conceptualArt))
∀x (American(x) → AmericanCitizen(x))

[PREMISE (GK)]:
Architect(monhoff) & Artist(monhoff) & Illustrator(monhoff).
American(monhoff).
! [X] : (Artist(X) => GoodAt(X, physicalArt) | GoodAt(X, conceptualArt)).
! [X] : (American(X) => AmericanCitizen(X)).

[CONCLUSION]:
Frederick Monhoff was good at physical art.

[CONCLUSION (FOL)]:
GoodAt(monhoff, physicalArt)

[CONCLUSION (GK)]:
GoodAt(monhoff, physicalArt).


===

['x']
['x']
[PREMISE]:
Frederick Monhoff was an architect, artist, and illustrator.
Frederick Monhoff was an American.
An artist is good at physical or conceptual art.
All Americans are American citizens.

[PREMISE (FOL)]:
Architect(monhoff) ∧ Artist(monhoff) ∧ Illustrator(monhoff)
American(monhoff)
∀x (Artist(x) → GoodAt(x, physicalArt) ∨ GoodAt(x, conceptualArt))
∀x (American(x) → AmericanCitizen(x))

[PREMISE (GK)]:
Architect(monhoff) & Artist(monhoff) & Illustrator(monhoff).
American(monhoff).
! [X] : (Artist(X) => GoodAt(X, physicalArt) | GoodAt(X, conceptualArt)).
! [X] : (American(X) => AmericanCitizen(X)).

[CONCLUSION]:
No illustrator was an American citizen.

[CONCLUSION (FOL)]:
¬(∃x (Illustrator(x) ∧ AmericanCitizen(x)))

[CONCLUSION (GK)]:
-(? [X] : (Illustrator(X) & AmericanCitizen(X))).


===

[]
['x']
[PREMISE]:
Miroslav Fiedler was a Czech mathematician.
Miroslav Fiedler is known for his contributions to linear algebra and graph theory.
Miroslav Fiedler is honored by the Fiedler eigenvalue.
Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.

[PREMISE (FOL)]:
Czech(miroslavFiedler) ∧ Mathematician(miroslavFiedler)
KnownFor(miroslavFiedler, contributionsToLinearAlgebraAndGraphTheory)
HonoredBy(miroslavFiedler, fiedlerEigenvalue)
TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian)

[PREMISE (GK)]:
Czech(miroslavFiedler) & Mathematician(miroslavFiedler).
KnownFor(miroslavFiedler, contributionsToLinearAlgebraAndGraphTheory).
HonoredBy(miroslavFiedler, fiedlerEigenvalue).
TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian).

[CONCLUSION]:
Miroslav Fiedler is honored by the second smallest eigenvalue of the graph Laplacian.

[CONCLUSION (FOL)]:
∃x (TheSecondSmallestEigenvalueOf(x, theGraphLaplacian) ∧ HonoredBy(miroslavFiedler, x))

[CONCLUSION (GK)]:
? [X] : (TheSecondSmallestEigenvalueOf(X, theGraphLaplacian) & HonoredBy(miroslavFiedler, X)).


===

[]
[]
[PREMISE]:
Miroslav Fiedler was a Czech mathematician.
Miroslav Fiedler is known for his contributions to linear algebra and graph theory.
Miroslav Fiedler is honored by the Fiedler eigenvalue.
Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.

[PREMISE (FOL)]:
Czech(miroslavFiedler) ∧ Mathematician(miroslavFiedler)
KnownFor(miroslavFiedler, contributionsToLinearAlgebraAndGraphTheory)
HonoredBy(miroslavFiedler, fiedlerEigenvalue)
TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian)

[PREMISE (GK)]:
Czech(miroslavFiedler) & Mathematician(miroslavFiedler).
KnownFor(miroslavFiedler, contributionsToLinearAlgebraAndGraphTheory).
HonoredBy(miroslavFiedler, fiedlerEigenvalue).
TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian).

[CONCLUSION]:
Miroslav Fiedler was a French mathematician.

[CONCLUSION (FOL)]:
French(miroslavFiedler) ∧ Mathematician(miroslavFiedler)

[CONCLUSION (GK)]:
French(miroslavFiedler) & Mathematician(miroslavFiedler).


===

[]
['x']
[PREMISE]:
Miroslav Fiedler was a Czech mathematician.
Miroslav Fiedler is known for his contributions to linear algebra and graph theory.
Miroslav Fiedler is honored by the Fiedler eigenvalue.
Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.

[PREMISE (FOL)]:
Czech(miroslavFiedler) ∧ Mathematician(miroslavFiedler)
KnownFor(miroslavFiedler, contributionsToLinearAlgebraAndGraphTheory)
HonoredBy(miroslavFiedler, fiedlerEigenvalue)
TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian)

[PREMISE (GK)]:
Czech(miroslavFiedler) & Mathematician(miroslavFiedler).
KnownFor(miroslavFiedler, contributionsToLinearAlgebraAndGraphTheory).
HonoredBy(miroslavFiedler, fiedlerEigenvalue).
TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian).

[CONCLUSION]:
A Czech mathematician is known for his contributions to linear algebra and graph theory.

[CONCLUSION (FOL)]:
∃x (Czech(x) ∧ Mathematician(x) ∧ KnownFor(x, contributionsToLinearAlgebraAndGraphTheory))

[CONCLUSION (GK)]:
? [X] : (Czech(X) & Mathematician(X) & KnownFor(X, contributionsToLinearAlgebraAndGraphTheory)).


===

['x']
['x']
[PREMISE]:
A laptop is a computer.
You can play games on a computer.
A phone is not a computer.

[PREMISE (FOL)]:
∀x (Laptop(x) → Computer(x))
∀x (Computer(x) → CanPlayGameOn(x))
∀x (Phone(x) → ¬Computer(x))

[PREMISE (GK)]:
! [X] : (Laptop(X) => Computer(X)).
! [X] : (Computer(X) => CanPlayGameOn(X)).
! [X] : (Phone(X) => -Computer(X)).

[CONCLUSION]:
You can play games on a laptop.

[CONCLUSION (FOL)]:
∀x (Laptop(x) → CanPlayGameOn(x))

[CONCLUSION (GK)]:
! [X] : (Laptop(X) => CanPlayGameOn(X)).


===

['x']
['x']
[PREMISE]:
A laptop is a computer.
You can play games on a computer.
A phone is not a computer.

[PREMISE (FOL)]:
∀x (Laptop(x) → Computer(x))
∀x (Computer(x) → CanPlayGameOn(x))
∀x (Phone(x) → ¬Computer(x))

[PREMISE (GK)]:
! [X] : (Laptop(X) => Computer(X)).
! [X] : (Computer(X) => CanPlayGameOn(X)).
! [X] : (Phone(X) => -Computer(X)).

[CONCLUSION]:
You can not play games on a phone.

[CONCLUSION (FOL)]:
∀x (Phone(x) → ¬CanPlayGameOn(x))

[CONCLUSION (GK)]:
! [X] : (Phone(X) => -CanPlayGameOn(X)).


===

['t']
['t']
[PREMISE]:
Walter Folger Brown was an American politician and lawyer who served as the postmaster general.
Walter Folger Brown graduated from Harvard University with a Bachelor of Arts.
While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.
Katherin Hafer married Walter Folger Brown.

[PREMISE (FOL)]:
AmericanPolitician(walterBrown) ∧ Lawyer(walterBrown) ∧ ServedAs(walterBrown, postMasterGeneral)
Graduated(walterBrown, harvard) ∧ GraduatedWith(walterBrown, bachelorsOfArt)
∃t(In(walterBrown, toledo, t) ∧ In(walterBrownFather, toledo, t) ∧ PracticedLawTogether(walterBrown, walterBrownFather, t))
Married(katherinHafer, walterBrown)

[PREMISE (GK)]:
AmericanPolitician(walterBrown) & Lawyer(walterBrown) & ServedAs(walterBrown, postMasterGeneral).
Graduated(walterBrown, harvard) & GraduatedWith(walterBrown, bachelorsOfArt).
? [T] :(In(walterBrown, toledo, T) & In(walterBrownFather, toledo, T) & PracticedLawTogether(walterBrown, walterBrownFather, T)).
Married(katherinHafer, walterBrown).

[CONCLUSION]:
Walter Folger Brown graduated with a Bachelor of Arts.

[CONCLUSION (FOL)]:
GraduatedWith(walterBrown, bachelorsOfArt)

[CONCLUSION (GK)]:
GraduatedWith(walterBrown, bachelorsOfArt).


===

['t']
['t']
[PREMISE]:
Walter Folger Brown was an American politician and lawyer who served as the postmaster general.
Walter Folger Brown graduated from Harvard University with a Bachelor of Arts.
While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.
Katherin Hafer married Walter Folger Brown.

[PREMISE (FOL)]:
AmericanPolitician(walterBrown) ∧ Lawyer(walterBrown) ∧ ServedAs(walterBrown, postMasterGeneral)
Graduated(walterBrown, harvard) ∧ GraduatedWith(walterBrown, bachelorsOfArt)
∃t(In(walterBrown, toledo, t) ∧ In(walterBrownFather, toledo, t) ∧ PracticedLawTogether(walterBrown, walterBrownFather, t))
Married(katherinHafer, walterBrown)

[PREMISE (GK)]:
AmericanPolitician(walterBrown) & Lawyer(walterBrown) & ServedAs(walterBrown, postMasterGeneral).
Graduated(walterBrown, harvard) & GraduatedWith(walterBrown, bachelorsOfArt).
? [T] :(In(walterBrown, toledo, T) & In(walterBrownFather, toledo, T) & PracticedLawTogether(walterBrown, walterBrownFather, T)).
Married(katherinHafer, walterBrown).

[CONCLUSION]:
Walter Folger Brown's father was in Toledo.

[CONCLUSION (FOL)]:
∃t(In(walterBrownFather, toledo, t))

[CONCLUSION (GK)]:
? [T] :(In(walterBrownFather, toledo, T)).


===

['t']
['t']
[PREMISE]:
Walter Folger Brown was an American politician and lawyer who served as the postmaster general.
Walter Folger Brown graduated from Harvard University with a Bachelor of Arts.
While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.
Katherin Hafer married Walter Folger Brown.

[PREMISE (FOL)]:
AmericanPolitician(walterBrown) ∧ Lawyer(walterBrown) ∧ ServedAs(walterBrown, postMasterGeneral)
Graduated(walterBrown, harvard) ∧ GraduatedWith(walterBrown, bachelorsOfArt)
∃t(In(walterBrown, toledo, t) ∧ In(walterBrownFather, toledo, t) ∧ PracticedLawTogether(walterBrown, walterBrownFather, t))
Married(katherinHafer, walterBrown)

[PREMISE (GK)]:
AmericanPolitician(walterBrown) & Lawyer(walterBrown) & ServedAs(walterBrown, postMasterGeneral).
Graduated(walterBrown, harvard) & GraduatedWith(walterBrown, bachelorsOfArt).
? [T] :(In(walterBrown, toledo, T) & In(walterBrownFather, toledo, T) & PracticedLawTogether(walterBrown, walterBrownFather, T)).
Married(katherinHafer, walterBrown).

[CONCLUSION]:
Walter Folger Brown was not in Toledo.

[CONCLUSION (FOL)]:
∃t(¬In(walterBrownFather, toledo, t))

[CONCLUSION (GK)]:
? [T] :(-In(walterBrownFather, toledo, T)).


===

['x']
['x']
[PREMISE]:
All products designed by Apple are sold at Apple Stores.
All products with Apple logos are designed by Apple.
All Macbooks have Apple logos.
All products with Apple M2 chips are Mackbooks.
A Thinkpad X1 is not both sold in Apple Stores and is a Macbook.

[PREMISE (FOL)]:
∀x ((Product(x) ∧ DesignedBy(x, apple)) → SoldIn(x, appleStore))
∀x ((Product(x) ∧ With(x, appleLogo)) → DesignedBy(x, apple))
∀x (Macbook(x) → With(x, appleLogo))
∀x ((Product(x) ∧ With(x, appleM2Chip)) → Macbook(x))
¬(SoldIn(thinkpadX1, appleStore) ∧ Macbook(thinkpadX1))

[PREMISE (GK)]:
! [X] : ((Product(X) & DesignedBy(X, apple)) => SoldIn(X, appleStore)).
! [X] : ((Product(X) & With(X, appleLogo)) => DesignedBy(X, apple)).
! [X] : (Macbook(X) => With(X, appleLogo)).
! [X] : ((Product(X) & With(X, appleM2Chip)) => Macbook(X)).
-(SoldIn(thinkpadX1, appleStore) & Macbook(thinkpadX1)).

[CONCLUSION]:
The Thinkpad X1 has an Apple M2 chip.

[CONCLUSION (FOL)]:
With(thinkpadX1, appleM2Chip)

[CONCLUSION (GK)]:
With(thinkpadX1, appleM2Chip).


===

['x']
['x']
[PREMISE]:
All products designed by Apple are sold at Apple Stores.
All products with Apple logos are designed by Apple.
All Macbooks have Apple logos.
All products with Apple M2 chips are Mackbooks.
A Thinkpad X1 is not both sold in Apple Stores and is a Macbook.

[PREMISE (FOL)]:
∀x ((Product(x) ∧ DesignedBy(x, apple)) → SoldIn(x, appleStore))
∀x ((Product(x) ∧ With(x, appleLogo)) → DesignedBy(x, apple))
∀x (Macbook(x) → With(x, appleLogo))
∀x ((Product(x) ∧ With(x, appleM2Chip)) → Macbook(x))
¬(SoldIn(thinkpadX1, appleStore) ∧ Macbook(thinkpadX1))

[PREMISE (GK)]:
! [X] : ((Product(X) & DesignedBy(X, apple)) => SoldIn(X, appleStore)).
! [X] : ((Product(X) & With(X, appleLogo)) => DesignedBy(X, apple)).
! [X] : (Macbook(X) => With(X, appleLogo)).
! [X] : ((Product(X) & With(X, appleM2Chip)) => Macbook(X)).
-(SoldIn(thinkpadX1, appleStore) & Macbook(thinkpadX1)).

[CONCLUSION]:
The Thinkpad X1 is sold in Apple Stores.

[CONCLUSION (FOL)]:
SoldIn(thinkpadX1, appleStore)

[CONCLUSION (GK)]:
SoldIn(thinkpadX1, appleStore).


===

['x']
['x']
[PREMISE]:
All products designed by Apple are sold at Apple Stores.
All products with Apple logos are designed by Apple.
All Macbooks have Apple logos.
All products with Apple M2 chips are Mackbooks.
A Thinkpad X1 is not both sold in Apple Stores and is a Macbook.

[PREMISE (FOL)]:
∀x ((Product(x) ∧ DesignedBy(x, apple)) → SoldIn(x, appleStore))
∀x ((Product(x) ∧ With(x, appleLogo)) → DesignedBy(x, apple))
∀x (Macbook(x) → With(x, appleLogo))
∀x ((Product(x) ∧ With(x, appleM2Chip)) → Macbook(x))
¬(SoldIn(thinkpadX1, appleStore) ∧ Macbook(thinkpadX1))

[PREMISE (GK)]:
! [X] : ((Product(X) & DesignedBy(X, apple)) => SoldIn(X, appleStore)).
! [X] : ((Product(X) & With(X, appleLogo)) => DesignedBy(X, apple)).
! [X] : (Macbook(X) => With(X, appleLogo)).
! [X] : ((Product(X) & With(X, appleM2Chip)) => Macbook(X)).
-(SoldIn(thinkpadX1, appleStore) & Macbook(thinkpadX1)).

[CONCLUSION]:
The Thinkpad X1 has an Apple M2 chip and is a Macbook.

[CONCLUSION (FOL)]:
With(thinkpadX1, appleM2Chip) ∧ Macbook(thinkpadX1)

[CONCLUSION (GK)]:
With(thinkpadX1, appleM2Chip) & Macbook(thinkpadX1).


===

['x']
['x']
[PREMISE]:
All products designed by Apple are sold at Apple Stores.
All products with Apple logos are designed by Apple.
All Macbooks have Apple logos.
All products with Apple M2 chips are Mackbooks.
A Thinkpad X1 is not both sold in Apple Stores and is a Macbook.

[PREMISE (FOL)]:
∀x ((Product(x) ∧ DesignedBy(x, apple)) → SoldIn(x, appleStore))
∀x ((Product(x) ∧ With(x, appleLogo)) → DesignedBy(x, apple))
∀x (Macbook(x) → With(x, appleLogo))
∀x ((Product(x) ∧ With(x, appleM2Chip)) → Macbook(x))
¬(SoldIn(thinkpadX1, appleStore) ∧ Macbook(thinkpadX1))

[PREMISE (GK)]:
! [X] : ((Product(X) & DesignedBy(X, apple)) => SoldIn(X, appleStore)).
! [X] : ((Product(X) & With(X, appleLogo)) => DesignedBy(X, apple)).
! [X] : (Macbook(X) => With(X, appleLogo)).
! [X] : ((Product(X) & With(X, appleM2Chip)) => Macbook(X)).
-(SoldIn(thinkpadX1, appleStore) & Macbook(thinkpadX1)).

[CONCLUSION]:
The Thinkpad X1 either has an Apple M2 chip or is a Macbook.

[CONCLUSION (FOL)]:
With(thinkpadX1, appleM2Chip)) ⊕ Macbook(thinkpadX1)

[CONCLUSION (GK)]:
With(thinkpadX1, appleM2Chip)) <~> Macbook(thinkpadX1).


===

['x']
['x']
[PREMISE]:
All products designed by Apple are sold at Apple Stores.
All products with Apple logos are designed by Apple.
All Macbooks have Apple logos.
All products with Apple M2 chips are Mackbooks.
A Thinkpad X1 is not both sold in Apple Stores and is a Macbook.

[PREMISE (FOL)]:
∀x ((Product(x) ∧ DesignedBy(x, apple)) → SoldIn(x, appleStore))
∀x ((Product(x) ∧ With(x, appleLogo)) → DesignedBy(x, apple))
∀x (Macbook(x) → With(x, appleLogo))
∀x ((Product(x) ∧ With(x, appleM2Chip)) → Macbook(x))
¬(SoldIn(thinkpadX1, appleStore) ∧ Macbook(thinkpadX1))

[PREMISE (GK)]:
! [X] : ((Product(X) & DesignedBy(X, apple)) => SoldIn(X, appleStore)).
! [X] : ((Product(X) & With(X, appleLogo)) => DesignedBy(X, apple)).
! [X] : (Macbook(X) => With(X, appleLogo)).
! [X] : ((Product(X) & With(X, appleM2Chip)) => Macbook(X)).
-(SoldIn(thinkpadX1, appleStore) & Macbook(thinkpadX1)).

[CONCLUSION]:
If the Thinkpad X1 has an Apple M2 chip and is a Macbook, then it neither has an Apple M2 chip nor is sold in Apple Stores.

[CONCLUSION (FOL)]:
(With(thinkpadX1, appleM2Chip) ∧ Macbook(thinkpadX1)) → ¬(With(thinkpadX1, appleM2Chip) ∨ SoldIn(thinkpadX1, appleStore))

[CONCLUSION (GK)]:
(With(thinkpadX1, appleM2Chip) & Macbook(thinkpadX1)) => -(With(thinkpadX1, appleM2Chip) | SoldIn(thinkpadX1, appleStore)).


===

[]
[]
[PREMISE]:
Oxford Circus is a road junction connecting Oxford Street and Regent Street.
Oxford Street and Regent Street are in London.
John Nash designed a construction on Regent Street.
John Nash designed Oxford Circus.
John Nash is a British architect.
Oxford Circus is the entrance to Oxford Circus tube station, a part of the Central line in 1900.

[PREMISE (FOL)]:
RoadJunction(oxfordCircus) ∧ Connect(oxfordCircus, oxfordSt, regentSt)
In(oxfordSt, london) ∧ In(regentSt, london)
Designed(nash, construction) ∧ On(construction, regentSt)
Designed(nash, oxfordCircus)
Architect(nash) ∧ British(nash)
EntraceTo(oxfordCircus, tubeStation) ∧ PartOf(tubeStation, centralline) ∧ In(tubeStation, 1900)

[PREMISE (GK)]:
RoadJunction(oxfordCircus) & Connect(oxfordCircus, oxfordSt, regentSt).
In(oxfordSt, london) & In(regentSt, london).
Designed(nash, construction) & On(construction, regentSt).
Designed(nash, oxfordCircus).
Architect(nash) & British(nash).
EntraceTo(oxfordCircus, tubeStation) & PartOf(tubeStation, centralline) & In(tubeStation, 1900).

[CONCLUSION]:
Oxford Circus is in London.

[CONCLUSION (FOL)]:
In(oxfordCircus, london)

[CONCLUSION (GK)]:
In(oxfordCircus, london).


===

[]
['x']
[PREMISE]:
Oxford Circus is a road junction connecting Oxford Street and Regent Street.
Oxford Street and Regent Street are in London.
John Nash designed a construction on Regent Street.
John Nash designed Oxford Circus.
John Nash is a British architect.
Oxford Circus is the entrance to Oxford Circus tube station, a part of the Central line in 1900.

[PREMISE (FOL)]:
RoadJunction(oxfordCircus) ∧ Connect(oxfordCircus, oxfordSt, regentSt)
In(oxfordSt, london) ∧ In(regentSt, london)
Designed(nash, construction) ∧ On(construction, regentSt)
Designed(nash, oxfordCircus)
Architect(nash) ∧ British(nash)
EntraceTo(oxfordCircus, tubeStation) ∧ PartOf(tubeStation, centralline) ∧ In(tubeStation, 1900)

[PREMISE (GK)]:
RoadJunction(oxfordCircus) & Connect(oxfordCircus, oxfordSt, regentSt).
In(oxfordSt, london) & In(regentSt, london).
Designed(nash, construction) & On(construction, regentSt).
Designed(nash, oxfordCircus).
Architect(nash) & British(nash).
EntraceTo(oxfordCircus, tubeStation) & PartOf(tubeStation, centralline) & In(tubeStation, 1900).

[CONCLUSION]:
Oxford Circus is designed by a British architect.

[CONCLUSION (FOL)]:
∃x (British(x) ∧ Architect(x) ∧ Design(x, oxfordCircus))

[CONCLUSION (GK)]:
? [X] : (British(X) & Architect(X) & Design(X, oxfordCircus)).


===

[]
['x']
[PREMISE]:
Oxford Circus is a road junction connecting Oxford Street and Regent Street.
Oxford Street and Regent Street are in London.
John Nash designed a construction on Regent Street.
John Nash designed Oxford Circus.
John Nash is a British architect.
Oxford Circus is the entrance to Oxford Circus tube station, a part of the Central line in 1900.

[PREMISE (FOL)]:
RoadJunction(oxfordCircus) ∧ Connect(oxfordCircus, oxfordSt, regentSt)
In(oxfordSt, london) ∧ In(regentSt, london)
Designed(nash, construction) ∧ On(construction, regentSt)
Designed(nash, oxfordCircus)
Architect(nash) ∧ British(nash)
EntraceTo(oxfordCircus, tubeStation) ∧ PartOf(tubeStation, centralline) ∧ In(tubeStation, 1900)

[PREMISE (GK)]:
RoadJunction(oxfordCircus) & Connect(oxfordCircus, oxfordSt, regentSt).
In(oxfordSt, london) & In(regentSt, london).
Designed(nash, construction) & On(construction, regentSt).
Designed(nash, oxfordCircus).
Architect(nash) & British(nash).
EntraceTo(oxfordCircus, tubeStation) & PartOf(tubeStation, centralline) & In(tubeStation, 1900).

[CONCLUSION]:
John Nash designed the Central line in 1900.

[CONCLUSION (FOL)]:
∀x (PartOf(x, centralLine) → Design(johnNash, x))

[CONCLUSION (GK)]:
! [X] : (PartOf(X, centralLine) => Design(johnNash, X)).


===

[]
[]
[PREMISE]:
Oxford Circus is a road junction connecting Oxford Street and Regent Street.
Oxford Street and Regent Street are in London.
John Nash designed a construction on Regent Street.
John Nash designed Oxford Circus.
John Nash is a British architect.
Oxford Circus is the entrance to Oxford Circus tube station, a part of the Central line in 1900.

[PREMISE (FOL)]:
RoadJunction(oxfordCircus) ∧ Connect(oxfordCircus, oxfordSt, regentSt)
In(oxfordSt, london) ∧ In(regentSt, london)
Designed(nash, construction) ∧ On(construction, regentSt)
Designed(nash, oxfordCircus)
Architect(nash) ∧ British(nash)
EntraceTo(oxfordCircus, tubeStation) ∧ PartOf(tubeStation, centralline) ∧ In(tubeStation, 1900)

[PREMISE (GK)]:
RoadJunction(oxfordCircus) & Connect(oxfordCircus, oxfordSt, regentSt).
In(oxfordSt, london) & In(regentSt, london).
Designed(nash, construction) & On(construction, regentSt).
Designed(nash, oxfordCircus).
Architect(nash) & British(nash).
EntraceTo(oxfordCircus, tubeStation) & PartOf(tubeStation, centralline) & In(tubeStation, 1900).

[CONCLUSION]:
Regent Street is not in London.

[CONCLUSION (FOL)]:
¬In(regentStreet, london)

[CONCLUSION (GK)]:
-In(regentStreet, london).


===

['x']
['x']
[PREMISE]:
All pets in my house are either cats or dogs.
All the dogs in my house bark.
Ghosts do not exist.
If some pet in my house barks, then it is not dead.
All of the pets in my house are either dead or alive.
Jojo is a pet in my house, and it is not alive.

[PREMISE (FOL)]:
∀x (Pet(x) ∧ In(x, myHouse) → Cat(x) ⊕ Dog(x))
∀x (Dog(x) ∧ In(x, myHouse) → Bark(x))
∀x (¬Ghost(x))
∀x (Bark(x) ∧ Pet(x) ∧ In(x, myHouse) → ¬Dead(x))
∀x (Pet(x) ∧ In(x, myHouse) → Dead(x) ⊕ Alive(x))
Pet(jojo) ∧ InMyHouse(jojo)∧ ¬Alive(jojo)

[PREMISE (GK)]:
! [X] : (Pet(X) & In(X, myHouse) => Cat(X) <~> Dog(X)).
! [X] : (Dog(X) & In(X, myHouse) => Bark(X)).
! [X] : (-Ghost(X)).
! [X] : (Bark(X) & Pet(X) & In(X, myHouse) => -Dead(X)).
! [X] : (Pet(X) & In(X, myHouse) => Dead(X) <~> Alive(X)).
Pet(jojo) & InMyHouse(jojo)& -Alive(jojo).

[CONCLUSION]:
Jojo is a ghost.

[CONCLUSION (FOL)]:
Ghost(jojo)

[CONCLUSION (GK)]:
Ghost(jojo).


===

['x']
['x']
[PREMISE]:
All pets in my house are either cats or dogs.
All the dogs in my house bark.
Ghosts do not exist.
If some pet in my house barks, then it is not dead.
All of the pets in my house are either dead or alive.
Jojo is a pet in my house, and it is not alive.

[PREMISE (FOL)]:
∀x (Pet(x) ∧ In(x, myHouse) → Cat(x) ⊕ Dog(x))
∀x (Dog(x) ∧ In(x, myHouse) → Bark(x))
∀x (¬Ghost(x))
∀x (Bark(x) ∧ Pet(x) ∧ In(x, myHouse) → ¬Dead(x))
∀x (Pet(x) ∧ In(x, myHouse) → Dead(x) ⊕ Alive(x))
Pet(jojo) ∧ InMyHouse(jojo)∧ ¬Alive(jojo)

[PREMISE (GK)]:
! [X] : (Pet(X) & In(X, myHouse) => Cat(X) <~> Dog(X)).
! [X] : (Dog(X) & In(X, myHouse) => Bark(X)).
! [X] : (-Ghost(X)).
! [X] : (Bark(X) & Pet(X) & In(X, myHouse) => -Dead(X)).
! [X] : (Pet(X) & In(X, myHouse) => Dead(X) <~> Alive(X)).
Pet(jojo) & InMyHouse(jojo)& -Alive(jojo).

[CONCLUSION]:
Jojo is a cat or a ghost.

[CONCLUSION (FOL)]:
Cat(jojo) ∨ Ghost(jojo)

[CONCLUSION (GK)]:
Cat(jojo) | Ghost(jojo).


===

['x']
['x']
[PREMISE]:
All pets in my house are either cats or dogs.
All the dogs in my house bark.
Ghosts do not exist.
If some pet in my house barks, then it is not dead.
All of the pets in my house are either dead or alive.
Jojo is a pet in my house, and it is not alive.

[PREMISE (FOL)]:
∀x (Pet(x) ∧ In(x, myHouse) → Cat(x) ⊕ Dog(x))
∀x (Dog(x) ∧ In(x, myHouse) → Bark(x))
∀x (¬Ghost(x))
∀x (Bark(x) ∧ Pet(x) ∧ In(x, myHouse) → ¬Dead(x))
∀x (Pet(x) ∧ In(x, myHouse) → Dead(x) ⊕ Alive(x))
Pet(jojo) ∧ InMyHouse(jojo)∧ ¬Alive(jojo)

[PREMISE (GK)]:
! [X] : (Pet(X) & In(X, myHouse) => Cat(X) <~> Dog(X)).
! [X] : (Dog(X) & In(X, myHouse) => Bark(X)).
! [X] : (-Ghost(X)).
! [X] : (Bark(X) & Pet(X) & In(X, myHouse) => -Dead(X)).
! [X] : (Pet(X) & In(X, myHouse) => Dead(X) <~> Alive(X)).
Pet(jojo) & InMyHouse(jojo)& -Alive(jojo).

[CONCLUSION]:
If Jojo is a cat or a ghost, then Jojo either barks or is a dog.

[CONCLUSION (FOL)]:
Cat(jojo) ∨ Ghost(jojo) → Bark(jojo) ⊕ Dog(jojo)

[CONCLUSION (GK)]:
Cat(jojo) | Ghost(jojo) => Bark(jojo) <~> Dog(jojo).


===

['x']
['x']
[PREMISE]:
All tigers are cats.
No cats are dogs.
All Bengal tigers are tigers.
All huskies are dogs.
Fido is either a Bengal tiger or a cat.

[PREMISE (FOL)]:
∀x (Tiger(x) → Cat(x))
∀x (Cat(x) → ¬Dog(x))
∀x (BengalTiger(x) → Tiger(x))
∀x (Husky(x) → Dog(x))
BengalTiger(fido) ⊕ Cat(fido)

[PREMISE (GK)]:
! [X] : (Tiger(X) => Cat(X)).
! [X] : (Cat(X) => -Dog(X)).
! [X] : (BengalTiger(X) => Tiger(X)).
! [X] : (Husky(X) => Dog(X)).
BengalTiger(fido) <~> Cat(fido).

[CONCLUSION]:
Fido is a husky animal.

[CONCLUSION (FOL)]:
Husky(fido)

[CONCLUSION (GK)]:
Husky(fido).


===

['x']
['x']
[PREMISE]:
All tigers are cats.
No cats are dogs.
All Bengal tigers are tigers.
All huskies are dogs.
Fido is either a Bengal tiger or a cat.

[PREMISE (FOL)]:
∀x (Tiger(x) → Cat(x))
∀x (Cat(x) → ¬Dog(x))
∀x (BengalTiger(x) → Tiger(x))
∀x (Husky(x) → Dog(x))
BengalTiger(fido) ⊕ Cat(fido)

[PREMISE (GK)]:
! [X] : (Tiger(X) => Cat(X)).
! [X] : (Cat(X) => -Dog(X)).
! [X] : (BengalTiger(X) => Tiger(X)).
! [X] : (Husky(X) => Dog(X)).
BengalTiger(fido) <~> Cat(fido).

[CONCLUSION]:
Fido is not a husky.

[CONCLUSION (FOL)]:
¬Husky(fido)

[CONCLUSION (GK)]:
-Husky(fido).


===

['x']
['x']
[PREMISE]:
All tigers are cats.
No cats are dogs.
All Bengal tigers are tigers.
All huskies are dogs.
Fido is either a Bengal tiger or a cat.

[PREMISE (FOL)]:
∀x (Tiger(x) → Cat(x))
∀x (Cat(x) → ¬Dog(x))
∀x (BengalTiger(x) → Tiger(x))
∀x (Husky(x) → Dog(x))
BengalTiger(fido) ⊕ Cat(fido)

[PREMISE (GK)]:
! [X] : (Tiger(X) => Cat(X)).
! [X] : (Cat(X) => -Dog(X)).
! [X] : (BengalTiger(X) => Tiger(X)).
! [X] : (Husky(X) => Dog(X)).
BengalTiger(fido) <~> Cat(fido).

[CONCLUSION]:
Fido is a Bengal tiger.

[CONCLUSION (FOL)]:
BengalTiger(fido)

[CONCLUSION (GK)]:
BengalTiger(fido).


===

['x']
['x']
[PREMISE]:
All tigers are cats.
No cats are dogs.
All Bengal tigers are tigers.
All huskies are dogs.
Fido is either a Bengal tiger or a cat.

[PREMISE (FOL)]:
∀x (Tiger(x) → Cat(x))
∀x (Cat(x) → ¬Dog(x))
∀x (BengalTiger(x) → Tiger(x))
∀x (Husky(x) → Dog(x))
BengalTiger(fido) ⊕ Cat(fido)

[PREMISE (GK)]:
! [X] : (Tiger(X) => Cat(X)).
! [X] : (Cat(X) => -Dog(X)).
! [X] : (BengalTiger(X) => Tiger(X)).
! [X] : (Husky(X) => Dog(X)).
BengalTiger(fido) <~> Cat(fido).

[CONCLUSION]:
Fido is neither a dog nor a husky.

[CONCLUSION (FOL)]:
¬Dog(fido) ∧ ¬Husky(fido)

[CONCLUSION (GK)]:
-Dog(fido) & -Husky(fido).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If a city holds a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.
If a city is in a state in the US, the city is a US city.
If a city is in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.
The 2028 Summer Olympics is scheduled to take place in Los Angeles.
Los Angeles is a city in California.
Atlanta is a US city.
Atlanta is in Georgia.
California is a state in the United States.
Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.
Atlanta in the United States held the 1996 Summer Olympics.

[PREMISE (FOL)]:
∀x ∀y ((SummerOlympicsIn(x,y) ∧ In(x, unitedStates)) → SummerOlympicsIn(x, unitedStates))
∀x ∀y ((In(x, y) ∧ In(y, unitedStates)) → In(x, unitedStates))
∀x ∀y ∀z ((In(x, z) ∧ State(z) ∧ SummerOlympicsIn(x,y)) → SummerOlympicsIn(z, y))
SummerOlympicsIn(losAngeles, yr2028)
In(losAngeles, california)
In(atlanta, unitedStates)
In(california, unitedStates)
In(atlanta, georgia)
¬InSummerOlympicsIn(boxing, yr2028) ∧ (¬InSummerOlympicsIn(modern_pentathlon, yr2028)) ∧ (¬InSummerOlympicsIn(weightlifting, yr2028))
SummerOlympicsIn(atlanta, yr1996)

[PREMISE (GK)]:
! [X] : ! [Y] : ((SummerOlympicsIn(X,Y) & In(X, unitedStates)) => SummerOlympicsIn(X, unitedStates)).
! [X] : ! [Y] : ((In(X, Y) & In(Y, unitedStates)) => In(X, unitedStates)).
! [X] : ! [Y] : ! [Z] : ((In(X, Z) & State(Z) & SummerOlympicsIn(X,Y)) => SummerOlympicsIn(Z, Y)).
SummerOlympicsIn(losAngeles, yr2028).
In(losAngeles, california).
In(atlanta, unitedStates).
In(california, unitedStates).
In(atlanta, georgia).
-InSummerOlympicsIn(boxing, yr2028) & (-InSummerOlympicsIn(modern_pentathlon, yr2028)) & (-InSummerOlympicsIn(weightlifting, yr2028)).
SummerOlympicsIn(atlanta, yr1996).

[CONCLUSION]:
The 2028 Summer Olympics will take place in the US.

[CONCLUSION (FOL)]:
SummerOlympicsIn(unitedStates, yr2028)

[CONCLUSION (GK)]:
SummerOlympicsIn(unitedStates, yr2028).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If a city holds a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.
If a city is in a state in the US, the city is a US city.
If a city is in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.
The 2028 Summer Olympics is scheduled to take place in Los Angeles.
Los Angeles is a city in California.
Atlanta is a US city.
Atlanta is in Georgia.
California is a state in the United States.
Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.
Atlanta in the United States held the 1996 Summer Olympics.

[PREMISE (FOL)]:
∀x ∀y ((SummerOlympicsIn(x,y) ∧ In(x, unitedStates)) → SummerOlympicsIn(x, unitedStates))
∀x ∀y ((In(x, y) ∧ In(y, unitedStates)) → In(x, unitedStates))
∀x ∀y ∀z ((In(x, z) ∧ State(z) ∧ SummerOlympicsIn(x,y)) → SummerOlympicsIn(z, y))
SummerOlympicsIn(losAngeles, yr2028)
In(losAngeles, california)
In(atlanta, unitedStates)
In(california, unitedStates)
In(atlanta, georgia)
¬InSummerOlympicsIn(boxing, yr2028) ∧ (¬InSummerOlympicsIn(modern_pentathlon, yr2028)) ∧ (¬InSummerOlympicsIn(weightlifting, yr2028))
SummerOlympicsIn(atlanta, yr1996)

[PREMISE (GK)]:
! [X] : ! [Y] : ((SummerOlympicsIn(X,Y) & In(X, unitedStates)) => SummerOlympicsIn(X, unitedStates)).
! [X] : ! [Y] : ((In(X, Y) & In(Y, unitedStates)) => In(X, unitedStates)).
! [X] : ! [Y] : ! [Z] : ((In(X, Z) & State(Z) & SummerOlympicsIn(X,Y)) => SummerOlympicsIn(Z, Y)).
SummerOlympicsIn(losAngeles, yr2028).
In(losAngeles, california).
In(atlanta, unitedStates).
In(california, unitedStates).
In(atlanta, georgia).
-InSummerOlympicsIn(boxing, yr2028) & (-InSummerOlympicsIn(modern_pentathlon, yr2028)) & (-InSummerOlympicsIn(weightlifting, yr2028)).
SummerOlympicsIn(atlanta, yr1996).

[CONCLUSION]:
The 1996 Summer Olympics is not in Georgia.

[CONCLUSION (FOL)]:
¬SummerOlympicsIn(georgia, yr1996)

[CONCLUSION (GK)]:
-SummerOlympicsIn(georgia, yr1996).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If a city holds a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.
If a city is in a state in the US, the city is a US city.
If a city is in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.
The 2028 Summer Olympics is scheduled to take place in Los Angeles.
Los Angeles is a city in California.
Atlanta is a US city.
Atlanta is in Georgia.
California is a state in the United States.
Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.
Atlanta in the United States held the 1996 Summer Olympics.

[PREMISE (FOL)]:
∀x ∀y ((SummerOlympicsIn(x,y) ∧ In(x, unitedStates)) → SummerOlympicsIn(x, unitedStates))
∀x ∀y ((In(x, y) ∧ In(y, unitedStates)) → In(x, unitedStates))
∀x ∀y ∀z ((In(x, z) ∧ State(z) ∧ SummerOlympicsIn(x,y)) → SummerOlympicsIn(z, y))
SummerOlympicsIn(losAngeles, yr2028)
In(losAngeles, california)
In(atlanta, unitedStates)
In(california, unitedStates)
In(atlanta, georgia)
¬InSummerOlympicsIn(boxing, yr2028) ∧ (¬InSummerOlympicsIn(modern_pentathlon, yr2028)) ∧ (¬InSummerOlympicsIn(weightlifting, yr2028))
SummerOlympicsIn(atlanta, yr1996)

[PREMISE (GK)]:
! [X] : ! [Y] : ((SummerOlympicsIn(X,Y) & In(X, unitedStates)) => SummerOlympicsIn(X, unitedStates)).
! [X] : ! [Y] : ((In(X, Y) & In(Y, unitedStates)) => In(X, unitedStates)).
! [X] : ! [Y] : ! [Z] : ((In(X, Z) & State(Z) & SummerOlympicsIn(X,Y)) => SummerOlympicsIn(Z, Y)).
SummerOlympicsIn(losAngeles, yr2028).
In(losAngeles, california).
In(atlanta, unitedStates).
In(california, unitedStates).
In(atlanta, georgia).
-InSummerOlympicsIn(boxing, yr2028) & (-InSummerOlympicsIn(modern_pentathlon, yr2028)) & (-InSummerOlympicsIn(weightlifting, yr2028)).
SummerOlympicsIn(atlanta, yr1996).

[CONCLUSION]:
Skateboarding will appear at The 2028 Summer Olympics.

[CONCLUSION (FOL)]:
InSummerOlympicsIn(skateboarding, yr2028)

[CONCLUSION (GK)]:
InSummerOlympicsIn(skateboarding, yr2028).


===

['x']
['x']
[PREMISE]:
The taiga vole is a large vole found in northwestern North America. 
Cats like playing with all voles.
The taiga vole lives in the boreal taiga zone.
The boreal taiga zone in North America is a cold place to live in.

[PREMISE (FOL)]:
Vole(taigaVole) ∧ LiveIn(taigaVole, northAmerica)
LikePlayingWith(cat, taigaVole)
LiveIn(taigaVole, borealTaigaZone)
∀x ((LiveIn(x, northAmerica) ∧ LiveIn(x, borealTaigaZone)) → LiveIn(x, coldPlace))

[PREMISE (GK)]:
Vole(taigaVole) & LiveIn(taigaVole, northAmerica).
LikePlayingWith(cat, taigaVole).
LiveIn(taigaVole, borealTaigaZone).
! [X] : ((LiveIn(X, northAmerica) & LiveIn(X, borealTaigaZone)) => LiveIn(X, coldPlace)).

[CONCLUSION]:
Cats like playing with taiga vole.

[CONCLUSION (FOL)]:
LikePlayingWith(cat, taigaVole)

[CONCLUSION (GK)]:
LikePlayingWith(cat, taigaVole).


===

['x']
['x']
[PREMISE]:
The taiga vole is a large vole found in northwestern North America. 
Cats like playing with all voles.
The taiga vole lives in the boreal taiga zone.
The boreal taiga zone in North America is a cold place to live in.

[PREMISE (FOL)]:
Vole(taigaVole) ∧ LiveIn(taigaVole, northAmerica)
LikePlayingWith(cat, taigaVole)
LiveIn(taigaVole, borealTaigaZone)
∀x ((LiveIn(x, northAmerica) ∧ LiveIn(x, borealTaigaZone)) → LiveIn(x, coldPlace))

[PREMISE (GK)]:
Vole(taigaVole) & LiveIn(taigaVole, northAmerica).
LikePlayingWith(cat, taigaVole).
LiveIn(taigaVole, borealTaigaZone).
! [X] : ((LiveIn(X, northAmerica) & LiveIn(X, borealTaigaZone)) => LiveIn(X, coldPlace)).

[CONCLUSION]:
Taiga vole's living place is not cold.

[CONCLUSION (FOL)]:
¬LiveIn(taigaVole, coldPlace)

[CONCLUSION (GK)]:
-LiveIn(taigaVole, coldPlace).


===

['x']
['x']
[PREMISE]:
A diseases affect females or males.
No women have prostate cancer.
A cancer is either prostate cancer or non-prostate cancer. 
No type of cancer is without mutations.
All non-prostate cancers are a type of cancer.
If adenocarcinoma is a type of cancer or without mutations or both, then adenocarcinoma is in women or without mutations or both.

[PREMISE (FOL)]:
∀x (Disease(x) → (Affects(x, female) ∨ Affects(x, male)) )
∀x (Affect(x, female) → ¬ProstateCancer(x))
∀x (ProstateCancer(x) ∨ NonProstateCancer(x)) 
∀x (Cancer(x) → ¬Without(x, mutation)) 
∀x (NonProstateCancer(x) → Cancer(x)) 
(Cancer(adenocarcinoma) ∨ Without(adenocarcinoma, mutation)) → (Affect(adenocarcinoma, female) ∨ Without(adenocarcinoma, mutation))

[PREMISE (GK)]:
! [X] : (Disease(X) => (Affects(X, female) | Affects(X, male)) ).
! [X] : (Affect(X, female) => -ProstateCancer(X)).
! [X] : (ProstateCancer(X) | NonProstateCancer(X)) .
! [X] : (Cancer(X) => -Without(X, mutation)) .
! [X] : (NonProstateCancer(X) => Cancer(X)) .
(Cancer(adenocarcinoma) | Without(adenocarcinoma, mutation)) => (Affect(adenocarcinoma, female) | Without(adenocarcinoma, mutation)).

[CONCLUSION]:
Adenocarcinoma is a prostate cancer.

[CONCLUSION (FOL)]:
ProstateCancer(adenocarcinoma)

[CONCLUSION (GK)]:
ProstateCancer(adenocarcinoma).


===

['x']
['x']
[PREMISE]:
A diseases affect females or males.
No women have prostate cancer.
A cancer is either prostate cancer or non-prostate cancer. 
No type of cancer is without mutations.
All non-prostate cancers are a type of cancer.
If adenocarcinoma is a type of cancer or without mutations or both, then adenocarcinoma is in women or without mutations or both.

[PREMISE (FOL)]:
∀x (Disease(x) → (Affects(x, female) ∨ Affects(x, male)) )
∀x (Affect(x, female) → ¬ProstateCancer(x))
∀x (ProstateCancer(x) ∨ NonProstateCancer(x)) 
∀x (Cancer(x) → ¬Without(x, mutation)) 
∀x (NonProstateCancer(x) → Cancer(x)) 
(Cancer(adenocarcinoma) ∨ Without(adenocarcinoma, mutation)) → (Affect(adenocarcinoma, female) ∨ Without(adenocarcinoma, mutation))

[PREMISE (GK)]:
! [X] : (Disease(X) => (Affects(X, female) | Affects(X, male)) ).
! [X] : (Affect(X, female) => -ProstateCancer(X)).
! [X] : (ProstateCancer(X) | NonProstateCancer(X)) .
! [X] : (Cancer(X) => -Without(X, mutation)) .
! [X] : (NonProstateCancer(X) => Cancer(X)) .
(Cancer(adenocarcinoma) | Without(adenocarcinoma, mutation)) => (Affect(adenocarcinoma, female) | Without(adenocarcinoma, mutation)).

[CONCLUSION]:
Adenocarcinoma is a disease in women.

[CONCLUSION (FOL)]:
Affect(adenocarcinoma, men)

[CONCLUSION (GK)]:
Affect(adenocarcinoma, men).


===

['x']
['x']
[PREMISE]:
A diseases affect females or males.
No women have prostate cancer.
A cancer is either prostate cancer or non-prostate cancer. 
No type of cancer is without mutations.
All non-prostate cancers are a type of cancer.
If adenocarcinoma is a type of cancer or without mutations or both, then adenocarcinoma is in women or without mutations or both.

[PREMISE (FOL)]:
∀x (Disease(x) → (Affects(x, female) ∨ Affects(x, male)) )
∀x (Affect(x, female) → ¬ProstateCancer(x))
∀x (ProstateCancer(x) ∨ NonProstateCancer(x)) 
∀x (Cancer(x) → ¬Without(x, mutation)) 
∀x (NonProstateCancer(x) → Cancer(x)) 
(Cancer(adenocarcinoma) ∨ Without(adenocarcinoma, mutation)) → (Affect(adenocarcinoma, female) ∨ Without(adenocarcinoma, mutation))

[PREMISE (GK)]:
! [X] : (Disease(X) => (Affects(X, female) | Affects(X, male)) ).
! [X] : (Affect(X, female) => -ProstateCancer(X)).
! [X] : (ProstateCancer(X) | NonProstateCancer(X)) .
! [X] : (Cancer(X) => -Without(X, mutation)) .
! [X] : (NonProstateCancer(X) => Cancer(X)) .
(Cancer(adenocarcinoma) | Without(adenocarcinoma, mutation)) => (Affect(adenocarcinoma, female) | Without(adenocarcinoma, mutation)).

[CONCLUSION]:
If adenocarcinoma is a disease in women or without mutations, then adenocarcinoma is without mutations and a non-prostate cancer.

[CONCLUSION (FOL)]:
(Affect(adenocarcinoma, men) ∨ Without(adenocarcinoma, mutation)) → (NonProstateCancer(adenocarcinoma) ∧ Without(adenocarcinoma, mutation))

[CONCLUSION (GK)]:
(Affect(adenocarcinoma, men) | Without(adenocarcinoma, mutation)) => (NonProstateCancer(adenocarcinoma) & Without(adenocarcinoma, mutation)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some monitors equipped in the lab are produced by the company named AOC. 
All monitors equipped in the lab are cheaper than their original prices. 
If a monitor is cheaper than its original price, then its resolution is 1080p. 
If a monitor has a resolution of 1080p, then it does not support the type-c port. 
LG34 is equipped in the lab.  

[PREMISE (FOL)]:
∃x ∃y  (LabMonitor(x) ∧ AOC(x) ∧ (¬(x=y)) ∧ LabMonitor(y) ∧ AOC(y))
∀x (LabMonitor(x) → Discounted(x))
∀x (Discounted(x) → A1080p(x))
∀x (A1080p(x) → ¬TypeC(x))
LabMonitor(lg-34)

[PREMISE (GK)]:
? [X] : ? [Y] :  (LabMonitor(X) & AOC(X) & (-(X=Y)) & LabMonitor(Y) & AOC(Y)).
! [X] : (LabMonitor(X) => Discounted(X)).
! [X] : (Discounted(X) => A1080p(X)).
! [X] : (A1080p(X) => -TypeC(X)).
LabMonitor(lg-34).

[CONCLUSION]:
LG34 machine is produced by AOC.

[CONCLUSION (FOL)]:
AOC(lg-34)

[CONCLUSION (GK)]:
AOC(lg-34).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some monitors equipped in the lab are produced by the company named AOC. 
All monitors equipped in the lab are cheaper than their original prices. 
If a monitor is cheaper than its original price, then its resolution is 1080p. 
If a monitor has a resolution of 1080p, then it does not support the type-c port. 
LG34 is equipped in the lab.  

[PREMISE (FOL)]:
∃x ∃y  (LabMonitor(x) ∧ AOC(x) ∧ (¬(x=y)) ∧ LabMonitor(y) ∧ AOC(y))
∀x (LabMonitor(x) → Discounted(x))
∀x (Discounted(x) → A1080p(x))
∀x (A1080p(x) → ¬TypeC(x))
LabMonitor(lg-34)

[PREMISE (GK)]:
? [X] : ? [Y] :  (LabMonitor(X) & AOC(X) & (-(X=Y)) & LabMonitor(Y) & AOC(Y)).
! [X] : (LabMonitor(X) => Discounted(X)).
! [X] : (Discounted(X) => A1080p(X)).
! [X] : (A1080p(X) => -TypeC(X)).
LabMonitor(lg-34).

[CONCLUSION]:
LG34 machine does not support the type-c port.

[CONCLUSION (FOL)]:
¬TypeC(lg-34)

[CONCLUSION (GK)]:
-TypeC(lg-34).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some monitors equipped in the lab are produced by the company named AOC. 
All monitors equipped in the lab are cheaper than their original prices. 
If a monitor is cheaper than its original price, then its resolution is 1080p. 
If a monitor has a resolution of 1080p, then it does not support the type-c port. 
LG34 is equipped in the lab.  

[PREMISE (FOL)]:
∃x ∃y  (LabMonitor(x) ∧ AOC(x) ∧ (¬(x=y)) ∧ LabMonitor(y) ∧ AOC(y))
∀x (LabMonitor(x) → Discounted(x))
∀x (Discounted(x) → A1080p(x))
∀x (A1080p(x) → ¬TypeC(x))
LabMonitor(lg-34)

[PREMISE (GK)]:
? [X] : ? [Y] :  (LabMonitor(X) & AOC(X) & (-(X=Y)) & LabMonitor(Y) & AOC(Y)).
! [X] : (LabMonitor(X) => Discounted(X)).
! [X] : (Discounted(X) => A1080p(X)).
! [X] : (A1080p(X) => -TypeC(X)).
LabMonitor(lg-34).

[CONCLUSION]:
LG34 is not with a resolution of 1080p.

[CONCLUSION (FOL)]:
¬A1080p(lg-34)

[CONCLUSION (GK)]:
-A1080p(lg-34).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All fruits sold at Nica's market are shipped from Colombia. 
Some fruits sold in New Haven are shipped from Mexico.
No fruits shipped from Colombia are sold at the local farmers market in New Haven. 
Avocados are a kind of fruit sold at the local farmers market in New Haven or at Nica's market. 
Avocados are either shipped from Colombia and sold in New Haven, or neither.

[PREMISE (FOL)]:
∀x ((Fruit(x) ∧ SoldAt(x, nicasMarket)) → ShippedFrom(x, colombia))
∃x ∃y (Fruit(x) ∧ SoldIn(x, newHaven) ∧ ShippedFrom(x, mexico) ∧ (¬(x=y)) ∧ Fruit(y) ∧ SoldIn(y, newHaven) ∧ ShippedFrom(y, mexico))
∀x ((Fruit(x) ∧ ShippedFrom(x, colombia)) → ¬(SoldAt(x, localFarmersMarket)))
Fruit(avocado) ∧ (SoldAt(avocado, localFarmersMarket) ∨ SoldAt(avocado, nica'sMarket))
¬(ShippedFrom(avocado, colombia) ⊕ SoldIn(avocado, newHaven))

[PREMISE (GK)]:
! [X] : ((Fruit(X) & SoldAt(X, nicasMarket)) => ShippedFrom(X, colombia)).
? [X] : ? [Y] : (Fruit(X) & SoldIn(X, newHaven) & ShippedFrom(X, mexico) & (-(X=Y)) & Fruit(Y) & SoldIn(Y, newHaven) & ShippedFrom(Y, mexico)).
! [X] : ((Fruit(X) & ShippedFrom(X, colombia)) => -(SoldAt(X, localFarmersMarket))).
Fruit(avocado) & (SoldAt(avocado, localFarmersMarket) | SoldAt(avocado, nica'sMarket)).
-(ShippedFrom(avocado, colombia) <~> SoldIn(avocado, newHaven)).

[CONCLUSION]:
Avocados are a kind of fruit sold at the local farmers market in New Haven.

[CONCLUSION (FOL)]:
Fruit(avocado) ∧ SoldAt(avocado, localFarmersMarket)

[CONCLUSION (GK)]:
Fruit(avocado) & SoldAt(avocado, localFarmersMarket).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All fruits sold at Nica's market are shipped from Colombia. 
Some fruits sold in New Haven are shipped from Mexico.
No fruits shipped from Colombia are sold at the local farmers market in New Haven. 
Avocados are a kind of fruit sold at the local farmers market in New Haven or at Nica's market. 
Avocados are either shipped from Colombia and sold in New Haven, or neither.

[PREMISE (FOL)]:
∀x ((Fruit(x) ∧ SoldAt(x, nicasMarket)) → ShippedFrom(x, colombia))
∃x ∃y (Fruit(x) ∧ SoldIn(x, newHaven) ∧ ShippedFrom(x, mexico) ∧ (¬(x=y)) ∧ Fruit(y) ∧ SoldIn(y, newHaven) ∧ ShippedFrom(y, mexico))
∀x ((Fruit(x) ∧ ShippedFrom(x, colombia)) → ¬(SoldAt(x, localFarmersMarket)))
Fruit(avocado) ∧ (SoldAt(avocado, localFarmersMarket) ∨ SoldAt(avocado, nica'sMarket))
¬(ShippedFrom(avocado, colombia) ⊕ SoldIn(avocado, newHaven))

[PREMISE (GK)]:
! [X] : ((Fruit(X) & SoldAt(X, nicasMarket)) => ShippedFrom(X, colombia)).
? [X] : ? [Y] : (Fruit(X) & SoldIn(X, newHaven) & ShippedFrom(X, mexico) & (-(X=Y)) & Fruit(Y) & SoldIn(Y, newHaven) & ShippedFrom(Y, mexico)).
! [X] : ((Fruit(X) & ShippedFrom(X, colombia)) => -(SoldAt(X, localFarmersMarket))).
Fruit(avocado) & (SoldAt(avocado, localFarmersMarket) | SoldAt(avocado, nica'sMarket)).
-(ShippedFrom(avocado, colombia) <~> SoldIn(avocado, newHaven)).

[CONCLUSION]:
Avocados are either sold at the local farmers market in New Haven or are sold in New Haven.

[CONCLUSION (FOL)]:
SoldAt(avocado, localFarmersMarket) ⊕ SoldIn(avocado, newHaven)

[CONCLUSION (GK)]:
SoldAt(avocado, localFarmersMarket) <~> SoldIn(avocado, newHaven).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All fruits sold at Nica's market are shipped from Colombia. 
Some fruits sold in New Haven are shipped from Mexico.
No fruits shipped from Colombia are sold at the local farmers market in New Haven. 
Avocados are a kind of fruit sold at the local farmers market in New Haven or at Nica's market. 
Avocados are either shipped from Colombia and sold in New Haven, or neither.

[PREMISE (FOL)]:
∀x ((Fruit(x) ∧ SoldAt(x, nicasMarket)) → ShippedFrom(x, colombia))
∃x ∃y (Fruit(x) ∧ SoldIn(x, newHaven) ∧ ShippedFrom(x, mexico) ∧ (¬(x=y)) ∧ Fruit(y) ∧ SoldIn(y, newHaven) ∧ ShippedFrom(y, mexico))
∀x ((Fruit(x) ∧ ShippedFrom(x, colombia)) → ¬(SoldAt(x, localFarmersMarket)))
Fruit(avocado) ∧ (SoldAt(avocado, localFarmersMarket) ∨ SoldAt(avocado, nica'sMarket))
¬(ShippedFrom(avocado, colombia) ⊕ SoldIn(avocado, newHaven))

[PREMISE (GK)]:
! [X] : ((Fruit(X) & SoldAt(X, nicasMarket)) => ShippedFrom(X, colombia)).
? [X] : ? [Y] : (Fruit(X) & SoldIn(X, newHaven) & ShippedFrom(X, mexico) & (-(X=Y)) & Fruit(Y) & SoldIn(Y, newHaven) & ShippedFrom(Y, mexico)).
! [X] : ((Fruit(X) & ShippedFrom(X, colombia)) => -(SoldAt(X, localFarmersMarket))).
Fruit(avocado) & (SoldAt(avocado, localFarmersMarket) | SoldAt(avocado, nica'sMarket)).
-(ShippedFrom(avocado, colombia) <~> SoldIn(avocado, newHaven)).

[CONCLUSION]:
Avocados are either sold in New Haven or sold at Nica's market.

[CONCLUSION (FOL)]:
SoldIn(avocado, newHaven) ⊕ SoldAt(x, nica'sMarket)

[CONCLUSION (GK)]:
SoldIn(avocado, newHaven) <~> SoldAt(X, nica'sMarket).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All fruits sold at Nica's market are shipped from Colombia. 
Some fruits sold in New Haven are shipped from Mexico.
No fruits shipped from Colombia are sold at the local farmers market in New Haven. 
Avocados are a kind of fruit sold at the local farmers market in New Haven or at Nica's market. 
Avocados are either shipped from Colombia and sold in New Haven, or neither.

[PREMISE (FOL)]:
∀x ((Fruit(x) ∧ SoldAt(x, nicasMarket)) → ShippedFrom(x, colombia))
∃x ∃y (Fruit(x) ∧ SoldIn(x, newHaven) ∧ ShippedFrom(x, mexico) ∧ (¬(x=y)) ∧ Fruit(y) ∧ SoldIn(y, newHaven) ∧ ShippedFrom(y, mexico))
∀x ((Fruit(x) ∧ ShippedFrom(x, colombia)) → ¬(SoldAt(x, localFarmersMarket)))
Fruit(avocado) ∧ (SoldAt(avocado, localFarmersMarket) ∨ SoldAt(avocado, nica'sMarket))
¬(ShippedFrom(avocado, colombia) ⊕ SoldIn(avocado, newHaven))

[PREMISE (GK)]:
! [X] : ((Fruit(X) & SoldAt(X, nicasMarket)) => ShippedFrom(X, colombia)).
? [X] : ? [Y] : (Fruit(X) & SoldIn(X, newHaven) & ShippedFrom(X, mexico) & (-(X=Y)) & Fruit(Y) & SoldIn(Y, newHaven) & ShippedFrom(Y, mexico)).
! [X] : ((Fruit(X) & ShippedFrom(X, colombia)) => -(SoldAt(X, localFarmersMarket))).
Fruit(avocado) & (SoldAt(avocado, localFarmersMarket) | SoldAt(avocado, nica'sMarket)).
-(ShippedFrom(avocado, colombia) <~> SoldIn(avocado, newHaven)).

[CONCLUSION]:
If avocados are not both sold at the local farmers market in New Haven and shipped from Columbia, then they are neither sold at the local farmers market in New Haven nor in New Haven generally.

[CONCLUSION (FOL)]:
¬(SoldAt(avocado, localFarmersMarket) ∧ ShippedFrom(avocado, colombia)) → ¬SoldAt(avocado, localFarmersMarket) ∧ ¬SoldIn(avocado, newHaven)

[CONCLUSION (GK)]:
-(SoldAt(avocado, localFarmersMarket) & ShippedFrom(avocado, colombia)) => -SoldAt(avocado, localFarmersMarket) & -SoldIn(avocado, newHaven).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some monitors equipped in the library are produced by AOC. 
All monitors equipped in the library are cheaper than 800 dollars. 
All monitors cheaper than 800 dollars are with a resolution lower than 1080p. 
If a monitor has a resolution lower than 1080p, then it does not support the type-c port. 
A-2017 supports the type-c port. 

[PREMISE (FOL)]:
∃x ∃y(Monitor(x) ∧ ProducedBy(x, aOC) ∧ In(x, library) ∧ (¬(x=y)) ∧ Monitor(y) ∧ ProducedBy(y, aOC) ∧ In(y, library))
∀x ((Monitor(x) ∧ In(x, library)) → CheaperThan(x, dollars800))
∀x ((Monitor(x) ∧ CheaperThan(x, dollars800)) → ResolutionLessThan(x, p1080))
∀x ((Monitor(x) ∧ ResolutionLessThan(x, p1080)) → ¬Supports(x, type-CPort))
Supports(a-2017, type-CPort)

[PREMISE (GK)]:
? [X] : ? [Y] :(Monitor(X) & ProducedBy(X, aOC) & In(X, library) & (-(X=Y)) & Monitor(Y) & ProducedBy(Y, aOC) & In(Y, library)).
! [X] : ((Monitor(X) & In(X, library)) => CheaperThan(X, dollars800)).
! [X] : ((Monitor(X) & CheaperThan(X, dollars800)) => ResolutionLessThan(X, p1080)).
! [X] : ((Monitor(X) & ResolutionLessThan(X, p1080)) => -Supports(X, type-CPort)).
Supports(a-2017, type-CPort).

[CONCLUSION]:
A-2017 is produced by AOC.

[CONCLUSION (FOL)]:
ProducedBy(x, aOC)

[CONCLUSION (GK)]:
ProducedBy(X, aOC).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some monitors equipped in the library are produced by AOC. 
All monitors equipped in the library are cheaper than 800 dollars. 
All monitors cheaper than 800 dollars are with a resolution lower than 1080p. 
If a monitor has a resolution lower than 1080p, then it does not support the type-c port. 
A-2017 supports the type-c port. 

[PREMISE (FOL)]:
∃x ∃y(Monitor(x) ∧ ProducedBy(x, aOC) ∧ In(x, library) ∧ (¬(x=y)) ∧ Monitor(y) ∧ ProducedBy(y, aOC) ∧ In(y, library))
∀x ((Monitor(x) ∧ In(x, library)) → CheaperThan(x, dollars800))
∀x ((Monitor(x) ∧ CheaperThan(x, dollars800)) → ResolutionLessThan(x, p1080))
∀x ((Monitor(x) ∧ ResolutionLessThan(x, p1080)) → ¬Supports(x, type-CPort))
Supports(a-2017, type-CPort)

[PREMISE (GK)]:
? [X] : ? [Y] :(Monitor(X) & ProducedBy(X, aOC) & In(X, library) & (-(X=Y)) & Monitor(Y) & ProducedBy(Y, aOC) & In(Y, library)).
! [X] : ((Monitor(X) & In(X, library)) => CheaperThan(X, dollars800)).
! [X] : ((Monitor(X) & CheaperThan(X, dollars800)) => ResolutionLessThan(X, p1080)).
! [X] : ((Monitor(X) & ResolutionLessThan(X, p1080)) => -Supports(X, type-CPort)).
Supports(a-2017, type-CPort).

[CONCLUSION]:
A-2017 is produced by AOC and equipped in the library.

[CONCLUSION (FOL)]:
ProducedBy(a-2017, aOC) ∧ In(a-2017, library)

[CONCLUSION (GK)]:
ProducedBy(a-2017, aOC) & In(a-2017, library).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some monitors equipped in the library are produced by AOC. 
All monitors equipped in the library are cheaper than 800 dollars. 
All monitors cheaper than 800 dollars are with a resolution lower than 1080p. 
If a monitor has a resolution lower than 1080p, then it does not support the type-c port. 
A-2017 supports the type-c port. 

[PREMISE (FOL)]:
∃x ∃y(Monitor(x) ∧ ProducedBy(x, aOC) ∧ In(x, library) ∧ (¬(x=y)) ∧ Monitor(y) ∧ ProducedBy(y, aOC) ∧ In(y, library))
∀x ((Monitor(x) ∧ In(x, library)) → CheaperThan(x, dollars800))
∀x ((Monitor(x) ∧ CheaperThan(x, dollars800)) → ResolutionLessThan(x, p1080))
∀x ((Monitor(x) ∧ ResolutionLessThan(x, p1080)) → ¬Supports(x, type-CPort))
Supports(a-2017, type-CPort)

[PREMISE (GK)]:
? [X] : ? [Y] :(Monitor(X) & ProducedBy(X, aOC) & In(X, library) & (-(X=Y)) & Monitor(Y) & ProducedBy(Y, aOC) & In(Y, library)).
! [X] : ((Monitor(X) & In(X, library)) => CheaperThan(X, dollars800)).
! [X] : ((Monitor(X) & CheaperThan(X, dollars800)) => ResolutionLessThan(X, p1080)).
! [X] : ((Monitor(X) & ResolutionLessThan(X, p1080)) => -Supports(X, type-CPort)).
Supports(a-2017, type-CPort).

[CONCLUSION]:
If either A-2017 is both with a resolution of 1080p and produced by AOC or it is neither, then it is not equipped in the library.

[CONCLUSION (FOL)]:
¬(ResolutionLessThan(a-2017, p1080) ⊕ ProducedBy(x, aOC)) → ¬(In(a-2017, library))

[CONCLUSION (GK)]:
-(ResolutionLessThan(a-2017, p1080) <~> ProducedBy(X, aOC)) => -(In(a-2017, library)).


===

[]
['x']
[PREMISE]:
Sūduva Marijampolė holds the Lithuanian Super Cup.
Sūduva Marijampolė is a soccer team.

[PREMISE (FOL)]:
Holds(suduva, theLithuanianSuperCup)
SoccerTeam(suduva)

[PREMISE (GK)]:
Holds(suduva, theLithuanianSuperCup).
SoccerTeam(suduva).

[CONCLUSION]:
Some soccer team holds the Lithuanian Super Cup.

[CONCLUSION (FOL)]:
∃x (SoccerTeam(x) ∧ Holds(x, theLithuanianSuperCup))

[CONCLUSION (GK)]:
? [X] : (SoccerTeam(X) & Holds(X, theLithuanianSuperCup)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Ainderby Quernhow is a village and civil parish in the Hambleton District.
Hambleton District is in North Yorkshire.
North Yorkshire is in England.
If place A is located in place B and place B is located in place C, then place A is located in place C.

[PREMISE (FOL)]:
Village(ainderbyQuernhow) ∧ CivilParish(ainderbyQuernhow) ∧ In(ainderbyQuernhow, hambletonDistrict)
In(hambletonDistrict, northYorkshire)
In(northYorkshire, england)
∀x ∀y ∀z ((In(x, y) ∧ In(y, z)) → In(x, z))

[PREMISE (GK)]:
Village(ainderbyQuernhow) & CivilParish(ainderbyQuernhow) & In(ainderbyQuernhow, hambletonDistrict).
In(hambletonDistrict, northYorkshire).
In(northYorkshire, england).
! [X] : ! [Y] : ! [Z] : ((In(X, Y) & In(Y, Z)) => In(X, Z)).

[CONCLUSION]:
There is a village in England.

[CONCLUSION (FOL)]:
∃x (Village(x) ∧ In(x, england))

[CONCLUSION (GK)]:
? [X] : (Village(X) & In(X, england)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Ainderby Quernhow is a village and civil parish in the Hambleton District.
Hambleton District is in North Yorkshire.
North Yorkshire is in England.
If place A is located in place B and place B is located in place C, then place A is located in place C.

[PREMISE (FOL)]:
Village(ainderbyQuernhow) ∧ CivilParish(ainderbyQuernhow) ∧ In(ainderbyQuernhow, hambletonDistrict)
In(hambletonDistrict, northYorkshire)
In(northYorkshire, england)
∀x ∀y ∀z ((In(x, y) ∧ In(y, z)) → In(x, z))

[PREMISE (GK)]:
Village(ainderbyQuernhow) & CivilParish(ainderbyQuernhow) & In(ainderbyQuernhow, hambletonDistrict).
In(hambletonDistrict, northYorkshire).
In(northYorkshire, england).
! [X] : ! [Y] : ! [Z] : ((In(X, Y) & In(Y, Z)) => In(X, Z)).

[CONCLUSION]:
There is no civil parish in England.

[CONCLUSION (FOL)]:
¬(∃x (CivilParish(x) ∧ In(x, england)))

[CONCLUSION (GK)]:
-(? [X] : (CivilParish(X) & In(X, england))).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Douglas Adams is an author who created the book collection called The Salmon of Doubt. 
The Salmon of Doubt is about life experiences and technology.
All authors are writers.
Writers create innovative ideas.
Some books that contain innovative ideas are about technology.

[PREMISE (FOL)]:
Author(douglasAdams) ∧ Authored(douglasAdams, theSalmonOfDoubt) ∧ Book(theSalmonOfDoubt)
About(theSalmonOfDoubt, lifeExperience) ∧ About(theSalmonOfDoubt, technology)
∀x (Author(x) → Writer(x))
∀x (Writer(x) → Create(x, innovativeIdea))
∃x ∃y (Contain(x, innovativeIdea) ∧ About(x, technology) ∧ (¬(x=y)) ∧ (Contain(y, innovativeIdea) ∧ About(y, technology)))

[PREMISE (GK)]:
Author(douglasAdams) & Authored(douglasAdams, theSalmonOfDoubt) & Book(theSalmonOfDoubt).
About(theSalmonOfDoubt, lifeExperience) & About(theSalmonOfDoubt, technology).
! [X] : (Author(X) => Writer(X)).
! [X] : (Writer(X) => Create(X, innovativeIdea)).
? [X] : ? [Y] : (Contain(X, innovativeIdea) & About(X, technology) & (-(X=Y)) & (Contain(Y, innovativeIdea) & About(Y, technology))).

[CONCLUSION]:
Douglas Adams is a writer.

[CONCLUSION (FOL)]:
Writer(douglasAdams)

[CONCLUSION (GK)]:
Writer(douglasAdams).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Douglas Adams is an author who created the book collection called The Salmon of Doubt. 
The Salmon of Doubt is about life experiences and technology.
All authors are writers.
Writers create innovative ideas.
Some books that contain innovative ideas are about technology.

[PREMISE (FOL)]:
Author(douglasAdams) ∧ Authored(douglasAdams, theSalmonOfDoubt) ∧ Book(theSalmonOfDoubt)
About(theSalmonOfDoubt, lifeExperience) ∧ About(theSalmonOfDoubt, technology)
∀x (Author(x) → Writer(x))
∀x (Writer(x) → Create(x, innovativeIdea))
∃x ∃y (Contain(x, innovativeIdea) ∧ About(x, technology) ∧ (¬(x=y)) ∧ (Contain(y, innovativeIdea) ∧ About(y, technology)))

[PREMISE (GK)]:
Author(douglasAdams) & Authored(douglasAdams, theSalmonOfDoubt) & Book(theSalmonOfDoubt).
About(theSalmonOfDoubt, lifeExperience) & About(theSalmonOfDoubt, technology).
! [X] : (Author(X) => Writer(X)).
! [X] : (Writer(X) => Create(X, innovativeIdea)).
? [X] : ? [Y] : (Contain(X, innovativeIdea) & About(X, technology) & (-(X=Y)) & (Contain(Y, innovativeIdea) & About(Y, technology))).

[CONCLUSION]:
Douglas Adams created innovative ideas.

[CONCLUSION (FOL)]:
Create(douglasAdams, innovativeIdea)

[CONCLUSION (GK)]:
Create(douglasAdams, innovativeIdea).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Douglas Adams is an author who created the book collection called The Salmon of Doubt. 
The Salmon of Doubt is about life experiences and technology.
All authors are writers.
Writers create innovative ideas.
Some books that contain innovative ideas are about technology.

[PREMISE (FOL)]:
Author(douglasAdams) ∧ Authored(douglasAdams, theSalmonOfDoubt) ∧ Book(theSalmonOfDoubt)
About(theSalmonOfDoubt, lifeExperience) ∧ About(theSalmonOfDoubt, technology)
∀x (Author(x) → Writer(x))
∀x (Writer(x) → Create(x, innovativeIdea))
∃x ∃y (Contain(x, innovativeIdea) ∧ About(x, technology) ∧ (¬(x=y)) ∧ (Contain(y, innovativeIdea) ∧ About(y, technology)))

[PREMISE (GK)]:
Author(douglasAdams) & Authored(douglasAdams, theSalmonOfDoubt) & Book(theSalmonOfDoubt).
About(theSalmonOfDoubt, lifeExperience) & About(theSalmonOfDoubt, technology).
! [X] : (Author(X) => Writer(X)).
! [X] : (Writer(X) => Create(X, innovativeIdea)).
? [X] : ? [Y] : (Contain(X, innovativeIdea) & About(X, technology) & (-(X=Y)) & (Contain(Y, innovativeIdea) & About(Y, technology))).

[CONCLUSION]:
The Salmon of Doubt has no innovative Ideas.

[CONCLUSION (FOL)]:
¬Contain(theSalmonOfDoubt, innovativeIdea)

[CONCLUSION (GK)]:
-Contain(theSalmonOfDoubt, innovativeIdea).


===

['x']
['x']
[PREMISE]:
No disposable products can help slow down global warming. 
All eco-friendly brands can help slow down global warming. 
All sustainable fashion brands are eco-friendly brands.
All fast fashion products are disposable products.
If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.

[PREMISE (FOL)]:
∀x (Disposable(x) ∧ Product(x) → ¬HelpSlowDown(x, globalWarming))
∀x (EcoFriendly(x) ∧ Brand(x) → Help(x, slowDownGlobalWarming))
∀x (Sustainable(x) ∧ FashionBrand(x) → EcoFriendly(x) ∧ Brand(x))
∀x (FastFashion(x) ∧ Product(x) → Disposable(x) ∧ Product(x)) 
¬HelpSlowDown(reformation, globalWarming) → (EcoFriendly(reformation) ∧ Brand(reformation)) ∨ (Sustainable(reformation) ∧ FashionBrand(reformation))

[PREMISE (GK)]:
! [X] : (Disposable(X) & Product(X) => -HelpSlowDown(X, globalWarming)).
! [X] : (EcoFriendly(X) & Brand(X) => Help(X, slowDownGlobalWarming)).
! [X] : (Sustainable(X) & FashionBrand(X) => EcoFriendly(X) & Brand(X)).
! [X] : (FastFashion(X) & Product(X) => Disposable(X) & Product(X)) .
-HelpSlowDown(reformation, globalWarming) => (EcoFriendly(reformation) & Brand(reformation)) | (Sustainable(reformation) & FashionBrand(reformation)).

[CONCLUSION]:
Reformation is an eco-friendly brand.

[CONCLUSION (FOL)]:
EcoFriendly(reformation) ∧ Brand(reformation)

[CONCLUSION (GK)]:
EcoFriendly(reformation) & Brand(reformation).


===

['x']
['x']
[PREMISE]:
No disposable products can help slow down global warming. 
All eco-friendly brands can help slow down global warming. 
All sustainable fashion brands are eco-friendly brands.
All fast fashion products are disposable products.
If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.

[PREMISE (FOL)]:
∀x (Disposable(x) ∧ Product(x) → ¬HelpSlowDown(x, globalWarming))
∀x (EcoFriendly(x) ∧ Brand(x) → Help(x, slowDownGlobalWarming))
∀x (Sustainable(x) ∧ FashionBrand(x) → EcoFriendly(x) ∧ Brand(x))
∀x (FastFashion(x) ∧ Product(x) → Disposable(x) ∧ Product(x)) 
¬HelpSlowDown(reformation, globalWarming) → (EcoFriendly(reformation) ∧ Brand(reformation)) ∨ (Sustainable(reformation) ∧ FashionBrand(reformation))

[PREMISE (GK)]:
! [X] : (Disposable(X) & Product(X) => -HelpSlowDown(X, globalWarming)).
! [X] : (EcoFriendly(X) & Brand(X) => Help(X, slowDownGlobalWarming)).
! [X] : (Sustainable(X) & FashionBrand(X) => EcoFriendly(X) & Brand(X)).
! [X] : (FastFashion(X) & Product(X) => Disposable(X) & Product(X)) .
-HelpSlowDown(reformation, globalWarming) => (EcoFriendly(reformation) & Brand(reformation)) | (Sustainable(reformation) & FashionBrand(reformation)).

[CONCLUSION]:
Reformation produces fast fashion products.

[CONCLUSION (FOL)]:
FastFashion(reformation) ∧ Product(reformation)

[CONCLUSION (GK)]:
FastFashion(reformation) & Product(reformation).


===

['x']
['x']
[PREMISE]:
No disposable products can help slow down global warming. 
All eco-friendly brands can help slow down global warming. 
All sustainable fashion brands are eco-friendly brands.
All fast fashion products are disposable products.
If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.

[PREMISE (FOL)]:
∀x (Disposable(x) ∧ Product(x) → ¬HelpSlowDown(x, globalWarming))
∀x (EcoFriendly(x) ∧ Brand(x) → Help(x, slowDownGlobalWarming))
∀x (Sustainable(x) ∧ FashionBrand(x) → EcoFriendly(x) ∧ Brand(x))
∀x (FastFashion(x) ∧ Product(x) → Disposable(x) ∧ Product(x)) 
¬HelpSlowDown(reformation, globalWarming) → (EcoFriendly(reformation) ∧ Brand(reformation)) ∨ (Sustainable(reformation) ∧ FashionBrand(reformation))

[PREMISE (GK)]:
! [X] : (Disposable(X) & Product(X) => -HelpSlowDown(X, globalWarming)).
! [X] : (EcoFriendly(X) & Brand(X) => Help(X, slowDownGlobalWarming)).
! [X] : (Sustainable(X) & FashionBrand(X) => EcoFriendly(X) & Brand(X)).
! [X] : (FastFashion(X) & Product(X) => Disposable(X) & Product(X)) .
-HelpSlowDown(reformation, globalWarming) => (EcoFriendly(reformation) & Brand(reformation)) | (Sustainable(reformation) & FashionBrand(reformation)).

[CONCLUSION]:
Reformation does not produce fast fashion products.

[CONCLUSION (FOL)]:
¬(FastFashion(reformation) ∧ Product(reformation))

[CONCLUSION (GK)]:
-(FastFashion(reformation) & Product(reformation)).


===

['x']
['x']
[PREMISE]:
No disposable products can help slow down global warming. 
All eco-friendly brands can help slow down global warming. 
All sustainable fashion brands are eco-friendly brands.
All fast fashion products are disposable products.
If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.

[PREMISE (FOL)]:
∀x (Disposable(x) ∧ Product(x) → ¬HelpSlowDown(x, globalWarming))
∀x (EcoFriendly(x) ∧ Brand(x) → Help(x, slowDownGlobalWarming))
∀x (Sustainable(x) ∧ FashionBrand(x) → EcoFriendly(x) ∧ Brand(x))
∀x (FastFashion(x) ∧ Product(x) → Disposable(x) ∧ Product(x)) 
¬HelpSlowDown(reformation, globalWarming) → (EcoFriendly(reformation) ∧ Brand(reformation)) ∨ (Sustainable(reformation) ∧ FashionBrand(reformation))

[PREMISE (GK)]:
! [X] : (Disposable(X) & Product(X) => -HelpSlowDown(X, globalWarming)).
! [X] : (EcoFriendly(X) & Brand(X) => Help(X, slowDownGlobalWarming)).
! [X] : (Sustainable(X) & FashionBrand(X) => EcoFriendly(X) & Brand(X)).
! [X] : (FastFashion(X) & Product(X) => Disposable(X) & Product(X)) .
-HelpSlowDown(reformation, globalWarming) => (EcoFriendly(reformation) & Brand(reformation)) | (Sustainable(reformation) & FashionBrand(reformation)).

[CONCLUSION]:
Reformation does not produce fast fashion products or does not produce disposable products.

[CONCLUSION (FOL)]:
¬(FastFashion(reformation) ∧ Product(reformation)) ∨ ¬(Disposable(x) ∧ Product(x))

[CONCLUSION (GK)]:
-(FastFashion(reformation) & Product(reformation)) | -(Disposable(X) & Product(X)).


===

['x']
['x']
[PREMISE]:
No disposable products can help slow down global warming. 
All eco-friendly brands can help slow down global warming. 
All sustainable fashion brands are eco-friendly brands.
All fast fashion products are disposable products.
If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.

[PREMISE (FOL)]:
∀x (Disposable(x) ∧ Product(x) → ¬HelpSlowDown(x, globalWarming))
∀x (EcoFriendly(x) ∧ Brand(x) → Help(x, slowDownGlobalWarming))
∀x (Sustainable(x) ∧ FashionBrand(x) → EcoFriendly(x) ∧ Brand(x))
∀x (FastFashion(x) ∧ Product(x) → Disposable(x) ∧ Product(x)) 
¬HelpSlowDown(reformation, globalWarming) → (EcoFriendly(reformation) ∧ Brand(reformation)) ∨ (Sustainable(reformation) ∧ FashionBrand(reformation))

[PREMISE (GK)]:
! [X] : (Disposable(X) & Product(X) => -HelpSlowDown(X, globalWarming)).
! [X] : (EcoFriendly(X) & Brand(X) => Help(X, slowDownGlobalWarming)).
! [X] : (Sustainable(X) & FashionBrand(X) => EcoFriendly(X) & Brand(X)).
! [X] : (FastFashion(X) & Product(X) => Disposable(X) & Product(X)) .
-HelpSlowDown(reformation, globalWarming) => (EcoFriendly(reformation) & Brand(reformation)) | (Sustainable(reformation) & FashionBrand(reformation)).

[CONCLUSION]:
If Reformation produces disposable products, then Reformation produces fast fashion products.

[CONCLUSION (FOL)]:
(Disposable(reformation) ∧ Product(reformation)) → (FastFashion(reformation) ∧ Product(reformation))

[CONCLUSION (GK)]:
(Disposable(reformation) & Product(reformation)) => (FastFashion(reformation) & Product(reformation)).


===

['x']
['x']
[PREMISE]:
No disposable products can help slow down global warming. 
All eco-friendly brands can help slow down global warming. 
All sustainable fashion brands are eco-friendly brands.
All fast fashion products are disposable products.
If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.

[PREMISE (FOL)]:
∀x (Disposable(x) ∧ Product(x) → ¬HelpSlowDown(x, globalWarming))
∀x (EcoFriendly(x) ∧ Brand(x) → Help(x, slowDownGlobalWarming))
∀x (Sustainable(x) ∧ FashionBrand(x) → EcoFriendly(x) ∧ Brand(x))
∀x (FastFashion(x) ∧ Product(x) → Disposable(x) ∧ Product(x)) 
¬HelpSlowDown(reformation, globalWarming) → (EcoFriendly(reformation) ∧ Brand(reformation)) ∨ (Sustainable(reformation) ∧ FashionBrand(reformation))

[PREMISE (GK)]:
! [X] : (Disposable(X) & Product(X) => -HelpSlowDown(X, globalWarming)).
! [X] : (EcoFriendly(X) & Brand(X) => Help(X, slowDownGlobalWarming)).
! [X] : (Sustainable(X) & FashionBrand(X) => EcoFriendly(X) & Brand(X)).
! [X] : (FastFashion(X) & Product(X) => Disposable(X) & Product(X)) .
-HelpSlowDown(reformation, globalWarming) => (EcoFriendly(reformation) & Brand(reformation)) | (Sustainable(reformation) & FashionBrand(reformation)).

[CONCLUSION]:
If Reformation produces fast fashion products or helps slow down global warming, then Reformation produces fast fashion products.

[CONCLUSION (FOL)]:
(FastFashion(reformation) ∧ Product(reformation)) ∨ ¬HelpSlowDown(reformation, globalWarming)

[CONCLUSION (GK)]:
(FastFashion(reformation) & Product(reformation)) | -HelpSlowDown(reformation, globalWarming).


===

[]
['x', 'y']
[PREMISE]:
Roy Richardson was a cricketer who played for Sint Maarten, a constituent country.
Roy Richardson was a right-handed batsman and medium-pace bowler.
Roy Richardson was old when he debuted in cricket.
Sherville Huggins dismissed Roy Richardson.

[PREMISE (FOL)]:
Cricketeer(royRichardson) ∧ PlaysFor(royRichardson, sintMaarten) ∧ ConstituentCountry(sintMaarten)
RightHanded(royRichardson) ∧ Batsman(royRichardson) ∧ MediumPaceBowler(royRichardson)
OldAtDebut(royRichardson)
Dismisses(shervilleHuggins, royRichardson)

[PREMISE (GK)]:
Cricketeer(royRichardson) & PlaysFor(royRichardson, sintMaarten) & ConstituentCountry(sintMaarten).
RightHanded(royRichardson) & Batsman(royRichardson) & MediumPaceBowler(royRichardson).
OldAtDebut(royRichardson).
Dismisses(shervilleHuggins, royRichardson).

[CONCLUSION]:
Sherville Huggins has never dismissed anyone playing cricket for a constituent country.

[CONCLUSION (FOL)]:
∀x ∀y ((ConsituentCountry(y) ∧ PlayedFor(x, y)) →  ¬Dismissed(shervillehuggins, x))

[CONCLUSION (GK)]:
! [X] : ! [Y] : ((ConsituentCountry(Y) & PlayedFor(X, Y)) =>  -Dismissed(shervillehuggins, X)).


===

[]
['x']
[PREMISE]:
Roy Richardson was a cricketer who played for Sint Maarten, a constituent country.
Roy Richardson was a right-handed batsman and medium-pace bowler.
Roy Richardson was old when he debuted in cricket.
Sherville Huggins dismissed Roy Richardson.

[PREMISE (FOL)]:
Cricketeer(royRichardson) ∧ PlaysFor(royRichardson, sintMaarten) ∧ ConstituentCountry(sintMaarten)
RightHanded(royRichardson) ∧ Batsman(royRichardson) ∧ MediumPaceBowler(royRichardson)
OldAtDebut(royRichardson)
Dismisses(shervilleHuggins, royRichardson)

[PREMISE (GK)]:
Cricketeer(royRichardson) & PlaysFor(royRichardson, sintMaarten) & ConstituentCountry(sintMaarten).
RightHanded(royRichardson) & Batsman(royRichardson) & MediumPaceBowler(royRichardson).
OldAtDebut(royRichardson).
Dismisses(shervilleHuggins, royRichardson).

[CONCLUSION]:
No right-handed medium-pace bowlers were playing for Sint Maarten.

[CONCLUSION (FOL)]:
∀x ((RightHanded(x) ∧ MediumPaceBowler(x)) → ¬PlayedFor(x, sintMaarten))

[CONCLUSION (GK)]:
! [X] : ((RightHanded(X) & MediumPaceBowler(X)) => -PlayedFor(X, sintMaarten)).


===

['x']
['x']
[PREMISE]:
To get a job at Google, you need to have a lot of work experience or a good education.
One needs to submit their resume to Google to get a job there.
John has a lot of work experience.
John submitted his resume to Google and got a job there.

[PREMISE (FOL)]:
∀x (GetAJobAt(x, google) → Have(x, aLotOfWorkExperience) ∨ Have(x, goodEducation))
∀x (GetAJobAt(x, google) → Submitted(x, resume, google))
Have(john, aLotOfWorkExperience)
Submitted(john, resume, google) ∧ GetAJobAt(john, google)

[PREMISE (GK)]:
! [X] : (GetAJobAt(X, google) => Have(X, aLotOfWorkExperience) | Have(X, goodEducation)).
! [X] : (GetAJobAt(X, google) => Submitted(X, resume, google)).
Have(john, aLotOfWorkExperience).
Submitted(john, resume, google) & GetAJobAt(john, google).

[CONCLUSION]:
John is a Yale graduate.

[CONCLUSION (FOL)]:
YaleGraduate(john)

[CONCLUSION (GK)]:
YaleGraduate(john).


===

['x']
['x']
[PREMISE]:
No iPhones are standalone desktops. 
All Apple-made cellphones are iPhones.  
All phones with A15 Bionic chips are Apple-made cell phones. 
All phones equipped with four core-GPU made by Apple are phones with A15 Bionic chips. 
If an unannounced Huawei phone is either a phone with A15 Bionic chips or equipped with four core-GPU made by Apple, then unannounced Huawei phone is neither a phone with A15 Bionic chips nor a standalone desktop.

[PREMISE (FOL)]:
∀x (IPhone(x) → ¬StandaloneDesktop(x))
∀x (AppleMade(x) ∧ Cellphone(x) → IPhone(x))
∀x (Phone(x) ∧ With(x, a15BionicChip) → AppleMade(x) ∧ Cellphone(x))
∀x (Phone(x) ∧ EquippedWith(x, fourCoreGPU) ∧ MadeBy(x, apple) → Phone(x) ∧ With(x, a15BionicChip))
(Phone(unannouncedHuaweiPhone) ∧ With(unannouncedHuaweiPhone, a15BionicChip)) ⊕ (Phone(unannouncedHuaweiPhone) ∧ EquippedWith(unannouncedHuaweiPhone, fourCoreGPU) ∧ MadeBy(unannouncedHuaweiPhone, apple)) → ¬(Phone(unannouncedHuaweiPhone) ∧ With(unannouncedHuaweiPhone, a15BionicChip) ∧ StandaloneDesktop(unannouncedHuaweiPhone))

[PREMISE (GK)]:
! [X] : (IPhone(X) => -StandaloneDesktop(X)).
! [X] : (AppleMade(X) & Cellphone(X) => IPhone(X)).
! [X] : (Phone(X) & With(X, a15BionicChip) => AppleMade(X) & Cellphone(X)).
! [X] : (Phone(X) & EquippedWith(X, fourCoreGPU) & MadeBy(X, apple) => Phone(X) & With(X, a15BionicChip)).
(Phone(unannouncedHuaweiPhone) & With(unannouncedHuaweiPhone, a15BionicChip)) <~> (Phone(unannouncedHuaweiPhone) & EquippedWith(unannouncedHuaweiPhone, fourCoreGPU) & MadeBy(unannouncedHuaweiPhone, apple)) => -(Phone(unannouncedHuaweiPhone) & With(unannouncedHuaweiPhone, a15BionicChip) & StandaloneDesktop(unannouncedHuaweiPhone)).

[CONCLUSION]:
Joe is a person taking classes.

[CONCLUSION (FOL)]:
AppleMade(unannouncedHuaweiPhone) ∧ Cellphone(unannouncedHuaweiPhone)

[CONCLUSION (GK)]:
AppleMade(unannouncedHuaweiPhone) & Cellphone(unannouncedHuaweiPhone).


===

['x']
['x']
[PREMISE]:
No iPhones are standalone desktops. 
All Apple-made cellphones are iPhones.  
All phones with A15 Bionic chips are Apple-made cell phones. 
All phones equipped with four core-GPU made by Apple are phones with A15 Bionic chips. 
If an unannounced Huawei phone is either a phone with A15 Bionic chips or equipped with four core-GPU made by Apple, then unannounced Huawei phone is neither a phone with A15 Bionic chips nor a standalone desktop.

[PREMISE (FOL)]:
∀x (IPhone(x) → ¬StandaloneDesktop(x))
∀x (AppleMade(x) ∧ Cellphone(x) → IPhone(x))
∀x (Phone(x) ∧ With(x, a15BionicChip) → AppleMade(x) ∧ Cellphone(x))
∀x (Phone(x) ∧ EquippedWith(x, fourCoreGPU) ∧ MadeBy(x, apple) → Phone(x) ∧ With(x, a15BionicChip))
(Phone(unannouncedHuaweiPhone) ∧ With(unannouncedHuaweiPhone, a15BionicChip)) ⊕ (Phone(unannouncedHuaweiPhone) ∧ EquippedWith(unannouncedHuaweiPhone, fourCoreGPU) ∧ MadeBy(unannouncedHuaweiPhone, apple)) → ¬(Phone(unannouncedHuaweiPhone) ∧ With(unannouncedHuaweiPhone, a15BionicChip) ∧ StandaloneDesktop(unannouncedHuaweiPhone))

[PREMISE (GK)]:
! [X] : (IPhone(X) => -StandaloneDesktop(X)).
! [X] : (AppleMade(X) & Cellphone(X) => IPhone(X)).
! [X] : (Phone(X) & With(X, a15BionicChip) => AppleMade(X) & Cellphone(X)).
! [X] : (Phone(X) & EquippedWith(X, fourCoreGPU) & MadeBy(X, apple) => Phone(X) & With(X, a15BionicChip)).
(Phone(unannouncedHuaweiPhone) & With(unannouncedHuaweiPhone, a15BionicChip)) <~> (Phone(unannouncedHuaweiPhone) & EquippedWith(unannouncedHuaweiPhone, fourCoreGPU) & MadeBy(unannouncedHuaweiPhone, apple)) => -(Phone(unannouncedHuaweiPhone) & With(unannouncedHuaweiPhone, a15BionicChip) & StandaloneDesktop(unannouncedHuaweiPhone)).

[CONCLUSION]:
Joe is a PhD student.

[CONCLUSION (FOL)]:
Phone(unannouncedHuaweiPhone) ∧ EquippedWith(unannouncedHuaweiPhone, fourCoreGPU) ∧ MadeByApple(unannouncedHuaweiPhone)

[CONCLUSION (GK)]:
Phone(unannouncedHuaweiPhone) & EquippedWith(unannouncedHuaweiPhone, fourCoreGPU) & MadeByApple(unannouncedHuaweiPhone).


===

['x']
['x']
[PREMISE]:
No iPhones are standalone desktops. 
All Apple-made cellphones are iPhones.  
All phones with A15 Bionic chips are Apple-made cell phones. 
All phones equipped with four core-GPU made by Apple are phones with A15 Bionic chips. 
If an unannounced Huawei phone is either a phone with A15 Bionic chips or equipped with four core-GPU made by Apple, then unannounced Huawei phone is neither a phone with A15 Bionic chips nor a standalone desktop.

[PREMISE (FOL)]:
∀x (IPhone(x) → ¬StandaloneDesktop(x))
∀x (AppleMade(x) ∧ Cellphone(x) → IPhone(x))
∀x (Phone(x) ∧ With(x, a15BionicChip) → AppleMade(x) ∧ Cellphone(x))
∀x (Phone(x) ∧ EquippedWith(x, fourCoreGPU) ∧ MadeBy(x, apple) → Phone(x) ∧ With(x, a15BionicChip))
(Phone(unannouncedHuaweiPhone) ∧ With(unannouncedHuaweiPhone, a15BionicChip)) ⊕ (Phone(unannouncedHuaweiPhone) ∧ EquippedWith(unannouncedHuaweiPhone, fourCoreGPU) ∧ MadeBy(unannouncedHuaweiPhone, apple)) → ¬(Phone(unannouncedHuaweiPhone) ∧ With(unannouncedHuaweiPhone, a15BionicChip) ∧ StandaloneDesktop(unannouncedHuaweiPhone))

[PREMISE (GK)]:
! [X] : (IPhone(X) => -StandaloneDesktop(X)).
! [X] : (AppleMade(X) & Cellphone(X) => IPhone(X)).
! [X] : (Phone(X) & With(X, a15BionicChip) => AppleMade(X) & Cellphone(X)).
! [X] : (Phone(X) & EquippedWith(X, fourCoreGPU) & MadeBy(X, apple) => Phone(X) & With(X, a15BionicChip)).
(Phone(unannouncedHuaweiPhone) & With(unannouncedHuaweiPhone, a15BionicChip)) <~> (Phone(unannouncedHuaweiPhone) & EquippedWith(unannouncedHuaweiPhone, fourCoreGPU) & MadeBy(unannouncedHuaweiPhone, apple)) => -(Phone(unannouncedHuaweiPhone) & With(unannouncedHuaweiPhone, a15BionicChip) & StandaloneDesktop(unannouncedHuaweiPhone)).

[CONCLUSION]:
Joe is not a PhD student.

[CONCLUSION (FOL)]:
¬(Phone(unannouncedHuaweiPhone) ∧ EquippedWith(unannouncedHuaweiPhone, fourCoreGPU) ∧ MadeByApple(unannouncedHuaweiPhone))

[CONCLUSION (GK)]:
-(Phone(unannouncedHuaweiPhone) & EquippedWith(unannouncedHuaweiPhone, fourCoreGPU) & MadeByApple(unannouncedHuaweiPhone)).


===

['x']
['x']
[PREMISE]:
Hugh Vanstone is one of the world's leading lighting designers. 
Hugh Vanstone is from the UK.
Hugh Vanstone has lit more than 160 productions.
Hugh Vanstone attended a school where he is from. 

[PREMISE (FOL)]:
WorldLeadingLightingDesigner(hughVanstone)
From(hughVanstone, unitedKingdom)
∃x(GreaterThan(x, num160) ∧ LitProductions(hughVanstone,x))
∃x(Hometown(hughVanstone,x) ∧ AttendedSchoolIn(hughVanstone,x))

[PREMISE (GK)]:
WorldLeadingLightingDesigner(hughVanstone).
From(hughVanstone, unitedKingdom).
? [X] :(GreaterThan(X, num160) & LitProductions(hughVanstone,X)).
? [X] :(Hometown(hughVanstone,X) & AttendedSchoolIn(hughVanstone,X)).

[CONCLUSION]:
Hugh Vanstone is one of the world's leading lighting designers and is from the UK.

[CONCLUSION (FOL)]:
WorldLeadingLightingDesigner(hughVanstone) ∧ From(hughVanstone, unitedKingdom)

[CONCLUSION (GK)]:
WorldLeadingLightingDesigner(hughVanstone) & From(hughVanstone, unitedKingdom).


===

['x']
['x']
[PREMISE]:
Hugh Vanstone is one of the world's leading lighting designers. 
Hugh Vanstone is from the UK.
Hugh Vanstone has lit more than 160 productions.
Hugh Vanstone attended a school where he is from. 

[PREMISE (FOL)]:
WorldLeadingLightingDesigner(hughVanstone)
From(hughVanstone, unitedKingdom)
∃x(GreaterThan(x, num160) ∧ LitProductions(hughVanstone,x))
∃x(Hometown(hughVanstone,x) ∧ AttendedSchoolIn(hughVanstone,x))

[PREMISE (GK)]:
WorldLeadingLightingDesigner(hughVanstone).
From(hughVanstone, unitedKingdom).
? [X] :(GreaterThan(X, num160) & LitProductions(hughVanstone,X)).
? [X] :(Hometown(hughVanstone,X) & AttendedSchoolIn(hughVanstone,X)).

[CONCLUSION]:
Hugh Vanstone has lit 170 productions.

[CONCLUSION (FOL)]:
∃x(GreaterThan(x, num170) ∧ LitProductions(hughVanstone,x))

[CONCLUSION (GK)]:
? [X] :(GreaterThan(X, num170) & LitProductions(hughVanstone,X)).


===

['x']
['x']
[PREMISE]:
Hugh Vanstone is one of the world's leading lighting designers. 
Hugh Vanstone is from the UK.
Hugh Vanstone has lit more than 160 productions.
Hugh Vanstone attended a school where he is from. 

[PREMISE (FOL)]:
WorldLeadingLightingDesigner(hughVanstone)
From(hughVanstone, unitedKingdom)
∃x(GreaterThan(x, num160) ∧ LitProductions(hughVanstone,x))
∃x(Hometown(hughVanstone,x) ∧ AttendedSchoolIn(hughVanstone,x))

[PREMISE (GK)]:
WorldLeadingLightingDesigner(hughVanstone).
From(hughVanstone, unitedKingdom).
? [X] :(GreaterThan(X, num160) & LitProductions(hughVanstone,X)).
? [X] :(Hometown(hughVanstone,X) & AttendedSchoolIn(hughVanstone,X)).

[CONCLUSION]:
Hugh Vanstone attended a school in the United States.

[CONCLUSION (FOL)]:
AttendedSchoolIn(hughVanstone, unitedStates)

[CONCLUSION (GK)]:
AttendedSchoolIn(hughVanstone, unitedStates).


===

['x']
['x']
[PREMISE]:
No man can run faster than Bolt. 
Superman is not a man.

[PREMISE (FOL)]:
∀x (Man(x) → ¬RunFasterThan(xm bolt))
¬Man(superman)

[PREMISE (GK)]:
! [X] : (Man(X) => -RunFasterThan(xm bolt)).
-Man(superman).

[CONCLUSION]:
Superman can run faster than Bolt.

[CONCLUSION (FOL)]:
RunFasterThan(superman, bolt)

[CONCLUSION (GK)]:
RunFasterThan(superman, bolt).


===

[]
['x']
[PREMISE]:
Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.
Knuth has been called the "father of the analysis of algorithms."

[PREMISE (FOL)]:
American(donaldErvinKnuth) ∧ ComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorEmeritusAt(donaldErvinKnuth, stanford)
Called(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms)

[PREMISE (GK)]:
American(donaldErvinKnuth) & ComputerScientist(donaldErvinKnuth) & Mathematician(donaldErvinKnuth) & ProfessorEmeritusAt(donaldErvinKnuth, stanford).
Called(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms).

[CONCLUSION]:
An American scientist has been called the "father of the analysis of algorithms".

[CONCLUSION (FOL)]:
∃x (American(x) ∧ ComputerScientist(x) ∧ Called(x, fatherOfTheAnalysisOfAlgorithms))

[CONCLUSION (GK)]:
? [X] : (American(X) & ComputerScientist(X) & Called(X, fatherOfTheAnalysisOfAlgorithms)).


===

[]
['x']
[PREMISE]:
Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.
Knuth has been called the "father of the analysis of algorithms."

[PREMISE (FOL)]:
American(donaldErvinKnuth) ∧ ComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorEmeritusAt(donaldErvinKnuth, stanford)
Called(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms)

[PREMISE (GK)]:
American(donaldErvinKnuth) & ComputerScientist(donaldErvinKnuth) & Mathematician(donaldErvinKnuth) & ProfessorEmeritusAt(donaldErvinKnuth, stanford).
Called(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms).

[CONCLUSION]:
A mathematician has been called the "father of the analysis of algorithms".

[CONCLUSION (FOL)]:
∃x (Mathematician(x) ∧ Called(x, fatherOfTheAnalysisOfAlgorithms))

[CONCLUSION (GK)]:
? [X] : (Mathematician(X) & Called(X, fatherOfTheAnalysisOfAlgorithms)).


===

[]
[]
[PREMISE]:
Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.
Knuth has been called the "father of the analysis of algorithms."

[PREMISE (FOL)]:
American(donaldErvinKnuth) ∧ ComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorEmeritusAt(donaldErvinKnuth, stanford)
Called(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms)

[PREMISE (GK)]:
American(donaldErvinKnuth) & ComputerScientist(donaldErvinKnuth) & Mathematician(donaldErvinKnuth) & ProfessorEmeritusAt(donaldErvinKnuth, stanford).
Called(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms).

[CONCLUSION]:
Donald Knuth is a well-known figure in the field of artificial intelligence.

[CONCLUSION (FOL)]:
WellKnownFigureIn(donaldErvinKnuth, artificialIntelligence)

[CONCLUSION (GK)]:
WellKnownFigureIn(donaldErvinKnuth, artificialIntelligence).


===

['x']
['x']
[PREMISE]:
Neocrepidodera Corpulentas are flea beetles or moths, or both.
Neocrepidodera Corpulentas are in the Chrysomelidae family.
There are no moths within the Chrysomelidae family.
There is a Neocrepidodera Corpulenta. 

[PREMISE (FOL)]:
∀x (NeocrepidoderaCorpulenta(x) → (FleaBeetle(x) ∨ Moth(x)))
∀x (NeocrepidoderaCorpulenta(x) → In(x, chrysomelidaeFamily))
∀x (In(x, chrysomelidaeFamily) → ¬Moth(x))
∃x (NeocrepidoderaCorpulenta(x))

[PREMISE (GK)]:
! [X] : (NeocrepidoderaCorpulenta(X) => (FleaBeetle(X) | Moth(X))).
! [X] : (NeocrepidoderaCorpulenta(X) => In(X, chrysomelidaeFamily)).
! [X] : (In(X, chrysomelidaeFamily) => -Moth(X)).
? [X] : (NeocrepidoderaCorpulenta(X)).

[CONCLUSION]:
There is a flea beetle within the Chrysomelidae family.

[CONCLUSION (FOL)]:
∃x (FleaBeetle(x) ∧ In(x, chrysomelidaeFamily))

[CONCLUSION (GK)]:
? [X] : (FleaBeetle(X) & In(X, chrysomelidaeFamily)).


===

['x']
['x']
[PREMISE]:
Neocrepidodera Corpulentas are flea beetles or moths, or both.
Neocrepidodera Corpulentas are in the Chrysomelidae family.
There are no moths within the Chrysomelidae family.
There is a Neocrepidodera Corpulenta. 

[PREMISE (FOL)]:
∀x (NeocrepidoderaCorpulenta(x) → (FleaBeetle(x) ∨ Moth(x)))
∀x (NeocrepidoderaCorpulenta(x) → In(x, chrysomelidaeFamily))
∀x (In(x, chrysomelidaeFamily) → ¬Moth(x))
∃x (NeocrepidoderaCorpulenta(x))

[PREMISE (GK)]:
! [X] : (NeocrepidoderaCorpulenta(X) => (FleaBeetle(X) | Moth(X))).
! [X] : (NeocrepidoderaCorpulenta(X) => In(X, chrysomelidaeFamily)).
! [X] : (In(X, chrysomelidaeFamily) => -Moth(X)).
? [X] : (NeocrepidoderaCorpulenta(X)).

[CONCLUSION]:
There are no flea beetles within the Chrysomelidae family.

[CONCLUSION (FOL)]:
∀x (FleaBeetle(x) → ¬In(x, chrysomelidaeFamily))

[CONCLUSION (GK)]:
! [X] : (FleaBeetle(X) => -In(X, chrysomelidaeFamily)).


===

['x']
['x']
[PREMISE]:
Carrozzeria Colli is a Milanese coachbuilder company established by Giuseppe Colli in 1931.
Carrozzeria Colli is a company that specializes in using aluminum.
The first automobiles built by Carrozzeria Colli were racing cars.
Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.
Carrozzeria Colli worked for airforces.
Carrozzeria Colli made car bodies. 

[PREMISE (FOL)]:
Milanese(carrozzeriaColli) ∧ CoachBuilder(carrozzeriaColli) ∧ Company(carrozzeriaColli) ∧ EstablishedBy(carrozzeriaColli, giuseppeColli) ∧ EstablishedIn(carrozzeriaColli, 1931)
Company(carrozzeriaColli) ∧ SpecializesIn(carrozzeriaColli, usingAluminum)
∀x (BuiltBy(x, carrozzeriaColli) ∧ FirstAutomobile(x) → RacingCar(x))
∃x (BuiltBy(x, carrozzeriaColli) ∧ RacingCar(x) ∧ Used(x, fiat1100mechanicals) ∧ Used(x, chassis))
∃x (Airforce(x) ∧ WorkedFor(carrozzeriaColli, x))
∃(CarBody(x) ∧ Made(x, carrozzeriaColli))

[PREMISE (GK)]:
Milanese(carrozzeriaColli) & CoachBuilder(carrozzeriaColli) & Company(carrozzeriaColli) & EstablishedBy(carrozzeriaColli, giuseppeColli) & EstablishedIn(carrozzeriaColli, 1931).
Company(carrozzeriaColli) & SpecializesIn(carrozzeriaColli, usingAluminum).
! [X] : (BuiltBy(X, carrozzeriaColli) & FirstAutomobile(X) => RacingCar(X)).
? [X] : (BuiltBy(X, carrozzeriaColli) & RacingCar(X) & Used(X, fiat1100mechanicals) & Used(X, chassis)).
? [X] : (Airforce(X) & WorkedFor(carrozzeriaColli, X)).
∃(CarBody(x) & Made(x, carrozzeriaColli)).

[CONCLUSION]:
Carrozzeria Colli made car bodies in 1931.

[CONCLUSION (FOL)]:
∃x (CarBody(x) ∧ Made(x, carrozzeriaColli) ∧ MadeIn(x, 1931))

[CONCLUSION (GK)]:
? [X] : (CarBody(X) & Made(X, carrozzeriaColli) & MadeIn(X, 1931)).


===

['x']
['x']
[PREMISE]:
Carrozzeria Colli is a Milanese coachbuilder company established by Giuseppe Colli in 1931.
Carrozzeria Colli is a company that specializes in using aluminum.
The first automobiles built by Carrozzeria Colli were racing cars.
Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.
Carrozzeria Colli worked for airforces.
Carrozzeria Colli made car bodies. 

[PREMISE (FOL)]:
Milanese(carrozzeriaColli) ∧ CoachBuilder(carrozzeriaColli) ∧ Company(carrozzeriaColli) ∧ EstablishedBy(carrozzeriaColli, giuseppeColli) ∧ EstablishedIn(carrozzeriaColli, 1931)
Company(carrozzeriaColli) ∧ SpecializesIn(carrozzeriaColli, usingAluminum)
∀x (BuiltBy(x, carrozzeriaColli) ∧ FirstAutomobile(x) → RacingCar(x))
∃x (BuiltBy(x, carrozzeriaColli) ∧ RacingCar(x) ∧ Used(x, fiat1100mechanicals) ∧ Used(x, chassis))
∃x (Airforce(x) ∧ WorkedFor(carrozzeriaColli, x))
∃(CarBody(x) ∧ Made(x, carrozzeriaColli))

[PREMISE (GK)]:
Milanese(carrozzeriaColli) & CoachBuilder(carrozzeriaColli) & Company(carrozzeriaColli) & EstablishedBy(carrozzeriaColli, giuseppeColli) & EstablishedIn(carrozzeriaColli, 1931).
Company(carrozzeriaColli) & SpecializesIn(carrozzeriaColli, usingAluminum).
! [X] : (BuiltBy(X, carrozzeriaColli) & FirstAutomobile(X) => RacingCar(X)).
? [X] : (BuiltBy(X, carrozzeriaColli) & RacingCar(X) & Used(X, fiat1100mechanicals) & Used(X, chassis)).
? [X] : (Airforce(X) & WorkedFor(carrozzeriaColli, X)).
∃(CarBody(x) & Made(x, carrozzeriaColli)).

[CONCLUSION]:
Carrozzeria Colli built airplanes during World War II.

[CONCLUSION (FOL)]:
∃x (Airplane(x) ∧ Made(x, carrozzeriaColli) ∧ MadeDuring(x, worldWarII))

[CONCLUSION (GK)]:
? [X] : (Airplane(X) & Made(X, carrozzeriaColli) & MadeDuring(X, worldWarII)).


===

['x']
['x', 'y']
[PREMISE]:
Carrozzeria Colli is a Milanese coachbuilder company established by Giuseppe Colli in 1931.
Carrozzeria Colli is a company that specializes in using aluminum.
The first automobiles built by Carrozzeria Colli were racing cars.
Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.
Carrozzeria Colli worked for airforces.
Carrozzeria Colli made car bodies. 

[PREMISE (FOL)]:
Milanese(carrozzeriaColli) ∧ CoachBuilder(carrozzeriaColli) ∧ Company(carrozzeriaColli) ∧ EstablishedBy(carrozzeriaColli, giuseppeColli) ∧ EstablishedIn(carrozzeriaColli, 1931)
Company(carrozzeriaColli) ∧ SpecializesIn(carrozzeriaColli, usingAluminum)
∀x (BuiltBy(x, carrozzeriaColli) ∧ FirstAutomobile(x) → RacingCar(x))
∃x (BuiltBy(x, carrozzeriaColli) ∧ RacingCar(x) ∧ Used(x, fiat1100mechanicals) ∧ Used(x, chassis))
∃x (Airforce(x) ∧ WorkedFor(carrozzeriaColli, x))
∃(CarBody(x) ∧ Made(x, carrozzeriaColli))

[PREMISE (GK)]:
Milanese(carrozzeriaColli) & CoachBuilder(carrozzeriaColli) & Company(carrozzeriaColli) & EstablishedBy(carrozzeriaColli, giuseppeColli) & EstablishedIn(carrozzeriaColli, 1931).
Company(carrozzeriaColli) & SpecializesIn(carrozzeriaColli, usingAluminum).
! [X] : (BuiltBy(X, carrozzeriaColli) & FirstAutomobile(X) => RacingCar(X)).
? [X] : (BuiltBy(X, carrozzeriaColli) & RacingCar(X) & Used(X, fiat1100mechanicals) & Used(X, chassis)).
? [X] : (Airforce(X) & WorkedFor(carrozzeriaColli, X)).
∃(CarBody(x) & Made(x, carrozzeriaColli)).

[CONCLUSION]:
Giuseppe Colli established a company that made car bodies.

[CONCLUSION (FOL)]:
∃x ∃y (Company(x) ∧ EstablishedBy(x, giuseppeColli) ∧ CarBody(y) ∧ Made(y, x))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Company(X) & EstablishedBy(X, giuseppeColli) & CarBody(Y) & Made(Y, X)).


===

['x']
['x']
[PREMISE]:
Carrozzeria Colli is a Milanese coachbuilder company established by Giuseppe Colli in 1931.
Carrozzeria Colli is a company that specializes in using aluminum.
The first automobiles built by Carrozzeria Colli were racing cars.
Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.
Carrozzeria Colli worked for airforces.
Carrozzeria Colli made car bodies. 

[PREMISE (FOL)]:
Milanese(carrozzeriaColli) ∧ CoachBuilder(carrozzeriaColli) ∧ Company(carrozzeriaColli) ∧ EstablishedBy(carrozzeriaColli, giuseppeColli) ∧ EstablishedIn(carrozzeriaColli, 1931)
Company(carrozzeriaColli) ∧ SpecializesIn(carrozzeriaColli, usingAluminum)
∀x (BuiltBy(x, carrozzeriaColli) ∧ FirstAutomobile(x) → RacingCar(x))
∃x (BuiltBy(x, carrozzeriaColli) ∧ RacingCar(x) ∧ Used(x, fiat1100mechanicals) ∧ Used(x, chassis))
∃x (Airforce(x) ∧ WorkedFor(carrozzeriaColli, x))
∃(CarBody(x) ∧ Made(x, carrozzeriaColli))

[PREMISE (GK)]:
Milanese(carrozzeriaColli) & CoachBuilder(carrozzeriaColli) & Company(carrozzeriaColli) & EstablishedBy(carrozzeriaColli, giuseppeColli) & EstablishedIn(carrozzeriaColli, 1931).
Company(carrozzeriaColli) & SpecializesIn(carrozzeriaColli, usingAluminum).
! [X] : (BuiltBy(X, carrozzeriaColli) & FirstAutomobile(X) => RacingCar(X)).
? [X] : (BuiltBy(X, carrozzeriaColli) & RacingCar(X) & Used(X, fiat1100mechanicals) & Used(X, chassis)).
? [X] : (Airforce(X) & WorkedFor(carrozzeriaColli, X)).
∃(CarBody(x) & Made(x, carrozzeriaColli)).

[CONCLUSION]:
Giuseppe Colli established a Milanese coachbuilder company that specialized in using aluminum.

[CONCLUSION (FOL)]:
∃x (Milanese(x) ∧ CoachBuilder(x) ∧ Company(x) ∧ EstablishedBy(x, giuseppeColli) ∧ SpecializesIn(x, usingAluminum))

[CONCLUSION (GK)]:
? [X] : (Milanese(X) & CoachBuilder(X) & Company(X) & EstablishedBy(X, giuseppeColli) & SpecializesIn(X, usingAluminum)).


===

['x']
['x']
[PREMISE]:
Carrozzeria Colli is a Milanese coachbuilder company established by Giuseppe Colli in 1931.
Carrozzeria Colli is a company that specializes in using aluminum.
The first automobiles built by Carrozzeria Colli were racing cars.
Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chassis.
Carrozzeria Colli worked for airforces.
Carrozzeria Colli made car bodies. 

[PREMISE (FOL)]:
Milanese(carrozzeriaColli) ∧ CoachBuilder(carrozzeriaColli) ∧ Company(carrozzeriaColli) ∧ EstablishedBy(carrozzeriaColli, giuseppeColli) ∧ EstablishedIn(carrozzeriaColli, 1931)
Company(carrozzeriaColli) ∧ SpecializesIn(carrozzeriaColli, usingAluminum)
∀x (BuiltBy(x, carrozzeriaColli) ∧ FirstAutomobile(x) → RacingCar(x))
∃x (BuiltBy(x, carrozzeriaColli) ∧ RacingCar(x) ∧ Used(x, fiat1100mechanicals) ∧ Used(x, chassis))
∃x (Airforce(x) ∧ WorkedFor(carrozzeriaColli, x))
∃(CarBody(x) ∧ Made(x, carrozzeriaColli))

[PREMISE (GK)]:
Milanese(carrozzeriaColli) & CoachBuilder(carrozzeriaColli) & Company(carrozzeriaColli) & EstablishedBy(carrozzeriaColli, giuseppeColli) & EstablishedIn(carrozzeriaColli, 1931).
Company(carrozzeriaColli) & SpecializesIn(carrozzeriaColli, usingAluminum).
! [X] : (BuiltBy(X, carrozzeriaColli) & FirstAutomobile(X) => RacingCar(X)).
? [X] : (BuiltBy(X, carrozzeriaColli) & RacingCar(X) & Used(X, fiat1100mechanicals) & Used(X, chassis)).
? [X] : (Airforce(X) & WorkedFor(carrozzeriaColli, X)).
∃(CarBody(x) & Made(x, carrozzeriaColli)).

[CONCLUSION]:
The first automobiles built by Carrozzeria Colli were built using Fiat 1100 mechanicals and chassis.

[CONCLUSION (FOL)]:
∃x (BuiltBy(x, carrozzeriaColli) ∧ FirstAutomobil(x) ∧ Used(x, fiat1100mechanicals) ∧ Used(x, chassis))

[CONCLUSION (GK)]:
? [X] : (BuiltBy(X, carrozzeriaColli) & FirstAutomobil(X) & Used(X, fiat1100mechanicals) & Used(X, chassis)).


===

['x']
['x']
[PREMISE]:
John will go to the cinema if and only if Jack goes to the cinema today.
Jack will go to the cinema if and only if Iron Man is on and the weather is not bad today.
Some days in March have bad weather.
Iron Man is on.
It's March now.

[PREMISE (FOL)]:
(GoTo(john, theCinema) ∧ GoTo(john, today)) ↔ GoTo(jack, theCinema) ∧ GoTo(jack, today)
(GoTo(john, theCinema) ∧ GoTo(john, today)) ↔ (On(ironman) ∧ ¬Bad(weather, today))
∃x (Day(x) ∧ March(x) → ¬Bad(weather, x))
On(ironman)
Day(presentMoment) ∧ March(presentMoment)

[PREMISE (GK)]:
(GoTo(john, theCinema) & GoTo(john, today)) ↔ GoTo(jack, theCinema) & GoTo(jack, today).
(GoTo(john, theCinema) & GoTo(john, today)) ↔ (On(ironman) & -Bad(weather, today)).
? [X] : (Day(X) & March(X) => -Bad(weather, X)).
On(ironman).
Day(presentMoment) & March(presentMoment).

[CONCLUSION]:
John will go to the cinema.

[CONCLUSION (FOL)]:
GoTo(john, theCinema) ∧ GoTo(john, today)

[CONCLUSION (GK)]:
GoTo(john, theCinema) & GoTo(john, today).


===

['x']
['x']
[PREMISE]:
John will go to the cinema if and only if Jack goes to the cinema today.
Jack will go to the cinema if and only if Iron Man is on and the weather is not bad today.
Some days in March have bad weather.
Iron Man is on.
It's March now.

[PREMISE (FOL)]:
(GoTo(john, theCinema) ∧ GoTo(john, today)) ↔ GoTo(jack, theCinema) ∧ GoTo(jack, today)
(GoTo(john, theCinema) ∧ GoTo(john, today)) ↔ (On(ironman) ∧ ¬Bad(weather, today))
∃x (Day(x) ∧ March(x) → ¬Bad(weather, x))
On(ironman)
Day(presentMoment) ∧ March(presentMoment)

[PREMISE (GK)]:
(GoTo(john, theCinema) & GoTo(john, today)) ↔ GoTo(jack, theCinema) & GoTo(jack, today).
(GoTo(john, theCinema) & GoTo(john, today)) ↔ (On(ironman) & -Bad(weather, today)).
? [X] : (Day(X) & March(X) => -Bad(weather, X)).
On(ironman).
Day(presentMoment) & March(presentMoment).

[CONCLUSION]:
The weather is good today.

[CONCLUSION (FOL)]:
¬Bad(weather, today)

[CONCLUSION (GK)]:
-Bad(weather, today).


===

['x']
['x']
[PREMISE]:
Quiksilver sells sportswear, clothing, footwear, and accessories.
Flannels are a type of clothing.
Joe owns an item from Quiksilver.

[PREMISE (FOL)]:
∀x (Sells(quiksilver, x) → (Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x)))
Clothing(flannel)
∃x (Sells(quiksilver, x) ∧ Owns(joe, x))

[PREMISE (GK)]:
! [X] : (Sells(quiksilver, X) => (Sportswear(X) | Clothing(X) | Footwear(X) | Accessory(X))).
Clothing(flannel).
? [X] : (Sells(quiksilver, X) & Owns(joe, X)).

[CONCLUSION]:
Quiksilver sells beer.

[CONCLUSION (FOL)]:
Sells(quiksilver, beer)

[CONCLUSION (GK)]:
Sells(quiksilver, beer).


===

['x']
['x']
[PREMISE]:
Quiksilver sells sportswear, clothing, footwear, and accessories.
Flannels are a type of clothing.
Joe owns an item from Quiksilver.

[PREMISE (FOL)]:
∀x (Sells(quiksilver, x) → (Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x)))
Clothing(flannel)
∃x (Sells(quiksilver, x) ∧ Owns(joe, x))

[PREMISE (GK)]:
! [X] : (Sells(quiksilver, X) => (Sportswear(X) | Clothing(X) | Footwear(X) | Accessory(X))).
Clothing(flannel).
? [X] : (Sells(quiksilver, X) & Owns(joe, X)).

[CONCLUSION]:
Joe owns a flannel.

[CONCLUSION (FOL)]:
Owns(joe, flannel)

[CONCLUSION (GK)]:
Owns(joe, flannel).


===

['x']
['x']
[PREMISE]:
Quiksilver sells sportswear, clothing, footwear, and accessories.
Flannels are a type of clothing.
Joe owns an item from Quiksilver.

[PREMISE (FOL)]:
∀x (Sells(quiksilver, x) → (Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x)))
Clothing(flannel)
∃x (Sells(quiksilver, x) ∧ Owns(joe, x))

[PREMISE (GK)]:
! [X] : (Sells(quiksilver, X) => (Sportswear(X) | Clothing(X) | Footwear(X) | Accessory(X))).
Clothing(flannel).
? [X] : (Sells(quiksilver, X) & Owns(joe, X)).

[CONCLUSION]:
Joe owns at least one piece of sportswear, clothing, footwear, or accessory

[CONCLUSION (FOL)]:
∃x (Owns(joe, x) ∧ Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x))

[CONCLUSION (GK)]:
? [X] : (Owns(joe, X) & Sportswear(X) | Clothing(X) | Footwear(X) | Accessory(X)).


===

['x']
['x']
[PREMISE]:
No video games released by Nintendo support the PS4 platform.
All video games in the Pokemon series are released by Nintendo. 
All video games in the FIFA series support the PS4 platform. 
All video games that allow users to simulate playing online soccer using licensed players are in the FIFA series.
The video game named “Be Lionel” is in the Pokemon series, or it allows users to simulate playing online soccer games using licensed players.

[PREMISE (FOL)]:
∀x (VideoGame(x) ∧ ReleasedBy(x, nintendo) → ¬Support(x, pS4))
∀x (VideoGame(x) ∧ In(x, pokemonSeries) → ReleasedBy(x, nintendo))
∀x (VideoGame(x) ∧ In(x, fIFASeries) → Support(x, pS4))
∀x (VideoGame(x) ∧ Simulate(x, onlineSoccer) ∧ Use(x, licensedPlayer) → In(x, fIFASeries))
VideoGame(beLionel) ∧ In(beLionel, pokemonSeries) ∨ (Simulate(beLionel, onlineSoccer) ∧ Use(beLionel, licensedPlayer))

[PREMISE (GK)]:
! [X] : (VideoGame(X) & ReleasedBy(X, nintendo) => -Support(X, pS4)).
! [X] : (VideoGame(X) & In(X, pokemonSeries) => ReleasedBy(X, nintendo)).
! [X] : (VideoGame(X) & In(X, fIFASeries) => Support(X, pS4)).
! [X] : (VideoGame(X) & Simulate(X, onlineSoccer) & Use(X, licensedPlayer) => In(X, fIFASeries)).
VideoGame(beLionel) & In(beLionel, pokemonSeries) | (Simulate(beLionel, onlineSoccer) & Use(beLionel, licensedPlayer)).

[CONCLUSION]:
The video game "Be Lionel" is in the pokemon series.

[CONCLUSION (FOL)]:
VideoGame(beLionel) ∧ PokemonSeries(beLionel)

[CONCLUSION (GK)]:
VideoGame(beLionel) & PokemonSeries(beLionel).


===

['x']
['x']
[PREMISE]:
No video games released by Nintendo support the PS4 platform.
All video games in the Pokemon series are released by Nintendo. 
All video games in the FIFA series support the PS4 platform. 
All video games that allow users to simulate playing online soccer using licensed players are in the FIFA series.
The video game named “Be Lionel” is in the Pokemon series, or it allows users to simulate playing online soccer games using licensed players.

[PREMISE (FOL)]:
∀x (VideoGame(x) ∧ ReleasedBy(x, nintendo) → ¬Support(x, pS4))
∀x (VideoGame(x) ∧ In(x, pokemonSeries) → ReleasedBy(x, nintendo))
∀x (VideoGame(x) ∧ In(x, fIFASeries) → Support(x, pS4))
∀x (VideoGame(x) ∧ Simulate(x, onlineSoccer) ∧ Use(x, licensedPlayer) → In(x, fIFASeries))
VideoGame(beLionel) ∧ In(beLionel, pokemonSeries) ∨ (Simulate(beLionel, onlineSoccer) ∧ Use(beLionel, licensedPlayer))

[PREMISE (GK)]:
! [X] : (VideoGame(X) & ReleasedBy(X, nintendo) => -Support(X, pS4)).
! [X] : (VideoGame(X) & In(X, pokemonSeries) => ReleasedBy(X, nintendo)).
! [X] : (VideoGame(X) & In(X, fIFASeries) => Support(X, pS4)).
! [X] : (VideoGame(X) & Simulate(X, onlineSoccer) & Use(X, licensedPlayer) => In(X, fIFASeries)).
VideoGame(beLionel) & In(beLionel, pokemonSeries) | (Simulate(beLionel, onlineSoccer) & Use(beLionel, licensedPlayer)).

[CONCLUSION]:
The video game named “Be Lionel” either is in the FIFA series and supports the PS4 platform, or it neither is in the FIFA series nor supports the PS4 platform.

[CONCLUSION (FOL)]:
VideoGame(beLionel) ∧  ¬(FIFASeries(beLionel) ⊕ Support(beLionel, pS4))

[CONCLUSION (GK)]:
VideoGame(beLionel) &  -(FIFASeries(beLionel) <~> Support(beLionel, pS4)).


===

['x']
['x']
[PREMISE]:
No video games released by Nintendo support the PS4 platform.
All video games in the Pokemon series are released by Nintendo. 
All video games in the FIFA series support the PS4 platform. 
All video games that allow users to simulate playing online soccer using licensed players are in the FIFA series.
The video game named “Be Lionel” is in the Pokemon series, or it allows users to simulate playing online soccer games using licensed players.

[PREMISE (FOL)]:
∀x (VideoGame(x) ∧ ReleasedBy(x, nintendo) → ¬Support(x, pS4))
∀x (VideoGame(x) ∧ In(x, pokemonSeries) → ReleasedBy(x, nintendo))
∀x (VideoGame(x) ∧ In(x, fIFASeries) → Support(x, pS4))
∀x (VideoGame(x) ∧ Simulate(x, onlineSoccer) ∧ Use(x, licensedPlayer) → In(x, fIFASeries))
VideoGame(beLionel) ∧ In(beLionel, pokemonSeries) ∨ (Simulate(beLionel, onlineSoccer) ∧ Use(beLionel, licensedPlayer))

[PREMISE (GK)]:
! [X] : (VideoGame(X) & ReleasedBy(X, nintendo) => -Support(X, pS4)).
! [X] : (VideoGame(X) & In(X, pokemonSeries) => ReleasedBy(X, nintendo)).
! [X] : (VideoGame(X) & In(X, fIFASeries) => Support(X, pS4)).
! [X] : (VideoGame(X) & Simulate(X, onlineSoccer) & Use(X, licensedPlayer) => In(X, fIFASeries)).
VideoGame(beLionel) & In(beLionel, pokemonSeries) | (Simulate(beLionel, onlineSoccer) & Use(beLionel, licensedPlayer)).

[CONCLUSION]:
The video game named “Be Lionel” is either in the FIFA series or supports the PS4 platform.

[CONCLUSION (FOL)]:
VideoGame(beLionel) ∧ FIFASeries(beLionel) ⊕ Support(beLionel, pS4)

[CONCLUSION (GK)]:
VideoGame(beLionel) & FIFASeries(beLionel) <~> Support(beLionel, pS4).


===

['x']
['x']
[PREMISE]:
No video games released by Nintendo support the PS4 platform.
All video games in the Pokemon series are released by Nintendo. 
All video games in the FIFA series support the PS4 platform. 
All video games that allow users to simulate playing online soccer using licensed players are in the FIFA series.
The video game named “Be Lionel” is in the Pokemon series, or it allows users to simulate playing online soccer games using licensed players.

[PREMISE (FOL)]:
∀x (VideoGame(x) ∧ ReleasedBy(x, nintendo) → ¬Support(x, pS4))
∀x (VideoGame(x) ∧ In(x, pokemonSeries) → ReleasedBy(x, nintendo))
∀x (VideoGame(x) ∧ In(x, fIFASeries) → Support(x, pS4))
∀x (VideoGame(x) ∧ Simulate(x, onlineSoccer) ∧ Use(x, licensedPlayer) → In(x, fIFASeries))
VideoGame(beLionel) ∧ In(beLionel, pokemonSeries) ∨ (Simulate(beLionel, onlineSoccer) ∧ Use(beLionel, licensedPlayer))

[PREMISE (GK)]:
! [X] : (VideoGame(X) & ReleasedBy(X, nintendo) => -Support(X, pS4)).
! [X] : (VideoGame(X) & In(X, pokemonSeries) => ReleasedBy(X, nintendo)).
! [X] : (VideoGame(X) & In(X, fIFASeries) => Support(X, pS4)).
! [X] : (VideoGame(X) & Simulate(X, onlineSoccer) & Use(X, licensedPlayer) => In(X, fIFASeries)).
VideoGame(beLionel) & In(beLionel, pokemonSeries) | (Simulate(beLionel, onlineSoccer) & Use(beLionel, licensedPlayer)).

[CONCLUSION]:
The video game named “Be Lionel”  is not in the FIFA or Pokemon series.

[CONCLUSION (FOL)]:
VideoGame(beLionel) ∧ ¬(FIFASeries(beLionel) ∨ Support(beLionel, pS4))

[CONCLUSION (GK)]:
VideoGame(beLionel) & -(FIFASeries(beLionel) | Support(beLionel, pS4)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
No payment cards issued by Russian banks can be used with ApplePay.
All MIR payment cards are issued by Russian banks.
Some international payment cards can be used with ApplePay.
Social payments in Russia can only be transferred to MIR payment cards.
Bank of America payment cards can be used with ApplePay.

[PREMISE (FOL)]:
∀x ∀y (PaymentCard(x) ∧ RussianBank(y) ∧ IssuedBy(x, y) → ¬UsedWith(x, applePay))
∀x ∀y (PaymentCard(x) ∧ MIR(x) → RussianBank(y) ∧ IssuedBy(x, y))
∃x (PaymentCard(x) ∧ International(x) → UsedWith(x, applePay))
∀x ∀y (SocialPayment(x) ∧TransferredTo(x, y) → PaymentCard(y) ∧ MIR(y))
PaymentCard(bankOfAmerica) ∧ UsedWith(bankOfAmerica, applePay)

[PREMISE (GK)]:
! [X] : ! [Y] : (PaymentCard(X) & RussianBank(Y) & IssuedBy(X, Y) => -UsedWith(X, applePay)).
! [X] : ! [Y] : (PaymentCard(X) & MIR(X) => RussianBank(Y) & IssuedBy(X, Y)).
? [X] : (PaymentCard(X) & International(X) => UsedWith(X, applePay)).
! [X] : ! [Y] : (SocialPayment(X) &TransferredTo(X, Y) => PaymentCard(Y) & MIR(Y)).
PaymentCard(bankOfAmerica) & UsedWith(bankOfAmerica, applePay).

[CONCLUSION]:
Bank of America payment cards are international.

[CONCLUSION (FOL)]:
PaymentCard(bankOfAmerica) ∧ International(bankOfAmerica)

[CONCLUSION (GK)]:
PaymentCard(bankOfAmerica) & International(bankOfAmerica).


===

['x', 'y']
['x', 'y']
[PREMISE]:
No payment cards issued by Russian banks can be used with ApplePay.
All MIR payment cards are issued by Russian banks.
Some international payment cards can be used with ApplePay.
Social payments in Russia can only be transferred to MIR payment cards.
Bank of America payment cards can be used with ApplePay.

[PREMISE (FOL)]:
∀x ∀y (PaymentCard(x) ∧ RussianBank(y) ∧ IssuedBy(x, y) → ¬UsedWith(x, applePay))
∀x ∀y (PaymentCard(x) ∧ MIR(x) → RussianBank(y) ∧ IssuedBy(x, y))
∃x (PaymentCard(x) ∧ International(x) → UsedWith(x, applePay))
∀x ∀y (SocialPayment(x) ∧TransferredTo(x, y) → PaymentCard(y) ∧ MIR(y))
PaymentCard(bankOfAmerica) ∧ UsedWith(bankOfAmerica, applePay)

[PREMISE (GK)]:
! [X] : ! [Y] : (PaymentCard(X) & RussianBank(Y) & IssuedBy(X, Y) => -UsedWith(X, applePay)).
! [X] : ! [Y] : (PaymentCard(X) & MIR(X) => RussianBank(Y) & IssuedBy(X, Y)).
? [X] : (PaymentCard(X) & International(X) => UsedWith(X, applePay)).
! [X] : ! [Y] : (SocialPayment(X) &TransferredTo(X, Y) => PaymentCard(Y) & MIR(Y)).
PaymentCard(bankOfAmerica) & UsedWith(bankOfAmerica, applePay).

[CONCLUSION]:
Bank of America payment cards are international and can be used to transfer social payments in Russia.

[CONCLUSION (FOL)]:
∀x (PaymentCard(bankOfAmerica) ∧ International(bankOfAmerica) ∧ SocialPayment(x) ∧TransferredTo(x, bankOfAmerica))

[CONCLUSION (GK)]:
! [X] : (PaymentCard(bankOfAmerica) & International(bankOfAmerica) & SocialPayment(X) &TransferredTo(X, bankOfAmerica)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
No payment cards issued by Russian banks can be used with ApplePay.
All MIR payment cards are issued by Russian banks.
Some international payment cards can be used with ApplePay.
Social payments in Russia can only be transferred to MIR payment cards.
Bank of America payment cards can be used with ApplePay.

[PREMISE (FOL)]:
∀x ∀y (PaymentCard(x) ∧ RussianBank(y) ∧ IssuedBy(x, y) → ¬UsedWith(x, applePay))
∀x ∀y (PaymentCard(x) ∧ MIR(x) → RussianBank(y) ∧ IssuedBy(x, y))
∃x (PaymentCard(x) ∧ International(x) → UsedWith(x, applePay))
∀x ∀y (SocialPayment(x) ∧TransferredTo(x, y) → PaymentCard(y) ∧ MIR(y))
PaymentCard(bankOfAmerica) ∧ UsedWith(bankOfAmerica, applePay)

[PREMISE (GK)]:
! [X] : ! [Y] : (PaymentCard(X) & RussianBank(Y) & IssuedBy(X, Y) => -UsedWith(X, applePay)).
! [X] : ! [Y] : (PaymentCard(X) & MIR(X) => RussianBank(Y) & IssuedBy(X, Y)).
? [X] : (PaymentCard(X) & International(X) => UsedWith(X, applePay)).
! [X] : ! [Y] : (SocialPayment(X) &TransferredTo(X, Y) => PaymentCard(Y) & MIR(Y)).
PaymentCard(bankOfAmerica) & UsedWith(bankOfAmerica, applePay).

[CONCLUSION]:
If Bank of America payment cards are international and can be used to transfer social payments in Russia, then they are international.

[CONCLUSION (FOL)]:
∀x ((PaymentCard(bandOfAmerica) ∧ International(bandOfAmerica) ∧ SocialPayment(x) ∧ TransferredTo(x, bandOfAmerica)) → International(bandOfAmerica))

[CONCLUSION (GK)]:
! [X] : ((PaymentCard(bandOfAmerica) & International(bandOfAmerica) & SocialPayment(X) & TransferredTo(X, bandOfAmerica)) => International(bandOfAmerica)).


===

['x']
['x']
[PREMISE]:
The Lumina APV is produced by Chevrolet. 
The Astro is a van produced by Chevrolet. 
Vehicles produced by Chevrolet in this batch are either cars or vans.

[PREMISE (FOL)]:
ProducedBy(luminaAPV, chevrolet)
ProducedBy(astro, chevrolet) ∧ Van(astro)
∀x (Vehicle(x) ∧ ProducedBy(x, chevrolet) ∧ InThisBatch(x) → (Car(x) ⊕ Van(x)))

[PREMISE (GK)]:
ProducedBy(luminaAPV, chevrolet).
ProducedBy(astro, chevrolet) & Van(astro).
! [X] : (Vehicle(X) & ProducedBy(X, chevrolet) & InThisBatch(X) => (Car(X) <~> Van(X))).

[CONCLUSION]:
The Lumina APV is a van.

[CONCLUSION (FOL)]:
Van(luminaAPV)

[CONCLUSION (GK)]:
Van(luminaAPV).


===

['x']
['x']
[PREMISE]:
The Lumina APV is produced by Chevrolet. 
The Astro is a van produced by Chevrolet. 
Vehicles produced by Chevrolet in this batch are either cars or vans.

[PREMISE (FOL)]:
ProducedBy(luminaAPV, chevrolet)
ProducedBy(astro, chevrolet) ∧ Van(astro)
∀x (Vehicle(x) ∧ ProducedBy(x, chevrolet) ∧ InThisBatch(x) → (Car(x) ⊕ Van(x)))

[PREMISE (GK)]:
ProducedBy(luminaAPV, chevrolet).
ProducedBy(astro, chevrolet) & Van(astro).
! [X] : (Vehicle(X) & ProducedBy(X, chevrolet) & InThisBatch(X) => (Car(X) <~> Van(X))).

[CONCLUSION]:
The Lumina APV is either a car or a van.

[CONCLUSION (FOL)]:
Car(luminaAPV) ⊕ Van(luminaAPV)

[CONCLUSION (GK)]:
Car(luminaAPV) <~> Van(luminaAPV).


===

['x']
['x']
[PREMISE]:
The Lumina APV is produced by Chevrolet. 
The Astro is a van produced by Chevrolet. 
Vehicles produced by Chevrolet in this batch are either cars or vans.

[PREMISE (FOL)]:
ProducedBy(luminaAPV, chevrolet)
ProducedBy(astro, chevrolet) ∧ Van(astro)
∀x (Vehicle(x) ∧ ProducedBy(x, chevrolet) ∧ InThisBatch(x) → (Car(x) ⊕ Van(x)))

[PREMISE (GK)]:
ProducedBy(luminaAPV, chevrolet).
ProducedBy(astro, chevrolet) & Van(astro).
! [X] : (Vehicle(X) & ProducedBy(X, chevrolet) & InThisBatch(X) => (Car(X) <~> Van(X))).

[CONCLUSION]:
The Astro is a van.

[CONCLUSION (FOL)]:
Van(astro)

[CONCLUSION (GK)]:
Van(astro).


===

['x']
['x']
[PREMISE]:
The Lumina APV is produced by Chevrolet. 
The Astro is a van produced by Chevrolet. 
Vehicles produced by Chevrolet in this batch are either cars or vans.

[PREMISE (FOL)]:
ProducedBy(luminaAPV, chevrolet)
ProducedBy(astro, chevrolet) ∧ Van(astro)
∀x (Vehicle(x) ∧ ProducedBy(x, chevrolet) ∧ InThisBatch(x) → (Car(x) ⊕ Van(x)))

[PREMISE (GK)]:
ProducedBy(luminaAPV, chevrolet).
ProducedBy(astro, chevrolet) & Van(astro).
! [X] : (Vehicle(X) & ProducedBy(X, chevrolet) & InThisBatch(X) => (Car(X) <~> Van(X))).

[CONCLUSION]:
The Astro is a car.

[CONCLUSION (FOL)]:
Car(astro)

[CONCLUSION (GK)]:
Car(astro).


===

['x']
['x']
[PREMISE]:
Everyone who works in the office is a commuter. 
People either work in the office or work from home.
Everyone who works from home has a relaxed schedule.
George is either a commuter or has a home office setup. 
If George is either a person who works from home or has a home office setup, then George is a commuter and is not a person who works from home.

[PREMISE (FOL)]:
∀x (WorkIn(x, office) → Commuter(x))
∀x (WorkIn(x, office) ⊕ WorkFrom(x, home))
∀x (WorkFrom(x, home) → Have(x, relaxedSchedule))
Commuter(george) ⊕ Have(george, homeOffice)
(WorkFrom(george, home) ⊕ Have(george, homeOffice)) → ¬WorkFrom(george, home) ∧ Commuter(george)

[PREMISE (GK)]:
! [X] : (WorkIn(X, office) => Commuter(X)).
! [X] : (WorkIn(X, office) <~> WorkFrom(X, home)).
! [X] : (WorkFrom(X, home) => Have(X, relaxedSchedule)).
Commuter(george) <~> Have(george, homeOffice).
(WorkFrom(george, home) <~> Have(george, homeOffice)) => -WorkFrom(george, home) & Commuter(george).

[CONCLUSION]:
George is a person who works from home.

[CONCLUSION (FOL)]:
WorkFrom(george, home)

[CONCLUSION (GK)]:
WorkFrom(george, home).


===

['x']
['x']
[PREMISE]:
Everyone who works in the office is a commuter. 
People either work in the office or work from home.
Everyone who works from home has a relaxed schedule.
George is either a commuter or has a home office setup. 
If George is either a person who works from home or has a home office setup, then George is a commuter and is not a person who works from home.

[PREMISE (FOL)]:
∀x (WorkIn(x, office) → Commuter(x))
∀x (WorkIn(x, office) ⊕ WorkFrom(x, home))
∀x (WorkFrom(x, home) → Have(x, relaxedSchedule))
Commuter(george) ⊕ Have(george, homeOffice)
(WorkFrom(george, home) ⊕ Have(george, homeOffice)) → ¬WorkFrom(george, home) ∧ Commuter(george)

[PREMISE (GK)]:
! [X] : (WorkIn(X, office) => Commuter(X)).
! [X] : (WorkIn(X, office) <~> WorkFrom(X, home)).
! [X] : (WorkFrom(X, home) => Have(X, relaxedSchedule)).
Commuter(george) <~> Have(george, homeOffice).
(WorkFrom(george, home) <~> Have(george, homeOffice)) => -WorkFrom(george, home) & Commuter(george).

[CONCLUSION]:
If George is not a person who works from home and a person who works in the office, then George is neither a commuter nor a person who has a relaxed schedule.

[CONCLUSION (FOL)]:
¬(WorkFrom(george, home) ∧ WorkIn(george, office)) → ¬(Commuter(george) ∨ Have(george, relaxedSchedule))

[CONCLUSION (GK)]:
-(WorkFrom(george, home) & WorkIn(george, office)) => -(Commuter(george) | Have(george, relaxedSchedule)).


===

['x']
['x']
[PREMISE]:
Everyone who works in the office is a commuter. 
People either work in the office or work from home.
Everyone who works from home has a relaxed schedule.
George is either a commuter or has a home office setup. 
If George is either a person who works from home or has a home office setup, then George is a commuter and is not a person who works from home.

[PREMISE (FOL)]:
∀x (WorkIn(x, office) → Commuter(x))
∀x (WorkIn(x, office) ⊕ WorkFrom(x, home))
∀x (WorkFrom(x, home) → Have(x, relaxedSchedule))
Commuter(george) ⊕ Have(george, homeOffice)
(WorkFrom(george, home) ⊕ Have(george, homeOffice)) → ¬WorkFrom(george, home) ∧ Commuter(george)

[PREMISE (GK)]:
! [X] : (WorkIn(X, office) => Commuter(X)).
! [X] : (WorkIn(X, office) <~> WorkFrom(X, home)).
! [X] : (WorkFrom(X, home) => Have(X, relaxedSchedule)).
Commuter(george) <~> Have(george, homeOffice).
(WorkFrom(george, home) <~> Have(george, homeOffice)) => -WorkFrom(george, home) & Commuter(george).

[CONCLUSION]:
If George is either a person who has a home office setup and a person who works in the office, or neither a person who has a home office setup nor a person who works in the office, then George is either a person who works from home or a person who has a relaxed schedule.

[CONCLUSION (FOL)]:
¬(Have(george, homeOffice) ⊕ WorkIn(george, office)) → (WorkFrom(george, home) ⊕ Have(george, relaxedSchedule))

[CONCLUSION (GK)]:
-(Have(george, homeOffice) <~> WorkIn(george, office)) => (WorkFrom(george, home) <~> Have(george, relaxedSchedule)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Jason Kramer is an American music supervisor.
Some American radio personalities are also music supervisors. 
Anyone who hosts a show on a public radio station is a radio personality.
Joe Rogan is a radio personality.
Jason Kramer hosted a show on a public radio station.

[PREMISE (FOL)]:
MusicSupervisor(jasonKramer) ∧ American(jasonKramer)
∃x ∃y (American(x) ∧ MusicSupervisor(x) ∧ RadioPersonality(x) ∧ (¬(x=y)) ∧ American(y) ∧ MusicSupervisor(y) ∧ RadioPersonality(y))
∀x ∀y((HostShowOn(x, y) ∧ PublicRadioStation(x)) → RadioPersonality(x))
RadioPersonality(joeRogan)
∃x(HostShowOn(jasonKramer, x) ∧ PublicRadioStation(x))

[PREMISE (GK)]:
MusicSupervisor(jasonKramer) & American(jasonKramer).
? [X] : ? [Y] : (American(X) & MusicSupervisor(X) & RadioPersonality(X) & (-(X=Y)) & American(Y) & MusicSupervisor(Y) & RadioPersonality(Y)).
! [X] : ! [Y] :((HostShowOn(X, Y) & PublicRadioStation(X)) => RadioPersonality(X)).
RadioPersonality(joeRogan).
? [X] :(HostShowOn(jasonKramer, X) & PublicRadioStation(X)).

[CONCLUSION]:
Joe Rogan is American.

[CONCLUSION (FOL)]:
American(joeRogan)

[CONCLUSION (GK)]:
American(joeRogan).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Jason Kramer is an American music supervisor.
Some American radio personalities are also music supervisors. 
Anyone who hosts a show on a public radio station is a radio personality.
Joe Rogan is a radio personality.
Jason Kramer hosted a show on a public radio station.

[PREMISE (FOL)]:
MusicSupervisor(jasonKramer) ∧ American(jasonKramer)
∃x ∃y (American(x) ∧ MusicSupervisor(x) ∧ RadioPersonality(x) ∧ (¬(x=y)) ∧ American(y) ∧ MusicSupervisor(y) ∧ RadioPersonality(y))
∀x ∀y((HostShowOn(x, y) ∧ PublicRadioStation(x)) → RadioPersonality(x))
RadioPersonality(joeRogan)
∃x(HostShowOn(jasonKramer, x) ∧ PublicRadioStation(x))

[PREMISE (GK)]:
MusicSupervisor(jasonKramer) & American(jasonKramer).
? [X] : ? [Y] : (American(X) & MusicSupervisor(X) & RadioPersonality(X) & (-(X=Y)) & American(Y) & MusicSupervisor(Y) & RadioPersonality(Y)).
! [X] : ! [Y] :((HostShowOn(X, Y) & PublicRadioStation(X)) => RadioPersonality(X)).
RadioPersonality(joeRogan).
? [X] :(HostShowOn(jasonKramer, X) & PublicRadioStation(X)).

[CONCLUSION]:
Jason Kramer is a music supervisor.

[CONCLUSION (FOL)]:
MusicSupervisor(jasonKramer)

[CONCLUSION (GK)]:
MusicSupervisor(jasonKramer).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Jason Kramer is an American music supervisor.
Some American radio personalities are also music supervisors. 
Anyone who hosts a show on a public radio station is a radio personality.
Joe Rogan is a radio personality.
Jason Kramer hosted a show on a public radio station.

[PREMISE (FOL)]:
MusicSupervisor(jasonKramer) ∧ American(jasonKramer)
∃x ∃y (American(x) ∧ MusicSupervisor(x) ∧ RadioPersonality(x) ∧ (¬(x=y)) ∧ American(y) ∧ MusicSupervisor(y) ∧ RadioPersonality(y))
∀x ∀y((HostShowOn(x, y) ∧ PublicRadioStation(x)) → RadioPersonality(x))
RadioPersonality(joeRogan)
∃x(HostShowOn(jasonKramer, x) ∧ PublicRadioStation(x))

[PREMISE (GK)]:
MusicSupervisor(jasonKramer) & American(jasonKramer).
? [X] : ? [Y] : (American(X) & MusicSupervisor(X) & RadioPersonality(X) & (-(X=Y)) & American(Y) & MusicSupervisor(Y) & RadioPersonality(Y)).
! [X] : ! [Y] :((HostShowOn(X, Y) & PublicRadioStation(X)) => RadioPersonality(X)).
RadioPersonality(joeRogan).
? [X] :(HostShowOn(jasonKramer, X) & PublicRadioStation(X)).

[CONCLUSION]:
Jason Kramer is a radio personality.

[CONCLUSION (FOL)]:
RadioPersonality(jasonKramer)

[CONCLUSION (GK)]:
RadioPersonality(jasonKramer).


===

['x']
['x']
[PREMISE]:
Hermès bags are not made in Italy.
All Birkin bags are Hermès bags. 
All Ferraris are made in Italy. 
All cars that carry a Ferrari V12 engine are Ferraris. 
All cars that are made in Maranello carry a Ferrari V12 engine.
A Lamborghini SUV is not both a Ferrari and made in Maranello. 
A Kelly bag is a Hermès bag, or it is a car that carries a Ferrari V12 engine. 

[PREMISE (FOL)]:
∀x ((Bag(x) ∧ Hermès(x)) → ¬MadeIn(x, italy))
∀x ((Bag(x) ∧ Birkin(x)) → Hermès(x))
∀x (Ferrari(x) → MadeIn(x, italy))
∀x ((Car(x) ∧ Carry(x, ferrariV12Engine)) → Ferrrari(x))
∀x ((Car(x) ∧ MadeIn(x, maranello)) → Carry(x, ferrariV12Engine))
¬(Ferrari(lamborghiniSUV) ∧ MadeIn(lamborghiniSUV, maranello))
(Bag(kelly) ∧ Hermès(kelly)) ∨ (Bag(kelly) ∧ Car(kelly) ∧ Carry(kelly, ferrariV12Engine))

[PREMISE (GK)]:
! [X] : ((Bag(X) & Hermès(X)) => -MadeIn(X, italy)).
! [X] : ((Bag(X) & Birkin(X)) => Hermès(X)).
! [X] : (Ferrari(X) => MadeIn(X, italy)).
! [X] : ((Car(X) & Carry(X, ferrariV12Engine)) => Ferrrari(X)).
! [X] : ((Car(X) & MadeIn(X, maranello)) => Carry(X, ferrariV12Engine)).
-(Ferrari(lamborghiniSUV) & MadeIn(lamborghiniSUV, maranello)).
(Bag(kelly) & Hermès(kelly)) | (Bag(kelly) & Car(kelly) & Carry(kelly, ferrariV12Engine)).

[CONCLUSION]:
A Lamborghini SUV is made in Italy.

[CONCLUSION (FOL)]:
MadeIn(lamborghiniSUV, italy)

[CONCLUSION (GK)]:
MadeIn(lamborghiniSUV, italy).


===

['x']
['x']
[PREMISE]:
Hermès bags are not made in Italy.
All Birkin bags are Hermès bags. 
All Ferraris are made in Italy. 
All cars that carry a Ferrari V12 engine are Ferraris. 
All cars that are made in Maranello carry a Ferrari V12 engine.
A Lamborghini SUV is not both a Ferrari and made in Maranello. 
A Kelly bag is a Hermès bag, or it is a car that carries a Ferrari V12 engine. 

[PREMISE (FOL)]:
∀x ((Bag(x) ∧ Hermès(x)) → ¬MadeIn(x, italy))
∀x ((Bag(x) ∧ Birkin(x)) → Hermès(x))
∀x (Ferrari(x) → MadeIn(x, italy))
∀x ((Car(x) ∧ Carry(x, ferrariV12Engine)) → Ferrrari(x))
∀x ((Car(x) ∧ MadeIn(x, maranello)) → Carry(x, ferrariV12Engine))
¬(Ferrari(lamborghiniSUV) ∧ MadeIn(lamborghiniSUV, maranello))
(Bag(kelly) ∧ Hermès(kelly)) ∨ (Bag(kelly) ∧ Car(kelly) ∧ Carry(kelly, ferrariV12Engine))

[PREMISE (GK)]:
! [X] : ((Bag(X) & Hermès(X)) => -MadeIn(X, italy)).
! [X] : ((Bag(X) & Birkin(X)) => Hermès(X)).
! [X] : (Ferrari(X) => MadeIn(X, italy)).
! [X] : ((Car(X) & Carry(X, ferrariV12Engine)) => Ferrrari(X)).
! [X] : ((Car(X) & MadeIn(X, maranello)) => Carry(X, ferrariV12Engine)).
-(Ferrari(lamborghiniSUV) & MadeIn(lamborghiniSUV, maranello)).
(Bag(kelly) & Hermès(kelly)) | (Bag(kelly) & Car(kelly) & Carry(kelly, ferrariV12Engine)).

[CONCLUSION]:
A Lamborghini SUV is not made in Italy.

[CONCLUSION (FOL)]:
¬MadeIn(lamborghiniSUV, italy)

[CONCLUSION (GK)]:
-MadeIn(lamborghiniSUV, italy).


===

['x']
['x']
[PREMISE]:
Hermès bags are not made in Italy.
All Birkin bags are Hermès bags. 
All Ferraris are made in Italy. 
All cars that carry a Ferrari V12 engine are Ferraris. 
All cars that are made in Maranello carry a Ferrari V12 engine.
A Lamborghini SUV is not both a Ferrari and made in Maranello. 
A Kelly bag is a Hermès bag, or it is a car that carries a Ferrari V12 engine. 

[PREMISE (FOL)]:
∀x ((Bag(x) ∧ Hermès(x)) → ¬MadeIn(x, italy))
∀x ((Bag(x) ∧ Birkin(x)) → Hermès(x))
∀x (Ferrari(x) → MadeIn(x, italy))
∀x ((Car(x) ∧ Carry(x, ferrariV12Engine)) → Ferrrari(x))
∀x ((Car(x) ∧ MadeIn(x, maranello)) → Carry(x, ferrariV12Engine))
¬(Ferrari(lamborghiniSUV) ∧ MadeIn(lamborghiniSUV, maranello))
(Bag(kelly) ∧ Hermès(kelly)) ∨ (Bag(kelly) ∧ Car(kelly) ∧ Carry(kelly, ferrariV12Engine))

[PREMISE (GK)]:
! [X] : ((Bag(X) & Hermès(X)) => -MadeIn(X, italy)).
! [X] : ((Bag(X) & Birkin(X)) => Hermès(X)).
! [X] : (Ferrari(X) => MadeIn(X, italy)).
! [X] : ((Car(X) & Carry(X, ferrariV12Engine)) => Ferrrari(X)).
! [X] : ((Car(X) & MadeIn(X, maranello)) => Carry(X, ferrariV12Engine)).
-(Ferrari(lamborghiniSUV) & MadeIn(lamborghiniSUV, maranello)).
(Bag(kelly) & Hermès(kelly)) | (Bag(kelly) & Car(kelly) & Carry(kelly, ferrariV12Engine)).

[CONCLUSION]:
A Kelly bag is a Birkin bag made in Maranello.

[CONCLUSION (FOL)]:
Bag(kelly) ∧ MadeIn(kelly, maranello) ∧ Birkin(kelly)

[CONCLUSION (GK)]:
Bag(kelly) & MadeIn(kelly, maranello) & Birkin(kelly).


===

['x']
['x']
[PREMISE]:
Hermès bags are not made in Italy.
All Birkin bags are Hermès bags. 
All Ferraris are made in Italy. 
All cars that carry a Ferrari V12 engine are Ferraris. 
All cars that are made in Maranello carry a Ferrari V12 engine.
A Lamborghini SUV is not both a Ferrari and made in Maranello. 
A Kelly bag is a Hermès bag, or it is a car that carries a Ferrari V12 engine. 

[PREMISE (FOL)]:
∀x ((Bag(x) ∧ Hermès(x)) → ¬MadeIn(x, italy))
∀x ((Bag(x) ∧ Birkin(x)) → Hermès(x))
∀x (Ferrari(x) → MadeIn(x, italy))
∀x ((Car(x) ∧ Carry(x, ferrariV12Engine)) → Ferrrari(x))
∀x ((Car(x) ∧ MadeIn(x, maranello)) → Carry(x, ferrariV12Engine))
¬(Ferrari(lamborghiniSUV) ∧ MadeIn(lamborghiniSUV, maranello))
(Bag(kelly) ∧ Hermès(kelly)) ∨ (Bag(kelly) ∧ Car(kelly) ∧ Carry(kelly, ferrariV12Engine))

[PREMISE (GK)]:
! [X] : ((Bag(X) & Hermès(X)) => -MadeIn(X, italy)).
! [X] : ((Bag(X) & Birkin(X)) => Hermès(X)).
! [X] : (Ferrari(X) => MadeIn(X, italy)).
! [X] : ((Car(X) & Carry(X, ferrariV12Engine)) => Ferrrari(X)).
! [X] : ((Car(X) & MadeIn(X, maranello)) => Carry(X, ferrariV12Engine)).
-(Ferrari(lamborghiniSUV) & MadeIn(lamborghiniSUV, maranello)).
(Bag(kelly) & Hermès(kelly)) | (Bag(kelly) & Car(kelly) & Carry(kelly, ferrariV12Engine)).

[CONCLUSION]:
A Kelly bag is not both made in Maranello and a Birkin bag.

[CONCLUSION (FOL)]:
Bag(kelly) ∧ ¬(MadeIn(kelly, maranello) ∧ Birkin(kelly))

[CONCLUSION (GK)]:
Bag(kelly) & -(MadeIn(kelly, maranello) & Birkin(kelly)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If someone lives in a place named Galicia, then they live in either Spain or Poland.
Spain is in Europe.
Poland is in Europe.
Rochelle lives in Europe.
Dominique does not live in Europe.
Alfonso lives in a place named Galicia.

[PREMISE (FOL)]:
∀x (∃y (LiveIn(x, y) ∧ Place(y) ∧ Named(y, galicia)) → LiveIn(x, spain) ⊕ LiveIn(x, poland))
∀x (LiveIn(x, spain) → LiveIn(x, europe))
∀x (LiveIn(x, poland) → LiveIn(x, europe))
LiveIn(rochelle, europe)
¬LiveIn(dominique, europe)
∃y (LiveIn(alfonso, y) ∧ Place(y) ∧ Named(y, galicia))

[PREMISE (GK)]:
! [X] : (? [Y] : (LiveIn(X, Y) & Place(Y) & Named(Y, galicia)) => LiveIn(X, spain) <~> LiveIn(X, poland)).
! [X] : (LiveIn(X, spain) => LiveIn(X, europe)).
! [X] : (LiveIn(X, poland) => LiveIn(X, europe)).
LiveIn(rochelle, europe).
-LiveIn(dominique, europe).
? [Y] : (LiveIn(alfonso, Y) & Place(Y) & Named(Y, galicia)).

[CONCLUSION]:
Rochelle lives in a place namedGalicia.

[CONCLUSION (FOL)]:
∃y (LiveIn(rochelle, y) ∧ Place(y) ∧ Named(y, galicia))

[CONCLUSION (GK)]:
? [Y] : (LiveIn(rochelle, Y) & Place(Y) & Named(Y, galicia)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If someone lives in a place named Galicia, then they live in either Spain or Poland.
Spain is in Europe.
Poland is in Europe.
Rochelle lives in Europe.
Dominique does not live in Europe.
Alfonso lives in a place named Galicia.

[PREMISE (FOL)]:
∀x (∃y (LiveIn(x, y) ∧ Place(y) ∧ Named(y, galicia)) → LiveIn(x, spain) ⊕ LiveIn(x, poland))
∀x (LiveIn(x, spain) → LiveIn(x, europe))
∀x (LiveIn(x, poland) → LiveIn(x, europe))
LiveIn(rochelle, europe)
¬LiveIn(dominique, europe)
∃y (LiveIn(alfonso, y) ∧ Place(y) ∧ Named(y, galicia))

[PREMISE (GK)]:
! [X] : (? [Y] : (LiveIn(X, Y) & Place(Y) & Named(Y, galicia)) => LiveIn(X, spain) <~> LiveIn(X, poland)).
! [X] : (LiveIn(X, spain) => LiveIn(X, europe)).
! [X] : (LiveIn(X, poland) => LiveIn(X, europe)).
LiveIn(rochelle, europe).
-LiveIn(dominique, europe).
? [Y] : (LiveIn(alfonso, Y) & Place(Y) & Named(Y, galicia)).

[CONCLUSION]:
Dominique does not live in Spain.

[CONCLUSION (FOL)]:
∀x (Live(dominique, x) → ¬In(x, spain))

[CONCLUSION (GK)]:
! [X] : (Live(dominique, X) => -In(X, spain)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If someone lives in a place named Galicia, then they live in either Spain or Poland.
Spain is in Europe.
Poland is in Europe.
Rochelle lives in Europe.
Dominique does not live in Europe.
Alfonso lives in a place named Galicia.

[PREMISE (FOL)]:
∀x (∃y (LiveIn(x, y) ∧ Place(y) ∧ Named(y, galicia)) → LiveIn(x, spain) ⊕ LiveIn(x, poland))
∀x (LiveIn(x, spain) → LiveIn(x, europe))
∀x (LiveIn(x, poland) → LiveIn(x, europe))
LiveIn(rochelle, europe)
¬LiveIn(dominique, europe)
∃y (LiveIn(alfonso, y) ∧ Place(y) ∧ Named(y, galicia))

[PREMISE (GK)]:
! [X] : (? [Y] : (LiveIn(X, Y) & Place(Y) & Named(Y, galicia)) => LiveIn(X, spain) <~> LiveIn(X, poland)).
! [X] : (LiveIn(X, spain) => LiveIn(X, europe)).
! [X] : (LiveIn(X, poland) => LiveIn(X, europe)).
LiveIn(rochelle, europe).
-LiveIn(dominique, europe).
? [Y] : (LiveIn(alfonso, Y) & Place(Y) & Named(Y, galicia)).

[CONCLUSION]:
Alfonso lives in Europe.

[CONCLUSION (FOL)]:
∀x (Live(alfonso, x) → In(x, europe))

[CONCLUSION (GK)]:
! [X] : (Live(alfonso, X) => In(X, europe)).


===

[]
[]
[PREMISE]:
Ralph Hammerthaler was born in Wasserburg am Inn.
Wasserburg am Inn is in Germany.
Germany is in Europe.
Ralph Hammerthaler is a German writer.
Ralph Hammerthaler was born in 1965. 

[PREMISE (FOL)]:
BornIn(ralphHammerthaler, wasserburgamInn)
LocatedIn(wasserbAmInn, germany)
LocatedIn(germany, europe)
Writer(ralphHammerthaler) ∧ German(ralphHammerthaler)
BornIn1965(ralphHammerthaler)

[PREMISE (GK)]:
BornIn(ralphHammerthaler, wasserburgamInn).
LocatedIn(wasserbAmInn, germany).
LocatedIn(germany, europe).
Writer(ralphHammerthaler) & German(ralphHammerthaler).
BornIn1965(ralphHammerthaler).

[CONCLUSION]:
Ralph Hammerthaler is a writer born in Asia.

[CONCLUSION (FOL)]:
Writer(ralphHammerthaler) ∧ BornIn(ralphHammerthaler, asia)

[CONCLUSION (GK)]:
Writer(ralphHammerthaler) & BornIn(ralphHammerthaler, asia).


===

[]
[]
[PREMISE]:
Ralph Hammerthaler was born in Wasserburg am Inn.
Wasserburg am Inn is in Germany.
Germany is in Europe.
Ralph Hammerthaler is a German writer.
Ralph Hammerthaler was born in 1965. 

[PREMISE (FOL)]:
BornIn(ralphHammerthaler, wasserburgamInn)
LocatedIn(wasserbAmInn, germany)
LocatedIn(germany, europe)
Writer(ralphHammerthaler) ∧ German(ralphHammerthaler)
BornIn1965(ralphHammerthaler)

[PREMISE (GK)]:
BornIn(ralphHammerthaler, wasserburgamInn).
LocatedIn(wasserbAmInn, germany).
LocatedIn(germany, europe).
Writer(ralphHammerthaler) & German(ralphHammerthaler).
BornIn1965(ralphHammerthaler).

[CONCLUSION]:
Ralph Hammerthaler lives in Germany.

[CONCLUSION (FOL)]:
LivesIn(ralphHammerthaler, germany)

[CONCLUSION (GK)]:
LivesIn(ralphHammerthaler, germany).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All books written by Neil Gaiman have sold more than one thousand copies.
Some books that have won Hugo Awards are written by Neil Gaiman.
Tomas has read all books written by Tolkien. 
Either Tomas has read Hamlet, or it has sold more than one thousand copies.
Hamlet has either sold more than one thousand copies or it is written by Neil Gaiman.

[PREMISE (FOL)]:
∀x ((Book(x) ∧ WrittenBy(x, neilGaiman)) → ∃y (MoreThan(y, num1000) ∧ SoldCopies(x, y)))
∃x ∃y (Book(x) ∧ Win(x, hugoAward) ∧ WrittenBy(x, neilGaiman) ∧ (¬(x=y)) ∧ Book(y) ∧ Win(y, hugoAward) ∧ WrittenBy(y, neilGaiman))
∀x ((Book(x) ∧ WrittenBy(x, tolkien)) → ReadBy(x, tomas))
ReadBy(hamlet, tomas) ⊕ (∃y (MoreThan(y, num1000) ∧ SoldCopies(hamlet, y)))
∃y (MoreThan(y, num1000) ∧ SoldCopies(hamlet, y)) ⊕ WrittenBy(hamlet, neilGaiman)

[PREMISE (GK)]:
! [X] : ((Book(X) & WrittenBy(X, neilGaiman)) => ? [Y] : (MoreThan(Y, num1000) & SoldCopies(X, Y))).
? [X] : ? [Y] : (Book(X) & Win(X, hugoAward) & WrittenBy(X, neilGaiman) & (-(X=Y)) & Book(Y) & Win(Y, hugoAward) & WrittenBy(Y, neilGaiman)).
! [X] : ((Book(X) & WrittenBy(X, tolkien)) => ReadBy(X, tomas)).
ReadBy(hamlet, tomas) <~> (? [Y] : (MoreThan(Y, num1000) & SoldCopies(hamlet, Y))).
? [Y] : (MoreThan(Y, num1000) & SoldCopies(hamlet, Y)) <~> WrittenBy(hamlet, neilGaiman).

[CONCLUSION]:
Hamlet has won a Hugo Award.

[CONCLUSION (FOL)]:
Win(hamlet, hugoAward)

[CONCLUSION (GK)]:
Win(hamlet, hugoAward).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All books written by Neil Gaiman have sold more than one thousand copies.
Some books that have won Hugo Awards are written by Neil Gaiman.
Tomas has read all books written by Tolkien. 
Either Tomas has read Hamlet, or it has sold more than one thousand copies.
Hamlet has either sold more than one thousand copies or it is written by Neil Gaiman.

[PREMISE (FOL)]:
∀x ((Book(x) ∧ WrittenBy(x, neilGaiman)) → ∃y (MoreThan(y, num1000) ∧ SoldCopies(x, y)))
∃x ∃y (Book(x) ∧ Win(x, hugoAward) ∧ WrittenBy(x, neilGaiman) ∧ (¬(x=y)) ∧ Book(y) ∧ Win(y, hugoAward) ∧ WrittenBy(y, neilGaiman))
∀x ((Book(x) ∧ WrittenBy(x, tolkien)) → ReadBy(x, tomas))
ReadBy(hamlet, tomas) ⊕ (∃y (MoreThan(y, num1000) ∧ SoldCopies(hamlet, y)))
∃y (MoreThan(y, num1000) ∧ SoldCopies(hamlet, y)) ⊕ WrittenBy(hamlet, neilGaiman)

[PREMISE (GK)]:
! [X] : ((Book(X) & WrittenBy(X, neilGaiman)) => ? [Y] : (MoreThan(Y, num1000) & SoldCopies(X, Y))).
? [X] : ? [Y] : (Book(X) & Win(X, hugoAward) & WrittenBy(X, neilGaiman) & (-(X=Y)) & Book(Y) & Win(Y, hugoAward) & WrittenBy(Y, neilGaiman)).
! [X] : ((Book(X) & WrittenBy(X, tolkien)) => ReadBy(X, tomas)).
ReadBy(hamlet, tomas) <~> (? [Y] : (MoreThan(Y, num1000) & SoldCopies(hamlet, Y))).
? [Y] : (MoreThan(Y, num1000) & SoldCopies(hamlet, Y)) <~> WrittenBy(hamlet, neilGaiman).

[CONCLUSION]:
Hamlet has won a Hugo Award and is written by Tolkien.

[CONCLUSION (FOL)]:
Win(hamlet, hugoAward) ∧ WrittenBy(hamlet, tolkien)

[CONCLUSION (GK)]:
Win(hamlet, hugoAward) & WrittenBy(hamlet, tolkien).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All books written by Neil Gaiman have sold more than one thousand copies.
Some books that have won Hugo Awards are written by Neil Gaiman.
Tomas has read all books written by Tolkien. 
Either Tomas has read Hamlet, or it has sold more than one thousand copies.
Hamlet has either sold more than one thousand copies or it is written by Neil Gaiman.

[PREMISE (FOL)]:
∀x ((Book(x) ∧ WrittenBy(x, neilGaiman)) → ∃y (MoreThan(y, num1000) ∧ SoldCopies(x, y)))
∃x ∃y (Book(x) ∧ Win(x, hugoAward) ∧ WrittenBy(x, neilGaiman) ∧ (¬(x=y)) ∧ Book(y) ∧ Win(y, hugoAward) ∧ WrittenBy(y, neilGaiman))
∀x ((Book(x) ∧ WrittenBy(x, tolkien)) → ReadBy(x, tomas))
ReadBy(hamlet, tomas) ⊕ (∃y (MoreThan(y, num1000) ∧ SoldCopies(hamlet, y)))
∃y (MoreThan(y, num1000) ∧ SoldCopies(hamlet, y)) ⊕ WrittenBy(hamlet, neilGaiman)

[PREMISE (GK)]:
! [X] : ((Book(X) & WrittenBy(X, neilGaiman)) => ? [Y] : (MoreThan(Y, num1000) & SoldCopies(X, Y))).
? [X] : ? [Y] : (Book(X) & Win(X, hugoAward) & WrittenBy(X, neilGaiman) & (-(X=Y)) & Book(Y) & Win(Y, hugoAward) & WrittenBy(Y, neilGaiman)).
! [X] : ((Book(X) & WrittenBy(X, tolkien)) => ReadBy(X, tomas)).
ReadBy(hamlet, tomas) <~> (? [Y] : (MoreThan(Y, num1000) & SoldCopies(hamlet, Y))).
? [Y] : (MoreThan(Y, num1000) & SoldCopies(hamlet, Y)) <~> WrittenBy(hamlet, neilGaiman).

[CONCLUSION]:
If Hamlet has either won a Hugo Award and is written by Tolkien, or neither has won a Hugo Award nor is written by Tolkien, then Hamlet has neither won a Hugo Award nor is written by Neil Gaiman.

[CONCLUSION (FOL)]:
¬(Win(hamlet, hugoAward) ⊕ WrittenBy(hamlet, tolkien)) → (¬Win(hamlet, hugoAward) ∧ (¬WrittenBy(hamlet, neilGaiman)))

[CONCLUSION (GK)]:
-(Win(hamlet, hugoAward) <~> WrittenBy(hamlet, tolkien)) => (-Win(hamlet, hugoAward) & (-WrittenBy(hamlet, neilGaiman))).


===

['x']
['x']
[PREMISE]:
Grass is not food
All meadows are grass.
All edible things are food. 
All fruits are edible.
All lemons are fruit.
Grapes are not both edible and lemons.
Bananas are grasses or fruits. 

[PREMISE (FOL)]:
∀x (Grass(x) → ¬Food(x))
∀x (Meadow(x) → Grass(x))
∀x (Edible(x) → Food(x))
∀x (Fruit(x) → Edible(x))
∀x (Lemon(x) → Fruit(x))
¬(Edible(grape) ∧ Lemon(grape))
Grass(banana) ∨ Fruit(banana)

[PREMISE (GK)]:
! [X] : (Grass(X) => -Food(X)).
! [X] : (Meadow(X) => Grass(X)).
! [X] : (Edible(X) => Food(X)).
! [X] : (Fruit(X) => Edible(X)).
! [X] : (Lemon(X) => Fruit(X)).
-(Edible(grape) & Lemon(grape)).
Grass(banana) | Fruit(banana).

[CONCLUSION]:
Grapes are food.

[CONCLUSION (FOL)]:
Food(grape)

[CONCLUSION (GK)]:
Food(grape).


===

['x']
['x']
[PREMISE]:
Grass is not food
All meadows are grass.
All edible things are food. 
All fruits are edible.
All lemons are fruit.
Grapes are not both edible and lemons.
Bananas are grasses or fruits. 

[PREMISE (FOL)]:
∀x (Grass(x) → ¬Food(x))
∀x (Meadow(x) → Grass(x))
∀x (Edible(x) → Food(x))
∀x (Fruit(x) → Edible(x))
∀x (Lemon(x) → Fruit(x))
¬(Edible(grape) ∧ Lemon(grape))
Grass(banana) ∨ Fruit(banana)

[PREMISE (GK)]:
! [X] : (Grass(X) => -Food(X)).
! [X] : (Meadow(X) => Grass(X)).
! [X] : (Edible(X) => Food(X)).
! [X] : (Fruit(X) => Edible(X)).
! [X] : (Lemon(X) => Fruit(X)).
-(Edible(grape) & Lemon(grape)).
Grass(banana) | Fruit(banana).

[CONCLUSION]:
Grapes are not a food.

[CONCLUSION (FOL)]:
¬Food(grape)

[CONCLUSION (GK)]:
-Food(grape).


===

['x']
['x']
[PREMISE]:
Grass is not food
All meadows are grass.
All edible things are food. 
All fruits are edible.
All lemons are fruit.
Grapes are not both edible and lemons.
Bananas are grasses or fruits. 

[PREMISE (FOL)]:
∀x (Grass(x) → ¬Food(x))
∀x (Meadow(x) → Grass(x))
∀x (Edible(x) → Food(x))
∀x (Fruit(x) → Edible(x))
∀x (Lemon(x) → Fruit(x))
¬(Edible(grape) ∧ Lemon(grape))
Grass(banana) ∨ Fruit(banana)

[PREMISE (GK)]:
! [X] : (Grass(X) => -Food(X)).
! [X] : (Meadow(X) => Grass(X)).
! [X] : (Edible(X) => Food(X)).
! [X] : (Fruit(X) => Edible(X)).
! [X] : (Lemon(X) => Fruit(X)).
-(Edible(grape) & Lemon(grape)).
Grass(banana) | Fruit(banana).

[CONCLUSION]:
Bananas are both lemons and meadows.

[CONCLUSION (FOL)]:
Lemon(banana) ∧ Meadow(banana)

[CONCLUSION (GK)]:
Lemon(banana) & Meadow(banana).


===

['x']
['x']
[PREMISE]:
Grass is not food
All meadows are grass.
All edible things are food. 
All fruits are edible.
All lemons are fruit.
Grapes are not both edible and lemons.
Bananas are grasses or fruits. 

[PREMISE (FOL)]:
∀x (Grass(x) → ¬Food(x))
∀x (Meadow(x) → Grass(x))
∀x (Edible(x) → Food(x))
∀x (Fruit(x) → Edible(x))
∀x (Lemon(x) → Fruit(x))
¬(Edible(grape) ∧ Lemon(grape))
Grass(banana) ∨ Fruit(banana)

[PREMISE (GK)]:
! [X] : (Grass(X) => -Food(X)).
! [X] : (Meadow(X) => Grass(X)).
! [X] : (Edible(X) => Food(X)).
! [X] : (Fruit(X) => Edible(X)).
! [X] : (Lemon(X) => Fruit(X)).
-(Edible(grape) & Lemon(grape)).
Grass(banana) | Fruit(banana).

[CONCLUSION]:
Bananas are not both a lemon and a meadow.

[CONCLUSION (FOL)]:
¬(Lemon(banana) ∧ Meadow(banana))

[CONCLUSION (GK)]:
-(Lemon(banana) & Meadow(banana)).


===

['x']
['x']
[PREMISE]:
The Golden State Warriors are a team from San Francisco.
The Golden State Warriors won the NBA finals.
All teams attending the NBA finals have won many games.
Boston Celtics are a team that lost the NBA finals.
If a team wins the NBA finals, then they will have more income.
If a team wins or loses at the NBA finals, then they are attending the finals.

[PREMISE (FOL)]:
Team(goldenStateWarriors) ∧ From(goldenStateWarriors, sanFrancisco)
Won(goldenStateWarriors, nbaFinals)
∀x ((Team(x) ∧ Attending(x, nbaFinals)) → WonManyGames(x))
Team(bostonCeltics) ∧ Lost(bostonCeltics, nbaFinals)
∀x ((Team(x) ∧ Won(x, nbaFinals)) → MoreIncome(x))
∀x ((Won(x, nbaFinals) ∨ Lost(x, nbaFinals)) → Attending(x, nbaFinals))

[PREMISE (GK)]:
Team(goldenStateWarriors) & From(goldenStateWarriors, sanFrancisco).
Won(goldenStateWarriors, nbaFinals).
! [X] : ((Team(X) & Attending(X, nbaFinals)) => WonManyGames(X)).
Team(bostonCeltics) & Lost(bostonCeltics, nbaFinals).
! [X] : ((Team(X) & Won(X, nbaFinals)) => MoreIncome(X)).
! [X] : ((Won(X, nbaFinals) | Lost(X, nbaFinals)) => Attending(X, nbaFinals)).

[CONCLUSION]:
The Boston Celtics are from San Francisco.

[CONCLUSION (FOL)]:
From(bostonCeltics, sanFrancisco)

[CONCLUSION (GK)]:
From(bostonCeltics, sanFrancisco).


===

['x']
['x']
[PREMISE]:
The Golden State Warriors are a team from San Francisco.
The Golden State Warriors won the NBA finals.
All teams attending the NBA finals have won many games.
Boston Celtics are a team that lost the NBA finals.
If a team wins the NBA finals, then they will have more income.
If a team wins or loses at the NBA finals, then they are attending the finals.

[PREMISE (FOL)]:
Team(goldenStateWarriors) ∧ From(goldenStateWarriors, sanFrancisco)
Won(goldenStateWarriors, nbaFinals)
∀x ((Team(x) ∧ Attending(x, nbaFinals)) → WonManyGames(x))
Team(bostonCeltics) ∧ Lost(bostonCeltics, nbaFinals)
∀x ((Team(x) ∧ Won(x, nbaFinals)) → MoreIncome(x))
∀x ((Won(x, nbaFinals) ∨ Lost(x, nbaFinals)) → Attending(x, nbaFinals))

[PREMISE (GK)]:
Team(goldenStateWarriors) & From(goldenStateWarriors, sanFrancisco).
Won(goldenStateWarriors, nbaFinals).
! [X] : ((Team(X) & Attending(X, nbaFinals)) => WonManyGames(X)).
Team(bostonCeltics) & Lost(bostonCeltics, nbaFinals).
! [X] : ((Team(X) & Won(X, nbaFinals)) => MoreIncome(X)).
! [X] : ((Won(X, nbaFinals) | Lost(X, nbaFinals)) => Attending(X, nbaFinals)).

[CONCLUSION]:
The Boston Celtics have more than 30 years of experience.

[CONCLUSION (FOL)]:
HasMoreThanThirtyYearsOfHistory(bostonCeltics)

[CONCLUSION (GK)]:
HasMoreThanThirtyYearsOfHistory(bostonCeltics).


===

['x']
['x']
[PREMISE]:
The Golden State Warriors are a team from San Francisco.
The Golden State Warriors won the NBA finals.
All teams attending the NBA finals have won many games.
Boston Celtics are a team that lost the NBA finals.
If a team wins the NBA finals, then they will have more income.
If a team wins or loses at the NBA finals, then they are attending the finals.

[PREMISE (FOL)]:
Team(goldenStateWarriors) ∧ From(goldenStateWarriors, sanFrancisco)
Won(goldenStateWarriors, nbaFinals)
∀x ((Team(x) ∧ Attending(x, nbaFinals)) → WonManyGames(x))
Team(bostonCeltics) ∧ Lost(bostonCeltics, nbaFinals)
∀x ((Team(x) ∧ Won(x, nbaFinals)) → MoreIncome(x))
∀x ((Won(x, nbaFinals) ∨ Lost(x, nbaFinals)) → Attending(x, nbaFinals))

[PREMISE (GK)]:
Team(goldenStateWarriors) & From(goldenStateWarriors, sanFrancisco).
Won(goldenStateWarriors, nbaFinals).
! [X] : ((Team(X) & Attending(X, nbaFinals)) => WonManyGames(X)).
Team(bostonCeltics) & Lost(bostonCeltics, nbaFinals).
! [X] : ((Team(X) & Won(X, nbaFinals)) => MoreIncome(X)).
! [X] : ((Won(X, nbaFinals) | Lost(X, nbaFinals)) => Attending(X, nbaFinals)).

[CONCLUSION]:
The Golden State Warriors will have more income from gate receipts.

[CONCLUSION (FOL)]:
MoreIncome(goldenStateWarriors)

[CONCLUSION (GK)]:
MoreIncome(goldenStateWarriors).


===

['x']
['x']
[PREMISE]:
Maya would only play the violin if her fingers could never be injured. 
Volleyball players can injure their ankles, fingers, or shoulder.
Maya is a volleyball player.

[PREMISE (FOL)]:
Play(maya, violin) → ¬CanInjure(maya, fingers)
∀x (VolleyballPlayer(x) → (CanInjure(ankles) ∧ CanInjure(fingers) ∧ CanInjure(shoulder)))
VolleyballPlayer(maya)

[PREMISE (GK)]:
Play(maya, violin) => -CanInjure(maya, fingers).
! [X] : (VolleyballPlayer(X) => (CanInjure(ankles) & CanInjure(fingers) & CanInjure(shoulder))).
VolleyballPlayer(maya).

[CONCLUSION]:
Maya will not play the violin.

[CONCLUSION (FOL)]:
¬Play(maya, violin)

[CONCLUSION (GK)]:
-Play(maya, violin).


===

['x']
['x']
[PREMISE]:
All devices belonging to the company are connected to Google Home. 
All devices with the company logo belong to the company. 
Each device either has the company logo or belongs to employees. 
All of the devices belonging to employees can be connected to the company's wifi. 
All of the devices connected to Google Home are controlled by managers. 
All of the devices that connect to the company's wifi are easy to operate. 
All of the devices that are easy to operate were produced after a new CTO is appointed. 
ModelXX was not produced after a new CTO was appointed.

[PREMISE (FOL)]:
∀x ((Devices(x) ∧ BelongTo(x, company)) → ConnectTo(x, googleHome))
∀x ((Devices(x) ∧ With(x, companyLogo)) → BelongTo(x, company))
∀x ((Devices(x) → (With(x, companyLogo) ⊕ BelongTo(x, employee)))
∀x ((Devices(x) ∧ BelongTo(x, employee)) → CanBeConnectedTo(x, wifi))
∀x ((Devices(x) ∧ ConnectTo(x, googleHome)) → ControlledBy(x, manager))
∀x ((Devices(x) ∧ CanBeConnectedTo(x, wifi)) → EasyToOperate(x))
∀x ((Devices(x) ∧ EasyToOperate(x)) → ProducedAfterNewCTOAppointed(x, company))
Devices(modelXX) ∧ (¬ProducedAfterNewCTOAppointed(modelXX, company))

[PREMISE (GK)]:
! [X] : ((Devices(X) & BelongTo(X, company)) => ConnectTo(X, googleHome)).
! [X] : ((Devices(X) & With(X, companyLogo)) => BelongTo(X, company)).
! [X] : ((Devices(X) => (With(X, companyLogo) <~> BelongTo(X, employee))).
! [X] : ((Devices(X) & BelongTo(X, employee)) => CanBeConnectedTo(X, wifi)).
! [X] : ((Devices(X) & ConnectTo(X, googleHome)) => ControlledBy(X, manager)).
! [X] : ((Devices(X) & CanBeConnectedTo(X, wifi)) => EasyToOperate(X)).
! [X] : ((Devices(X) & EasyToOperate(X)) => ProducedAfterNewCTOAppointed(X, company)).
Devices(modelXX) & (-ProducedAfterNewCTOAppointed(modelXX, company)).

[CONCLUSION]:
ModelXX is controlled by managers.

[CONCLUSION (FOL)]:
ControlledBy(x, manager)

[CONCLUSION (GK)]:
ControlledBy(X, manager).


===

['x']
['x']
[PREMISE]:
All devices belonging to the company are connected to Google Home. 
All devices with the company logo belong to the company. 
Each device either has the company logo or belongs to employees. 
All of the devices belonging to employees can be connected to the company's wifi. 
All of the devices connected to Google Home are controlled by managers. 
All of the devices that connect to the company's wifi are easy to operate. 
All of the devices that are easy to operate were produced after a new CTO is appointed. 
ModelXX was not produced after a new CTO was appointed.

[PREMISE (FOL)]:
∀x ((Devices(x) ∧ BelongTo(x, company)) → ConnectTo(x, googleHome))
∀x ((Devices(x) ∧ With(x, companyLogo)) → BelongTo(x, company))
∀x ((Devices(x) → (With(x, companyLogo) ⊕ BelongTo(x, employee)))
∀x ((Devices(x) ∧ BelongTo(x, employee)) → CanBeConnectedTo(x, wifi))
∀x ((Devices(x) ∧ ConnectTo(x, googleHome)) → ControlledBy(x, manager))
∀x ((Devices(x) ∧ CanBeConnectedTo(x, wifi)) → EasyToOperate(x))
∀x ((Devices(x) ∧ EasyToOperate(x)) → ProducedAfterNewCTOAppointed(x, company))
Devices(modelXX) ∧ (¬ProducedAfterNewCTOAppointed(modelXX, company))

[PREMISE (GK)]:
! [X] : ((Devices(X) & BelongTo(X, company)) => ConnectTo(X, googleHome)).
! [X] : ((Devices(X) & With(X, companyLogo)) => BelongTo(X, company)).
! [X] : ((Devices(X) => (With(X, companyLogo) <~> BelongTo(X, employee))).
! [X] : ((Devices(X) & BelongTo(X, employee)) => CanBeConnectedTo(X, wifi)).
! [X] : ((Devices(X) & ConnectTo(X, googleHome)) => ControlledBy(X, manager)).
! [X] : ((Devices(X) & CanBeConnectedTo(X, wifi)) => EasyToOperate(X)).
! [X] : ((Devices(X) & EasyToOperate(X)) => ProducedAfterNewCTOAppointed(X, company)).
Devices(modelXX) & (-ProducedAfterNewCTOAppointed(modelXX, company)).

[CONCLUSION]:
ModelXX is either produced after a new CTO was appointed or it is controlled by managers.

[CONCLUSION (FOL)]:
ProducedAfterNewCTOAppointed(modelXX, theCompany) ⊕ ControlledBy(x, manager)

[CONCLUSION (GK)]:
ProducedAfterNewCTOAppointed(modelXX, theCompany) <~> ControlledBy(X, manager).


===

['x']
['x']
[PREMISE]:
All devices belonging to the company are connected to Google Home. 
All devices with the company logo belong to the company. 
Each device either has the company logo or belongs to employees. 
All of the devices belonging to employees can be connected to the company's wifi. 
All of the devices connected to Google Home are controlled by managers. 
All of the devices that connect to the company's wifi are easy to operate. 
All of the devices that are easy to operate were produced after a new CTO is appointed. 
ModelXX was not produced after a new CTO was appointed.

[PREMISE (FOL)]:
∀x ((Devices(x) ∧ BelongTo(x, company)) → ConnectTo(x, googleHome))
∀x ((Devices(x) ∧ With(x, companyLogo)) → BelongTo(x, company))
∀x ((Devices(x) → (With(x, companyLogo) ⊕ BelongTo(x, employee)))
∀x ((Devices(x) ∧ BelongTo(x, employee)) → CanBeConnectedTo(x, wifi))
∀x ((Devices(x) ∧ ConnectTo(x, googleHome)) → ControlledBy(x, manager))
∀x ((Devices(x) ∧ CanBeConnectedTo(x, wifi)) → EasyToOperate(x))
∀x ((Devices(x) ∧ EasyToOperate(x)) → ProducedAfterNewCTOAppointed(x, company))
Devices(modelXX) ∧ (¬ProducedAfterNewCTOAppointed(modelXX, company))

[PREMISE (GK)]:
! [X] : ((Devices(X) & BelongTo(X, company)) => ConnectTo(X, googleHome)).
! [X] : ((Devices(X) & With(X, companyLogo)) => BelongTo(X, company)).
! [X] : ((Devices(X) => (With(X, companyLogo) <~> BelongTo(X, employee))).
! [X] : ((Devices(X) & BelongTo(X, employee)) => CanBeConnectedTo(X, wifi)).
! [X] : ((Devices(X) & ConnectTo(X, googleHome)) => ControlledBy(X, manager)).
! [X] : ((Devices(X) & CanBeConnectedTo(X, wifi)) => EasyToOperate(X)).
! [X] : ((Devices(X) & EasyToOperate(X)) => ProducedAfterNewCTOAppointed(X, company)).
Devices(modelXX) & (-ProducedAfterNewCTOAppointed(modelXX, company)).

[CONCLUSION]:
ModelXX is not with the company logo, and managers do not control it.

[CONCLUSION (FOL)]:
¬With(modelXX, companyLogo) ∧ (¬ControlledBy(x, manager))

[CONCLUSION (GK)]:
-With(modelXX, companyLogo) & (-ControlledBy(X, manager)).


===

['x']
['x']
[PREMISE]:
All devices belonging to the company are connected to Google Home. 
All devices with the company logo belong to the company. 
Each device either has the company logo or belongs to employees. 
All of the devices belonging to employees can be connected to the company's wifi. 
All of the devices connected to Google Home are controlled by managers. 
All of the devices that connect to the company's wifi are easy to operate. 
All of the devices that are easy to operate were produced after a new CTO is appointed. 
ModelXX was not produced after a new CTO was appointed.

[PREMISE (FOL)]:
∀x ((Devices(x) ∧ BelongTo(x, company)) → ConnectTo(x, googleHome))
∀x ((Devices(x) ∧ With(x, companyLogo)) → BelongTo(x, company))
∀x ((Devices(x) → (With(x, companyLogo) ⊕ BelongTo(x, employee)))
∀x ((Devices(x) ∧ BelongTo(x, employee)) → CanBeConnectedTo(x, wifi))
∀x ((Devices(x) ∧ ConnectTo(x, googleHome)) → ControlledBy(x, manager))
∀x ((Devices(x) ∧ CanBeConnectedTo(x, wifi)) → EasyToOperate(x))
∀x ((Devices(x) ∧ EasyToOperate(x)) → ProducedAfterNewCTOAppointed(x, company))
Devices(modelXX) ∧ (¬ProducedAfterNewCTOAppointed(modelXX, company))

[PREMISE (GK)]:
! [X] : ((Devices(X) & BelongTo(X, company)) => ConnectTo(X, googleHome)).
! [X] : ((Devices(X) & With(X, companyLogo)) => BelongTo(X, company)).
! [X] : ((Devices(X) => (With(X, companyLogo) <~> BelongTo(X, employee))).
! [X] : ((Devices(X) & BelongTo(X, employee)) => CanBeConnectedTo(X, wifi)).
! [X] : ((Devices(X) & ConnectTo(X, googleHome)) => ControlledBy(X, manager)).
! [X] : ((Devices(X) & CanBeConnectedTo(X, wifi)) => EasyToOperate(X)).
! [X] : ((Devices(X) & EasyToOperate(X)) => ProducedAfterNewCTOAppointed(X, company)).
Devices(modelXX) & (-ProducedAfterNewCTOAppointed(modelXX, company)).

[CONCLUSION]:
ModelXX is either with the company logo or controlled by managers.

[CONCLUSION (FOL)]:
With(modelXX, companyLogo) ⊕ ControlledBy(x, manager)

[CONCLUSION (GK)]:
With(modelXX, companyLogo) <~> ControlledBy(X, manager).


===

['x']
['x', 'y']
[PREMISE]:
All CD players are delicate mechanisms.
No delicate mechanisms are suitable toys for children.

[PREMISE (FOL)]:
∀x (CDPlayer(x) → DelicateMechanism(x))
∀x (DelicateMechanism(x) → ¬(Toy(x) ∧ SuitableFor(x, children)))

[PREMISE (GK)]:
! [X] : (CDPlayer(X) => DelicateMechanism(X)).
! [X] : (DelicateMechanism(X) => -(Toy(X) & SuitableFor(X, children))).

[CONCLUSION]:
Some CD players are suitable toys for children.

[CONCLUSION (FOL)]:
∃x ∃y (CDPlayer(x) ∧ CDPlayer(y) ∧ Toy(x) ∧ Toy(y) ∧ SuitableFor(x, children) ∧ SuitableFor(y, children) ∧ ¬(x=y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (CDPlayer(X) & CDPlayer(Y) & Toy(X) & Toy(Y) & SuitableFor(X, children) & SuitableFor(Y, children) & -(X=Y)).


===

['x']
['x']
[PREMISE]:
All mammals are living beings.
All elephants are mammals.
All baby elephants are elephants.
Some baby elephants are sleepy.
If Jumbo is a living being, then Jumbo is not both an elephant and a mammal.
If Jumbo is sleepy, then Jumbo is either a baby elephant or a mammal.

[PREMISE (FOL)]:
∀x (Mammal(x) → LivingBeing(x)) 
∀x (Elephant(x) → Mammal(x))
∀x (BabyElephant(x) → Elephant(x))
∃x (BabyElephant(x) ∧ Sleepy(x))
LivingBeing(jumbo) → ¬(Elephant(jumbo) ∧ Mammal(jumbo))
Sleepy(jumbo) → BabyElephant(jumbo) ⊕ Mammal(jumbo)

[PREMISE (GK)]:
! [X] : (Mammal(X) => LivingBeing(X)) .
! [X] : (Elephant(X) => Mammal(X)).
! [X] : (BabyElephant(X) => Elephant(X)).
? [X] : (BabyElephant(X) & Sleepy(X)).
LivingBeing(jumbo) => -(Elephant(jumbo) & Mammal(jumbo)).
Sleepy(jumbo) => BabyElephant(jumbo) <~> Mammal(jumbo).

[CONCLUSION]:
Jumbo is sleepy.

[CONCLUSION (FOL)]:
Sleepy(jumbo)

[CONCLUSION (GK)]:
Sleepy(jumbo).


===

['x']
['x']
[PREMISE]:
All mammals are living beings.
All elephants are mammals.
All baby elephants are elephants.
Some baby elephants are sleepy.
If Jumbo is a living being, then Jumbo is not both an elephant and a mammal.
If Jumbo is sleepy, then Jumbo is either a baby elephant or a mammal.

[PREMISE (FOL)]:
∀x (Mammal(x) → LivingBeing(x)) 
∀x (Elephant(x) → Mammal(x))
∀x (BabyElephant(x) → Elephant(x))
∃x (BabyElephant(x) ∧ Sleepy(x))
LivingBeing(jumbo) → ¬(Elephant(jumbo) ∧ Mammal(jumbo))
Sleepy(jumbo) → BabyElephant(jumbo) ⊕ Mammal(jumbo)

[PREMISE (GK)]:
! [X] : (Mammal(X) => LivingBeing(X)) .
! [X] : (Elephant(X) => Mammal(X)).
! [X] : (BabyElephant(X) => Elephant(X)).
? [X] : (BabyElephant(X) & Sleepy(X)).
LivingBeing(jumbo) => -(Elephant(jumbo) & Mammal(jumbo)).
Sleepy(jumbo) => BabyElephant(jumbo) <~> Mammal(jumbo).

[CONCLUSION]:
Jumbo is not sleepy.

[CONCLUSION (FOL)]:
¬Sleepy(jumbo)

[CONCLUSION (GK)]:
-Sleepy(jumbo).


===

['x']
['x']
[PREMISE]:
All mammals are living beings.
All elephants are mammals.
All baby elephants are elephants.
Some baby elephants are sleepy.
If Jumbo is a living being, then Jumbo is not both an elephant and a mammal.
If Jumbo is sleepy, then Jumbo is either a baby elephant or a mammal.

[PREMISE (FOL)]:
∀x (Mammal(x) → LivingBeing(x)) 
∀x (Elephant(x) → Mammal(x))
∀x (BabyElephant(x) → Elephant(x))
∃x (BabyElephant(x) ∧ Sleepy(x))
LivingBeing(jumbo) → ¬(Elephant(jumbo) ∧ Mammal(jumbo))
Sleepy(jumbo) → BabyElephant(jumbo) ⊕ Mammal(jumbo)

[PREMISE (GK)]:
! [X] : (Mammal(X) => LivingBeing(X)) .
! [X] : (Elephant(X) => Mammal(X)).
! [X] : (BabyElephant(X) => Elephant(X)).
? [X] : (BabyElephant(X) & Sleepy(X)).
LivingBeing(jumbo) => -(Elephant(jumbo) & Mammal(jumbo)).
Sleepy(jumbo) => BabyElephant(jumbo) <~> Mammal(jumbo).

[CONCLUSION]:
Jumbo is a living being.

[CONCLUSION (FOL)]:
LivingBeing(jumbo)

[CONCLUSION (GK)]:
LivingBeing(jumbo).


===

['x']
['x']
[PREMISE]:
All mammals are living beings.
All elephants are mammals.
All baby elephants are elephants.
Some baby elephants are sleepy.
If Jumbo is a living being, then Jumbo is not both an elephant and a mammal.
If Jumbo is sleepy, then Jumbo is either a baby elephant or a mammal.

[PREMISE (FOL)]:
∀x (Mammal(x) → LivingBeing(x)) 
∀x (Elephant(x) → Mammal(x))
∀x (BabyElephant(x) → Elephant(x))
∃x (BabyElephant(x) ∧ Sleepy(x))
LivingBeing(jumbo) → ¬(Elephant(jumbo) ∧ Mammal(jumbo))
Sleepy(jumbo) → BabyElephant(jumbo) ⊕ Mammal(jumbo)

[PREMISE (GK)]:
! [X] : (Mammal(X) => LivingBeing(X)) .
! [X] : (Elephant(X) => Mammal(X)).
! [X] : (BabyElephant(X) => Elephant(X)).
? [X] : (BabyElephant(X) & Sleepy(X)).
LivingBeing(jumbo) => -(Elephant(jumbo) & Mammal(jumbo)).
Sleepy(jumbo) => BabyElephant(jumbo) <~> Mammal(jumbo).

[CONCLUSION]:
Jumbo is neither sleepy nor a baby elephant.

[CONCLUSION (FOL)]:
¬Sleepy(jumbo) ∧ ¬BabyElephant(jumbo))

[CONCLUSION (GK)]:
-Sleepy(jumbo) & -BabyElephant(jumbo)).


===

['x']
['x']
[PREMISE]:
All mammals are living beings.
All elephants are mammals.
All baby elephants are elephants.
Some baby elephants are sleepy.
If Jumbo is a living being, then Jumbo is not both an elephant and a mammal.
If Jumbo is sleepy, then Jumbo is either a baby elephant or a mammal.

[PREMISE (FOL)]:
∀x (Mammal(x) → LivingBeing(x)) 
∀x (Elephant(x) → Mammal(x))
∀x (BabyElephant(x) → Elephant(x))
∃x (BabyElephant(x) ∧ Sleepy(x))
LivingBeing(jumbo) → ¬(Elephant(jumbo) ∧ Mammal(jumbo))
Sleepy(jumbo) → BabyElephant(jumbo) ⊕ Mammal(jumbo)

[PREMISE (GK)]:
! [X] : (Mammal(X) => LivingBeing(X)) .
! [X] : (Elephant(X) => Mammal(X)).
! [X] : (BabyElephant(X) => Elephant(X)).
? [X] : (BabyElephant(X) & Sleepy(X)).
LivingBeing(jumbo) => -(Elephant(jumbo) & Mammal(jumbo)).
Sleepy(jumbo) => BabyElephant(jumbo) <~> Mammal(jumbo).

[CONCLUSION]:
Jumbo is not sleepy or an elephant.

[CONCLUSION (FOL)]:
¬(Sleepy(jumbo) ⊕ Elephant(jumbo))

[CONCLUSION (GK)]:
-(Sleepy(jumbo) <~> Elephant(jumbo)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
No planet in the solar system relies on nuclear fusion to generate light.
All stars in the solar system rely on nuclear fusion to generate light. 
All celestial bodies in the solar systems that have greater than 0.08 solar masses are stars. 
If a celestial body in the solar system has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity, then it is a planet.
If Europa is a celestial body in the solar system that has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity or relies on nuclear fusion to generate light, then Europa is a celestial body in the solar system. 

[PREMISE (FOL)]:
∀x (Planet(x) ∧ In(x, solarSystem) → ¬RelyOnToGenerate(x, nuclearFusion, light))
∀x (Star(x) ∧ In(x, solarSystem) → RelyOnToGenerate(x, nuclearFusion, light))
∀x (CelestialBody(x) ∧ In(x, solarSystem) ∧ GreaterThan(x, solarMass, 0point08) → Star(x))
∀x (CelestialBody(x) ∧ In(x, solarSystem) ∧ (∃y (OrbitOf(y, x) ∧ Clear(x, y) ∧ DebrisFree(y))) ∧ NearlySphericalShape(x, gravity) → Planet(x))
(CelestialBody(europa) ∧ In(europa, solarSystem) ∧ (∃y (OrbitOf(y, x) ∧ Clear(x, y) ∧ DebrisFree(y))) ∧ NearlySphericalShape(europa, gravity)) ∨ RelyOnToGenerate(europa, nuclearFusion, light) → CelestialBody(europa) ∧ In(europa, solarSystem)

[PREMISE (GK)]:
! [X] : (Planet(X) & In(X, solarSystem) => -RelyOnToGenerate(X, nuclearFusion, light)).
! [X] : (Star(X) & In(X, solarSystem) => RelyOnToGenerate(X, nuclearFusion, light)).
! [X] : (CelestialBody(X) & In(X, solarSystem) & GreaterThan(X, solarMass, 0point08) => Star(X)).
! [X] : (CelestialBody(X) & In(X, solarSystem) & (? [Y] : (OrbitOf(Y, X) & Clear(X, Y) & DebrisFree(Y))) & NearlySphericalShape(X, gravity) => Planet(X)).
(CelestialBody(europa) & In(europa, solarSystem) & (? [Y] : (OrbitOf(Y, x) & Clear(x, Y) & DebrisFree(Y))) & NearlySphericalShape(europa, gravity)) | RelyOnToGenerate(europa, nuclearFusion, light) => CelestialBody(europa) & In(europa, solarSystem).

[CONCLUSION]:
Europa is a celestial body in the solar system has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity.

[CONCLUSION (FOL)]:
CelestialBody(europa) ∧ In(europa, solarSystem) ∧ (∃y (OrbitOf(y, x) ∧ Clear(x, y) ∧ DebrisFree(y))) ∧ NearlySphericalShape(europa, gravity)

[CONCLUSION (GK)]:
CelestialBody(europa) & In(europa, solarSystem) & (? [Y] : (OrbitOf(Y, X) & Clear(X, Y) & DebrisFree(Y))) & NearlySphericalShape(europa, gravity).


===

['x', 'y']
['x', 'y']
[PREMISE]:
No planet in the solar system relies on nuclear fusion to generate light.
All stars in the solar system rely on nuclear fusion to generate light. 
All celestial bodies in the solar systems that have greater than 0.08 solar masses are stars. 
If a celestial body in the solar system has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity, then it is a planet.
If Europa is a celestial body in the solar system that has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity or relies on nuclear fusion to generate light, then Europa is a celestial body in the solar system. 

[PREMISE (FOL)]:
∀x (Planet(x) ∧ In(x, solarSystem) → ¬RelyOnToGenerate(x, nuclearFusion, light))
∀x (Star(x) ∧ In(x, solarSystem) → RelyOnToGenerate(x, nuclearFusion, light))
∀x (CelestialBody(x) ∧ In(x, solarSystem) ∧ GreaterThan(x, solarMass, 0point08) → Star(x))
∀x (CelestialBody(x) ∧ In(x, solarSystem) ∧ (∃y (OrbitOf(y, x) ∧ Clear(x, y) ∧ DebrisFree(y))) ∧ NearlySphericalShape(x, gravity) → Planet(x))
(CelestialBody(europa) ∧ In(europa, solarSystem) ∧ (∃y (OrbitOf(y, x) ∧ Clear(x, y) ∧ DebrisFree(y))) ∧ NearlySphericalShape(europa, gravity)) ∨ RelyOnToGenerate(europa, nuclearFusion, light) → CelestialBody(europa) ∧ In(europa, solarSystem)

[PREMISE (GK)]:
! [X] : (Planet(X) & In(X, solarSystem) => -RelyOnToGenerate(X, nuclearFusion, light)).
! [X] : (Star(X) & In(X, solarSystem) => RelyOnToGenerate(X, nuclearFusion, light)).
! [X] : (CelestialBody(X) & In(X, solarSystem) & GreaterThan(X, solarMass, 0point08) => Star(X)).
! [X] : (CelestialBody(X) & In(X, solarSystem) & (? [Y] : (OrbitOf(Y, X) & Clear(X, Y) & DebrisFree(Y))) & NearlySphericalShape(X, gravity) => Planet(X)).
(CelestialBody(europa) & In(europa, solarSystem) & (? [Y] : (OrbitOf(Y, x) & Clear(x, Y) & DebrisFree(Y))) & NearlySphericalShape(europa, gravity)) | RelyOnToGenerate(europa, nuclearFusion, light) => CelestialBody(europa) & In(europa, solarSystem).

[CONCLUSION]:
Europa is a celestial body in one of the solar systems that have greater than 0.08 solar masses.

[CONCLUSION (FOL)]:
CelestialBody(europa) ∧ In(europa, solarSystem) ∧ GreaterThan(europa, solarMass, 0.08)

[CONCLUSION (GK)]:
CelestialBody(europa) & In(europa, solarSystem) & GreaterThan(europa, solarMass, 0.08).


===

['x', 'y']
['x', 'y']
[PREMISE]:
No planet in the solar system relies on nuclear fusion to generate light.
All stars in the solar system rely on nuclear fusion to generate light. 
All celestial bodies in the solar systems that have greater than 0.08 solar masses are stars. 
If a celestial body in the solar system has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity, then it is a planet.
If Europa is a celestial body in the solar system that has cleared its orbit of other debris and has a nearly spherical shape due to its own gravity or relies on nuclear fusion to generate light, then Europa is a celestial body in the solar system. 

[PREMISE (FOL)]:
∀x (Planet(x) ∧ In(x, solarSystem) → ¬RelyOnToGenerate(x, nuclearFusion, light))
∀x (Star(x) ∧ In(x, solarSystem) → RelyOnToGenerate(x, nuclearFusion, light))
∀x (CelestialBody(x) ∧ In(x, solarSystem) ∧ GreaterThan(x, solarMass, 0point08) → Star(x))
∀x (CelestialBody(x) ∧ In(x, solarSystem) ∧ (∃y (OrbitOf(y, x) ∧ Clear(x, y) ∧ DebrisFree(y))) ∧ NearlySphericalShape(x, gravity) → Planet(x))
(CelestialBody(europa) ∧ In(europa, solarSystem) ∧ (∃y (OrbitOf(y, x) ∧ Clear(x, y) ∧ DebrisFree(y))) ∧ NearlySphericalShape(europa, gravity)) ∨ RelyOnToGenerate(europa, nuclearFusion, light) → CelestialBody(europa) ∧ In(europa, solarSystem)

[PREMISE (GK)]:
! [X] : (Planet(X) & In(X, solarSystem) => -RelyOnToGenerate(X, nuclearFusion, light)).
! [X] : (Star(X) & In(X, solarSystem) => RelyOnToGenerate(X, nuclearFusion, light)).
! [X] : (CelestialBody(X) & In(X, solarSystem) & GreaterThan(X, solarMass, 0point08) => Star(X)).
! [X] : (CelestialBody(X) & In(X, solarSystem) & (? [Y] : (OrbitOf(Y, X) & Clear(X, Y) & DebrisFree(Y))) & NearlySphericalShape(X, gravity) => Planet(X)).
(CelestialBody(europa) & In(europa, solarSystem) & (? [Y] : (OrbitOf(Y, x) & Clear(x, Y) & DebrisFree(Y))) & NearlySphericalShape(europa, gravity)) | RelyOnToGenerate(europa, nuclearFusion, light) => CelestialBody(europa) & In(europa, solarSystem).

[CONCLUSION]:
Europa is not a celestial body in one of the solar systems that have greater than 0.08 solar masses.

[CONCLUSION (FOL)]:
¬(CelestialBody(europa) ∧ In(europa, solarSystem) ∧ GreaterThan(europa, solarMass, 0.08))

[CONCLUSION (GK)]:
-(CelestialBody(europa) & In(europa, solarSystem) & GreaterThan(europa, solarMass, 0.08)).


===

['x']
['x']
[PREMISE]:
If Max listens to music, he either listens to classical music or rap.
All the classical songs that Max listens to are from the 12th century. 
If Max is listening to a rap song, then the song is by Kanye West. 
All songs by Kanye West are full of lyrics. 
All songs that are full of lyrics need to be written with words
It is not true that “As it was” by Harry Styles is classical music that Max listens to and is from the 12th century.
Max listens to "As it was" by Harry Styles.

[PREMISE (FOL)]:
∀x (MaxListenTo(x) → (ClassicalMusic(x) ⊕ Rap(x)))
∀x (MaxListenTo(x) ∧ ClassicalMusic(x) → Song(x) ∧ From(x, 12thCentury))
∀x (MaxListenTo(x) ∧ Rap(x) → Song(x) ∧ By(x, kanyeWest))
∀x (Song(x) ∧ By(x, kanyeWest) → Song(x) ∧ FullOfLyrics(x))
∀x (Song(x) ∧ FullOfLyrics(x) → NeedToBeWrittenWith(x, words))
¬(ClassicalMusic(asItWasByHarryStyles) ∧ Song(asItWasByHarryStyles) ∧ From(asItWasByHarryStyles, 12thCentury))
MaxListenTo(asItWasByHarryStyles)

[PREMISE (GK)]:
! [X] : (MaxListenTo(X) => (ClassicalMusic(X) <~> Rap(X))).
! [X] : (MaxListenTo(X) & ClassicalMusic(X) => Song(X) & From(X, 12thCentury)).
! [X] : (MaxListenTo(X) & Rap(X) => Song(X) & By(X, kanyeWest)).
! [X] : (Song(X) & By(X, kanyeWest) => Song(X) & FullOfLyrics(X)).
! [X] : (Song(X) & FullOfLyrics(X) => NeedToBeWrittenWith(X, words)).
-(ClassicalMusic(asItWasByHarryStyles) & Song(asItWasByHarryStyles) & From(asItWasByHarryStyles, 12thCentury)).
MaxListenTo(asItWasByHarryStyles).

[CONCLUSION]:
“As it was” by Harry Styles needs to be written with words.

[CONCLUSION (FOL)]:
NeedToBeWrittenWith(asItWasByHarryStyles, words)

[CONCLUSION (GK)]:
NeedToBeWrittenWith(asItWasByHarryStyles, words).


===

['x']
['x']
[PREMISE]:
If Max listens to music, he either listens to classical music or rap.
All the classical songs that Max listens to are from the 12th century. 
If Max is listening to a rap song, then the song is by Kanye West. 
All songs by Kanye West are full of lyrics. 
All songs that are full of lyrics need to be written with words
It is not true that “As it was” by Harry Styles is classical music that Max listens to and is from the 12th century.
Max listens to "As it was" by Harry Styles.

[PREMISE (FOL)]:
∀x (MaxListenTo(x) → (ClassicalMusic(x) ⊕ Rap(x)))
∀x (MaxListenTo(x) ∧ ClassicalMusic(x) → Song(x) ∧ From(x, 12thCentury))
∀x (MaxListenTo(x) ∧ Rap(x) → Song(x) ∧ By(x, kanyeWest))
∀x (Song(x) ∧ By(x, kanyeWest) → Song(x) ∧ FullOfLyrics(x))
∀x (Song(x) ∧ FullOfLyrics(x) → NeedToBeWrittenWith(x, words))
¬(ClassicalMusic(asItWasByHarryStyles) ∧ Song(asItWasByHarryStyles) ∧ From(asItWasByHarryStyles, 12thCentury))
MaxListenTo(asItWasByHarryStyles)

[PREMISE (GK)]:
! [X] : (MaxListenTo(X) => (ClassicalMusic(X) <~> Rap(X))).
! [X] : (MaxListenTo(X) & ClassicalMusic(X) => Song(X) & From(X, 12thCentury)).
! [X] : (MaxListenTo(X) & Rap(X) => Song(X) & By(X, kanyeWest)).
! [X] : (Song(X) & By(X, kanyeWest) => Song(X) & FullOfLyrics(X)).
! [X] : (Song(X) & FullOfLyrics(X) => NeedToBeWrittenWith(X, words)).
-(ClassicalMusic(asItWasByHarryStyles) & Song(asItWasByHarryStyles) & From(asItWasByHarryStyles, 12thCentury)).
MaxListenTo(asItWasByHarryStyles).

[CONCLUSION]:
"As it was” by Harry Styles is a song from the 12th century.

[CONCLUSION (FOL)]:
Song(asItWasByHarryStyles) ∧ From(asItWasByHarryStyles, 12thCentury)

[CONCLUSION (GK)]:
Song(asItWasByHarryStyles) & From(asItWasByHarryStyles, 12thCentury).


===

['x']
['x']
[PREMISE]:
If Max listens to music, he either listens to classical music or rap.
All the classical songs that Max listens to are from the 12th century. 
If Max is listening to a rap song, then the song is by Kanye West. 
All songs by Kanye West are full of lyrics. 
All songs that are full of lyrics need to be written with words
It is not true that “As it was” by Harry Styles is classical music that Max listens to and is from the 12th century.
Max listens to "As it was" by Harry Styles.

[PREMISE (FOL)]:
∀x (MaxListenTo(x) → (ClassicalMusic(x) ⊕ Rap(x)))
∀x (MaxListenTo(x) ∧ ClassicalMusic(x) → Song(x) ∧ From(x, 12thCentury))
∀x (MaxListenTo(x) ∧ Rap(x) → Song(x) ∧ By(x, kanyeWest))
∀x (Song(x) ∧ By(x, kanyeWest) → Song(x) ∧ FullOfLyrics(x))
∀x (Song(x) ∧ FullOfLyrics(x) → NeedToBeWrittenWith(x, words))
¬(ClassicalMusic(asItWasByHarryStyles) ∧ Song(asItWasByHarryStyles) ∧ From(asItWasByHarryStyles, 12thCentury))
MaxListenTo(asItWasByHarryStyles)

[PREMISE (GK)]:
! [X] : (MaxListenTo(X) => (ClassicalMusic(X) <~> Rap(X))).
! [X] : (MaxListenTo(X) & ClassicalMusic(X) => Song(X) & From(X, 12thCentury)).
! [X] : (MaxListenTo(X) & Rap(X) => Song(X) & By(X, kanyeWest)).
! [X] : (Song(X) & By(X, kanyeWest) => Song(X) & FullOfLyrics(X)).
! [X] : (Song(X) & FullOfLyrics(X) => NeedToBeWrittenWith(X, words)).
-(ClassicalMusic(asItWasByHarryStyles) & Song(asItWasByHarryStyles) & From(asItWasByHarryStyles, 12thCentury)).
MaxListenTo(asItWasByHarryStyles).

[CONCLUSION]:
"As it was” by Harry Styles is not both a song from Kanye West and needed to be written with words.

[CONCLUSION (FOL)]:
¬(Song(asItWasByHarryStyles) ∧ By(asItWasByHarryStyles, kanyeWest) ∧ NeedToBeWrittenWith(asItWasByHarryStyles, words))

[CONCLUSION (GK)]:
-(Song(asItWasByHarryStyles) & By(asItWasByHarryStyles, kanyeWest) & NeedToBeWrittenWith(asItWasByHarryStyles, words)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
"Your Woman" is a song by the British one-person band White Town.
"Your Woman" song peaked at No. 1 on the UK Singles Chart.
If a song peaked at No.1 at a particular place, it was extremely popular.
"Your Woman" peaked at No. 1 in Iceland, Israel, and Spain.

[PREMISE (FOL)]:
Produce(whiteTown, yourWoman) ∧ OnePersonBand(whiteTown)
Peak(yourWoman, uKSinglesChart)
∀x ((∃y(Peak(x, y))) → Popular(x))
Peak(yourWoman, iceland) ∧ Peak(yourWoman, israel) ∧ Peak(yourWoman, spain)

[PREMISE (GK)]:
Produce(whiteTown, yourWoman) & OnePersonBand(whiteTown).
Peak(yourWoman, uKSinglesChart).
! [X] : ((? [Y] :(Peak(X, Y))) => Popular(X)).
Peak(yourWoman, iceland) & Peak(yourWoman, israel) & Peak(yourWoman, spain).

[CONCLUSION]:
"Your Woman" was extremely popular.

[CONCLUSION (FOL)]:
Popular(yourWoman)

[CONCLUSION (GK)]:
Popular(yourWoman).


===

['x', 'y']
['x', 'y']
[PREMISE]:
"Your Woman" is a song by the British one-person band White Town.
"Your Woman" song peaked at No. 1 on the UK Singles Chart.
If a song peaked at No.1 at a particular place, it was extremely popular.
"Your Woman" peaked at No. 1 in Iceland, Israel, and Spain.

[PREMISE (FOL)]:
Produce(whiteTown, yourWoman) ∧ OnePersonBand(whiteTown)
Peak(yourWoman, uKSinglesChart)
∀x ((∃y(Peak(x, y))) → Popular(x))
Peak(yourWoman, iceland) ∧ Peak(yourWoman, israel) ∧ Peak(yourWoman, spain)

[PREMISE (GK)]:
Produce(whiteTown, yourWoman) & OnePersonBand(whiteTown).
Peak(yourWoman, uKSinglesChart).
! [X] : ((? [Y] :(Peak(X, Y))) => Popular(X)).
Peak(yourWoman, iceland) & Peak(yourWoman, israel) & Peak(yourWoman, spain).

[CONCLUSION]:
White Town did not produce any popular songs.

[CONCLUSION (FOL)]:
∀x (Produce(whiteTown, x) → ¬Popular(x))

[CONCLUSION (GK)]:
! [X] : (Produce(whiteTown, X) => -Popular(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
"Your Woman" is a song by the British one-person band White Town.
"Your Woman" song peaked at No. 1 on the UK Singles Chart.
If a song peaked at No.1 at a particular place, it was extremely popular.
"Your Woman" peaked at No. 1 in Iceland, Israel, and Spain.

[PREMISE (FOL)]:
Produce(whiteTown, yourWoman) ∧ OnePersonBand(whiteTown)
Peak(yourWoman, uKSinglesChart)
∀x ((∃y(Peak(x, y))) → Popular(x))
Peak(yourWoman, iceland) ∧ Peak(yourWoman, israel) ∧ Peak(yourWoman, spain)

[PREMISE (GK)]:
Produce(whiteTown, yourWoman) & OnePersonBand(whiteTown).
Peak(yourWoman, uKSinglesChart).
! [X] : ((? [Y] :(Peak(X, Y))) => Popular(X)).
Peak(yourWoman, iceland) & Peak(yourWoman, israel) & Peak(yourWoman, spain).

[CONCLUSION]:
White Town was a successful band.

[CONCLUSION (FOL)]:
Successful(whiteTown)

[CONCLUSION (GK)]:
Successful(whiteTown).


===

['x']
['x']
[PREMISE]:

All functions that represent straight lines on the coordinate plane are linear functions. 
No linear functions are non-convex functions.
A function is either a non-convex fuction or a convex function.
All quasi-convex functions are real-valued functions.
All convex functions are quasi-convex functions. 
The maximum of quasiconvex functions is a function.
The maximum of quasiconvex functions is a function that represents straight lines on the coordinate plane or it is a convex function or it is not a non-convex function.

[PREMISE (FOL)]:
∀x (Function(x) ∧ RepresentOn(x, straightLine, coordinatePlane) → LinearFunction(x))
∀x (LinearFunction(x) → ¬NonConvexFunction(x))
∀x (Function(x) → NonConvexFunction(x) ⊕ ConvexFunction(x))
∀x (QuasiConvexFunction(x) → RealValuedFunction(x))
∀x (ConvexFunction(x) → QuasiConvexFunction(x))
Function(maximumOfQuasiConvexFunction)
(Function(maximumOfQuasiConvexFunction) ∧ RepresentOn(maximumOfQuasiConvexFunction, straightLine, coordinatePlane)) ∨ ConvexFunction(maximumOfQuasiConvexFunction) ∨ ¬NonConvexFunction(maximumOfQuasiConvexFunction)

[PREMISE (GK)]:
! [X] : (Function(X) & RepresentOn(X, straightLine, coordinatePlane) => LinearFunction(X)).
! [X] : (LinearFunction(X) => -NonConvexFunction(X)).
! [X] : (Function(X) => NonConvexFunction(X) <~> ConvexFunction(X)).
! [X] : (QuasiConvexFunction(X) => RealValuedFunction(X)).
! [X] : (ConvexFunction(X) => QuasiConvexFunction(X)).
Function(maximumOfQuasiConvexFunction).
(Function(maximumOfQuasiConvexFunction) & RepresentOn(maximumOfQuasiConvexFunction, straightLine, coordinatePlane)) | ConvexFunction(maximumOfQuasiConvexFunction) | -NonConvexFunction(maximumOfQuasiConvexFunction).

[CONCLUSION]:
The maximum of quasiconvex functions is a function that represent straight lines on the coordinate plane.

[CONCLUSION (FOL)]:
Function(maximumOfQuasiConvexFunction) ∧ RepresentOn(maximumOfQuasiConvexFunction, straightLine, coordinatePlane)

[CONCLUSION (GK)]:
Function(maximumOfQuasiConvexFunction) & RepresentOn(maximumOfQuasiConvexFunction, straightLine, coordinatePlane).


===

['x']
['x']
[PREMISE]:

All functions that represent straight lines on the coordinate plane are linear functions. 
No linear functions are non-convex functions.
A function is either a non-convex fuction or a convex function.
All quasi-convex functions are real-valued functions.
All convex functions are quasi-convex functions. 
The maximum of quasiconvex functions is a function.
The maximum of quasiconvex functions is a function that represents straight lines on the coordinate plane or it is a convex function or it is not a non-convex function.

[PREMISE (FOL)]:
∀x (Function(x) ∧ RepresentOn(x, straightLine, coordinatePlane) → LinearFunction(x))
∀x (LinearFunction(x) → ¬NonConvexFunction(x))
∀x (Function(x) → NonConvexFunction(x) ⊕ ConvexFunction(x))
∀x (QuasiConvexFunction(x) → RealValuedFunction(x))
∀x (ConvexFunction(x) → QuasiConvexFunction(x))
Function(maximumOfQuasiConvexFunction)
(Function(maximumOfQuasiConvexFunction) ∧ RepresentOn(maximumOfQuasiConvexFunction, straightLine, coordinatePlane)) ∨ ConvexFunction(maximumOfQuasiConvexFunction) ∨ ¬NonConvexFunction(maximumOfQuasiConvexFunction)

[PREMISE (GK)]:
! [X] : (Function(X) & RepresentOn(X, straightLine, coordinatePlane) => LinearFunction(X)).
! [X] : (LinearFunction(X) => -NonConvexFunction(X)).
! [X] : (Function(X) => NonConvexFunction(X) <~> ConvexFunction(X)).
! [X] : (QuasiConvexFunction(X) => RealValuedFunction(X)).
! [X] : (ConvexFunction(X) => QuasiConvexFunction(X)).
Function(maximumOfQuasiConvexFunction).
(Function(maximumOfQuasiConvexFunction) & RepresentOn(maximumOfQuasiConvexFunction, straightLine, coordinatePlane)) | ConvexFunction(maximumOfQuasiConvexFunction) | -NonConvexFunction(maximumOfQuasiConvexFunction).

[CONCLUSION]:
The maximum of quasiconvex functions is not a real-valued function.

[CONCLUSION (FOL)]:
¬RealValuedFunction(maximumOfQuasiConvexFunction)

[CONCLUSION (GK)]:
-RealValuedFunction(maximumOfQuasiConvexFunction).


===

['x']
['x']
[PREMISE]:

All functions that represent straight lines on the coordinate plane are linear functions. 
No linear functions are non-convex functions.
A function is either a non-convex fuction or a convex function.
All quasi-convex functions are real-valued functions.
All convex functions are quasi-convex functions. 
The maximum of quasiconvex functions is a function.
The maximum of quasiconvex functions is a function that represents straight lines on the coordinate plane or it is a convex function or it is not a non-convex function.

[PREMISE (FOL)]:
∀x (Function(x) ∧ RepresentOn(x, straightLine, coordinatePlane) → LinearFunction(x))
∀x (LinearFunction(x) → ¬NonConvexFunction(x))
∀x (Function(x) → NonConvexFunction(x) ⊕ ConvexFunction(x))
∀x (QuasiConvexFunction(x) → RealValuedFunction(x))
∀x (ConvexFunction(x) → QuasiConvexFunction(x))
Function(maximumOfQuasiConvexFunction)
(Function(maximumOfQuasiConvexFunction) ∧ RepresentOn(maximumOfQuasiConvexFunction, straightLine, coordinatePlane)) ∨ ConvexFunction(maximumOfQuasiConvexFunction) ∨ ¬NonConvexFunction(maximumOfQuasiConvexFunction)

[PREMISE (GK)]:
! [X] : (Function(X) & RepresentOn(X, straightLine, coordinatePlane) => LinearFunction(X)).
! [X] : (LinearFunction(X) => -NonConvexFunction(X)).
! [X] : (Function(X) => NonConvexFunction(X) <~> ConvexFunction(X)).
! [X] : (QuasiConvexFunction(X) => RealValuedFunction(X)).
! [X] : (ConvexFunction(X) => QuasiConvexFunction(X)).
Function(maximumOfQuasiConvexFunction).
(Function(maximumOfQuasiConvexFunction) & RepresentOn(maximumOfQuasiConvexFunction, straightLine, coordinatePlane)) | ConvexFunction(maximumOfQuasiConvexFunction) | -NonConvexFunction(maximumOfQuasiConvexFunction).

[CONCLUSION]:
The maximum of quasiconvex functions is a quasi-convex function or it is not a real-valued function.

[CONCLUSION (FOL)]:
QuasiConvexFunction(maximumOfQuasiConvexFunction) ∨ ¬RealValuedFunction(maximumOfQuasiConvexFunction)

[CONCLUSION (GK)]:
QuasiConvexFunction(maximumOfQuasiConvexFunction) | -RealValuedFunction(maximumOfQuasiConvexFunction).


===

['w', 'x', 'y', 'z']
['w', 'x', 'y', 'z']
[PREMISE]:
If two soccer teams score the same number of goals in one UCL final during the regular time, they need to play for the extra time.
If two soccer teams score the same number of goals in one UCL final during both regular and extra time, they need to play the penalty shoot-out.
Real Madrid and Atlético Madrid both scored one goal in the 2016 UCL final during the regular time.
Real Madrid and Atlético Madrid both scored zero goals in the 2016 UCL final during the extra time.

[PREMISE (FOL)]:
∀w ∀x ∀y ∀z (SoccerTeam(x) ∧ SoccerTeam(y) ∧ NumberOfGoalScored(x, z) ∧ NumberOfGoalScored(y, w) ∧ y=w ∧ During(regularTime) → PlayExtra(x, y))
∀x ∀y (SoccerTeam(x) ∧ SoccerTeam(y) ∧ SameScore(x, y) ∧ During(regularTime) ∧ During(extraTime) → PlayPenalty(x, y))
SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(regularTime)
SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(extraTime)

[PREMISE (GK)]:
! [W] : ! [X] : ! [Y] : ! [Z] : (SoccerTeam(X) & SoccerTeam(Y) & NumberOfGoalScored(X, Z) & NumberOfGoalScored(Y, W) & Y=W & During(regularTime) => PlayExtra(X, Y)).
! [X] : ! [Y] : (SoccerTeam(X) & SoccerTeam(Y) & SameScore(X, Y) & During(regularTime) & During(extraTime) => PlayPenalty(X, Y)).
SoccerTeam(realMadrid) & SoccerTeam(atleticoMadrid) & SameScore(realMadrid, atleticoMadrid) & During(regularTime).
SoccerTeam(realMadrid) & SoccerTeam(atleticoMadrid) & SameScore(realMadrid, atleticoMadrid) & During(extraTime).

[CONCLUSION]:
Real Madrid and Atlético Madrid needed to play a penalty shoot-out in the 2016 UCL final.

[CONCLUSION (FOL)]:
PlayPenalty(realMadrid, atleticoMadrid)

[CONCLUSION (GK)]:
PlayPenalty(realMadrid, atleticoMadrid).


===

['w', 'x', 'y', 'z']
['w', 'x', 'y', 'z']
[PREMISE]:
If two soccer teams score the same number of goals in one UCL final during the regular time, they need to play for the extra time.
If two soccer teams score the same number of goals in one UCL final during both regular and extra time, they need to play the penalty shoot-out.
Real Madrid and Atlético Madrid both scored one goal in the 2016 UCL final during the regular time.
Real Madrid and Atlético Madrid both scored zero goals in the 2016 UCL final during the extra time.

[PREMISE (FOL)]:
∀w ∀x ∀y ∀z (SoccerTeam(x) ∧ SoccerTeam(y) ∧ NumberOfGoalScored(x, z) ∧ NumberOfGoalScored(y, w) ∧ y=w ∧ During(regularTime) → PlayExtra(x, y))
∀x ∀y (SoccerTeam(x) ∧ SoccerTeam(y) ∧ SameScore(x, y) ∧ During(regularTime) ∧ During(extraTime) → PlayPenalty(x, y))
SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(regularTime)
SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(extraTime)

[PREMISE (GK)]:
! [W] : ! [X] : ! [Y] : ! [Z] : (SoccerTeam(X) & SoccerTeam(Y) & NumberOfGoalScored(X, Z) & NumberOfGoalScored(Y, W) & Y=W & During(regularTime) => PlayExtra(X, Y)).
! [X] : ! [Y] : (SoccerTeam(X) & SoccerTeam(Y) & SameScore(X, Y) & During(regularTime) & During(extraTime) => PlayPenalty(X, Y)).
SoccerTeam(realMadrid) & SoccerTeam(atleticoMadrid) & SameScore(realMadrid, atleticoMadrid) & During(regularTime).
SoccerTeam(realMadrid) & SoccerTeam(atleticoMadrid) & SameScore(realMadrid, atleticoMadrid) & During(extraTime).

[CONCLUSION]:
Real Madrid and Atlético Madrid did not need to play a penalty shoot-out in the 2016 UCL final.

[CONCLUSION (FOL)]:
¬PlayPenalty(realMadrid, atleticoMadrid)

[CONCLUSION (GK)]:
-PlayPenalty(realMadrid, atleticoMadrid).


===

['x']
['x']
[PREMISE]:
System 7 is a UK-based electronic dance music band.
Steve Hillage and Miquette Giraudy formed System 7.
Steve Hillage and Miquette Giraudy are former members of the band Gong.
Electric dance music bands are bands.
System 7 has released several club singles.
Club singles are not singles.

[PREMISE (FOL)]:
BasedIn(system7, uk) ∧ ElectronicDanceMusicBand(system7)
Form(stevehillage, system7) ∧ Form(miquettegiraudy, system7)
FormerMemberOf(stevehillage, gong) ∧ FormerMemberOf(miquettegiraudy, gong)
∀x (ElectronicDanceMusicBand(x) → Band(x))
∃x (ClubSingle(x) ∧ Release(system7, x))
∀x (ClubSingle(x) → ¬Single(x))

[PREMISE (GK)]:
BasedIn(system7, uk) & ElectronicDanceMusicBand(system7).
Form(stevehillage, system7) & Form(miquettegiraudy, system7).
FormerMemberOf(stevehillage, gong) & FormerMemberOf(miquettegiraudy, gong).
! [X] : (ElectronicDanceMusicBand(X) => Band(X)).
? [X] : (ClubSingle(X) & Release(system7, X)).
! [X] : (ClubSingle(X) => -Single(X)).

[CONCLUSION]:
System 7 was formed by former members of Gong.

[CONCLUSION (FOL)]:
∃x (Form(x, system7) ∧ FormerMemberOf(x, gong))

[CONCLUSION (GK)]:
? [X] : (Form(X, system7) & FormerMemberOf(X, gong)).


===

['x']
['x']
[PREMISE]:
System 7 is a UK-based electronic dance music band.
Steve Hillage and Miquette Giraudy formed System 7.
Steve Hillage and Miquette Giraudy are former members of the band Gong.
Electric dance music bands are bands.
System 7 has released several club singles.
Club singles are not singles.

[PREMISE (FOL)]:
BasedIn(system7, uk) ∧ ElectronicDanceMusicBand(system7)
Form(stevehillage, system7) ∧ Form(miquettegiraudy, system7)
FormerMemberOf(stevehillage, gong) ∧ FormerMemberOf(miquettegiraudy, gong)
∀x (ElectronicDanceMusicBand(x) → Band(x))
∃x (ClubSingle(x) ∧ Release(system7, x))
∀x (ClubSingle(x) → ¬Single(x))

[PREMISE (GK)]:
BasedIn(system7, uk) & ElectronicDanceMusicBand(system7).
Form(stevehillage, system7) & Form(miquettegiraudy, system7).
FormerMemberOf(stevehillage, gong) & FormerMemberOf(miquettegiraudy, gong).
! [X] : (ElectronicDanceMusicBand(X) => Band(X)).
? [X] : (ClubSingle(X) & Release(system7, X)).
! [X] : (ClubSingle(X) => -Single(X)).

[CONCLUSION]:
System 7 has released several singles.

[CONCLUSION (FOL)]:
∃x (Single(x) ∧ Release(system7, x))

[CONCLUSION (GK)]:
? [X] : (Single(X) & Release(system7, X)).


===

['x']
['x']
[PREMISE]:
System 7 is a UK-based electronic dance music band.
Steve Hillage and Miquette Giraudy formed System 7.
Steve Hillage and Miquette Giraudy are former members of the band Gong.
Electric dance music bands are bands.
System 7 has released several club singles.
Club singles are not singles.

[PREMISE (FOL)]:
BasedIn(system7, uk) ∧ ElectronicDanceMusicBand(system7)
Form(stevehillage, system7) ∧ Form(miquettegiraudy, system7)
FormerMemberOf(stevehillage, gong) ∧ FormerMemberOf(miquettegiraudy, gong)
∀x (ElectronicDanceMusicBand(x) → Band(x))
∃x (ClubSingle(x) ∧ Release(system7, x))
∀x (ClubSingle(x) → ¬Single(x))

[PREMISE (GK)]:
BasedIn(system7, uk) & ElectronicDanceMusicBand(system7).
Form(stevehillage, system7) & Form(miquettegiraudy, system7).
FormerMemberOf(stevehillage, gong) & FormerMemberOf(miquettegiraudy, gong).
! [X] : (ElectronicDanceMusicBand(X) => Band(X)).
? [X] : (ClubSingle(X) & Release(system7, X)).
! [X] : (ClubSingle(X) => -Single(X)).

[CONCLUSION]:
System 7 is not a band.

[CONCLUSION (FOL)]:
¬Band(system7)

[CONCLUSION (GK)]:
-Band(system7).


===

['x']
['x']
[PREMISE]:
A summarization model is always faithful if it uses content from the input documents.
Extractive models are summarization models.
An extractive model can only use content from the input documents.

[PREMISE (FOL)]:
∀x (Model(x) ∧ Summarization(x) ∧ OnlyUseInputDocument(x) → Faithful(x))
∀x (Model(x) ∧ Extractive(x) → Model(x) ∧ Summarization(x))
∀x (Model(x) ∧ Extractive(x) → OnlyUseInputDocument(x))

[PREMISE (GK)]:
! [X] : (Model(X) & Summarization(X) & OnlyUseInputDocument(X) => Faithful(X)).
! [X] : (Model(X) & Extractive(X) => Model(X) & Summarization(X)).
! [X] : (Model(X) & Extractive(X) => OnlyUseInputDocument(X)).

[CONCLUSION]:
Extractive models are always faithful.

[CONCLUSION (FOL)]:
∀x (Model(x) ∧ Extractive(x) → Faithful(x))

[CONCLUSION (GK)]:
! [X] : (Model(X) & Extractive(X) => Faithful(X)).


===

['x']
['x']
[PREMISE]:
A summarization model is always faithful if it uses content from the input documents.
Extractive models are summarization models.
An extractive model can only use content from the input documents.

[PREMISE (FOL)]:
∀x (Model(x) ∧ Summarization(x) ∧ OnlyUseInputDocument(x) → Faithful(x))
∀x (Model(x) ∧ Extractive(x) → Model(x) ∧ Summarization(x))
∀x (Model(x) ∧ Extractive(x) → OnlyUseInputDocument(x))

[PREMISE (GK)]:
! [X] : (Model(X) & Summarization(X) & OnlyUseInputDocument(X) => Faithful(X)).
! [X] : (Model(X) & Extractive(X) => Model(X) & Summarization(X)).
! [X] : (Model(X) & Extractive(X) => OnlyUseInputDocument(X)).

[CONCLUSION]:
Extractive models are not always faithful.

[CONCLUSION (FOL)]:
∃x (Model(x) ∧ Extractive(x) ∧ ¬Faithful(x))

[CONCLUSION (GK)]:
? [X] : (Model(X) & Extractive(X) & -Faithful(X)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If Robin's friends practice coding questions, then they are not studying to go to medical school to become a doctor.
If Robin's friends want to work in the software engineering industry, then they practice coding questions.
If Robin's friends enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.
If Robin's friends grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.
If Robin's friends study hard, then they grew up with parents who worked as doctors.
Mark is Robin's friend.
If Mark neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Mark is either a person who studies hard or grew up with parents who worked as doctors.

[PREMISE (FOL)]:
∀x (RobinsFriends(x) ∧ Practice(x, codingQuestion) → ¬StudyingToGoToToBecome(x, medicalSchool, doctor))
∀x (RobinsFriends(x) ∧ WantToWorkIn(x, softwareEngineeringIndustry) → PracticeCodingQuestions(x))
∀x (RobinsFriends(x) ∧ Enjoy(x, healthcareField) ∧ WantToHelp(x, peopleWithMedicalIssue) → StudyingToGoToToBecome(x, medicalSchool, doctor))
∀x (RobinsFriends(x) ∧ (∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z))) → EnjoyHealthcareFields(x) ∧ WantToHelp(x, peopleWithMedicalIssue))
∀x (RobinsFriends(x) ∧ StudyHard(x) → ∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z)))
RobinsFriends(mark)
¬((Enjoy(x, healthcareField) ∧ WantToHelp(mark, peopleWithMedicalIssues)) ∧ ¬(∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z))) → StudyHard(mark) ∨ (∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z)))

[PREMISE (GK)]:
! [X] : (RobinsFriends(X) & Practice(X, codingQuestion) => -StudyingToGoToToBecome(X, medicalSchool, doctor)).
! [X] : (RobinsFriends(X) & WantToWorkIn(X, softwareEngineeringIndustry) => PracticeCodingQuestions(X)).
! [X] : (RobinsFriends(X) & Enjoy(X, healthcareField) & WantToHelp(X, peopleWithMedicalIssue) => StudyingToGoToToBecome(X, medicalSchool, doctor)).
! [X] : (RobinsFriends(X) & (? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(X, Y) & GrowUpWith(X, Z) & ParentOf(Y, X) & ParentOf(Z, X) & Doctor(Y) & Doctor(Z))) => EnjoyHealthcareFields(X) & WantToHelp(X, peopleWithMedicalIssue)).
! [X] : (RobinsFriends(X) & StudyHard(X) => ? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(X, Y) & GrowUpWith(X, Z) & ParentOf(Y, X) & ParentOf(Z, X) & Doctor(Y) & Doctor(Z))).
RobinsFriends(mark).
-((Enjoy(x, healthcareField) & WantToHelp(mark, peopleWithMedicalIssues)) & -(? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(x, Y) & GrowUpWith(x, Z) & ParentOf(Y, x) & ParentOf(Z, x) & Doctor(Y) & Doctor(Z))) => StudyHard(mark) | (? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(x, Y) & GrowUpWith(x, Z) & ParentOf(Y, x) & ParentOf(Z, x) & Doctor(Y) & Doctor(Z))).

[CONCLUSION]:
Mark is Robin's friend and he is a person who studies hard.

[CONCLUSION (FOL)]:
RobinsFriends(mark) ∧ StudyHard(mark)

[CONCLUSION (GK)]:
RobinsFriends(mark) & StudyHard(mark).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If Robin's friends practice coding questions, then they are not studying to go to medical school to become a doctor.
If Robin's friends want to work in the software engineering industry, then they practice coding questions.
If Robin's friends enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.
If Robin's friends grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.
If Robin's friends study hard, then they grew up with parents who worked as doctors.
Mark is Robin's friend.
If Mark neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Mark is either a person who studies hard or grew up with parents who worked as doctors.

[PREMISE (FOL)]:
∀x (RobinsFriends(x) ∧ Practice(x, codingQuestion) → ¬StudyingToGoToToBecome(x, medicalSchool, doctor))
∀x (RobinsFriends(x) ∧ WantToWorkIn(x, softwareEngineeringIndustry) → PracticeCodingQuestions(x))
∀x (RobinsFriends(x) ∧ Enjoy(x, healthcareField) ∧ WantToHelp(x, peopleWithMedicalIssue) → StudyingToGoToToBecome(x, medicalSchool, doctor))
∀x (RobinsFriends(x) ∧ (∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z))) → EnjoyHealthcareFields(x) ∧ WantToHelp(x, peopleWithMedicalIssue))
∀x (RobinsFriends(x) ∧ StudyHard(x) → ∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z)))
RobinsFriends(mark)
¬((Enjoy(x, healthcareField) ∧ WantToHelp(mark, peopleWithMedicalIssues)) ∧ ¬(∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z))) → StudyHard(mark) ∨ (∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z)))

[PREMISE (GK)]:
! [X] : (RobinsFriends(X) & Practice(X, codingQuestion) => -StudyingToGoToToBecome(X, medicalSchool, doctor)).
! [X] : (RobinsFriends(X) & WantToWorkIn(X, softwareEngineeringIndustry) => PracticeCodingQuestions(X)).
! [X] : (RobinsFriends(X) & Enjoy(X, healthcareField) & WantToHelp(X, peopleWithMedicalIssue) => StudyingToGoToToBecome(X, medicalSchool, doctor)).
! [X] : (RobinsFriends(X) & (? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(X, Y) & GrowUpWith(X, Z) & ParentOf(Y, X) & ParentOf(Z, X) & Doctor(Y) & Doctor(Z))) => EnjoyHealthcareFields(X) & WantToHelp(X, peopleWithMedicalIssue)).
! [X] : (RobinsFriends(X) & StudyHard(X) => ? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(X, Y) & GrowUpWith(X, Z) & ParentOf(Y, X) & ParentOf(Z, X) & Doctor(Y) & Doctor(Z))).
RobinsFriends(mark).
-((Enjoy(x, healthcareField) & WantToHelp(mark, peopleWithMedicalIssues)) & -(? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(x, Y) & GrowUpWith(x, Z) & ParentOf(Y, x) & ParentOf(Z, x) & Doctor(Y) & Doctor(Z))) => StudyHard(mark) | (? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(x, Y) & GrowUpWith(x, Z) & ParentOf(Y, x) & ParentOf(Z, x) & Doctor(Y) & Doctor(Z))).

[CONCLUSION]:
Mark is Robin's friend and he practices coding questions and wants to work in the software engineering industry.

[CONCLUSION (FOL)]:
RobinsFriends(mark) ∧ Practice(mark, codingQuestion) ∧ WantToWorkIn(mark, softwareEngineeringIndustry)

[CONCLUSION (GK)]:
RobinsFriends(mark) & Practice(mark, codingQuestion) & WantToWorkIn(mark, softwareEngineeringIndustry).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If Robin's friends practice coding questions, then they are not studying to go to medical school to become a doctor.
If Robin's friends want to work in the software engineering industry, then they practice coding questions.
If Robin's friends enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.
If Robin's friends grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.
If Robin's friends study hard, then they grew up with parents who worked as doctors.
Mark is Robin's friend.
If Mark neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Mark is either a person who studies hard or grew up with parents who worked as doctors.

[PREMISE (FOL)]:
∀x (RobinsFriends(x) ∧ Practice(x, codingQuestion) → ¬StudyingToGoToToBecome(x, medicalSchool, doctor))
∀x (RobinsFriends(x) ∧ WantToWorkIn(x, softwareEngineeringIndustry) → PracticeCodingQuestions(x))
∀x (RobinsFriends(x) ∧ Enjoy(x, healthcareField) ∧ WantToHelp(x, peopleWithMedicalIssue) → StudyingToGoToToBecome(x, medicalSchool, doctor))
∀x (RobinsFriends(x) ∧ (∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z))) → EnjoyHealthcareFields(x) ∧ WantToHelp(x, peopleWithMedicalIssue))
∀x (RobinsFriends(x) ∧ StudyHard(x) → ∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z)))
RobinsFriends(mark)
¬((Enjoy(x, healthcareField) ∧ WantToHelp(mark, peopleWithMedicalIssues)) ∧ ¬(∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z))) → StudyHard(mark) ∨ (∃y ∃z (¬(y=z) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z) ∧ ParentOf(y, x) ∧ ParentOf(z, x) ∧ Doctor(y) ∧ Doctor(z)))

[PREMISE (GK)]:
! [X] : (RobinsFriends(X) & Practice(X, codingQuestion) => -StudyingToGoToToBecome(X, medicalSchool, doctor)).
! [X] : (RobinsFriends(X) & WantToWorkIn(X, softwareEngineeringIndustry) => PracticeCodingQuestions(X)).
! [X] : (RobinsFriends(X) & Enjoy(X, healthcareField) & WantToHelp(X, peopleWithMedicalIssue) => StudyingToGoToToBecome(X, medicalSchool, doctor)).
! [X] : (RobinsFriends(X) & (? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(X, Y) & GrowUpWith(X, Z) & ParentOf(Y, X) & ParentOf(Z, X) & Doctor(Y) & Doctor(Z))) => EnjoyHealthcareFields(X) & WantToHelp(X, peopleWithMedicalIssue)).
! [X] : (RobinsFriends(X) & StudyHard(X) => ? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(X, Y) & GrowUpWith(X, Z) & ParentOf(Y, X) & ParentOf(Z, X) & Doctor(Y) & Doctor(Z))).
RobinsFriends(mark).
-((Enjoy(x, healthcareField) & WantToHelp(mark, peopleWithMedicalIssues)) & -(? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(x, Y) & GrowUpWith(x, Z) & ParentOf(Y, x) & ParentOf(Z, x) & Doctor(Y) & Doctor(Z))) => StudyHard(mark) | (? [Y] : ? [Z] : (-(Y=Z) & GrowUpWith(x, Y) & GrowUpWith(x, Z) & ParentOf(Y, x) & ParentOf(Z, x) & Doctor(Y) & Doctor(Z))).

[CONCLUSION]:
Mark is Robin's friend and he neither practices coding questions nor works to work in the software engineering industry.

[CONCLUSION (FOL)]:
RobinsFriends(mark) ∧ ¬(Practice(mark, codingQuestion) ∨ WantToWorkIn(mark, softwareEngineeringIndustry))

[CONCLUSION (GK)]:
RobinsFriends(mark) & -(Practice(mark, codingQuestion) | WantToWorkIn(mark, softwareEngineeringIndustry)).


===

['x']
['x']
[PREMISE]:
People who work at Jess's company and go to the spa frequently are not people who are miserly and need to save a large portion of their income.
People who work at Jess's company are either miserly and need to save a large portion of their income, or frivolously spend a lot of money.
If people who work at Jess's company frivolously spend a lot of money when they go out, then they value quality manufacturing and luxury items.
If people who work at Jess's company value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.
Thomas works at Jess's company.
If Thomas is not miserly and needs to save a large portion of his income, then Thomas does not value quality manufacturing and luxury items.
Thomas values quality manufacturing and luxury items or he is not miserly.

[PREMISE (FOL)]:
∀x (WorkAt(x, jesssCompany) ∧ GoToSpafrequently(x) → ¬(Miserly(x) ∧ NeedToSave(x, aLargePortionOfIncome)))
∀x (WorkAt(x, jesssCompany) → Miserly(x) ∧ NeedToSave(x, aLargePortionOfIncome)⊕ SpendFrivolously(x, aLotOfMoney))
∀x (WorkAt(x, jesssCompany) ∧ SpendFrivolously(x, aLotOfMoney) → Value(x, qualityManufacturing) ∧ Value(x, luxuryItem))
∀x (WorkAt(x, jesssCompany) ∧ Value(x, qualityManufacturing) ∧ Value(x, luxuryItem) → Enjoy(x, shopping, materialisticItem))
WorkAt(thomas, jesssCompany)
¬(Miserly(thomas) ∧ NeedToSave(thomas, aLargePortionOfIncome)) → ¬((Value(thomas, qualityManufacturing) ∧ Value(thomas, luxuryItem)))
(Value(thomas, qualityManufacturing) ∧ Value(thomas, luxuryItem)) ∨ ¬(Miserly(x) ∧ NeedToSave(x, aLargePortionOfIncome))

[PREMISE (GK)]:
! [X] : (WorkAt(X, jesssCompany) & GoToSpafrequently(X) => -(Miserly(X) & NeedToSave(X, aLargePortionOfIncome))).
! [X] : (WorkAt(X, jesssCompany) => Miserly(X) & NeedToSave(X, aLargePortionOfIncome)<~> SpendFrivolously(X, aLotOfMoney)).
! [X] : (WorkAt(X, jesssCompany) & SpendFrivolously(X, aLotOfMoney) => Value(X, qualityManufacturing) & Value(X, luxuryItem)).
! [X] : (WorkAt(X, jesssCompany) & Value(X, qualityManufacturing) & Value(X, luxuryItem) => Enjoy(X, shopping, materialisticItem)).
WorkAt(thomas, jesssCompany).
-(Miserly(thomas) & NeedToSave(thomas, aLargePortionOfIncome)) => -((Value(thomas, qualityManufacturing) & Value(thomas, luxuryItem))).
(Value(thomas, qualityManufacturing) & Value(thomas, luxuryItem)) | -(Miserly(x) & NeedToSave(x, aLargePortionOfIncome)).

[CONCLUSION]:
Thomas frivolously spends a lot of money.

[CONCLUSION (FOL)]:
SpendFrivolously(thomas, aLotOfMoney)

[CONCLUSION (GK)]:
SpendFrivolously(thomas, aLotOfMoney).


===

['x']
['x']
[PREMISE]:
People who work at Jess's company and go to the spa frequently are not people who are miserly and need to save a large portion of their income.
People who work at Jess's company are either miserly and need to save a large portion of their income, or frivolously spend a lot of money.
If people who work at Jess's company frivolously spend a lot of money when they go out, then they value quality manufacturing and luxury items.
If people who work at Jess's company value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.
Thomas works at Jess's company.
If Thomas is not miserly and needs to save a large portion of his income, then Thomas does not value quality manufacturing and luxury items.
Thomas values quality manufacturing and luxury items or he is not miserly.

[PREMISE (FOL)]:
∀x (WorkAt(x, jesssCompany) ∧ GoToSpafrequently(x) → ¬(Miserly(x) ∧ NeedToSave(x, aLargePortionOfIncome)))
∀x (WorkAt(x, jesssCompany) → Miserly(x) ∧ NeedToSave(x, aLargePortionOfIncome)⊕ SpendFrivolously(x, aLotOfMoney))
∀x (WorkAt(x, jesssCompany) ∧ SpendFrivolously(x, aLotOfMoney) → Value(x, qualityManufacturing) ∧ Value(x, luxuryItem))
∀x (WorkAt(x, jesssCompany) ∧ Value(x, qualityManufacturing) ∧ Value(x, luxuryItem) → Enjoy(x, shopping, materialisticItem))
WorkAt(thomas, jesssCompany)
¬(Miserly(thomas) ∧ NeedToSave(thomas, aLargePortionOfIncome)) → ¬((Value(thomas, qualityManufacturing) ∧ Value(thomas, luxuryItem)))
(Value(thomas, qualityManufacturing) ∧ Value(thomas, luxuryItem)) ∨ ¬(Miserly(x) ∧ NeedToSave(x, aLargePortionOfIncome))

[PREMISE (GK)]:
! [X] : (WorkAt(X, jesssCompany) & GoToSpafrequently(X) => -(Miserly(X) & NeedToSave(X, aLargePortionOfIncome))).
! [X] : (WorkAt(X, jesssCompany) => Miserly(X) & NeedToSave(X, aLargePortionOfIncome)<~> SpendFrivolously(X, aLotOfMoney)).
! [X] : (WorkAt(X, jesssCompany) & SpendFrivolously(X, aLotOfMoney) => Value(X, qualityManufacturing) & Value(X, luxuryItem)).
! [X] : (WorkAt(X, jesssCompany) & Value(X, qualityManufacturing) & Value(X, luxuryItem) => Enjoy(X, shopping, materialisticItem)).
WorkAt(thomas, jesssCompany).
-(Miserly(thomas) & NeedToSave(thomas, aLargePortionOfIncome)) => -((Value(thomas, qualityManufacturing) & Value(thomas, luxuryItem))).
(Value(thomas, qualityManufacturing) & Value(thomas, luxuryItem)) | -(Miserly(x) & NeedToSave(x, aLargePortionOfIncome)).

[CONCLUSION]:
Thomas either enjoys shopping for materialistic items in his free time or, if he does not, then he goes to the spa frequently.

[CONCLUSION (FOL)]:
Enjoy(thomas, shopping, materialisticItem) ⊕ GoToSpaFrequently(thomas)

[CONCLUSION (GK)]:
Enjoy(thomas, shopping, materialisticItem) <~> GoToSpaFrequently(thomas).


===

['x']
['x']
[PREMISE]:
People who work at Jess's company and go to the spa frequently are not people who are miserly and need to save a large portion of their income.
People who work at Jess's company are either miserly and need to save a large portion of their income, or frivolously spend a lot of money.
If people who work at Jess's company frivolously spend a lot of money when they go out, then they value quality manufacturing and luxury items.
If people who work at Jess's company value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.
Thomas works at Jess's company.
If Thomas is not miserly and needs to save a large portion of his income, then Thomas does not value quality manufacturing and luxury items.
Thomas values quality manufacturing and luxury items or he is not miserly.

[PREMISE (FOL)]:
∀x (WorkAt(x, jesssCompany) ∧ GoToSpafrequently(x) → ¬(Miserly(x) ∧ NeedToSave(x, aLargePortionOfIncome)))
∀x (WorkAt(x, jesssCompany) → Miserly(x) ∧ NeedToSave(x, aLargePortionOfIncome)⊕ SpendFrivolously(x, aLotOfMoney))
∀x (WorkAt(x, jesssCompany) ∧ SpendFrivolously(x, aLotOfMoney) → Value(x, qualityManufacturing) ∧ Value(x, luxuryItem))
∀x (WorkAt(x, jesssCompany) ∧ Value(x, qualityManufacturing) ∧ Value(x, luxuryItem) → Enjoy(x, shopping, materialisticItem))
WorkAt(thomas, jesssCompany)
¬(Miserly(thomas) ∧ NeedToSave(thomas, aLargePortionOfIncome)) → ¬((Value(thomas, qualityManufacturing) ∧ Value(thomas, luxuryItem)))
(Value(thomas, qualityManufacturing) ∧ Value(thomas, luxuryItem)) ∨ ¬(Miserly(x) ∧ NeedToSave(x, aLargePortionOfIncome))

[PREMISE (GK)]:
! [X] : (WorkAt(X, jesssCompany) & GoToSpafrequently(X) => -(Miserly(X) & NeedToSave(X, aLargePortionOfIncome))).
! [X] : (WorkAt(X, jesssCompany) => Miserly(X) & NeedToSave(X, aLargePortionOfIncome)<~> SpendFrivolously(X, aLotOfMoney)).
! [X] : (WorkAt(X, jesssCompany) & SpendFrivolously(X, aLotOfMoney) => Value(X, qualityManufacturing) & Value(X, luxuryItem)).
! [X] : (WorkAt(X, jesssCompany) & Value(X, qualityManufacturing) & Value(X, luxuryItem) => Enjoy(X, shopping, materialisticItem)).
WorkAt(thomas, jesssCompany).
-(Miserly(thomas) & NeedToSave(thomas, aLargePortionOfIncome)) => -((Value(thomas, qualityManufacturing) & Value(thomas, luxuryItem))).
(Value(thomas, qualityManufacturing) & Value(thomas, luxuryItem)) | -(Miserly(x) & NeedToSave(x, aLargePortionOfIncome)).

[CONCLUSION]:
If Thomas either enjoys shopping for materialistic items in his free time or, if he does not, then he goes to the spa frequently, then Thomas neither values quality manufacturing and luxury items nor goes to the spa frequently.

[CONCLUSION (FOL)]:
Enjoy(thomas, shopping, materialisticItem) ⊕ GoToSpaFrequently(thomas) → ¬((Value(x, qualityManufacturing) ∧ Value(x, luxuryItem)) ∨ GoToSpaFrequently(thomas))

[CONCLUSION (GK)]:
Enjoy(thomas, shopping, materialisticItem) <~> GoToSpaFrequently(thomas) => -((Value(X, qualityManufacturing) & Value(X, luxuryItem)) | GoToSpaFrequently(thomas)).


===

['x']
['x']
[PREMISE]:
The indie pop band Phoenix has released six albums. 
Phoenix's album "Wolfgang Amadeus Phoenix" sold over 500,000 copies. 
A certified gold album or single is one which sold over half a million copies. 
"1901" is a single from Phoenix's album "Wolfgang Amadeus Phoenix."
Over 400,000 copies of "1901" have been sold. 

[PREMISE (FOL)]:
AlbumsReleased(phoenix, 6)
Album(wolfgangamadeusphoenix) ∧ IsAlbumOf(wolfgangamadeusphoenix, phoenix) ∧ SoldOver(wolfgangamadeusphoenix, 500,000)
∀x ((Album(x) ∨ Single(x)) ∧ SoldOver(x, 500,000) → CertifiedGold(x))
Single(1901) ∧ From(1901, wolfgangamadeusphoenix) ∧ By(1901, phoenix)
SoldOver(l1901, 400,000)

[PREMISE (GK)]:
AlbumsReleased(phoenix, 6).
Album(wolfgangamadeusphoenix) & IsAlbumOf(wolfgangamadeusphoenix, phoenix) & SoldOver(wolfgangamadeusphoenix, 500,000).
! [X] : ((Album(X) | Single(X)) & SoldOver(X, 500,000) => CertifiedGold(X)).
Single(1901) & From(1901, wolfgangamadeusphoenix) & By(1901, phoenix).
SoldOver(l1901, 400,000).

[CONCLUSION]:
The album "Wolfgang Amadeus Phoenix" is a certified gold album.

[CONCLUSION (FOL)]:
CertifiedGold(wolfgangamAdeusPhoenix)

[CONCLUSION (GK)]:
CertifiedGold(wolfgangamAdeusPhoenix).


===

['x']
['x']
[PREMISE]:
The indie pop band Phoenix has released six albums. 
Phoenix's album "Wolfgang Amadeus Phoenix" sold over 500,000 copies. 
A certified gold album or single is one which sold over half a million copies. 
"1901" is a single from Phoenix's album "Wolfgang Amadeus Phoenix."
Over 400,000 copies of "1901" have been sold. 

[PREMISE (FOL)]:
AlbumsReleased(phoenix, 6)
Album(wolfgangamadeusphoenix) ∧ IsAlbumOf(wolfgangamadeusphoenix, phoenix) ∧ SoldOver(wolfgangamadeusphoenix, 500,000)
∀x ((Album(x) ∨ Single(x)) ∧ SoldOver(x, 500,000) → CertifiedGold(x))
Single(1901) ∧ From(1901, wolfgangamadeusphoenix) ∧ By(1901, phoenix)
SoldOver(l1901, 400,000)

[PREMISE (GK)]:
AlbumsReleased(phoenix, 6).
Album(wolfgangamadeusphoenix) & IsAlbumOf(wolfgangamadeusphoenix, phoenix) & SoldOver(wolfgangamadeusphoenix, 500,000).
! [X] : ((Album(X) | Single(X)) & SoldOver(X, 500,000) => CertifiedGold(X)).
Single(1901) & From(1901, wolfgangamadeusphoenix) & By(1901, phoenix).
SoldOver(l1901, 400,000).

[CONCLUSION]:
The single "1901" is a certified gold single.

[CONCLUSION (FOL)]:
CertifiedGold(1901)

[CONCLUSION (GK)]:
CertifiedGold(1901).


===

['x']
['x']
[PREMISE]:
Peter Parker is either a superhero or a civilian.
The Hulk is a destroyer.
The Hulk wakes up when he is angry.
If the Hulk wakes up, then he will break a bridge.
Thor is a god.
Thor will break a bridge when he is happy.
A god is not a destroyer.
Peter Parker wears a uniform when he is a superhero.
Peter Parker is not a civilian if a destroyer is breaking a bridge.
If Thor is happy, the Hulk is angry.

[PREMISE (FOL)]:
Superhero(peterParker) ⊕ Civilian(peterParker)
Destroyer(theHulk)
Angry(theHulk) → WakesUp(theHulk)
WakesUp(theHulk) → Breaks(theHulk, bridge)
God(thor)
Happy(thor) → Breaks(thor, bridge)
∀x (God(x) → ¬Destroyer(x))
Superhero(peter) → Wears(peter, uniform)
∀x ((Destroyer(x) ∧ Breaks(x,bridge)) → ¬Civilian(peter))
Happy(thor) → Angry(theHulk)

[PREMISE (GK)]:
Superhero(peterParker) <~> Civilian(peterParker).
Destroyer(theHulk).
Angry(theHulk) => WakesUp(theHulk).
WakesUp(theHulk) => Breaks(theHulk, bridge).
God(thor).
Happy(thor) => Breaks(thor, bridge).
! [X] : (God(X) => -Destroyer(X)).
Superhero(peter) => Wears(peter, uniform).
! [X] : ((Destroyer(X) & Breaks(X,bridge)) => -Civilian(peter)).
Happy(thor) => Angry(theHulk).

[CONCLUSION]:
If the Hulk does not wake up, then Thor is not happy.

[CONCLUSION (FOL)]:
¬WakesUp(theHulk) → ¬Happy(thor)

[CONCLUSION (GK)]:
-WakesUp(theHulk) => -Happy(thor).


===

['x']
['x']
[PREMISE]:
Peter Parker is either a superhero or a civilian.
The Hulk is a destroyer.
The Hulk wakes up when he is angry.
If the Hulk wakes up, then he will break a bridge.
Thor is a god.
Thor will break a bridge when he is happy.
A god is not a destroyer.
Peter Parker wears a uniform when he is a superhero.
Peter Parker is not a civilian if a destroyer is breaking a bridge.
If Thor is happy, the Hulk is angry.

[PREMISE (FOL)]:
Superhero(peterParker) ⊕ Civilian(peterParker)
Destroyer(theHulk)
Angry(theHulk) → WakesUp(theHulk)
WakesUp(theHulk) → Breaks(theHulk, bridge)
God(thor)
Happy(thor) → Breaks(thor, bridge)
∀x (God(x) → ¬Destroyer(x))
Superhero(peter) → Wears(peter, uniform)
∀x ((Destroyer(x) ∧ Breaks(x,bridge)) → ¬Civilian(peter))
Happy(thor) → Angry(theHulk)

[PREMISE (GK)]:
Superhero(peterParker) <~> Civilian(peterParker).
Destroyer(theHulk).
Angry(theHulk) => WakesUp(theHulk).
WakesUp(theHulk) => Breaks(theHulk, bridge).
God(thor).
Happy(thor) => Breaks(thor, bridge).
! [X] : (God(X) => -Destroyer(X)).
Superhero(peter) => Wears(peter, uniform).
! [X] : ((Destroyer(X) & Breaks(X,bridge)) => -Civilian(peter)).
Happy(thor) => Angry(theHulk).

[CONCLUSION]:
If Thor is happy, then Peter Parker wears a uniform.

[CONCLUSION (FOL)]:
Happy(thor) → Wears(peterParker, uniform)

[CONCLUSION (GK)]:
Happy(thor) => Wears(peterParker, uniform).


===

['x']
['x']
[PREMISE]:
Peter Parker is either a superhero or a civilian.
The Hulk is a destroyer.
The Hulk wakes up when he is angry.
If the Hulk wakes up, then he will break a bridge.
Thor is a god.
Thor will break a bridge when he is happy.
A god is not a destroyer.
Peter Parker wears a uniform when he is a superhero.
Peter Parker is not a civilian if a destroyer is breaking a bridge.
If Thor is happy, the Hulk is angry.

[PREMISE (FOL)]:
Superhero(peterParker) ⊕ Civilian(peterParker)
Destroyer(theHulk)
Angry(theHulk) → WakesUp(theHulk)
WakesUp(theHulk) → Breaks(theHulk, bridge)
God(thor)
Happy(thor) → Breaks(thor, bridge)
∀x (God(x) → ¬Destroyer(x))
Superhero(peter) → Wears(peter, uniform)
∀x ((Destroyer(x) ∧ Breaks(x,bridge)) → ¬Civilian(peter))
Happy(thor) → Angry(theHulk)

[PREMISE (GK)]:
Superhero(peterParker) <~> Civilian(peterParker).
Destroyer(theHulk).
Angry(theHulk) => WakesUp(theHulk).
WakesUp(theHulk) => Breaks(theHulk, bridge).
God(thor).
Happy(thor) => Breaks(thor, bridge).
! [X] : (God(X) => -Destroyer(X)).
Superhero(peter) => Wears(peter, uniform).
! [X] : ((Destroyer(X) & Breaks(X,bridge)) => -Civilian(peter)).
Happy(thor) => Angry(theHulk).

[CONCLUSION]:
If Thor is not happy, then no bridge will be broken.

[CONCLUSION (FOL)]:
¬Happy(thor) → ¬Breaks(thor, bridge)

[CONCLUSION (GK)]:
-Happy(thor) => -Breaks(thor, bridge).


===

[]
[]
[PREMISE]:
Diethylcarbamazine is a medication discovered in the year 1947.
Diethylcarbamazine can be used to treat river blindness.
The only preferred treatment for river blindness is ivermectin.
Diethylcarbamazine is not ivermectin.

[PREMISE (FOL)]:
Medication(diethylcarbamazine) ∧ DiscoversIn(diethylcarbamazine, yr1947)
Treats(diethylcarbamazine, riverBlindness)
PreferredTreatmentFor(riverBlindness, ivermectin)
¬(Is(diethylcarbamazine, ivermectin))

[PREMISE (GK)]:
Medication(diethylcarbamazine) & DiscoversIn(diethylcarbamazine, yr1947).
Treats(diethylcarbamazine, riverBlindness).
PreferredTreatmentFor(riverBlindness, ivermectin).
-(Is(diethylcarbamazine, ivermectin)).

[CONCLUSION]:
Diethylcarbamazine is not preferred for the treatment of river blindness.

[CONCLUSION (FOL)]:
¬(PreferredTreatmentFor(riverBlindness, diethylcarbamazine))

[CONCLUSION (GK)]:
-(PreferredTreatmentFor(riverBlindness, diethylcarbamazine)).


===

[]
[]
[PREMISE]:
Diethylcarbamazine is a medication discovered in the year 1947.
Diethylcarbamazine can be used to treat river blindness.
The only preferred treatment for river blindness is ivermectin.
Diethylcarbamazine is not ivermectin.

[PREMISE (FOL)]:
Medication(diethylcarbamazine) ∧ DiscoversIn(diethylcarbamazine, yr1947)
Treats(diethylcarbamazine, riverBlindness)
PreferredTreatmentFor(riverBlindness, ivermectin)
¬(Is(diethylcarbamazine, ivermectin))

[PREMISE (GK)]:
Medication(diethylcarbamazine) & DiscoversIn(diethylcarbamazine, yr1947).
Treats(diethylcarbamazine, riverBlindness).
PreferredTreatmentFor(riverBlindness, ivermectin).
-(Is(diethylcarbamazine, ivermectin)).

[CONCLUSION]:
Diethylcarbamazine was often used to treat river blindness.

[CONCLUSION (FOL)]:
Treats(diethylcarbamazine, riverBlindness)

[CONCLUSION (GK)]:
Treats(diethylcarbamazine, riverBlindness).


===

[]
[]
[PREMISE]:
Diethylcarbamazine is a medication discovered in the year 1947.
Diethylcarbamazine can be used to treat river blindness.
The only preferred treatment for river blindness is ivermectin.
Diethylcarbamazine is not ivermectin.

[PREMISE (FOL)]:
Medication(diethylcarbamazine) ∧ DiscoversIn(diethylcarbamazine, yr1947)
Treats(diethylcarbamazine, riverBlindness)
PreferredTreatmentFor(riverBlindness, ivermectin)
¬(Is(diethylcarbamazine, ivermectin))

[PREMISE (GK)]:
Medication(diethylcarbamazine) & DiscoversIn(diethylcarbamazine, yr1947).
Treats(diethylcarbamazine, riverBlindness).
PreferredTreatmentFor(riverBlindness, ivermectin).
-(Is(diethylcarbamazine, ivermectin)).

[CONCLUSION]:
Diethylcarbamazine is used in the treatment of filariasis.

[CONCLUSION (FOL)]:
Treats(diethylcarbamazine, filariasis)

[CONCLUSION (GK)]:
Treats(diethylcarbamazine, filariasis).


===

['x']
['x']
[PREMISE]:
All prime numbers are natural numbers.
All integers are real numbers. 
All real numbers are complex numbers. 
One is a prime number or a natural number or both.
If one is not a complex number, then one is a prime number and an integer.

[PREMISE (FOL)]:
∀x (PrimeNumber(x) → NaturalNumber(x)) 
∀x (Integer(x) → RealNumber(x))
∀x (RealNumber(x) → ComplexNumber(x)) 
PrimeNumber(one) ∨ NaturalNumber(one)
¬ComplexNumber(one) → (PrimeNumber(one) ∧ Integer(one))

[PREMISE (GK)]:
! [X] : (PrimeNumber(X) => NaturalNumber(X)) .
! [X] : (Integer(X) => RealNumber(X)).
! [X] : (RealNumber(X) => ComplexNumber(X)) .
PrimeNumber(one) | NaturalNumber(one).
-ComplexNumber(one) => (PrimeNumber(one) & Integer(one)).

[CONCLUSION]:
One is a real number.

[CONCLUSION (FOL)]:
RealNumber(one)

[CONCLUSION (GK)]:
RealNumber(one).


===

['x']
['x']
[PREMISE]:
All prime numbers are natural numbers.
All integers are real numbers. 
All real numbers are complex numbers. 
One is a prime number or a natural number or both.
If one is not a complex number, then one is a prime number and an integer.

[PREMISE (FOL)]:
∀x (PrimeNumber(x) → NaturalNumber(x)) 
∀x (Integer(x) → RealNumber(x))
∀x (RealNumber(x) → ComplexNumber(x)) 
PrimeNumber(one) ∨ NaturalNumber(one)
¬ComplexNumber(one) → (PrimeNumber(one) ∧ Integer(one))

[PREMISE (GK)]:
! [X] : (PrimeNumber(X) => NaturalNumber(X)) .
! [X] : (Integer(X) => RealNumber(X)).
! [X] : (RealNumber(X) => ComplexNumber(X)) .
PrimeNumber(one) | NaturalNumber(one).
-ComplexNumber(one) => (PrimeNumber(one) & Integer(one)).

[CONCLUSION]:
One is a prime number and a natural number.

[CONCLUSION (FOL)]:
PrimeNumber(one) ∧ NaturalNumber(one)

[CONCLUSION (GK)]:
PrimeNumber(one) & NaturalNumber(one).


===

['x']
['x']
[PREMISE]:
All prime numbers are natural numbers.
All integers are real numbers. 
All real numbers are complex numbers. 
One is a prime number or a natural number or both.
If one is not a complex number, then one is a prime number and an integer.

[PREMISE (FOL)]:
∀x (PrimeNumber(x) → NaturalNumber(x)) 
∀x (Integer(x) → RealNumber(x))
∀x (RealNumber(x) → ComplexNumber(x)) 
PrimeNumber(one) ∨ NaturalNumber(one)
¬ComplexNumber(one) → (PrimeNumber(one) ∧ Integer(one))

[PREMISE (GK)]:
! [X] : (PrimeNumber(X) => NaturalNumber(X)) .
! [X] : (Integer(X) => RealNumber(X)).
! [X] : (RealNumber(X) => ComplexNumber(X)) .
PrimeNumber(one) | NaturalNumber(one).
-ComplexNumber(one) => (PrimeNumber(one) & Integer(one)).

[CONCLUSION]:
One is either a prime number or a natural number.

[CONCLUSION (FOL)]:
PrimeNumber(one) ⊕  NaturalNumber(one)

[CONCLUSION (GK)]:
PrimeNumber(one) <~>  NaturalNumber(one).


===

['x']
['x']
[PREMISE]:
If some diseases require a medical diagnosis, then lab tests or imaging is required. 
All rare diseases require a medical diagnosis.
If a disease is mild, then no lab tests or imaging is required. 
All blood cancers are rare diseases.
All types of leukemia are diseases and blood cancers. 
Bladder cancer is a disease and is blood cancer or Leukemia.

[PREMISE (FOL)]:
∀x (Disease(x) ∧ Require(x, medicalDiagnosis) → RequiredFor(labTest, x) ∨ RequiredFor(imaging, x)) 
∀x (RareDisease(x) → Require(x, medicalDiagnosis))
∀x (Disease(x) ∧ Mild(x) → ¬(RequiredFor(labTest, x) ∨ RequiredFor(imaging, x))) 
∀x (BloodCancer(x) → RareDiseases(x))
∀x (Disease(x) ∧ Leukemia(x) → BloodCancer(x))
Disease(bladderCancer) ∧ (BloodCancer(bladderCancer) ∨ Leukemia(bladderCancer))

[PREMISE (GK)]:
! [X] : (Disease(X) & Require(X, medicalDiagnosis) => RequiredFor(labTest, X) | RequiredFor(imaging, X)) .
! [X] : (RareDisease(X) => Require(X, medicalDiagnosis)).
! [X] : (Disease(X) & Mild(X) => -(RequiredFor(labTest, X) | RequiredFor(imaging, X))) .
! [X] : (BloodCancer(X) => RareDiseases(X)).
! [X] : (Disease(X) & Leukemia(X) => BloodCancer(X)).
Disease(bladderCancer) & (BloodCancer(bladderCancer) | Leukemia(bladderCancer)).

[CONCLUSION]:
Bladder cancer is a mild disease.

[CONCLUSION (FOL)]:
Mild(bladderCancer)

[CONCLUSION (GK)]:
Mild(bladderCancer).


===

['x']
['x']
[PREMISE]:
If some diseases require a medical diagnosis, then lab tests or imaging is required. 
All rare diseases require a medical diagnosis.
If a disease is mild, then no lab tests or imaging is required. 
All blood cancers are rare diseases.
All types of leukemia are diseases and blood cancers. 
Bladder cancer is a disease and is blood cancer or Leukemia.

[PREMISE (FOL)]:
∀x (Disease(x) ∧ Require(x, medicalDiagnosis) → RequiredFor(labTest, x) ∨ RequiredFor(imaging, x)) 
∀x (RareDisease(x) → Require(x, medicalDiagnosis))
∀x (Disease(x) ∧ Mild(x) → ¬(RequiredFor(labTest, x) ∨ RequiredFor(imaging, x))) 
∀x (BloodCancer(x) → RareDiseases(x))
∀x (Disease(x) ∧ Leukemia(x) → BloodCancer(x))
Disease(bladderCancer) ∧ (BloodCancer(bladderCancer) ∨ Leukemia(bladderCancer))

[PREMISE (GK)]:
! [X] : (Disease(X) & Require(X, medicalDiagnosis) => RequiredFor(labTest, X) | RequiredFor(imaging, X)) .
! [X] : (RareDisease(X) => Require(X, medicalDiagnosis)).
! [X] : (Disease(X) & Mild(X) => -(RequiredFor(labTest, X) | RequiredFor(imaging, X))) .
! [X] : (BloodCancer(X) => RareDiseases(X)).
! [X] : (Disease(X) & Leukemia(X) => BloodCancer(X)).
Disease(bladderCancer) & (BloodCancer(bladderCancer) | Leukemia(bladderCancer)).

[CONCLUSION]:
Bladder cancer is Leukemia.

[CONCLUSION (FOL)]:
Leukemia(bladderCancer)

[CONCLUSION (GK)]:
Leukemia(bladderCancer).


===

['x']
['x']
[PREMISE]:
If some diseases require a medical diagnosis, then lab tests or imaging is required. 
All rare diseases require a medical diagnosis.
If a disease is mild, then no lab tests or imaging is required. 
All blood cancers are rare diseases.
All types of leukemia are diseases and blood cancers. 
Bladder cancer is a disease and is blood cancer or Leukemia.

[PREMISE (FOL)]:
∀x (Disease(x) ∧ Require(x, medicalDiagnosis) → RequiredFor(labTest, x) ∨ RequiredFor(imaging, x)) 
∀x (RareDisease(x) → Require(x, medicalDiagnosis))
∀x (Disease(x) ∧ Mild(x) → ¬(RequiredFor(labTest, x) ∨ RequiredFor(imaging, x))) 
∀x (BloodCancer(x) → RareDiseases(x))
∀x (Disease(x) ∧ Leukemia(x) → BloodCancer(x))
Disease(bladderCancer) ∧ (BloodCancer(bladderCancer) ∨ Leukemia(bladderCancer))

[PREMISE (GK)]:
! [X] : (Disease(X) & Require(X, medicalDiagnosis) => RequiredFor(labTest, X) | RequiredFor(imaging, X)) .
! [X] : (RareDisease(X) => Require(X, medicalDiagnosis)).
! [X] : (Disease(X) & Mild(X) => -(RequiredFor(labTest, X) | RequiredFor(imaging, X))) .
! [X] : (BloodCancer(X) => RareDiseases(X)).
! [X] : (Disease(X) & Leukemia(X) => BloodCancer(X)).
Disease(bladderCancer) & (BloodCancer(bladderCancer) | Leukemia(bladderCancer)).

[CONCLUSION]:
Bladder cancer is either a rare disease or a mild disease.

[CONCLUSION (FOL)]:
RareDisease(bladderCancer) ⊕ Mild(bladderCancer)

[CONCLUSION (GK)]:
RareDisease(bladderCancer) <~> Mild(bladderCancer).


===

['x', 'y']
['x', 'y']
[PREMISE]:
There are no elements with atomic number between 61-63 that are not scarce in China.
Non-rare earth elements are not scarce in China.
All elements are either non-rare earth elements or rare earth elements. 
All rare earth elements can be used for industry.
All rare earth elements are essential for exploring future directions of electronics.
Lithium is either a non-rare earth element and essential for exploring future directions of electronics, or is not a non-rare earth element and is not essential for exploring future directions of electronics.

[PREMISE (FOL)]:
∀x ((Element(x) ∧ ∃y(Between(y, num61, num63) ∧ AtomicNumber(x, y))) → ScarceIn(x, china))
∀x (¬RareEarthElement(x) → ¬ScarceIn(x, china)) 
∀x (¬RareEarthElement(x) ⊕ RareEarthElement(x)) 
∀x (RareEarthElement(x) → UsedIn(x, industry)) 
∀x (RareEarthElement(x) → EssentialFor(x, electronics))
¬(¬RareEarthElement(lithium) ⊕ EssentialFor(lithium, electronics))

[PREMISE (GK)]:
! [X] : ((Element(X) & ? [Y] :(Between(Y, num61, num63) & AtomicNumber(X, Y))) => ScarceIn(X, china)).
! [X] : (-RareEarthElement(X) => -ScarceIn(X, china)) .
! [X] : (-RareEarthElement(X) <~> RareEarthElement(X)) .
! [X] : (RareEarthElement(X) => UsedIn(X, industry)) .
! [X] : (RareEarthElement(X) => EssentialFor(X, electronics)).
-(-RareEarthElement(lithium) <~> EssentialFor(lithium, electronics)).

[CONCLUSION]:
Lithium is a rare earth element.

[CONCLUSION (FOL)]:
RareEarthElement(lithium)

[CONCLUSION (GK)]:
RareEarthElement(lithium).


===

['x', 'y']
['x', 'y']
[PREMISE]:
There are no elements with atomic number between 61-63 that are not scarce in China.
Non-rare earth elements are not scarce in China.
All elements are either non-rare earth elements or rare earth elements. 
All rare earth elements can be used for industry.
All rare earth elements are essential for exploring future directions of electronics.
Lithium is either a non-rare earth element and essential for exploring future directions of electronics, or is not a non-rare earth element and is not essential for exploring future directions of electronics.

[PREMISE (FOL)]:
∀x ((Element(x) ∧ ∃y(Between(y, num61, num63) ∧ AtomicNumber(x, y))) → ScarceIn(x, china))
∀x (¬RareEarthElement(x) → ¬ScarceIn(x, china)) 
∀x (¬RareEarthElement(x) ⊕ RareEarthElement(x)) 
∀x (RareEarthElement(x) → UsedIn(x, industry)) 
∀x (RareEarthElement(x) → EssentialFor(x, electronics))
¬(¬RareEarthElement(lithium) ⊕ EssentialFor(lithium, electronics))

[PREMISE (GK)]:
! [X] : ((Element(X) & ? [Y] :(Between(Y, num61, num63) & AtomicNumber(X, Y))) => ScarceIn(X, china)).
! [X] : (-RareEarthElement(X) => -ScarceIn(X, china)) .
! [X] : (-RareEarthElement(X) <~> RareEarthElement(X)) .
! [X] : (RareEarthElement(X) => UsedIn(X, industry)) .
! [X] : (RareEarthElement(X) => EssentialFor(X, electronics)).
-(-RareEarthElement(lithium) <~> EssentialFor(lithium, electronics)).

[CONCLUSION]:
Lithium is an element with atomic number between 61-63 and is used for batteries.

[CONCLUSION (FOL)]:
Element(x) ∧ ∃y(Between(y, num61, num63) ∧ AtomicNumber(x, y)) ∧ UsedFor(lithium, batteries)

[CONCLUSION (GK)]:
Element(X) & ? [Y] :(Between(Y, num61, num63) & AtomicNumber(X, Y)) & UsedFor(lithium, batteries).


===

['x', 'y']
['x', 'y']
[PREMISE]:
There are no elements with atomic number between 61-63 that are not scarce in China.
Non-rare earth elements are not scarce in China.
All elements are either non-rare earth elements or rare earth elements. 
All rare earth elements can be used for industry.
All rare earth elements are essential for exploring future directions of electronics.
Lithium is either a non-rare earth element and essential for exploring future directions of electronics, or is not a non-rare earth element and is not essential for exploring future directions of electronics.

[PREMISE (FOL)]:
∀x ((Element(x) ∧ ∃y(Between(y, num61, num63) ∧ AtomicNumber(x, y))) → ScarceIn(x, china))
∀x (¬RareEarthElement(x) → ¬ScarceIn(x, china)) 
∀x (¬RareEarthElement(x) ⊕ RareEarthElement(x)) 
∀x (RareEarthElement(x) → UsedIn(x, industry)) 
∀x (RareEarthElement(x) → EssentialFor(x, electronics))
¬(¬RareEarthElement(lithium) ⊕ EssentialFor(lithium, electronics))

[PREMISE (GK)]:
! [X] : ((Element(X) & ? [Y] :(Between(Y, num61, num63) & AtomicNumber(X, Y))) => ScarceIn(X, china)).
! [X] : (-RareEarthElement(X) => -ScarceIn(X, china)) .
! [X] : (-RareEarthElement(X) <~> RareEarthElement(X)) .
! [X] : (RareEarthElement(X) => UsedIn(X, industry)) .
! [X] : (RareEarthElement(X) => EssentialFor(X, electronics)).
-(-RareEarthElement(lithium) <~> EssentialFor(lithium, electronics)).

[CONCLUSION]:
If Lithium is not essential for exploring future directions of electronics or an element with atomic number between 61-63, then Lithium is not a non-rare earth element or usable in industry.

[CONCLUSION (FOL)]:
¬(EssentialFor(lithium, electronics) ⊕ (∃y(Between(y, num61, num63) ∧ AtomicNumber(lithium, y)))) → ¬(¬RareEarthMetals(lithium) ∨ UsedIn(lithium, industry))

[CONCLUSION (GK)]:
-(EssentialFor(lithium, electronics) <~> (? [Y] :(Between(Y, num61, num63) & AtomicNumber(lithium, Y)))) => -(-RareEarthMetals(lithium) | UsedIn(lithium, industry)).


===

['x']
['x']
[PREMISE]:
If people don't often clean their homes, then they do not have tidy houses.
If people don't prioritize cleaning, then they do not often clean their homes.
If people hire a maid or cleaning service, then they have tidy houses.
If people don't care about cleanliness, then they do not prioritize cleaning.
Either Jack does hire a maid or cleaning service and does not often clean his home, or he does not hire a maid or cleaning service nor often clean his home.

[PREMISE (FOL)]:
∀x (¬CleanOften(x, home) → ¬Have(x, tidyHouse))
∀x (¬Prioritize(x, cleaning) → ¬CleanOften(x, home))
∀x (Hire(x, maid) ∨ Hire(x, cleaningService) → Have(x, tidyHouse))
∀x (¬CareAbout(x, cleanliness) → ¬Prioritize(x, cleaning))
¬(Hire(x, maid) ∨ Hire(x, cleaningService)) ⊕ ¬CleanOften(jack, home))

[PREMISE (GK)]:
! [X] : (-CleanOften(X, home) => -Have(X, tidyHouse)).
! [X] : (-Prioritize(X, cleaning) => -CleanOften(X, home)).
! [X] : (Hire(X, maid) | Hire(X, cleaningService) => Have(X, tidyHouse)).
! [X] : (-CareAbout(X, cleanliness) => -Prioritize(X, cleaning)).
-(Hire(x, maid) | Hire(x, cleaningService)) <~> -CleanOften(jack, home)).

[CONCLUSION]:
Jack doesn't care about cleanliness.

[CONCLUSION (FOL)]:
¬(CareAbout(jack, cleanliness))

[CONCLUSION (GK)]:
-(CareAbout(jack, cleanliness)).


===

['x']
['x']
[PREMISE]:
If people don't often clean their homes, then they do not have tidy houses.
If people don't prioritize cleaning, then they do not often clean their homes.
If people hire a maid or cleaning service, then they have tidy houses.
If people don't care about cleanliness, then they do not prioritize cleaning.
Either Jack does hire a maid or cleaning service and does not often clean his home, or he does not hire a maid or cleaning service nor often clean his home.

[PREMISE (FOL)]:
∀x (¬CleanOften(x, home) → ¬Have(x, tidyHouse))
∀x (¬Prioritize(x, cleaning) → ¬CleanOften(x, home))
∀x (Hire(x, maid) ∨ Hire(x, cleaningService) → Have(x, tidyHouse))
∀x (¬CareAbout(x, cleanliness) → ¬Prioritize(x, cleaning))
¬(Hire(x, maid) ∨ Hire(x, cleaningService)) ⊕ ¬CleanOften(jack, home))

[PREMISE (GK)]:
! [X] : (-CleanOften(X, home) => -Have(X, tidyHouse)).
! [X] : (-Prioritize(X, cleaning) => -CleanOften(X, home)).
! [X] : (Hire(X, maid) | Hire(X, cleaningService) => Have(X, tidyHouse)).
! [X] : (-CareAbout(X, cleanliness) => -Prioritize(X, cleaning)).
-(Hire(x, maid) | Hire(x, cleaningService)) <~> -CleanOften(jack, home)).

[CONCLUSION]:
Jack does care about cleanliness.

[CONCLUSION (FOL)]:
CareAbout(jack, cleanliness)

[CONCLUSION (GK)]:
CareAbout(jack, cleanliness).


===

['x']
['x']
[PREMISE]:
If people don't often clean their homes, then they do not have tidy houses.
If people don't prioritize cleaning, then they do not often clean their homes.
If people hire a maid or cleaning service, then they have tidy houses.
If people don't care about cleanliness, then they do not prioritize cleaning.
Either Jack does hire a maid or cleaning service and does not often clean his home, or he does not hire a maid or cleaning service nor often clean his home.

[PREMISE (FOL)]:
∀x (¬CleanOften(x, home) → ¬Have(x, tidyHouse))
∀x (¬Prioritize(x, cleaning) → ¬CleanOften(x, home))
∀x (Hire(x, maid) ∨ Hire(x, cleaningService) → Have(x, tidyHouse))
∀x (¬CareAbout(x, cleanliness) → ¬Prioritize(x, cleaning))
¬(Hire(x, maid) ∨ Hire(x, cleaningService)) ⊕ ¬CleanOften(jack, home))

[PREMISE (GK)]:
! [X] : (-CleanOften(X, home) => -Have(X, tidyHouse)).
! [X] : (-Prioritize(X, cleaning) => -CleanOften(X, home)).
! [X] : (Hire(X, maid) | Hire(X, cleaningService) => Have(X, tidyHouse)).
! [X] : (-CareAbout(X, cleanliness) => -Prioritize(X, cleaning)).
-(Hire(x, maid) | Hire(x, cleaningService)) <~> -CleanOften(jack, home)).

[CONCLUSION]:
Jack has a tidy house.

[CONCLUSION (FOL)]:
Have(jack, tidyHouse)

[CONCLUSION (GK)]:
Have(jack, tidyHouse).


===

['x']
['x']
[PREMISE]:
If people don't often clean their homes, then they do not have tidy houses.
If people don't prioritize cleaning, then they do not often clean their homes.
If people hire a maid or cleaning service, then they have tidy houses.
If people don't care about cleanliness, then they do not prioritize cleaning.
Either Jack does hire a maid or cleaning service and does not often clean his home, or he does not hire a maid or cleaning service nor often clean his home.

[PREMISE (FOL)]:
∀x (¬CleanOften(x, home) → ¬Have(x, tidyHouse))
∀x (¬Prioritize(x, cleaning) → ¬CleanOften(x, home))
∀x (Hire(x, maid) ∨ Hire(x, cleaningService) → Have(x, tidyHouse))
∀x (¬CareAbout(x, cleanliness) → ¬Prioritize(x, cleaning))
¬(Hire(x, maid) ∨ Hire(x, cleaningService)) ⊕ ¬CleanOften(jack, home))

[PREMISE (GK)]:
! [X] : (-CleanOften(X, home) => -Have(X, tidyHouse)).
! [X] : (-Prioritize(X, cleaning) => -CleanOften(X, home)).
! [X] : (Hire(X, maid) | Hire(X, cleaningService) => Have(X, tidyHouse)).
! [X] : (-CareAbout(X, cleanliness) => -Prioritize(X, cleaning)).
-(Hire(x, maid) | Hire(x, cleaningService)) <~> -CleanOften(jack, home)).

[CONCLUSION]:
Jack neither lives in the suburbs nor is too busy to clean.

[CONCLUSION (FOL)]:
¬(¬CareAbout(jack, cleanliness) ∨ ¬CleanOften(jack, home)

[CONCLUSION (GK)]:
-(-CareAbout(jack, cleanliness) | -CleanOften(jack, home).


===

['x']
['x']
[PREMISE]:
If people don't often clean their homes, then they do not have tidy houses.
If people don't prioritize cleaning, then they do not often clean their homes.
If people hire a maid or cleaning service, then they have tidy houses.
If people don't care about cleanliness, then they do not prioritize cleaning.
Either Jack does hire a maid or cleaning service and does not often clean his home, or he does not hire a maid or cleaning service nor often clean his home.

[PREMISE (FOL)]:
∀x (¬CleanOften(x, home) → ¬Have(x, tidyHouse))
∀x (¬Prioritize(x, cleaning) → ¬CleanOften(x, home))
∀x (Hire(x, maid) ∨ Hire(x, cleaningService) → Have(x, tidyHouse))
∀x (¬CareAbout(x, cleanliness) → ¬Prioritize(x, cleaning))
¬(Hire(x, maid) ∨ Hire(x, cleaningService)) ⊕ ¬CleanOften(jack, home))

[PREMISE (GK)]:
! [X] : (-CleanOften(X, home) => -Have(X, tidyHouse)).
! [X] : (-Prioritize(X, cleaning) => -CleanOften(X, home)).
! [X] : (Hire(X, maid) | Hire(X, cleaningService) => Have(X, tidyHouse)).
! [X] : (-CareAbout(X, cleanliness) => -Prioritize(X, cleaning)).
-(Hire(x, maid) | Hire(x, cleaningService)) <~> -CleanOften(jack, home)).

[CONCLUSION]:
Jack is overburdened and lives in the suburbs.

[CONCLUSION (FOL)]:
¬Prioritize(jack, cleaning) ∨ ¬CareAbout(jack, cleanliness)

[CONCLUSION (GK)]:
-Prioritize(jack, cleaning) | -CareAbout(jack, cleanliness).


===

[]
[]
[PREMISE]:
The bottle not falling is either standing upright or toppled over. 
The bottle not falling is not standing upright.

[PREMISE (FOL)]:
¬Falling(bottle) → (Upright(bottle) ⊕ ToppledOver(bottle))
¬Falling(bottle) → ¬Upright(bottle)

[PREMISE (GK)]:
-Falling(bottle) => (Upright(bottle) <~> ToppledOver(bottle)).
-Falling(bottle) => -Upright(bottle).

[CONCLUSION]:
The bottle not falling is toppled over.

[CONCLUSION (FOL)]:
¬Falling(bottle) → ToppleOver(bottle)

[CONCLUSION (GK)]:
-Falling(bottle) => ToppleOver(bottle).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Everyone who chooses what they want to do with their time has flexible schedules.
Everyone with a lot of free time chooses what they want to do with their time.
People either have a lot of free time or they invest in a career in which they are willing to spend the rest of their lives.
If people invest in a career in which they are willing to spend the rest of their lives, then they are hardworking individuals with high ambitions and goals for the future.  
If people are hardworking individuals with high ambitions and goals for the future, then they are not short sighted.
John is not either a hardworking individual with high ambitions and goals for the future or has a flexible schedule.

[PREMISE (FOL)]:
∀x (ChooseWhatToDoWith(x, time) → FlexibleSchedule(x))
∀x (Have(x, lotsOfFreetime) → ChooseWhatToDoWith(x, time))
∀x (Have(x, lotsOfFreetime) ⊕ (∃y (InvestIn(x, y) ∧ Career(y) ∧ WillingToSpendIn(restOfLife, y))))
∀x (∃y (InvestIn(x, y) ∧ Career(y) ∧ WillingToSpendIn(restOfLife, y)) → Hardworking(x))
∀x (Hardworking(x) ∧ HaveFor(x, highAmbition, future) ∧ HaveFor(x, goal, future) → ¬ShortSighted(x))
¬((Hardworking(john) ∧ HaveFor(john, highAmbition, future) ∧ HaveFor(john, goal, future)) ⊕ FlexibleSchedule(john))

[PREMISE (GK)]:
! [X] : (ChooseWhatToDoWith(X, time) => FlexibleSchedule(X)).
! [X] : (Have(X, lotsOfFreetime) => ChooseWhatToDoWith(X, time)).
! [X] : (Have(X, lotsOfFreetime) <~> (? [Y] : (InvestIn(X, Y) & Career(Y) & WillingToSpendIn(restOfLife, Y)))).
! [X] : (? [Y] : (InvestIn(X, Y) & Career(Y) & WillingToSpendIn(restOfLife, Y)) => Hardworking(X)).
! [X] : (Hardworking(X) & HaveFor(X, highAmbition, future) & HaveFor(X, goal, future) => -ShortSighted(X)).
-((Hardworking(john) & HaveFor(john, highAmbition, future) & HaveFor(john, goal, future)) <~> FlexibleSchedule(john)).

[CONCLUSION]:
John is short sighted.

[CONCLUSION (FOL)]:
Organized(john)

[CONCLUSION (GK)]:
Organized(john).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Everyone who chooses what they want to do with their time has flexible schedules.
Everyone with a lot of free time chooses what they want to do with their time.
People either have a lot of free time or they invest in a career in which they are willing to spend the rest of their lives.
If people invest in a career in which they are willing to spend the rest of their lives, then they are hardworking individuals with high ambitions and goals for the future.  
If people are hardworking individuals with high ambitions and goals for the future, then they are not short sighted.
John is not either a hardworking individual with high ambitions and goals for the future or has a flexible schedule.

[PREMISE (FOL)]:
∀x (ChooseWhatToDoWith(x, time) → FlexibleSchedule(x))
∀x (Have(x, lotsOfFreetime) → ChooseWhatToDoWith(x, time))
∀x (Have(x, lotsOfFreetime) ⊕ (∃y (InvestIn(x, y) ∧ Career(y) ∧ WillingToSpendIn(restOfLife, y))))
∀x (∃y (InvestIn(x, y) ∧ Career(y) ∧ WillingToSpendIn(restOfLife, y)) → Hardworking(x))
∀x (Hardworking(x) ∧ HaveFor(x, highAmbition, future) ∧ HaveFor(x, goal, future) → ¬ShortSighted(x))
¬((Hardworking(john) ∧ HaveFor(john, highAmbition, future) ∧ HaveFor(john, goal, future)) ⊕ FlexibleSchedule(john))

[PREMISE (GK)]:
! [X] : (ChooseWhatToDoWith(X, time) => FlexibleSchedule(X)).
! [X] : (Have(X, lotsOfFreetime) => ChooseWhatToDoWith(X, time)).
! [X] : (Have(X, lotsOfFreetime) <~> (? [Y] : (InvestIn(X, Y) & Career(Y) & WillingToSpendIn(restOfLife, Y)))).
! [X] : (? [Y] : (InvestIn(X, Y) & Career(Y) & WillingToSpendIn(restOfLife, Y)) => Hardworking(X)).
! [X] : (Hardworking(X) & HaveFor(X, highAmbition, future) & HaveFor(X, goal, future) => -ShortSighted(X)).
-((Hardworking(john) & HaveFor(john, highAmbition, future) & HaveFor(john, goal, future)) <~> FlexibleSchedule(john)).

[CONCLUSION]:
John chooses what he want to do with his time.

[CONCLUSION (FOL)]:
ChooseWhatToDoWith(john, time)

[CONCLUSION (GK)]:
ChooseWhatToDoWith(john, time).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Everyone who chooses what they want to do with their time has flexible schedules.
Everyone with a lot of free time chooses what they want to do with their time.
People either have a lot of free time or they invest in a career in which they are willing to spend the rest of their lives.
If people invest in a career in which they are willing to spend the rest of their lives, then they are hardworking individuals with high ambitions and goals for the future.  
If people are hardworking individuals with high ambitions and goals for the future, then they are not short sighted.
John is not either a hardworking individual with high ambitions and goals for the future or has a flexible schedule.

[PREMISE (FOL)]:
∀x (ChooseWhatToDoWith(x, time) → FlexibleSchedule(x))
∀x (Have(x, lotsOfFreetime) → ChooseWhatToDoWith(x, time))
∀x (Have(x, lotsOfFreetime) ⊕ (∃y (InvestIn(x, y) ∧ Career(y) ∧ WillingToSpendIn(restOfLife, y))))
∀x (∃y (InvestIn(x, y) ∧ Career(y) ∧ WillingToSpendIn(restOfLife, y)) → Hardworking(x))
∀x (Hardworking(x) ∧ HaveFor(x, highAmbition, future) ∧ HaveFor(x, goal, future) → ¬ShortSighted(x))
¬((Hardworking(john) ∧ HaveFor(john, highAmbition, future) ∧ HaveFor(john, goal, future)) ⊕ FlexibleSchedule(john))

[PREMISE (GK)]:
! [X] : (ChooseWhatToDoWith(X, time) => FlexibleSchedule(X)).
! [X] : (Have(X, lotsOfFreetime) => ChooseWhatToDoWith(X, time)).
! [X] : (Have(X, lotsOfFreetime) <~> (? [Y] : (InvestIn(X, Y) & Career(Y) & WillingToSpendIn(restOfLife, Y)))).
! [X] : (? [Y] : (InvestIn(X, Y) & Career(Y) & WillingToSpendIn(restOfLife, Y)) => Hardworking(X)).
! [X] : (Hardworking(X) & HaveFor(X, highAmbition, future) & HaveFor(X, goal, future) => -ShortSighted(X)).
-((Hardworking(john) & HaveFor(john, highAmbition, future) & HaveFor(john, goal, future)) <~> FlexibleSchedule(john)).

[CONCLUSION]:
John is either a hardworking individual with high ambitions and goals for the future or is short sighted.

[CONCLUSION (FOL)]:
(Hardworking(john) ∧ HaveFor(john, highAmbition, future) ∧ HaveFor(john, goal, future)) ⊕ ShortSighted(john)

[CONCLUSION (GK)]:
(Hardworking(john) & HaveFor(john, highAmbition, future) & HaveFor(john, goal, future)) <~> ShortSighted(john).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Ableton has an office in Germany.
Ableton has an office in the USA.
USA and Germany are different countries.
Any company that has offices in different countries is a multinational company.
Ableton makes music software.

[PREMISE (FOL)]:
OfficeIn(ableton, germany)
OfficeIn(ableton, unitedStates)
¬SameCountry(germany, unitedStates)
∀x ∀y ∀z (OfficeIn(x, y) ∧ OfficeIn(x, z) ∧ (¬SameCountry(y, z)) → MultinationalCompany(x))
MakesMusicSoftware(ableton)

[PREMISE (GK)]:
OfficeIn(ableton, germany).
OfficeIn(ableton, unitedStates).
-SameCountry(germany, unitedStates).
! [X] : ! [Y] : ! [Z] : (OfficeIn(X, Y) & OfficeIn(X, Z) & (-SameCountry(Y, Z)) => MultinationalCompany(X)).
MakesMusicSoftware(ableton).

[CONCLUSION]:
Ableton is a multinational company.

[CONCLUSION (FOL)]:
MultinationalCompany(ableton)

[CONCLUSION (GK)]:
MultinationalCompany(ableton).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Ableton has an office in Germany.
Ableton has an office in the USA.
USA and Germany are different countries.
Any company that has offices in different countries is a multinational company.
Ableton makes music software.

[PREMISE (FOL)]:
OfficeIn(ableton, germany)
OfficeIn(ableton, unitedStates)
¬SameCountry(germany, unitedStates)
∀x ∀y ∀z (OfficeIn(x, y) ∧ OfficeIn(x, z) ∧ (¬SameCountry(y, z)) → MultinationalCompany(x))
MakesMusicSoftware(ableton)

[PREMISE (GK)]:
OfficeIn(ableton, germany).
OfficeIn(ableton, unitedStates).
-SameCountry(germany, unitedStates).
! [X] : ! [Y] : ! [Z] : (OfficeIn(X, Y) & OfficeIn(X, Z) & (-SameCountry(Y, Z)) => MultinationalCompany(X)).
MakesMusicSoftware(ableton).

[CONCLUSION]:
Ableton makes AI software.

[CONCLUSION (FOL)]:
MakesAISoftware(ableton)

[CONCLUSION (GK)]:
MakesAISoftware(ableton).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Ableton has an office in Germany.
Ableton has an office in the USA.
USA and Germany are different countries.
Any company that has offices in different countries is a multinational company.
Ableton makes music software.

[PREMISE (FOL)]:
OfficeIn(ableton, germany)
OfficeIn(ableton, unitedStates)
¬SameCountry(germany, unitedStates)
∀x ∀y ∀z (OfficeIn(x, y) ∧ OfficeIn(x, z) ∧ (¬SameCountry(y, z)) → MultinationalCompany(x))
MakesMusicSoftware(ableton)

[PREMISE (GK)]:
OfficeIn(ableton, germany).
OfficeIn(ableton, unitedStates).
-SameCountry(germany, unitedStates).
! [X] : ! [Y] : ! [Z] : (OfficeIn(X, Y) & OfficeIn(X, Z) & (-SameCountry(Y, Z)) => MultinationalCompany(X)).
MakesMusicSoftware(ableton).

[CONCLUSION]:
Ableton does not have an office in Germany.

[CONCLUSION (FOL)]:
¬OfficeIn(ableton, germany)

[CONCLUSION (GK)]:
-OfficeIn(ableton, germany).


===

['x']
['x']
[PREMISE]:
Those who can fly over a vast distance glide in the air. 
Flightless birds cannot fly over a vast distance. 
Penguins are flightless birds. 
Nonflying birds in Antarctica are penguins. 
Fido is a penguin, or flies over a vast distance. 

[PREMISE (FOL)]:
∀x (FlyOver(x, vastDistance) → GlideInAir(x))
∀x (Flightless(x) ∧ Bird(x) → ¬FlyOver(x, vastDistance))
∀x (Penguin(x) → Flightless(x) ∧ Bird(x))
∀x (NonFlying(x) ∧ Bird(x) ∧ In(x, antarctica) → Penguin(x))
Penguin(fido) ∨ FlyOver(fido, vastDistance)

[PREMISE (GK)]:
! [X] : (FlyOver(X, vastDistance) => GlideInAir(X)).
! [X] : (Flightless(X) & Bird(X) => -FlyOver(X, vastDistance)).
! [X] : (Penguin(X) => Flightless(X) & Bird(X)).
! [X] : (NonFlying(X) & Bird(X) & In(X, antarctica) => Penguin(X)).
Penguin(fido) | FlyOver(fido, vastDistance).

[CONCLUSION]:
Fido is a flightless bird

[CONCLUSION (FOL)]:
Flightless(fido) ∧ Bird(fido)

[CONCLUSION (GK)]:
Flightless(fido) & Bird(fido).


===

['x']
['x']
[PREMISE]:
Those who can fly over a vast distance glide in the air. 
Flightless birds cannot fly over a vast distance. 
Penguins are flightless birds. 
Nonflying birds in Antarctica are penguins. 
Fido is a penguin, or flies over a vast distance. 

[PREMISE (FOL)]:
∀x (FlyOver(x, vastDistance) → GlideInAir(x))
∀x (Flightless(x) ∧ Bird(x) → ¬FlyOver(x, vastDistance))
∀x (Penguin(x) → Flightless(x) ∧ Bird(x))
∀x (NonFlying(x) ∧ Bird(x) ∧ In(x, antarctica) → Penguin(x))
Penguin(fido) ∨ FlyOver(fido, vastDistance)

[PREMISE (GK)]:
! [X] : (FlyOver(X, vastDistance) => GlideInAir(X)).
! [X] : (Flightless(X) & Bird(X) => -FlyOver(X, vastDistance)).
! [X] : (Penguin(X) => Flightless(X) & Bird(X)).
! [X] : (NonFlying(X) & Bird(X) & In(X, antarctica) => Penguin(X)).
Penguin(fido) | FlyOver(fido, vastDistance).

[CONCLUSION]:
Fido is not a nonflying bird in Antarctica, and he cannot glid in the air.

[CONCLUSION (FOL)]:
¬(NonFlying(fido) ∧ Bird(fido) ∧ In(fido, antarctica)) ∧ ¬GlideInAir(fido)

[CONCLUSION (GK)]:
-(NonFlying(fido) & Bird(fido) & In(fido, antarctica)) & -GlideInAir(fido).


===

['x']
['x']
[PREMISE]:
Those who can fly over a vast distance glide in the air. 
Flightless birds cannot fly over a vast distance. 
Penguins are flightless birds. 
Nonflying birds in Antarctica are penguins. 
Fido is a penguin, or flies over a vast distance. 

[PREMISE (FOL)]:
∀x (FlyOver(x, vastDistance) → GlideInAir(x))
∀x (Flightless(x) ∧ Bird(x) → ¬FlyOver(x, vastDistance))
∀x (Penguin(x) → Flightless(x) ∧ Bird(x))
∀x (NonFlying(x) ∧ Bird(x) ∧ In(x, antarctica) → Penguin(x))
Penguin(fido) ∨ FlyOver(fido, vastDistance)

[PREMISE (GK)]:
! [X] : (FlyOver(X, vastDistance) => GlideInAir(X)).
! [X] : (Flightless(X) & Bird(X) => -FlyOver(X, vastDistance)).
! [X] : (Penguin(X) => Flightless(X) & Bird(X)).
! [X] : (NonFlying(X) & Bird(X) & In(X, antarctica) => Penguin(X)).
Penguin(fido) | FlyOver(fido, vastDistance).

[CONCLUSION]:
If Fido either can fly over a vast distance or cannot fly over a vast distance, then Fido is a nonflying bird in Antartica.

[CONCLUSION (FOL)]:
(FlyOver(fido, vastDistance) ⊕ ¬FlyOver(fido, vastDistance)) → (NonFlying(fido) ∧ Bird(fido) ∧ In(fido, antarctica))

[CONCLUSION (GK)]:
(FlyOver(fido, vastDistance) <~> -FlyOver(fido, vastDistance)) => (NonFlying(fido) & Bird(fido) & In(fido, antarctica)).


===

['x']
['x']
[PREMISE]:
All members of the university faculty are professors.
All principal investigators are members of the university faculty.
No professor is also an undergraduate student.
Anyone pursuing a bachelor's degree is an undergraduate student.
Leon is not pursuing a bachelor's degree, and he is not a principal investigator.
If Leon is not pursuing a bachelor's degree, then he is a professor.

[PREMISE (FOL)]:
∀x (MemberOf(x, universityFaculty) → Professor(x))
∀x (PrincipalInvestigator(x) → MemberOf(x, universityFaculty))
∀x (Professor(x) → ¬UndergraduateStudent(x))
∀x (Pursuing(x, bachelor) → UndergraduateStudent(x))
¬(Pursuing(leon, bachelor) ⊕ PrincipalInvestigator(leon))
¬Pursuing(leon, bachelor) → Professor(leon)

[PREMISE (GK)]:
! [X] : (MemberOf(X, universityFaculty) => Professor(X)).
! [X] : (PrincipalInvestigator(X) => MemberOf(X, universityFaculty)).
! [X] : (Professor(X) => -UndergraduateStudent(X)).
! [X] : (Pursuing(X, bachelor) => UndergraduateStudent(X)).
-(Pursuing(leon, bachelor) <~> PrincipalInvestigator(leon)).
-Pursuing(leon, bachelor) => Professor(leon).

[CONCLUSION]:
Leon is a member of university faculty.

[CONCLUSION (FOL)]:
MemberOf(leon, universityFaculty)

[CONCLUSION (GK)]:
MemberOf(leon, universityFaculty).


===

['x']
['x']
[PREMISE]:
All members of the university faculty are professors.
All principal investigators are members of the university faculty.
No professor is also an undergraduate student.
Anyone pursuing a bachelor's degree is an undergraduate student.
Leon is not pursuing a bachelor's degree, and he is not a principal investigator.
If Leon is not pursuing a bachelor's degree, then he is a professor.

[PREMISE (FOL)]:
∀x (MemberOf(x, universityFaculty) → Professor(x))
∀x (PrincipalInvestigator(x) → MemberOf(x, universityFaculty))
∀x (Professor(x) → ¬UndergraduateStudent(x))
∀x (Pursuing(x, bachelor) → UndergraduateStudent(x))
¬(Pursuing(leon, bachelor) ⊕ PrincipalInvestigator(leon))
¬Pursuing(leon, bachelor) → Professor(leon)

[PREMISE (GK)]:
! [X] : (MemberOf(X, universityFaculty) => Professor(X)).
! [X] : (PrincipalInvestigator(X) => MemberOf(X, universityFaculty)).
! [X] : (Professor(X) => -UndergraduateStudent(X)).
! [X] : (Pursuing(X, bachelor) => UndergraduateStudent(X)).
-(Pursuing(leon, bachelor) <~> PrincipalInvestigator(leon)).
-Pursuing(leon, bachelor) => Professor(leon).

[CONCLUSION]:
Leon is neither an undergraduate student nor a principal investigator.

[CONCLUSION (FOL)]:
¬UndergraduateStudent(leon) ∧ ¬PrincipalInvestigator(leon)

[CONCLUSION (GK)]:
-UndergraduateStudent(leon) & -PrincipalInvestigator(leon).


===

['x']
['x']
[PREMISE]:
All members of the university faculty are professors.
All principal investigators are members of the university faculty.
No professor is also an undergraduate student.
Anyone pursuing a bachelor's degree is an undergraduate student.
Leon is not pursuing a bachelor's degree, and he is not a principal investigator.
If Leon is not pursuing a bachelor's degree, then he is a professor.

[PREMISE (FOL)]:
∀x (MemberOf(x, universityFaculty) → Professor(x))
∀x (PrincipalInvestigator(x) → MemberOf(x, universityFaculty))
∀x (Professor(x) → ¬UndergraduateStudent(x))
∀x (Pursuing(x, bachelor) → UndergraduateStudent(x))
¬(Pursuing(leon, bachelor) ⊕ PrincipalInvestigator(leon))
¬Pursuing(leon, bachelor) → Professor(leon)

[PREMISE (GK)]:
! [X] : (MemberOf(X, universityFaculty) => Professor(X)).
! [X] : (PrincipalInvestigator(X) => MemberOf(X, universityFaculty)).
! [X] : (Professor(X) => -UndergraduateStudent(X)).
! [X] : (Pursuing(X, bachelor) => UndergraduateStudent(X)).
-(Pursuing(leon, bachelor) <~> PrincipalInvestigator(leon)).
-Pursuing(leon, bachelor) => Professor(leon).

[CONCLUSION]:
If leon is not a principal investigator, then Leon is an undergraduate student.

[CONCLUSION (FOL)]:
¬PrincipalInvestigator(leon) → UndergraduateStudent(leon)

[CONCLUSION (GK)]:
-PrincipalInvestigator(leon) => UndergraduateStudent(leon).


===

['x']
['x']
[PREMISE]:
A cutman is responsible for preventing and treating physical damage to a fighter.
Cutmen appear in boxing matches, kickboxing matches, or mixed martial arts matches bout. 
Cutmen handle swelling, nosebleeds and lacerations. 
Jack is a cutman.

[PREMISE (FOL)]:
∀x (Cutman(x) → Prevent(x, physicalDamageToAFighter) ∧ Treat(x, physicalDamageToAFighter))
∀x (Cutman(x) → AppearIn(x, boxingMatch) ∨ AppearIn(x, kickboxingMatch) ∨ AppearIn(x, mixedMartialArtsMatchBout))
∀x (Cutman(x) → Handle(x, swelling) ∧ Handle(x, nosebleed) ∧ Handle(x, laceration))
Cutman(jack)

[PREMISE (GK)]:
! [X] : (Cutman(X) => Prevent(X, physicalDamageToAFighter) & Treat(X, physicalDamageToAFighter)).
! [X] : (Cutman(X) => AppearIn(X, boxingMatch) | AppearIn(X, kickboxingMatch) | AppearIn(X, mixedMartialArtsMatchBout)).
! [X] : (Cutman(X) => Handle(X, swelling) & Handle(X, nosebleed) & Handle(X, laceration)).
Cutman(jack).

[CONCLUSION]:
No cutmen appear in boxing matches.

[CONCLUSION (FOL)]:
¬(∃x (Cutman(x) ∧ AppearIn(x, boxingMatch)))

[CONCLUSION (GK)]:
-(? [X] : (Cutman(X) & AppearIn(X, boxingMatch))).


===

['x']
['x']
[PREMISE]:
A cutman is responsible for preventing and treating physical damage to a fighter.
Cutmen appear in boxing matches, kickboxing matches, or mixed martial arts matches bout. 
Cutmen handle swelling, nosebleeds and lacerations. 
Jack is a cutman.

[PREMISE (FOL)]:
∀x (Cutman(x) → Prevent(x, physicalDamageToAFighter) ∧ Treat(x, physicalDamageToAFighter))
∀x (Cutman(x) → AppearIn(x, boxingMatch) ∨ AppearIn(x, kickboxingMatch) ∨ AppearIn(x, mixedMartialArtsMatchBout))
∀x (Cutman(x) → Handle(x, swelling) ∧ Handle(x, nosebleed) ∧ Handle(x, laceration))
Cutman(jack)

[PREMISE (GK)]:
! [X] : (Cutman(X) => Prevent(X, physicalDamageToAFighter) & Treat(X, physicalDamageToAFighter)).
! [X] : (Cutman(X) => AppearIn(X, boxingMatch) | AppearIn(X, kickboxingMatch) | AppearIn(X, mixedMartialArtsMatchBout)).
! [X] : (Cutman(X) => Handle(X, swelling) & Handle(X, nosebleed) & Handle(X, laceration)).
Cutman(jack).

[CONCLUSION]:
If someone is not a cutman, then they cannot handle nosebleeds.

[CONCLUSION (FOL)]:
∀x (¬Cutman(x) → ¬Handle(x, nosebleed))

[CONCLUSION (GK)]:
! [X] : (-Cutman(X) => -Handle(X, nosebleed)).


===

['x']
['x']
[PREMISE]:
A cutman is responsible for preventing and treating physical damage to a fighter.
Cutmen appear in boxing matches, kickboxing matches, or mixed martial arts matches bout. 
Cutmen handle swelling, nosebleeds and lacerations. 
Jack is a cutman.

[PREMISE (FOL)]:
∀x (Cutman(x) → Prevent(x, physicalDamageToAFighter) ∧ Treat(x, physicalDamageToAFighter))
∀x (Cutman(x) → AppearIn(x, boxingMatch) ∨ AppearIn(x, kickboxingMatch) ∨ AppearIn(x, mixedMartialArtsMatchBout))
∀x (Cutman(x) → Handle(x, swelling) ∧ Handle(x, nosebleed) ∧ Handle(x, laceration))
Cutman(jack)

[PREMISE (GK)]:
! [X] : (Cutman(X) => Prevent(X, physicalDamageToAFighter) & Treat(X, physicalDamageToAFighter)).
! [X] : (Cutman(X) => AppearIn(X, boxingMatch) | AppearIn(X, kickboxingMatch) | AppearIn(X, mixedMartialArtsMatchBout)).
! [X] : (Cutman(X) => Handle(X, swelling) & Handle(X, nosebleed) & Handle(X, laceration)).
Cutman(jack).

[CONCLUSION]:
Jack is responsible for treating physical damage to a fighter.

[CONCLUSION (FOL)]:
Treat(jack, physicalDamageToAFighter)

[CONCLUSION (GK)]:
Treat(jack, physicalDamageToAFighter).


===

['x']
['x', 'y']
[PREMISE]:
The Mona Lisa is a world's best-known painting.
The Mona Lisa is a portrait painted by Leonardo da Vinci.
Leonardo da Vinci was a scientist and painter.
Painting genres can be history, portrait, animal, landscape, and still life.

[PREMISE (FOL)]:
Painting(monaLisa) ∧ TheWorldsBestKnown(monaLisa)
PaintedBy(monaLisa, leonardodaVinci) ∧ Portrait(monaLisa)
Scientist(leonardodaVinci) ∧ Painter(leonardodaVinci)
∀x (Painting(x) → (History(x) ∨ Portrait(x) ∨ Animal(x) ∨ Landscape(x) ∨ StillLife(x)))

[PREMISE (GK)]:
Painting(monaLisa) & TheWorldsBestKnown(monaLisa).
PaintedBy(monaLisa, leonardodaVinci) & Portrait(monaLisa).
Scientist(leonardodaVinci) & Painter(leonardodaVinci).
! [X] : (Painting(X) => (History(X) | Portrait(X) | Animal(X) | Landscape(X) | StillLife(X))).

[CONCLUSION]:
A world's best-known artwork is painted by a scientist.

[CONCLUSION (FOL)]:
∃x ∃y (Painting(x) ∧ TheWorldsBestKnown(x) ∧ PaintedBy(x, y) ∧ Scientist(y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Painting(X) & TheWorldsBestKnown(X) & PaintedBy(X, Y) & Scientist(Y)).


===

['x']
['x']
[PREMISE]:
The Mona Lisa is a world's best-known painting.
The Mona Lisa is a portrait painted by Leonardo da Vinci.
Leonardo da Vinci was a scientist and painter.
Painting genres can be history, portrait, animal, landscape, and still life.

[PREMISE (FOL)]:
Painting(monaLisa) ∧ TheWorldsBestKnown(monaLisa)
PaintedBy(monaLisa, leonardodaVinci) ∧ Portrait(monaLisa)
Scientist(leonardodaVinci) ∧ Painter(leonardodaVinci)
∀x (Painting(x) → (History(x) ∨ Portrait(x) ∨ Animal(x) ∨ Landscape(x) ∨ StillLife(x)))

[PREMISE (GK)]:
Painting(monaLisa) & TheWorldsBestKnown(monaLisa).
PaintedBy(monaLisa, leonardodaVinci) & Portrait(monaLisa).
Scientist(leonardodaVinci) & Painter(leonardodaVinci).
! [X] : (Painting(X) => (History(X) | Portrait(X) | Animal(X) | Landscape(X) | StillLife(X))).

[CONCLUSION]:
Leonardo da Vinci has artworks in the landscape genre.

[CONCLUSION (FOL)]:
∃x (PaintedBy(x, leonardodaVinci) ∧ Landscape(x))

[CONCLUSION (GK)]:
? [X] : (PaintedBy(X, leonardodaVinci) & Landscape(X)).


===

['x']
['x']
[PREMISE]:
The Mona Lisa is a world's best-known painting.
The Mona Lisa is a portrait painted by Leonardo da Vinci.
Leonardo da Vinci was a scientist and painter.
Painting genres can be history, portrait, animal, landscape, and still life.

[PREMISE (FOL)]:
Painting(monaLisa) ∧ TheWorldsBestKnown(monaLisa)
PaintedBy(monaLisa, leonardodaVinci) ∧ Portrait(monaLisa)
Scientist(leonardodaVinci) ∧ Painter(leonardodaVinci)
∀x (Painting(x) → (History(x) ∨ Portrait(x) ∨ Animal(x) ∨ Landscape(x) ∨ StillLife(x)))

[PREMISE (GK)]:
Painting(monaLisa) & TheWorldsBestKnown(monaLisa).
PaintedBy(monaLisa, leonardodaVinci) & Portrait(monaLisa).
Scientist(leonardodaVinci) & Painter(leonardodaVinci).
! [X] : (Painting(X) => (History(X) | Portrait(X) | Animal(X) | Landscape(X) | StillLife(X))).

[CONCLUSION]:
No world's best-known artworks are portraits.

[CONCLUSION (FOL)]:
∀x (WorldsBestKnown(x)  → ¬Portrait(x))

[CONCLUSION (GK)]:
! [X] : (WorldsBestKnown(X)  => -Portrait(X)).


===

['x']
['x']
[PREMISE]:
No professional tennis umpires are professional tennis players.
If you are a World Tour player, then you are a professional tennis player.
All Grand Slam champions are World Tour players.
All Grand Slam umpires are professional tennis umpires.
Nadal is a World Tour player or a Grand Slam champion

[PREMISE (FOL)]:
∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))
∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))
∀x (GrandSlamChampion(x) → WorldTourPlayer(x))
∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))
WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)

[PREMISE (GK)]:
! [X] : (ProfessionalTennisUmpire(X) => -ProfessionalTennisPlayer(X)).
! [X] : (WorldTourPlayer(X) => ProfessionalTennisPlayer(X)).
! [X] : (GrandSlamChampion(X) => WorldTourPlayer(X)).
! [X] : (GrandSlamUmpire(X) => ProfessionalTennisUmpire(X)).
WorldTourPlayer(nadal) | GrandSlamChampion(nadal).

[CONCLUSION]:
Nadal is a Grand Slam umpire.

[CONCLUSION (FOL)]:
GrandSlamUmpire(nadal)

[CONCLUSION (GK)]:
GrandSlamUmpire(nadal).


===

['x']
['x']
[PREMISE]:
No professional tennis umpires are professional tennis players.
If you are a World Tour player, then you are a professional tennis player.
All Grand Slam champions are World Tour players.
All Grand Slam umpires are professional tennis umpires.
Nadal is a World Tour player or a Grand Slam champion

[PREMISE (FOL)]:
∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))
∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))
∀x (GrandSlamChampion(x) → WorldTourPlayer(x))
∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))
WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)

[PREMISE (GK)]:
! [X] : (ProfessionalTennisUmpire(X) => -ProfessionalTennisPlayer(X)).
! [X] : (WorldTourPlayer(X) => ProfessionalTennisPlayer(X)).
! [X] : (GrandSlamChampion(X) => WorldTourPlayer(X)).
! [X] : (GrandSlamUmpire(X) => ProfessionalTennisUmpire(X)).
WorldTourPlayer(nadal) | GrandSlamChampion(nadal).

[CONCLUSION]:
Nadal is not a Grand Slam umpire.

[CONCLUSION (FOL)]:
¬GrandSlamUmpire(nadal)

[CONCLUSION (GK)]:
-GrandSlamUmpire(nadal).


===

['x']
['x']
[PREMISE]:
No professional tennis umpires are professional tennis players.
If you are a World Tour player, then you are a professional tennis player.
All Grand Slam champions are World Tour players.
All Grand Slam umpires are professional tennis umpires.
Nadal is a World Tour player or a Grand Slam champion

[PREMISE (FOL)]:
∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))
∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))
∀x (GrandSlamChampion(x) → WorldTourPlayer(x))
∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))
WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)

[PREMISE (GK)]:
! [X] : (ProfessionalTennisUmpire(X) => -ProfessionalTennisPlayer(X)).
! [X] : (WorldTourPlayer(X) => ProfessionalTennisPlayer(X)).
! [X] : (GrandSlamChampion(X) => WorldTourPlayer(X)).
! [X] : (GrandSlamUmpire(X) => ProfessionalTennisUmpire(X)).
WorldTourPlayer(nadal) | GrandSlamChampion(nadal).

[CONCLUSION]:
Nadal is a Grand Slam champion.

[CONCLUSION (FOL)]:
GrandSlamChampion(nadal)

[CONCLUSION (GK)]:
GrandSlamChampion(nadal).


===

['x']
['x']
[PREMISE]:
No professional tennis umpires are professional tennis players.
If you are a World Tour player, then you are a professional tennis player.
All Grand Slam champions are World Tour players.
All Grand Slam umpires are professional tennis umpires.
Nadal is a World Tour player or a Grand Slam champion

[PREMISE (FOL)]:
∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))
∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))
∀x (GrandSlamChampion(x) → WorldTourPlayer(x))
∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))
WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)

[PREMISE (GK)]:
! [X] : (ProfessionalTennisUmpire(X) => -ProfessionalTennisPlayer(X)).
! [X] : (WorldTourPlayer(X) => ProfessionalTennisPlayer(X)).
! [X] : (GrandSlamChampion(X) => WorldTourPlayer(X)).
! [X] : (GrandSlamUmpire(X) => ProfessionalTennisUmpire(X)).
WorldTourPlayer(nadal) | GrandSlamChampion(nadal).

[CONCLUSION]:
Nadal is neither a Grand Slam umpire nor a professional tennis umpire.

[CONCLUSION (FOL)]:
¬(GrandSlamUmpire(nadal) ∨ ProfessionalTennisUmpire(nadal))

[CONCLUSION (GK)]:
-(GrandSlamUmpire(nadal) | ProfessionalTennisUmpire(nadal)).


===

['x']
['x']
[PREMISE]:
No professional tennis umpires are professional tennis players.
If you are a World Tour player, then you are a professional tennis player.
All Grand Slam champions are World Tour players.
All Grand Slam umpires are professional tennis umpires.
Nadal is a World Tour player or a Grand Slam champion

[PREMISE (FOL)]:
∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))
∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))
∀x (GrandSlamChampion(x) → WorldTourPlayer(x))
∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))
WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)

[PREMISE (GK)]:
! [X] : (ProfessionalTennisUmpire(X) => -ProfessionalTennisPlayer(X)).
! [X] : (WorldTourPlayer(X) => ProfessionalTennisPlayer(X)).
! [X] : (GrandSlamChampion(X) => WorldTourPlayer(X)).
! [X] : (GrandSlamUmpire(X) => ProfessionalTennisUmpire(X)).
WorldTourPlayer(nadal) | GrandSlamChampion(nadal).

[CONCLUSION]:
If Nadal is a professional tennis umpire, then Nadal is a Grand Slam Umpire.

[CONCLUSION (FOL)]:
ProfessionalTennisUmpire(nadal) → GrandSlamUmpire(nadal)

[CONCLUSION (GK)]:
ProfessionalTennisUmpire(nadal) => GrandSlamUmpire(nadal).


===

['x']
['x']
[PREMISE]:
No professional tennis umpires are professional tennis players.
If you are a World Tour player, then you are a professional tennis player.
All Grand Slam champions are World Tour players.
All Grand Slam umpires are professional tennis umpires.
Nadal is a World Tour player or a Grand Slam champion

[PREMISE (FOL)]:
∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))
∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))
∀x (GrandSlamChampion(x) → WorldTourPlayer(x))
∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))
WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)

[PREMISE (GK)]:
! [X] : (ProfessionalTennisUmpire(X) => -ProfessionalTennisPlayer(X)).
! [X] : (WorldTourPlayer(X) => ProfessionalTennisPlayer(X)).
! [X] : (GrandSlamChampion(X) => WorldTourPlayer(X)).
! [X] : (GrandSlamUmpire(X) => ProfessionalTennisUmpire(X)).
WorldTourPlayer(nadal) | GrandSlamChampion(nadal).

[CONCLUSION]:
If Nadal is a Grand Slam umpire or a professional tennis player, then Nadal is a Grand Slam umpire.

[CONCLUSION (FOL)]:
GrandSlamUmpire(nadal) ∨ ProfessionalTennisPlayer(nadal) → GrandSlamUmpire(nadal)

[CONCLUSION (GK)]:
GrandSlamUmpire(nadal) | ProfessionalTennisPlayer(nadal) => GrandSlamUmpire(nadal).


===

['x']
['x']
[PREMISE]:
Businesses are either sanctioned or unsanctioned.
Sanctioned businesses are limited.
Unsanctioned businesses are free.
The Crude Oil Data Exchange is a business that isn't free.

[PREMISE (FOL)]:
∀x (Buisness(x) → Sanctioned(x) ⊕ ¬Sanctioned(x))
∀x (Buisness(x) ∧ Sanctioned(x) → Limited(x))
∀x (Buisness(x) ∧ ¬Sanctioned(x) → Free(x))
Buisness(crudeOilDataExchange) ∧ ¬Free(crudeOilDataExchange)

[PREMISE (GK)]:
! [X] : (Buisness(X) => Sanctioned(X) <~> -Sanctioned(X)).
! [X] : (Buisness(X) & Sanctioned(X) => Limited(X)).
! [X] : (Buisness(X) & -Sanctioned(X) => Free(X)).
Buisness(crudeOilDataExchange) & -Free(crudeOilDataExchange).

[CONCLUSION]:
Crude Oil Data Exchange is sanctioned.

[CONCLUSION (FOL)]:
Sanctioned(crudeOilDataExchange)

[CONCLUSION (GK)]:
Sanctioned(crudeOilDataExchange).


===

['x']
['x']
[PREMISE]:
Businesses are either sanctioned or unsanctioned.
Sanctioned businesses are limited.
Unsanctioned businesses are free.
The Crude Oil Data Exchange is a business that isn't free.

[PREMISE (FOL)]:
∀x (Buisness(x) → Sanctioned(x) ⊕ ¬Sanctioned(x))
∀x (Buisness(x) ∧ Sanctioned(x) → Limited(x))
∀x (Buisness(x) ∧ ¬Sanctioned(x) → Free(x))
Buisness(crudeOilDataExchange) ∧ ¬Free(crudeOilDataExchange)

[PREMISE (GK)]:
! [X] : (Buisness(X) => Sanctioned(X) <~> -Sanctioned(X)).
! [X] : (Buisness(X) & Sanctioned(X) => Limited(X)).
! [X] : (Buisness(X) & -Sanctioned(X) => Free(X)).
Buisness(crudeOilDataExchange) & -Free(crudeOilDataExchange).

[CONCLUSION]:
Crude Oil Data Exchange is unsanctioned.

[CONCLUSION (FOL)]:
¬Sanctioned(crudeOilDataExchange)

[CONCLUSION (GK)]:
-Sanctioned(crudeOilDataExchange).


===

['x']
['x']
[PREMISE]:
Businesses are either sanctioned or unsanctioned.
Sanctioned businesses are limited.
Unsanctioned businesses are free.
The Crude Oil Data Exchange is a business that isn't free.

[PREMISE (FOL)]:
∀x (Buisness(x) → Sanctioned(x) ⊕ ¬Sanctioned(x))
∀x (Buisness(x) ∧ Sanctioned(x) → Limited(x))
∀x (Buisness(x) ∧ ¬Sanctioned(x) → Free(x))
Buisness(crudeOilDataExchange) ∧ ¬Free(crudeOilDataExchange)

[PREMISE (GK)]:
! [X] : (Buisness(X) => Sanctioned(X) <~> -Sanctioned(X)).
! [X] : (Buisness(X) & Sanctioned(X) => Limited(X)).
! [X] : (Buisness(X) & -Sanctioned(X) => Free(X)).
Buisness(crudeOilDataExchange) & -Free(crudeOilDataExchange).

[CONCLUSION]:
Crude Oil Data Exchange is limited.

[CONCLUSION (FOL)]:
Limited(crudeOilDataExchange)

[CONCLUSION (GK)]:
Limited(crudeOilDataExchange).


===

['x']
['x']
[PREMISE]:
When something is depressing, it is sad.
The end of a relationship is depressing. 

[PREMISE (FOL)]:
∀x (Depressing(x) → Sad(x))
Depressing(v)

[PREMISE (GK)]:
! [X] : (Depressing(X) => Sad(X)).
Depressing(v).

[CONCLUSION]:
The end of a relationship is invigorating

[CONCLUSION (FOL)]:
Invigorating(v)

[CONCLUSION (GK)]:
Invigorating(v).


===

[]
[]
[PREMISE]:
Palstaves are a type of early bronze axe.
Palstaves are found in northern, western, and southwestern Europe and are cast in molds.
John Evans is an archeologist who popularized the term "palstave."
Paalstabs are not a type of axe but rather a digging shovel.

[PREMISE (FOL)]:
EarlyBronzeAge(palstave) ∧ Axe(palstave)
FoundIn(palstave, northernEurope) ∨ FoundIn(palstave, westernEurope) ∨ FoundIn(palstave, southWesternEurope)) ∧ CastIn(palstave, molds)
Archeologist(johnEvans) ∧ Popularize(johnEvans, termPalstave)
¬Axe(paalstab) ∧ DiggingShovel(paalstab)

[PREMISE (GK)]:
EarlyBronzeAge(palstave) & Axe(palstave).
FoundIn(palstave, northernEurope) | FoundIn(palstave, westernEurope) | FoundIn(palstave, southWesternEurope)) & CastIn(palstave, molds).
Archeologist(johnEvans) & Popularize(johnEvans, termPalstave).
-Axe(paalstab) & DiggingShovel(paalstab).

[CONCLUSION]:
John Evans Popularized the term paalstab.

[CONCLUSION (FOL)]:
Popularized(johnEvans, termPalstave)

[CONCLUSION (GK)]:
Popularized(johnEvans, termPalstave).


===

[]
['x']
[PREMISE]:
Palstaves are a type of early bronze axe.
Palstaves are found in northern, western, and southwestern Europe and are cast in molds.
John Evans is an archeologist who popularized the term "palstave."
Paalstabs are not a type of axe but rather a digging shovel.

[PREMISE (FOL)]:
EarlyBronzeAge(palstave) ∧ Axe(palstave)
FoundIn(palstave, northernEurope) ∨ FoundIn(palstave, westernEurope) ∨ FoundIn(palstave, southWesternEurope)) ∧ CastIn(palstave, molds)
Archeologist(johnEvans) ∧ Popularize(johnEvans, termPalstave)
¬Axe(paalstab) ∧ DiggingShovel(paalstab)

[PREMISE (GK)]:
EarlyBronzeAge(palstave) & Axe(palstave).
FoundIn(palstave, northernEurope) | FoundIn(palstave, westernEurope) | FoundIn(palstave, southWesternEurope)) & CastIn(palstave, molds).
Archeologist(johnEvans) & Popularize(johnEvans, termPalstave).
-Axe(paalstab) & DiggingShovel(paalstab).

[CONCLUSION]:
There is an axe that is found in Western Europe.

[CONCLUSION (FOL)]:
∃x (Axe(x) ∧ FoundIn(x, westernEurope))

[CONCLUSION (GK)]:
? [X] : (Axe(X) & FoundIn(X, westernEurope)).


===

[]
['x', 'y']
[PREMISE]:
Palstaves are a type of early bronze axe.
Palstaves are found in northern, western, and southwestern Europe and are cast in molds.
John Evans is an archeologist who popularized the term "palstave."
Paalstabs are not a type of axe but rather a digging shovel.

[PREMISE (FOL)]:
EarlyBronzeAge(palstave) ∧ Axe(palstave)
FoundIn(palstave, northernEurope) ∨ FoundIn(palstave, westernEurope) ∨ FoundIn(palstave, southWesternEurope)) ∧ CastIn(palstave, molds)
Archeologist(johnEvans) ∧ Popularize(johnEvans, termPalstave)
¬Axe(paalstab) ∧ DiggingShovel(paalstab)

[PREMISE (GK)]:
EarlyBronzeAge(palstave) & Axe(palstave).
FoundIn(palstave, northernEurope) | FoundIn(palstave, westernEurope) | FoundIn(palstave, southWesternEurope)) & CastIn(palstave, molds).
Archeologist(johnEvans) & Popularize(johnEvans, termPalstave).
-Axe(paalstab) & DiggingShovel(paalstab).

[CONCLUSION]:
Archeologists haven't popularized anything.

[CONCLUSION (FOL)]:
∀x ∀y (Archeologist(x) → ¬Popularize(x, y))

[CONCLUSION (GK)]:
! [X] : ! [Y] : (Archeologist(X) => -Popularize(X, Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Koei Tecmo is a Japanese video game and anime holding company.
Holding companies hold several companies.
Tecmo was disbanded in Japan, while Koei survived but was renamed.
Video game holding companies are holding companies.

[PREMISE (FOL)]:
Japanese(koeitecmo) ∧ VideoGameHoldingCompany(koeitecmo) ∧ AnimeHoldingCompany(koeitecmo) ∧ HoldingCompany(x) 
∀x (HoldingCompany(x) → ∃y(Company(y) ∧ Holds(x, y)))
DisbandsIn(tecmo, japan) ∧ Survives(koei) ∧ Renames(koei)
∀x (VideoGameHoldingCompany(x) → HoldingCompany(x))

[PREMISE (GK)]:
Japanese(koeitecmo) & VideoGameHoldingCompany(koeitecmo) & AnimeHoldingCompany(koeitecmo) & HoldingCompany(x) .
! [X] : (HoldingCompany(X) => ? [Y] :(Company(Y) & Holds(X, Y))).
DisbandsIn(tecmo, japan) & Survives(koei) & Renames(koei).
! [X] : (VideoGameHoldingCompany(X) => HoldingCompany(X)).

[CONCLUSION]:
Koei Tecmo holds another company.

[CONCLUSION (FOL)]:
∃x (Company(x) ∧ Holds(koeitecmo, x))

[CONCLUSION (GK)]:
? [X] : (Company(X) & Holds(koeitecmo, X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Koei Tecmo is a Japanese video game and anime holding company.
Holding companies hold several companies.
Tecmo was disbanded in Japan, while Koei survived but was renamed.
Video game holding companies are holding companies.

[PREMISE (FOL)]:
Japanese(koeitecmo) ∧ VideoGameHoldingCompany(koeitecmo) ∧ AnimeHoldingCompany(koeitecmo) ∧ HoldingCompany(x) 
∀x (HoldingCompany(x) → ∃y(Company(y) ∧ Holds(x, y)))
DisbandsIn(tecmo, japan) ∧ Survives(koei) ∧ Renames(koei)
∀x (VideoGameHoldingCompany(x) → HoldingCompany(x))

[PREMISE (GK)]:
Japanese(koeitecmo) & VideoGameHoldingCompany(koeitecmo) & AnimeHoldingCompany(koeitecmo) & HoldingCompany(x) .
! [X] : (HoldingCompany(X) => ? [Y] :(Company(Y) & Holds(X, Y))).
DisbandsIn(tecmo, japan) & Survives(koei) & Renames(koei).
! [X] : (VideoGameHoldingCompany(X) => HoldingCompany(X)).

[CONCLUSION]:
Tecmo holds another company.

[CONCLUSION (FOL)]:
∃x (Company(x) ∧ Holds(tecmo, x))

[CONCLUSION (GK)]:
? [X] : (Company(X) & Holds(tecmo, X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Koei Tecmo is a Japanese video game and anime holding company.
Holding companies hold several companies.
Tecmo was disbanded in Japan, while Koei survived but was renamed.
Video game holding companies are holding companies.

[PREMISE (FOL)]:
Japanese(koeitecmo) ∧ VideoGameHoldingCompany(koeitecmo) ∧ AnimeHoldingCompany(koeitecmo) ∧ HoldingCompany(x) 
∀x (HoldingCompany(x) → ∃y(Company(y) ∧ Holds(x, y)))
DisbandsIn(tecmo, japan) ∧ Survives(koei) ∧ Renames(koei)
∀x (VideoGameHoldingCompany(x) → HoldingCompany(x))

[PREMISE (GK)]:
Japanese(koeitecmo) & VideoGameHoldingCompany(koeitecmo) & AnimeHoldingCompany(koeitecmo) & HoldingCompany(x) .
! [X] : (HoldingCompany(X) => ? [Y] :(Company(Y) & Holds(X, Y))).
DisbandsIn(tecmo, japan) & Survives(koei) & Renames(koei).
! [X] : (VideoGameHoldingCompany(X) => HoldingCompany(X)).

[CONCLUSION]:
Koei Tecmo holds anime.

[CONCLUSION (FOL)]:
AnimeHoldingCompany(koeitecmo)

[CONCLUSION (GK)]:
AnimeHoldingCompany(koeitecmo).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
The PlayStation EyeToy is a camera accessory for the PlayStation 2 system. 
The PlayStation Eye is a camera accessory for the PlayStation 3 system.
The PlayStation Camera is a camera accessory for the PlayStation 4 and the PlayStation 5 systems.
Camera accessories for a system are compatible with that system.
Playstation 2, 3,4, and 5 are all different.
Only the PlayStation Camera camera system is compatible with different systems.

[PREMISE (FOL)]:
System(playStation2) ∧ CameraAccessoryFor(playStationEyeToy, playStation2)
System(playStation3) ∧ CameraAccessoryFor(playStationEye, playStation3)  
System(playStation4) ∧ System(playStation5) ∧ CameraAccessoryFor(playStationCamera, playStation4) ∧ CameraAccessoryFor(playStationCamera, playStation5)
∀x ∀y (CameraAccessoryFor(x, y) ∧ System(y) → CompatibleWith(x, y))
¬(playStation2=playStation3) ∧ ¬(playStation2=playStation4) ∧ ¬(playStation2=playStation5) ∧ ¬(playStation3=playStation4) ∧ ¬(playStation3=playStation5) ∧ ¬(playStation4=playStation5)
∀x ∃y ∃z (System(y) ∧ System(z) ∧ ¬(y=z) ∧ CompatibleWith(x, y) ∧ CompatibleWith(x, z) → x=playstationCamera)

[PREMISE (GK)]:
System(playStation2) & CameraAccessoryFor(playStationEyeToy, playStation2).
System(playStation3) & CameraAccessoryFor(playStationEye, playStation3)  .
System(playStation4) & System(playStation5) & CameraAccessoryFor(playStationCamera, playStation4) & CameraAccessoryFor(playStationCamera, playStation5).
! [X] : ! [Y] : (CameraAccessoryFor(X, Y) & System(Y) => CompatibleWith(X, Y)).
-(playStation2=playStation3) & -(playStation2=playStation4) & -(playStation2=playStation5) & -(playStation3=playStation4) & -(playStation3=playStation5) & -(playStation4=playStation5).
! [X] : ? [Y] : ? [Z] : (System(Y) & System(Z) & -(Y=Z) & CompatibleWith(X, Y) & CompatibleWith(X, Z) => X=playstationCamera).

[CONCLUSION]:
The Playstation Eye is compatible with the PlayStation 2 and the PlayStation 3.

[CONCLUSION (FOL)]:
Compatible(playStationEye, playStation2) ∧ Compatible(playStationEye, playStation3)

[CONCLUSION (GK)]:
Compatible(playStationEye, playStation2) & Compatible(playStationEye, playStation3).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
The PlayStation EyeToy is a camera accessory for the PlayStation 2 system. 
The PlayStation Eye is a camera accessory for the PlayStation 3 system.
The PlayStation Camera is a camera accessory for the PlayStation 4 and the PlayStation 5 systems.
Camera accessories for a system are compatible with that system.
Playstation 2, 3,4, and 5 are all different.
Only the PlayStation Camera camera system is compatible with different systems.

[PREMISE (FOL)]:
System(playStation2) ∧ CameraAccessoryFor(playStationEyeToy, playStation2)
System(playStation3) ∧ CameraAccessoryFor(playStationEye, playStation3)  
System(playStation4) ∧ System(playStation5) ∧ CameraAccessoryFor(playStationCamera, playStation4) ∧ CameraAccessoryFor(playStationCamera, playStation5)
∀x ∀y (CameraAccessoryFor(x, y) ∧ System(y) → CompatibleWith(x, y))
¬(playStation2=playStation3) ∧ ¬(playStation2=playStation4) ∧ ¬(playStation2=playStation5) ∧ ¬(playStation3=playStation4) ∧ ¬(playStation3=playStation5) ∧ ¬(playStation4=playStation5)
∀x ∃y ∃z (System(y) ∧ System(z) ∧ ¬(y=z) ∧ CompatibleWith(x, y) ∧ CompatibleWith(x, z) → x=playstationCamera)

[PREMISE (GK)]:
System(playStation2) & CameraAccessoryFor(playStationEyeToy, playStation2).
System(playStation3) & CameraAccessoryFor(playStationEye, playStation3)  .
System(playStation4) & System(playStation5) & CameraAccessoryFor(playStationCamera, playStation4) & CameraAccessoryFor(playStationCamera, playStation5).
! [X] : ! [Y] : (CameraAccessoryFor(X, Y) & System(Y) => CompatibleWith(X, Y)).
-(playStation2=playStation3) & -(playStation2=playStation4) & -(playStation2=playStation5) & -(playStation3=playStation4) & -(playStation3=playStation5) & -(playStation4=playStation5).
! [X] : ? [Y] : ? [Z] : (System(Y) & System(Z) & -(Y=Z) & CompatibleWith(X, Y) & CompatibleWith(X, Z) => X=playstationCamera).

[CONCLUSION]:
The Playstation EyeToy is compatible with the PlayStation 2.

[CONCLUSION (FOL)]:
Compatible(playStationEyeToy, playStation2)

[CONCLUSION (GK)]:
Compatible(playStationEyeToy, playStation2).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
The PlayStation EyeToy is a camera accessory for the PlayStation 2 system. 
The PlayStation Eye is a camera accessory for the PlayStation 3 system.
The PlayStation Camera is a camera accessory for the PlayStation 4 and the PlayStation 5 systems.
Camera accessories for a system are compatible with that system.
Playstation 2, 3,4, and 5 are all different.
Only the PlayStation Camera camera system is compatible with different systems.

[PREMISE (FOL)]:
System(playStation2) ∧ CameraAccessoryFor(playStationEyeToy, playStation2)
System(playStation3) ∧ CameraAccessoryFor(playStationEye, playStation3)  
System(playStation4) ∧ System(playStation5) ∧ CameraAccessoryFor(playStationCamera, playStation4) ∧ CameraAccessoryFor(playStationCamera, playStation5)
∀x ∀y (CameraAccessoryFor(x, y) ∧ System(y) → CompatibleWith(x, y))
¬(playStation2=playStation3) ∧ ¬(playStation2=playStation4) ∧ ¬(playStation2=playStation5) ∧ ¬(playStation3=playStation4) ∧ ¬(playStation3=playStation5) ∧ ¬(playStation4=playStation5)
∀x ∃y ∃z (System(y) ∧ System(z) ∧ ¬(y=z) ∧ CompatibleWith(x, y) ∧ CompatibleWith(x, z) → x=playstationCamera)

[PREMISE (GK)]:
System(playStation2) & CameraAccessoryFor(playStationEyeToy, playStation2).
System(playStation3) & CameraAccessoryFor(playStationEye, playStation3)  .
System(playStation4) & System(playStation5) & CameraAccessoryFor(playStationCamera, playStation4) & CameraAccessoryFor(playStationCamera, playStation5).
! [X] : ! [Y] : (CameraAccessoryFor(X, Y) & System(Y) => CompatibleWith(X, Y)).
-(playStation2=playStation3) & -(playStation2=playStation4) & -(playStation2=playStation5) & -(playStation3=playStation4) & -(playStation3=playStation5) & -(playStation4=playStation5).
! [X] : ? [Y] : ? [Z] : (System(Y) & System(Z) & -(Y=Z) & CompatibleWith(X, Y) & CompatibleWith(X, Z) => X=playstationCamera).

[CONCLUSION]:
The Playstation Camera can be used for all Playstation consoles.

[CONCLUSION (FOL)]:
Compatible(playStationCamera, playStation2) ∧ Compatible(playStationCamera, playStation3) ∧ Compatible(playStationCamera, playStation4) ∧ Compatible(playStationCamera, playStation5)

[CONCLUSION (GK)]:
Compatible(playStationCamera, playStation2) & Compatible(playStationCamera, playStation3) & Compatible(playStationCamera, playStation4) & Compatible(playStationCamera, playStation5).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Adam Buska is a European football player.
If a European plays football, they play what Americans call soccer.

[PREMISE (FOL)]:
FootballPlayer(adamBuska) ∧ European(adamBuska)
∀x (FootballPlayer(x) ∧ European(x) → ∃y (Call(american, y, soccer) ∧ Play(x, y)))

[PREMISE (GK)]:
FootballPlayer(adamBuska) & European(adamBuska).
! [X] : (FootballPlayer(X) & European(X) => ? [Y] : (Call(american, Y, soccer) & Play(X, Y))).

[CONCLUSION]:
Adam Buska plays what Americans call soccer.

[CONCLUSION (FOL)]:
∃y (Call(american, y, soccer) ∧ Play(adamBuska, y))

[CONCLUSION (GK)]:
? [Y] : (Call(american, Y, soccer) & Play(adamBuska, Y)).


===

['x']
['x']
[PREMISE]:
If a game is one of the top-3 best selling video-games, then it is multiplatform.
If a game has sold more than 100 million copies, then it is one of the top-3 best-selling video games.
Some games that support Windows are developed by Nintendo.
All multiplatform games can be played on a wide range of devices.
Pokemon Diamond version is neither developed by Nintendo nor can be played on a wide range of devices.

[PREMISE (FOL)]:
∀x (ATop3BestSellingVideoGame(x) → Multiplatform(x))
∀x (SoldMoreThan100MillionCopies(x) → ATop3BestSellingVideoGame(x))
∃x ((SupportsWindows(x) ∧ AGameDevelopedByNintendo(x)))
∀x (Multiplatform(x) → CanBePlayedOnAWideRangeOfDevices(x))
¬(DevelopedByNintendo(PokemonDiamond) ∨ CanBePlayedOnAWideRangeOfDevices(PokemonDiamond))

[PREMISE (GK)]:
! [X] : (ATop3BestSellingVideoGame(X) => Multiplatform(X)).
! [X] : (SoldMoreThan100MillionCopies(X) => ATop3BestSellingVideoGame(X)).
? [X] : ((SupportsWindows(X) & AGameDevelopedByNintendo(X))).
! [X] : (Multiplatform(X) => CanBePlayedOnAWideRangeOfDevices(X)).
-(DevelopedByNintendo(PokemonDiamond) | CanBePlayedOnAWideRangeOfDevices(PokemonDiamond)).

[CONCLUSION]:
Pokemon Diamond version supports Windows.

[CONCLUSION (FOL)]:
Game(PokemonDiamond) ∧ SupportsWindows(PokemonDiamond)

[CONCLUSION (GK)]:
Game(PokemonDiamond) & SupportsWindows(PokemonDiamond).


===

['x']
['x']
[PREMISE]:
If a game is one of the top-3 best selling video-games, then it is multiplatform.
If a game has sold more than 100 million copies, then it is one of the top-3 best-selling video games.
Some games that support Windows are developed by Nintendo.
All multiplatform games can be played on a wide range of devices.
Pokemon Diamond version is neither developed by Nintendo nor can be played on a wide range of devices.

[PREMISE (FOL)]:
∀x (ATop3BestSellingVideoGame(x) → Multiplatform(x))
∀x (SoldMoreThan100MillionCopies(x) → ATop3BestSellingVideoGame(x))
∃x ((SupportsWindows(x) ∧ AGameDevelopedByNintendo(x)))
∀x (Multiplatform(x) → CanBePlayedOnAWideRangeOfDevices(x))
¬(DevelopedByNintendo(PokemonDiamond) ∨ CanBePlayedOnAWideRangeOfDevices(PokemonDiamond))

[PREMISE (GK)]:
! [X] : (ATop3BestSellingVideoGame(X) => Multiplatform(X)).
! [X] : (SoldMoreThan100MillionCopies(X) => ATop3BestSellingVideoGame(X)).
? [X] : ((SupportsWindows(X) & AGameDevelopedByNintendo(X))).
! [X] : (Multiplatform(X) => CanBePlayedOnAWideRangeOfDevices(X)).
-(DevelopedByNintendo(PokemonDiamond) | CanBePlayedOnAWideRangeOfDevices(PokemonDiamond)).

[CONCLUSION]:
Pokemon Diamond version supports Windows and has sold more than 100 million copies.

[CONCLUSION (FOL)]:
(Game(PokemonDiamond) ∧ SupportsWindows(PokemonDiamond)) ∧ (Game(PokemonDiamond) ∧ SoldMoreThan100MillionCopies(PokemonDiamond))

[CONCLUSION (GK)]:
(Game(PokemonDiamond) & SupportsWindows(PokemonDiamond)) & (Game(PokemonDiamond) & SoldMoreThan100MillionCopies(PokemonDiamond)).


===

['x']
['x']
[PREMISE]:
If a game is one of the top-3 best selling video-games, then it is multiplatform.
If a game has sold more than 100 million copies, then it is one of the top-3 best-selling video games.
Some games that support Windows are developed by Nintendo.
All multiplatform games can be played on a wide range of devices.
Pokemon Diamond version is neither developed by Nintendo nor can be played on a wide range of devices.

[PREMISE (FOL)]:
∀x (ATop3BestSellingVideoGame(x) → Multiplatform(x))
∀x (SoldMoreThan100MillionCopies(x) → ATop3BestSellingVideoGame(x))
∃x ((SupportsWindows(x) ∧ AGameDevelopedByNintendo(x)))
∀x (Multiplatform(x) → CanBePlayedOnAWideRangeOfDevices(x))
¬(DevelopedByNintendo(PokemonDiamond) ∨ CanBePlayedOnAWideRangeOfDevices(PokemonDiamond))

[PREMISE (GK)]:
! [X] : (ATop3BestSellingVideoGame(X) => Multiplatform(X)).
! [X] : (SoldMoreThan100MillionCopies(X) => ATop3BestSellingVideoGame(X)).
? [X] : ((SupportsWindows(X) & AGameDevelopedByNintendo(X))).
! [X] : (Multiplatform(X) => CanBePlayedOnAWideRangeOfDevices(X)).
-(DevelopedByNintendo(PokemonDiamond) | CanBePlayedOnAWideRangeOfDevices(PokemonDiamond)).

[CONCLUSION]:
If Pokemon Diamond version either supports Windows or has sold more than 100 million copies, then Pokemon Diamond version either is both multiplatform and one of the top-3 best selling video games, or is neither multiplatform nor one of the top-3 best selling video games.

[CONCLUSION (FOL)]:
((Game(PokemonDiamond) ∧ SupportsWindows(PokemonDiamond)) ⊕ ((Game(PokemonDiamond) v (SoldMoreThan100MillionCopies(PokemonDiamond))) → (Multiplatform(PokemonDiamond) ∧ (Game(PokemonDiamond) ∧ ATop3BestSellingVideoGame(PokemonDiamond))) ⊕ (¬Multiplatform(PokemonDiamond) ∧ ¬(Game(PokemonDiamond) ∧ ATop3BestSellingVideoGame(PokemonDiamond)))

[CONCLUSION (GK)]:
((Game(PokemonDiamond) & SupportsWindows(PokemonDiamond)) <~> ((Game(PokemonDiamond) v (SoldMoreThan100MillionCopies(PokemonDiamond))) => (Multiplatform(PokemonDiamond) & (Game(PokemonDiamond) & ATop3BestSellingVideoGame(PokemonDiamond))) <~> (-Multiplatform(PokemonDiamond) & -(Game(PokemonDiamond) & ATop3BestSellingVideoGame(PokemonDiamond))).


===

['x']
['x']
[PREMISE]:
China is one of the BRICS, and its economy is emerging.
If someone is from China, then they are from a country of BRICS.
India is one of the BRICS, and its economy is emerging.
If someone is from India, then they are in a country of BRICS.
All people from China are Chinese people.
All people from India are Indian people.
There is a person from India.

[PREMISE (FOL)]:
∃x (BRIC(x) ∧ ¬(x=china) ∧ BRIC(china) ∧ Emerging(chinaEconomy))
∀x (From(x, china) → From(x, bric))
BRIC(india) ∧ Emerging(indiaEconomy)
∀x (From(x, india) → From(x, bric))
∀x (From(x, china) → Chinese(x))
∀x (From(x, india) → Indian(x))
∃x (From(x, india))

[PREMISE (GK)]:
? [X] : (BRIC(X) & -(X=china) & BRIC(china) & Emerging(chinaEconomy)).
! [X] : (From(X, china) => From(X, bric)).
BRIC(india) & Emerging(indiaEconomy).
! [X] : (From(X, india) => From(X, bric)).
! [X] : (From(X, china) => Chinese(X)).
! [X] : (From(X, india) => Indian(X)).
? [X] : (From(X, india)).

[CONCLUSION]:
No people from BRICS are Indian people.

[CONCLUSION (FOL)]:
∀x (From(x, countryOfBRICS) → ¬IndianPeople(x))

[CONCLUSION (GK)]:
! [X] : (From(X, countryOfBRICS) => -IndianPeople(X)).


===

['x']
['x']
[PREMISE]:
China is one of the BRICS, and its economy is emerging.
If someone is from China, then they are from a country of BRICS.
India is one of the BRICS, and its economy is emerging.
If someone is from India, then they are in a country of BRICS.
All people from China are Chinese people.
All people from India are Indian people.
There is a person from India.

[PREMISE (FOL)]:
∃x (BRIC(x) ∧ ¬(x=china) ∧ BRIC(china) ∧ Emerging(chinaEconomy))
∀x (From(x, china) → From(x, bric))
BRIC(india) ∧ Emerging(indiaEconomy)
∀x (From(x, india) → From(x, bric))
∀x (From(x, china) → Chinese(x))
∀x (From(x, india) → Indian(x))
∃x (From(x, india))

[PREMISE (GK)]:
? [X] : (BRIC(X) & -(X=china) & BRIC(china) & Emerging(chinaEconomy)).
! [X] : (From(X, china) => From(X, bric)).
BRIC(india) & Emerging(indiaEconomy).
! [X] : (From(X, india) => From(X, bric)).
! [X] : (From(X, china) => Chinese(X)).
! [X] : (From(X, india) => Indian(X)).
? [X] : (From(X, india)).

[CONCLUSION]:
India's economy is not emerging.

[CONCLUSION (FOL)]:
EmergingEconomy(india)

[CONCLUSION (GK)]:
EmergingEconomy(india).


===

['x']
['x']
[PREMISE]:
China is one of the BRICS, and its economy is emerging.
If someone is from China, then they are from a country of BRICS.
India is one of the BRICS, and its economy is emerging.
If someone is from India, then they are in a country of BRICS.
All people from China are Chinese people.
All people from India are Indian people.
There is a person from India.

[PREMISE (FOL)]:
∃x (BRIC(x) ∧ ¬(x=china) ∧ BRIC(china) ∧ Emerging(chinaEconomy))
∀x (From(x, china) → From(x, bric))
BRIC(india) ∧ Emerging(indiaEconomy)
∀x (From(x, india) → From(x, bric))
∀x (From(x, china) → Chinese(x))
∀x (From(x, india) → Indian(x))
∃x (From(x, india))

[PREMISE (GK)]:
? [X] : (BRIC(X) & -(X=china) & BRIC(china) & Emerging(chinaEconomy)).
! [X] : (From(X, china) => From(X, bric)).
BRIC(india) & Emerging(indiaEconomy).
! [X] : (From(X, india) => From(X, bric)).
! [X] : (From(X, china) => Chinese(X)).
! [X] : (From(X, india) => Indian(X)).
? [X] : (From(X, india)).

[CONCLUSION]:
There is an Indian people from BRICS.

[CONCLUSION (FOL)]:
∃x (IndianPeople(x) ∧ From(x, countryOfBRICS))

[CONCLUSION (GK)]:
? [X] : (IndianPeople(X) & From(X, countryOfBRICS)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Daveed Diggs is an actor and film producer.
Daveed Diggs played two roles in the musical Hamilton on Broadway.
One of the actors from Hamilton won the best actor award.
The actor playing Thomas Jefferson won the best actor award.
Daveed Diggs played Thomas Jefferson.
Musicals on Broadway are not films.

[PREMISE (FOL)]:
Actor(daveedDiggs) ∧ FilmProducer(daveedDiggs)
∃x ∃y(PlaysIn(daveedDiggs, x, hamilton) ∧ (¬(x=y)) ∧ PlaysIn(daveedDiggs, y, hamilton)) ∧ OnBroadway(hamilton) ∧ Musical(hamilton)
∃x ∃y(Actor(x) ∧ PlaysIn(x, y, hamilton) ∧ Wins(x, bestActorAward))
∃x (Actor(x) ∧ PlaysIn(x, thomasJefferson, hamilton) ∧ Wins(x, bestActorAward))
Plays(daveedDiggs, thomasJefferson)
∀x ((Musical(x) ∧ OnBroadway(x)) → ¬Film(x))

[PREMISE (GK)]:
Actor(daveedDiggs) & FilmProducer(daveedDiggs).
? [X] : ? [Y] :(PlaysIn(daveedDiggs, X, hamilton) & (-(X=Y)) & PlaysIn(daveedDiggs, Y, hamilton)) & OnBroadway(hamilton) & Musical(hamilton).
? [X] : ? [Y] :(Actor(X) & PlaysIn(X, Y, hamilton) & Wins(X, bestActorAward)).
? [X] : (Actor(X) & PlaysIn(X, thomasJefferson, hamilton) & Wins(X, bestActorAward)).
Plays(daveedDiggs, thomasJefferson).
! [X] : ((Musical(X) & OnBroadway(X)) => -Film(X)).

[CONCLUSION]:
Hamilton is a film.

[CONCLUSION (FOL)]:
Film(hamilton)

[CONCLUSION (GK)]:
Film(hamilton).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Daveed Diggs is an actor and film producer.
Daveed Diggs played two roles in the musical Hamilton on Broadway.
One of the actors from Hamilton won the best actor award.
The actor playing Thomas Jefferson won the best actor award.
Daveed Diggs played Thomas Jefferson.
Musicals on Broadway are not films.

[PREMISE (FOL)]:
Actor(daveedDiggs) ∧ FilmProducer(daveedDiggs)
∃x ∃y(PlaysIn(daveedDiggs, x, hamilton) ∧ (¬(x=y)) ∧ PlaysIn(daveedDiggs, y, hamilton)) ∧ OnBroadway(hamilton) ∧ Musical(hamilton)
∃x ∃y(Actor(x) ∧ PlaysIn(x, y, hamilton) ∧ Wins(x, bestActorAward))
∃x (Actor(x) ∧ PlaysIn(x, thomasJefferson, hamilton) ∧ Wins(x, bestActorAward))
Plays(daveedDiggs, thomasJefferson)
∀x ((Musical(x) ∧ OnBroadway(x)) → ¬Film(x))

[PREMISE (GK)]:
Actor(daveedDiggs) & FilmProducer(daveedDiggs).
? [X] : ? [Y] :(PlaysIn(daveedDiggs, X, hamilton) & (-(X=Y)) & PlaysIn(daveedDiggs, Y, hamilton)) & OnBroadway(hamilton) & Musical(hamilton).
? [X] : ? [Y] :(Actor(X) & PlaysIn(X, Y, hamilton) & Wins(X, bestActorAward)).
? [X] : (Actor(X) & PlaysIn(X, thomasJefferson, hamilton) & Wins(X, bestActorAward)).
Plays(daveedDiggs, thomasJefferson).
! [X] : ((Musical(X) & OnBroadway(X)) => -Film(X)).

[CONCLUSION]:
Daveed Diggs won the best actor award.

[CONCLUSION (FOL)]:
Wins(daveedDiggs, bestActorAward)

[CONCLUSION (GK)]:
Wins(daveedDiggs, bestActorAward).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Daveed Diggs is an actor and film producer.
Daveed Diggs played two roles in the musical Hamilton on Broadway.
One of the actors from Hamilton won the best actor award.
The actor playing Thomas Jefferson won the best actor award.
Daveed Diggs played Thomas Jefferson.
Musicals on Broadway are not films.

[PREMISE (FOL)]:
Actor(daveedDiggs) ∧ FilmProducer(daveedDiggs)
∃x ∃y(PlaysIn(daveedDiggs, x, hamilton) ∧ (¬(x=y)) ∧ PlaysIn(daveedDiggs, y, hamilton)) ∧ OnBroadway(hamilton) ∧ Musical(hamilton)
∃x ∃y(Actor(x) ∧ PlaysIn(x, y, hamilton) ∧ Wins(x, bestActorAward))
∃x (Actor(x) ∧ PlaysIn(x, thomasJefferson, hamilton) ∧ Wins(x, bestActorAward))
Plays(daveedDiggs, thomasJefferson)
∀x ((Musical(x) ∧ OnBroadway(x)) → ¬Film(x))

[PREMISE (GK)]:
Actor(daveedDiggs) & FilmProducer(daveedDiggs).
? [X] : ? [Y] :(PlaysIn(daveedDiggs, X, hamilton) & (-(X=Y)) & PlaysIn(daveedDiggs, Y, hamilton)) & OnBroadway(hamilton) & Musical(hamilton).
? [X] : ? [Y] :(Actor(X) & PlaysIn(X, Y, hamilton) & Wins(X, bestActorAward)).
? [X] : (Actor(X) & PlaysIn(X, thomasJefferson, hamilton) & Wins(X, bestActorAward)).
Plays(daveedDiggs, thomasJefferson).
! [X] : ((Musical(X) & OnBroadway(X)) => -Film(X)).

[CONCLUSION]:
Hamilton won two awards.

[CONCLUSION (FOL)]:
∃x ∃y(Wins(hamilton, x) ∧ (¬(x=y)) ∧ Wins(hamilton, y))

[CONCLUSION (GK)]:
? [X] : ? [Y] :(Wins(hamilton, X) & (-(X=Y)) & Wins(hamilton, Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Ernest Pohl was a Polish football player. 
A football player in the Polish First Division has scored over 180 goals. 
Ernest Pohl scored more than 180 goals in the Polish First Division. 
Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska. 
Ernest Pohl is from Ruda Śląska. 

[PREMISE (FOL)]:
Polish(ernestPohl) ∧ FootballPlayer(ernestPohl)
∃x (FootballPlayer(x) ∧ In(x, polishFirstDivision) ∧ ScoredOver(x, 180Goals))
In(ernestPohl, polishFirstDivision) ∧ ScoredOver(ernestPohl, 180Goals)
∃x ∃y (GornikZabrzes(x) ∧ Stadium(x) ∧ NamedAfter(x, y) ∧ SoccerPlayer(y) ∧ From(y, rudaŚląska))
From(ernestPohl, rudaŚląska))

[PREMISE (GK)]:
Polish(ernestPohl) & FootballPlayer(ernestPohl).
? [X] : (FootballPlayer(X) & In(X, polishFirstDivision) & ScoredOver(X, 180Goals)).
In(ernestPohl, polishFirstDivision) & ScoredOver(ernestPohl, 180Goals).
? [X] : ? [Y] : (GornikZabrzes(X) & Stadium(X) & NamedAfter(X, Y) & SoccerPlayer(Y) & From(Y, rudaŚląska)).
From(ernestPohl, rudaŚląska)).

[CONCLUSION]:
Ernest Pohl has not scored more than 180 goals.

[CONCLUSION (FOL)]:
¬ScoredOver(ernestPohl, 180Goals)

[CONCLUSION (GK)]:
-ScoredOver(ernestPohl, 180Goals).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Ernest Pohl was a Polish football player. 
A football player in the Polish First Division has scored over 180 goals. 
Ernest Pohl scored more than 180 goals in the Polish First Division. 
Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska. 
Ernest Pohl is from Ruda Śląska. 

[PREMISE (FOL)]:
Polish(ernestPohl) ∧ FootballPlayer(ernestPohl)
∃x (FootballPlayer(x) ∧ In(x, polishFirstDivision) ∧ ScoredOver(x, 180Goals))
In(ernestPohl, polishFirstDivision) ∧ ScoredOver(ernestPohl, 180Goals)
∃x ∃y (GornikZabrzes(x) ∧ Stadium(x) ∧ NamedAfter(x, y) ∧ SoccerPlayer(y) ∧ From(y, rudaŚląska))
From(ernestPohl, rudaŚląska))

[PREMISE (GK)]:
Polish(ernestPohl) & FootballPlayer(ernestPohl).
? [X] : (FootballPlayer(X) & In(X, polishFirstDivision) & ScoredOver(X, 180Goals)).
In(ernestPohl, polishFirstDivision) & ScoredOver(ernestPohl, 180Goals).
? [X] : ? [Y] : (GornikZabrzes(X) & Stadium(X) & NamedAfter(X, Y) & SoccerPlayer(Y) & From(Y, rudaŚląska)).
From(ernestPohl, rudaŚląska)).

[CONCLUSION]:
Górnik Zabrze's stadium was named after Ernest Pohl.

[CONCLUSION (FOL)]:
∀x (GornikZabrzes(x) ∧ Stadium(x) → NamedAfter(x, ernestPohl))

[CONCLUSION (GK)]:
! [X] : (GornikZabrzes(X) & Stadium(X) => NamedAfter(X, ernestPohl)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Ann J. Land was a member of the Philadelphia City Council and the Democratic Party.
Ann J. Land ran unopposed for the Philadelphia City Council in 1980.
People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.
Michael Nutter was a political challenger.
Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.

[PREMISE (FOL)]:
MemberOf(annJLand, philadelphiaCityCouncil) ∧ MemberOf(annJLand, democraticParty)
RunUnopposedFor(ann, philadelphiaCityCouncil, year1980)
∀x ∀y (RunUnopposedFor(x, philadelphiaCityCouncil, y) → ElectedTo(x, philadelphiaCityCouncil, y))
PoliticalChallenger(michaelNutter)
Defeat(annJLand, michaelNutter) ∧ RunFor(annJLand, philadelphiaCityCouncil, year1987)

[PREMISE (GK)]:
MemberOf(annJLand, philadelphiaCityCouncil) & MemberOf(annJLand, democraticParty).
RunUnopposedFor(ann, philadelphiaCityCouncil, year1980).
! [X] : ! [Y] : (RunUnopposedFor(X, philadelphiaCityCouncil, Y) => ElectedTo(X, philadelphiaCityCouncil, Y)).
PoliticalChallenger(michaelNutter).
Defeat(annJLand, michaelNutter) & RunFor(annJLand, philadelphiaCityCouncil, year1987).

[CONCLUSION]:
Ann J. Land was elected to the Philadelphia City Council in 1980.

[CONCLUSION (FOL)]:
ElectedTo(ann, philadelphiaCityCouncil, year1980)

[CONCLUSION (GK)]:
ElectedTo(ann, philadelphiaCityCouncil, year1980).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Ann J. Land was a member of the Philadelphia City Council and the Democratic Party.
Ann J. Land ran unopposed for the Philadelphia City Council in 1980.
People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.
Michael Nutter was a political challenger.
Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.

[PREMISE (FOL)]:
MemberOf(annJLand, philadelphiaCityCouncil) ∧ MemberOf(annJLand, democraticParty)
RunUnopposedFor(ann, philadelphiaCityCouncil, year1980)
∀x ∀y (RunUnopposedFor(x, philadelphiaCityCouncil, y) → ElectedTo(x, philadelphiaCityCouncil, y))
PoliticalChallenger(michaelNutter)
Defeat(annJLand, michaelNutter) ∧ RunFor(annJLand, philadelphiaCityCouncil, year1987)

[PREMISE (GK)]:
MemberOf(annJLand, philadelphiaCityCouncil) & MemberOf(annJLand, democraticParty).
RunUnopposedFor(ann, philadelphiaCityCouncil, year1980).
! [X] : ! [Y] : (RunUnopposedFor(X, philadelphiaCityCouncil, Y) => ElectedTo(X, philadelphiaCityCouncil, Y)).
PoliticalChallenger(michaelNutter).
Defeat(annJLand, michaelNutter) & RunFor(annJLand, philadelphiaCityCouncil, year1987).

[CONCLUSION]:
Ann J. Land was elected to the Philadelphia City Council in 1987.

[CONCLUSION (FOL)]:
ElectedTo(ann, philadelphiaCityCouncil, year1987)

[CONCLUSION (GK)]:
ElectedTo(ann, philadelphiaCityCouncil, year1987).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Ann J. Land was a member of the Philadelphia City Council and the Democratic Party.
Ann J. Land ran unopposed for the Philadelphia City Council in 1980.
People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.
Michael Nutter was a political challenger.
Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.

[PREMISE (FOL)]:
MemberOf(annJLand, philadelphiaCityCouncil) ∧ MemberOf(annJLand, democraticParty)
RunUnopposedFor(ann, philadelphiaCityCouncil, year1980)
∀x ∀y (RunUnopposedFor(x, philadelphiaCityCouncil, y) → ElectedTo(x, philadelphiaCityCouncil, y))
PoliticalChallenger(michaelNutter)
Defeat(annJLand, michaelNutter) ∧ RunFor(annJLand, philadelphiaCityCouncil, year1987)

[PREMISE (GK)]:
MemberOf(annJLand, philadelphiaCityCouncil) & MemberOf(annJLand, democraticParty).
RunUnopposedFor(ann, philadelphiaCityCouncil, year1980).
! [X] : ! [Y] : (RunUnopposedFor(X, philadelphiaCityCouncil, Y) => ElectedTo(X, philadelphiaCityCouncil, Y)).
PoliticalChallenger(michaelNutter).
Defeat(annJLand, michaelNutter) & RunFor(annJLand, philadelphiaCityCouncil, year1987).

[CONCLUSION]:
There was some member of the Democratic Party elected to the Philadelphia City Council in 1980.

[CONCLUSION (FOL)]:
∃x (MemberOf(x, democraticParty) ∧ ElectedTo(x, philadelphiaCouncil, year1980))

[CONCLUSION (GK)]:
? [X] : (MemberOf(X, democraticParty) & ElectedTo(X, philadelphiaCouncil, year1980)).


===

['w', 'x', 'y', 'z']
['w', 'x', 'y', 'z']
[PREMISE]:
Aberdeen won the cup in the 2013 final.
Rangers won the cup in the 2014 final.
Aberdeen and Rangers are different teams.
Different teams cannot win the cup in the same year's final.

[PREMISE (FOL)]:
WonCup(aberdeen, year2013Final)
WonCup(rangers, year2014Final)
¬(aberdeen=rangers)
∀x ∀y ∀z ∀w (¬(x=y) ∧ WonCup(x, z) ∧ WonCup(y, w) → ¬(z=w))

[PREMISE (GK)]:
WonCup(aberdeen, year2013Final).
WonCup(rangers, year2014Final).
-(aberdeen=rangers).
! [X] : ! [Y] : ! [Z] : ! [W] : (-(X=Y) & WonCup(X, Z) & WonCup(Y, W) => -(Z=W)).

[CONCLUSION]:
Rangers won the cup in 2015.

[CONCLUSION (FOL)]:
WonCup(rangers, year2015Final)

[CONCLUSION (GK)]:
WonCup(rangers, year2015Final).


===

['w', 'x', 'y', 'z']
['w', 'x', 'y', 'z']
[PREMISE]:
Aberdeen won the cup in the 2013 final.
Rangers won the cup in the 2014 final.
Aberdeen and Rangers are different teams.
Different teams cannot win the cup in the same year's final.

[PREMISE (FOL)]:
WonCup(aberdeen, year2013Final)
WonCup(rangers, year2014Final)
¬(aberdeen=rangers)
∀x ∀y ∀z ∀w (¬(x=y) ∧ WonCup(x, z) ∧ WonCup(y, w) → ¬(z=w))

[PREMISE (GK)]:
WonCup(aberdeen, year2013Final).
WonCup(rangers, year2014Final).
-(aberdeen=rangers).
! [X] : ! [Y] : ! [Z] : ! [W] : (-(X=Y) & WonCup(X, Z) & WonCup(Y, W) => -(Z=W)).

[CONCLUSION]:
Rangers won the cup in 2013.

[CONCLUSION (FOL)]:
WonCup(rangers, year2013Final)

[CONCLUSION (GK)]:
WonCup(rangers, year2013Final).


===

['w', 'x', 'y', 'z']
['w', 'x', 'y', 'z']
[PREMISE]:
Aberdeen won the cup in the 2013 final.
Rangers won the cup in the 2014 final.
Aberdeen and Rangers are different teams.
Different teams cannot win the cup in the same year's final.

[PREMISE (FOL)]:
WonCup(aberdeen, year2013Final)
WonCup(rangers, year2014Final)
¬(aberdeen=rangers)
∀x ∀y ∀z ∀w (¬(x=y) ∧ WonCup(x, z) ∧ WonCup(y, w) → ¬(z=w))

[PREMISE (GK)]:
WonCup(aberdeen, year2013Final).
WonCup(rangers, year2014Final).
-(aberdeen=rangers).
! [X] : ! [Y] : ! [Z] : ! [W] : (-(X=Y) & WonCup(X, Z) & WonCup(Y, W) => -(Z=W)).

[CONCLUSION]:
Aberdeen has once won a cup.

[CONCLUSION (FOL)]:
∃x (WonCup(aberdeen, x))

[CONCLUSION (GK)]:
? [X] : (WonCup(aberdeen, X)).


===

['x']
['x']
[PREMISE]:
All young working professionals who have regular 9-5 jobs have stable jobs.
Some people living in Manhattan are young professionals with regular 9-5 jobs.
All people who have stable jobs are people who work regularly.
People who work regularly do not frequently disobey their bosses.
Mary either frequently disobeys her bosses and works regularly, or that she neither frequently disobeys her bosses nor works regularly.

[PREMISE (FOL)]:
∀x (YoungWorkingProfessional(x) ∧ Have(x, regular9To5Job) → Have(x, stableJob))
∃x (LiveIn(x, manhattan) ∧ YoungWorkingProfessional(x) ∧ Have(x, regular9To5Job))
∀x (Have(x, stableJob) → WorkRegularly(x))
∀x (WorkRegularly(x) → ¬DisobeyFrequently(x, boss))
¬(DisobeyFrequently(mary, boss) ⊕ WorkRegularly(mary))

[PREMISE (GK)]:
! [X] : (YoungWorkingProfessional(X) & Have(X, regular9To5Job) => Have(X, stableJob)).
? [X] : (LiveIn(X, manhattan) & YoungWorkingProfessional(X) & Have(X, regular9To5Job)).
! [X] : (Have(X, stableJob) => WorkRegularly(X)).
! [X] : (WorkRegularly(X) => -DisobeyFrequently(X, boss)).
-(DisobeyFrequently(mary, boss) <~> WorkRegularly(mary)).

[CONCLUSION]:
Mary lives in Manhattan.

[CONCLUSION (FOL)]:
LiveIn(mary, manhattan)

[CONCLUSION (GK)]:
LiveIn(mary, manhattan).


===

['x']
['x']
[PREMISE]:
All young working professionals who have regular 9-5 jobs have stable jobs.
Some people living in Manhattan are young professionals with regular 9-5 jobs.
All people who have stable jobs are people who work regularly.
People who work regularly do not frequently disobey their bosses.
Mary either frequently disobeys her bosses and works regularly, or that she neither frequently disobeys her bosses nor works regularly.

[PREMISE (FOL)]:
∀x (YoungWorkingProfessional(x) ∧ Have(x, regular9To5Job) → Have(x, stableJob))
∃x (LiveIn(x, manhattan) ∧ YoungWorkingProfessional(x) ∧ Have(x, regular9To5Job))
∀x (Have(x, stableJob) → WorkRegularly(x))
∀x (WorkRegularly(x) → ¬DisobeyFrequently(x, boss))
¬(DisobeyFrequently(mary, boss) ⊕ WorkRegularly(mary))

[PREMISE (GK)]:
! [X] : (YoungWorkingProfessional(X) & Have(X, regular9To5Job) => Have(X, stableJob)).
? [X] : (LiveIn(X, manhattan) & YoungWorkingProfessional(X) & Have(X, regular9To5Job)).
! [X] : (Have(X, stableJob) => WorkRegularly(X)).
! [X] : (WorkRegularly(X) => -DisobeyFrequently(X, boss)).
-(DisobeyFrequently(mary, boss) <~> WorkRegularly(mary)).

[CONCLUSION]:
Mary lives in Manhattan and is a young working professional who has a regular 9-5 job.

[CONCLUSION (FOL)]:
LiveIn(mary, manhattan) ∧ YoungWorkingProfessional(mary) ∧ Have(mary, regular9-5Job)

[CONCLUSION (GK)]:
LiveIn(mary, manhattan) & YoungWorkingProfessional(mary) & Have(mary, regular9-5Job).


===

['x']
['x']
[PREMISE]:
All young working professionals who have regular 9-5 jobs have stable jobs.
Some people living in Manhattan are young professionals with regular 9-5 jobs.
All people who have stable jobs are people who work regularly.
People who work regularly do not frequently disobey their bosses.
Mary either frequently disobeys her bosses and works regularly, or that she neither frequently disobeys her bosses nor works regularly.

[PREMISE (FOL)]:
∀x (YoungWorkingProfessional(x) ∧ Have(x, regular9To5Job) → Have(x, stableJob))
∃x (LiveIn(x, manhattan) ∧ YoungWorkingProfessional(x) ∧ Have(x, regular9To5Job))
∀x (Have(x, stableJob) → WorkRegularly(x))
∀x (WorkRegularly(x) → ¬DisobeyFrequently(x, boss))
¬(DisobeyFrequently(mary, boss) ⊕ WorkRegularly(mary))

[PREMISE (GK)]:
! [X] : (YoungWorkingProfessional(X) & Have(X, regular9To5Job) => Have(X, stableJob)).
? [X] : (LiveIn(X, manhattan) & YoungWorkingProfessional(X) & Have(X, regular9To5Job)).
! [X] : (Have(X, stableJob) => WorkRegularly(X)).
! [X] : (WorkRegularly(X) => -DisobeyFrequently(X, boss)).
-(DisobeyFrequently(mary, boss) <~> WorkRegularly(mary)).

[CONCLUSION]:
If Mary is a young working professional who has a regular 9-5 job, then Mary does not live in Manhattan.

[CONCLUSION (FOL)]:
YoungWorkingProfessional(mary) ∧ Have(mary, regular9-5Job) → ¬LiveIn(mary, manhattan)

[CONCLUSION (GK)]:
YoungWorkingProfessional(mary) & Have(mary, regular9-5Job) => -LiveIn(mary, manhattan).


===

['x']
['x']
[PREMISE]:
All brain study designs are either block designs or event-related designs. 
All event-related brain study designs are brain image acquisition.
All brain image acquisition in brain study designs is preceded by data processing.
Nothing in brain study designs preceded by data processing analyzes data.
Picture memory is a type of brain study design that is not either event-related or analyzing data.

[PREMISE (FOL)]:
∀x (BrainStudy(x) → (BlockDesign(x) ⊕ Event-relatedDesign(x)))
∀x ((BrainStudy(x) ∧ EventRelatedDesign(x)) → BrainImageAcquisition(x))
∀x ((BrainStudy(x) ∧ BrainImageAcquisition(x)) → PrecededBy(x, dataProcessing))
∀x ((BrainStudy(x) ∧ PrecededBy(x, dataProcessing)) → ¬Analyze(x, data))
BrainStudy(pictureMemory) ∧ (¬(EventRelatedDesign(pictureMemory) ⊕ AnalyzingData(pictureMemory)))

[PREMISE (GK)]:
! [X] : (BrainStudy(X) => (BlockDesign(X) <~> Event-relatedDesign(X))).
! [X] : ((BrainStudy(X) & EventRelatedDesign(X)) => BrainImageAcquisition(X)).
! [X] : ((BrainStudy(X) & BrainImageAcquisition(X)) => PrecededBy(X, dataProcessing)).
! [X] : ((BrainStudy(X) & PrecededBy(X, dataProcessing)) => -Analyze(X, data)).
BrainStudy(pictureMemory) & (-(EventRelatedDesign(pictureMemory) <~> AnalyzingData(pictureMemory))).

[CONCLUSION]:
Picture memory is preceded by data processing.

[CONCLUSION (FOL)]:
PrecededBy(pictureMemory, dataProcessing)

[CONCLUSION (GK)]:
PrecededBy(pictureMemory, dataProcessing).


===

['x']
['x']
[PREMISE]:
All brain study designs are either block designs or event-related designs. 
All event-related brain study designs are brain image acquisition.
All brain image acquisition in brain study designs is preceded by data processing.
Nothing in brain study designs preceded by data processing analyzes data.
Picture memory is a type of brain study design that is not either event-related or analyzing data.

[PREMISE (FOL)]:
∀x (BrainStudy(x) → (BlockDesign(x) ⊕ Event-relatedDesign(x)))
∀x ((BrainStudy(x) ∧ EventRelatedDesign(x)) → BrainImageAcquisition(x))
∀x ((BrainStudy(x) ∧ BrainImageAcquisition(x)) → PrecededBy(x, dataProcessing))
∀x ((BrainStudy(x) ∧ PrecededBy(x, dataProcessing)) → ¬Analyze(x, data))
BrainStudy(pictureMemory) ∧ (¬(EventRelatedDesign(pictureMemory) ⊕ AnalyzingData(pictureMemory)))

[PREMISE (GK)]:
! [X] : (BrainStudy(X) => (BlockDesign(X) <~> Event-relatedDesign(X))).
! [X] : ((BrainStudy(X) & EventRelatedDesign(X)) => BrainImageAcquisition(X)).
! [X] : ((BrainStudy(X) & BrainImageAcquisition(X)) => PrecededBy(X, dataProcessing)).
! [X] : ((BrainStudy(X) & PrecededBy(X, dataProcessing)) => -Analyze(X, data)).
BrainStudy(pictureMemory) & (-(EventRelatedDesign(pictureMemory) <~> AnalyzingData(pictureMemory))).

[CONCLUSION]:
Picture memory is a block design.

[CONCLUSION (FOL)]:
BlockDesign(pictureMemory)

[CONCLUSION (GK)]:
BlockDesign(pictureMemory).


===

['x']
['x']
[PREMISE]:
All brain study designs are either block designs or event-related designs. 
All event-related brain study designs are brain image acquisition.
All brain image acquisition in brain study designs is preceded by data processing.
Nothing in brain study designs preceded by data processing analyzes data.
Picture memory is a type of brain study design that is not either event-related or analyzing data.

[PREMISE (FOL)]:
∀x (BrainStudy(x) → (BlockDesign(x) ⊕ Event-relatedDesign(x)))
∀x ((BrainStudy(x) ∧ EventRelatedDesign(x)) → BrainImageAcquisition(x))
∀x ((BrainStudy(x) ∧ BrainImageAcquisition(x)) → PrecededBy(x, dataProcessing))
∀x ((BrainStudy(x) ∧ PrecededBy(x, dataProcessing)) → ¬Analyze(x, data))
BrainStudy(pictureMemory) ∧ (¬(EventRelatedDesign(pictureMemory) ⊕ AnalyzingData(pictureMemory)))

[PREMISE (GK)]:
! [X] : (BrainStudy(X) => (BlockDesign(X) <~> Event-relatedDesign(X))).
! [X] : ((BrainStudy(X) & EventRelatedDesign(X)) => BrainImageAcquisition(X)).
! [X] : ((BrainStudy(X) & BrainImageAcquisition(X)) => PrecededBy(X, dataProcessing)).
! [X] : ((BrainStudy(X) & PrecededBy(X, dataProcessing)) => -Analyze(X, data)).
BrainStudy(pictureMemory) & (-(EventRelatedDesign(pictureMemory) <~> AnalyzingData(pictureMemory))).

[CONCLUSION]:
Picture memory is either a block design or analyzing data.

[CONCLUSION (FOL)]:
BlockDesign(pictureMemory) ⊕ Analyze(pictureMemory, data)

[CONCLUSION (GK)]:
BlockDesign(pictureMemory) <~> Analyze(pictureMemory, data).


===

['x']
['x']
[PREMISE]:
All brain study designs are either block designs or event-related designs. 
All event-related brain study designs are brain image acquisition.
All brain image acquisition in brain study designs is preceded by data processing.
Nothing in brain study designs preceded by data processing analyzes data.
Picture memory is a type of brain study design that is not either event-related or analyzing data.

[PREMISE (FOL)]:
∀x (BrainStudy(x) → (BlockDesign(x) ⊕ Event-relatedDesign(x)))
∀x ((BrainStudy(x) ∧ EventRelatedDesign(x)) → BrainImageAcquisition(x))
∀x ((BrainStudy(x) ∧ BrainImageAcquisition(x)) → PrecededBy(x, dataProcessing))
∀x ((BrainStudy(x) ∧ PrecededBy(x, dataProcessing)) → ¬Analyze(x, data))
BrainStudy(pictureMemory) ∧ (¬(EventRelatedDesign(pictureMemory) ⊕ AnalyzingData(pictureMemory)))

[PREMISE (GK)]:
! [X] : (BrainStudy(X) => (BlockDesign(X) <~> Event-relatedDesign(X))).
! [X] : ((BrainStudy(X) & EventRelatedDesign(X)) => BrainImageAcquisition(X)).
! [X] : ((BrainStudy(X) & BrainImageAcquisition(X)) => PrecededBy(X, dataProcessing)).
! [X] : ((BrainStudy(X) & PrecededBy(X, dataProcessing)) => -Analyze(X, data)).
BrainStudy(pictureMemory) & (-(EventRelatedDesign(pictureMemory) <~> AnalyzingData(pictureMemory))).

[CONCLUSION]:
If picture memory is not analyzing data, then picture memory is a block design and analyzing data.

[CONCLUSION (FOL)]:
¬Analyze(pictureMemory, data) → (BlockDesign(pictureMemory) ∧ Analyze(pictureMemory, data))

[CONCLUSION (GK)]:
-Analyze(pictureMemory, data) => (BlockDesign(pictureMemory) & Analyze(pictureMemory, data)).


===

['x']
['x']
[PREMISE]:
The USS Lyon was a US Navy ship involved in WWII.
All ships involved in WWII are currently decommissioned or in a museum.

[PREMISE (FOL)]:
USNavyShip(theUSSLyon) ∧ InvolvedIn(theUSSLyon, wWII)
∀x (InvolvedIn(x, wWII) → (CurrentlyDecommissioned(x) ∨ In(x, museum)))

[PREMISE (GK)]:
USNavyShip(theUSSLyon) & InvolvedIn(theUSSLyon, wWII).
! [X] : (InvolvedIn(X, wWII) => (CurrentlyDecommissioned(X) | In(X, museum))).

[CONCLUSION]:
The USS Lyon is currently decommissioned.

[CONCLUSION (FOL)]:
CurrentlyDecommissioned(theUSSLyon)

[CONCLUSION (GK)]:
CurrentlyDecommissioned(theUSSLyon).


===

['x']
['x']
[PREMISE]:
All disposables are designed to be used only once.
Some items used in Tom's house are eco-friendly.
Every item used in Tom's house is either disposable or reusable. 
If something is made from metal, then it is not made from plastic. 
All reusable items used in Tom's house are made from metal.
The chopsticks used in Tom's house are either made from metals and plastics, or that they are neither made from metals nor plastics.

[PREMISE (FOL)]:
∀x (Disposable(x) → DesignedToBeOnlyUsedOnce(x))
∃x (EcoFriendly(x))
∀x (UsedIn(x, tomsHouse) → Disposable(x) ⊕ Reusable(x))
∀x (MadeFrom(x, metal) → ¬MadeFrom(x, plastic))
∀x (Reusable(x) → MadeFrom(x, metal))
¬(MadeFrom(chopsticksUsedInTomsHouse, metal) ⊕ MadeFrom(chopsticksUsedInTomsHouse, plastic))

[PREMISE (GK)]:
! [X] : (Disposable(X) => DesignedToBeOnlyUsedOnce(X)).
? [X] : (EcoFriendly(X)).
! [X] : (UsedIn(X, tomsHouse) => Disposable(X) <~> Reusable(X)).
! [X] : (MadeFrom(X, metal) => -MadeFrom(X, plastic)).
! [X] : (Reusable(X) => MadeFrom(X, metal)).
-(MadeFrom(chopsticksUsedInTomsHouse, metal) <~> MadeFrom(chopsticksUsedInTomsHouse, plastic)).

[CONCLUSION]:
The chopsticks used in Tom's house are eco-friendly.

[CONCLUSION (FOL)]:
EcoFriendly(chopsticks)

[CONCLUSION (GK)]:
EcoFriendly(chopsticks).


===

['x']
['x']
[PREMISE]:
All disposables are designed to be used only once.
Some items used in Tom's house are eco-friendly.
Every item used in Tom's house is either disposable or reusable. 
If something is made from metal, then it is not made from plastic. 
All reusable items used in Tom's house are made from metal.
The chopsticks used in Tom's house are either made from metals and plastics, or that they are neither made from metals nor plastics.

[PREMISE (FOL)]:
∀x (Disposable(x) → DesignedToBeOnlyUsedOnce(x))
∃x (EcoFriendly(x))
∀x (UsedIn(x, tomsHouse) → Disposable(x) ⊕ Reusable(x))
∀x (MadeFrom(x, metal) → ¬MadeFrom(x, plastic))
∀x (Reusable(x) → MadeFrom(x, metal))
¬(MadeFrom(chopsticksUsedInTomsHouse, metal) ⊕ MadeFrom(chopsticksUsedInTomsHouse, plastic))

[PREMISE (GK)]:
! [X] : (Disposable(X) => DesignedToBeOnlyUsedOnce(X)).
? [X] : (EcoFriendly(X)).
! [X] : (UsedIn(X, tomsHouse) => Disposable(X) <~> Reusable(X)).
! [X] : (MadeFrom(X, metal) => -MadeFrom(X, plastic)).
! [X] : (Reusable(X) => MadeFrom(X, metal)).
-(MadeFrom(chopsticksUsedInTomsHouse, metal) <~> MadeFrom(chopsticksUsedInTomsHouse, plastic)).

[CONCLUSION]:
The chopsticks used in Tom's house are eco-friendly or designed to be used only once.

[CONCLUSION (FOL)]:
EcoFriendly(chopsticks) ∨ DesignedToBeOnlyUsedOnce(chopsticks)

[CONCLUSION (GK)]:
EcoFriendly(chopsticks) | DesignedToBeOnlyUsedOnce(chopsticks).


===

['x']
['x']
[PREMISE]:
All disposables are designed to be used only once.
Some items used in Tom's house are eco-friendly.
Every item used in Tom's house is either disposable or reusable. 
If something is made from metal, then it is not made from plastic. 
All reusable items used in Tom's house are made from metal.
The chopsticks used in Tom's house are either made from metals and plastics, or that they are neither made from metals nor plastics.

[PREMISE (FOL)]:
∀x (Disposable(x) → DesignedToBeOnlyUsedOnce(x))
∃x (EcoFriendly(x))
∀x (UsedIn(x, tomsHouse) → Disposable(x) ⊕ Reusable(x))
∀x (MadeFrom(x, metal) → ¬MadeFrom(x, plastic))
∀x (Reusable(x) → MadeFrom(x, metal))
¬(MadeFrom(chopsticksUsedInTomsHouse, metal) ⊕ MadeFrom(chopsticksUsedInTomsHouse, plastic))

[PREMISE (GK)]:
! [X] : (Disposable(X) => DesignedToBeOnlyUsedOnce(X)).
? [X] : (EcoFriendly(X)).
! [X] : (UsedIn(X, tomsHouse) => Disposable(X) <~> Reusable(X)).
! [X] : (MadeFrom(X, metal) => -MadeFrom(X, plastic)).
! [X] : (Reusable(X) => MadeFrom(X, metal)).
-(MadeFrom(chopsticksUsedInTomsHouse, metal) <~> MadeFrom(chopsticksUsedInTomsHouse, plastic)).

[CONCLUSION]:
If chopsticks used in Tom's house are made from plastic or designed to be used only once, then they are made from plastic and are eco-friendly.

[CONCLUSION (FOL)]:
MadeFrom(chopsticks, plastic) ∨ DesignedBeOnlyUsedOnce(chopsticks) → MadeFrom(chopsticks, plastic) ∧ EcoFriendly(chopsticks)

[CONCLUSION (GK)]:
MadeFrom(chopsticks, plastic) | DesignedBeOnlyUsedOnce(chopsticks) => MadeFrom(chopsticks, plastic) & EcoFriendly(chopsticks).


===

['x']
['x']
[PREMISE]:
Anything lazy is unproductive.
No one unproductive is energetic.
If something is a sloth, then it is lazy.
Some animals are sloths.
Sid is neither an energetic person nor a sloth.

[PREMISE (FOL)]:
∀x (Lazy(x) → Unproductive(x))
∀x (Unproductive(x) → ¬Energetic(x))
∀x (Sloth(x) → Lazy(x))
∃x (Animal(x) ∧ Sloth(x))
¬Energetic(sid) ∧ ¬Sloth(sid))

[PREMISE (GK)]:
! [X] : (Lazy(X) => Unproductive(X)).
! [X] : (Unproductive(X) => -Energetic(X)).
! [X] : (Sloth(X) => Lazy(X)).
? [X] : (Animal(X) & Sloth(X)).
-Energetic(sid) & -Sloth(sid)).

[CONCLUSION]:
Sid is an animal.

[CONCLUSION (FOL)]:
Animal(sid)

[CONCLUSION (GK)]:
Animal(sid).


===

['x']
['x']
[PREMISE]:
Anything lazy is unproductive.
No one unproductive is energetic.
If something is a sloth, then it is lazy.
Some animals are sloths.
Sid is neither an energetic person nor a sloth.

[PREMISE (FOL)]:
∀x (Lazy(x) → Unproductive(x))
∀x (Unproductive(x) → ¬Energetic(x))
∀x (Sloth(x) → Lazy(x))
∃x (Animal(x) ∧ Sloth(x))
¬Energetic(sid) ∧ ¬Sloth(sid))

[PREMISE (GK)]:
! [X] : (Lazy(X) => Unproductive(X)).
! [X] : (Unproductive(X) => -Energetic(X)).
! [X] : (Sloth(X) => Lazy(X)).
? [X] : (Animal(X) & Sloth(X)).
-Energetic(sid) & -Sloth(sid)).

[CONCLUSION]:
Sid is an energetic person and an animal.

[CONCLUSION (FOL)]:
Energetic(sid) ∧ Animal(sid)

[CONCLUSION (GK)]:
Energetic(sid) & Animal(sid).


===

['x']
['x']
[PREMISE]:
Anything lazy is unproductive.
No one unproductive is energetic.
If something is a sloth, then it is lazy.
Some animals are sloths.
Sid is neither an energetic person nor a sloth.

[PREMISE (FOL)]:
∀x (Lazy(x) → Unproductive(x))
∀x (Unproductive(x) → ¬Energetic(x))
∀x (Sloth(x) → Lazy(x))
∃x (Animal(x) ∧ Sloth(x))
¬Energetic(sid) ∧ ¬Sloth(sid))

[PREMISE (GK)]:
! [X] : (Lazy(X) => Unproductive(X)).
! [X] : (Unproductive(X) => -Energetic(X)).
! [X] : (Sloth(X) => Lazy(X)).
? [X] : (Animal(X) & Sloth(X)).
-Energetic(sid) & -Sloth(sid)).

[CONCLUSION]:
If Sid is either an animal or unproductive, then Sid is not an energetic person.

[CONCLUSION (FOL)]:
Animal(sid) ⊕ Unproductive(sid)) → ¬Energetic(sid)

[CONCLUSION (GK)]:
Animal(sid) <~> Unproductive(sid)) => -Energetic(sid).


===

['x', 'y']
['x', 'y']
[PREMISE]:
European soccer clubs can attend UCL, UEL, and UECL.
A soccer club eligible to attend UCL has a higher ranking than a soccer club eligible to attend UEL.
A soccer club eligible to attend UEL has a higher ranking than a soccer club eligible to attend UECL.
Manchester United and Machester City are both European soccer clubs.
Manchester United is eligible to attend UEL next season.
Manchester City is eligible to attend UCL next season.

[PREMISE (FOL)]:
∀x (EuropeanSoccerClub(x) → Attend(x, ucl) ∨ Attend(x, uel) ∨ Attend(x, uecl))
∀x ∀y (EuropeanSoccerClub(x) ∧ EuropeanSoccerClub(y) ∧ Attend(x, ucl) ∧ Attend(y, uel) → HigherRank(x, y))
∀x ∀y (EuropeanSoccerClub(x) ∧ EuropeanSoccerClub(y) ∧ Attend(x, uel) ∧ Attend(y, uecl) → HigherRank(x, y))
EuropeanSoccerClub(manchesterUnited) ∧ EuropeanSoccerClub(manchesterCity)
Attend(manchesterunited, uel)
Attend(manchestercity, ucl)

[PREMISE (GK)]:
! [X] : (EuropeanSoccerClub(X) => Attend(X, ucl) | Attend(X, uel) | Attend(X, uecl)).
! [X] : ! [Y] : (EuropeanSoccerClub(X) & EuropeanSoccerClub(Y) & Attend(X, ucl) & Attend(Y, uel) => HigherRank(X, Y)).
! [X] : ! [Y] : (EuropeanSoccerClub(X) & EuropeanSoccerClub(Y) & Attend(X, uel) & Attend(Y, uecl) => HigherRank(X, Y)).
EuropeanSoccerClub(manchesterUnited) & EuropeanSoccerClub(manchesterCity).
Attend(manchesterunited, uel).
Attend(manchestercity, ucl).

[CONCLUSION]:
Manchester City has a higher ranking than Manchester United.

[CONCLUSION (FOL)]:
HigherRank(manchesterCity, manchesterUnited)

[CONCLUSION (GK)]:
HigherRank(manchesterCity, manchesterUnited).


===

['w', 'x', 'y', 'z']
['w', 'x', 'y', 'z']
[PREMISE]:
If a person coaches a football club, the person is a football coach.
If a person has a position in a club in a year, and the club is in NFL in the same year, the person plays in NFL.
Minnesota Vikings is a football club.
Dennis Green coached Minnesota Vikings.
Cris Carter had 13 touchdown receptions.
Minnesota Vikings were in the National Football League in 1997.
John Randle was Minnesota Vikings defensive tackle in 1997.

[PREMISE (FOL)]:
∀x ∀y ((Coach(x, y) ∧ FootballClub(y)) → FootballCoach(x))
∀w ∀x ∀y ∀z ((PlayPositionFor(x, w, y, z) ∧ InNFL(y, z)) → PlayInNFL(x))
FootballClub(minnesotaVikings)
Coach(dennisGreen, minnesotaVikings)
ReceiveTD(crisCarter, num13)
InNFL(minnesotaVikings, yr1997)
PlayPositionFor(johnRandle, defensiveTackle, minnesotaVikings, yr1997)

[PREMISE (GK)]:
! [X] : ! [Y] : ((Coach(X, Y) & FootballClub(Y)) => FootballCoach(X)).
! [W] : ! [X] : ! [Y] : ! [Z] : ((PlayPositionFor(X, W, Y, Z) & InNFL(Y, Z)) => PlayInNFL(X)).
FootballClub(minnesotaVikings).
Coach(dennisGreen, minnesotaVikings).
ReceiveTD(crisCarter, num13).
InNFL(minnesotaVikings, yr1997).
PlayPositionFor(johnRandle, defensiveTackle, minnesotaVikings, yr1997).

[CONCLUSION]:
Dennis Green is a football coach.

[CONCLUSION (FOL)]:
FootballCoach(dennisGreen)

[CONCLUSION (GK)]:
FootballCoach(dennisGreen).


===

['w', 'x', 'y', 'z']
['w', 'x', 'y', 'z']
[PREMISE]:
If a person coaches a football club, the person is a football coach.
If a person has a position in a club in a year, and the club is in NFL in the same year, the person plays in NFL.
Minnesota Vikings is a football club.
Dennis Green coached Minnesota Vikings.
Cris Carter had 13 touchdown receptions.
Minnesota Vikings were in the National Football League in 1997.
John Randle was Minnesota Vikings defensive tackle in 1997.

[PREMISE (FOL)]:
∀x ∀y ((Coach(x, y) ∧ FootballClub(y)) → FootballCoach(x))
∀w ∀x ∀y ∀z ((PlayPositionFor(x, w, y, z) ∧ InNFL(y, z)) → PlayInNFL(x))
FootballClub(minnesotaVikings)
Coach(dennisGreen, minnesotaVikings)
ReceiveTD(crisCarter, num13)
InNFL(minnesotaVikings, yr1997)
PlayPositionFor(johnRandle, defensiveTackle, minnesotaVikings, yr1997)

[PREMISE (GK)]:
! [X] : ! [Y] : ((Coach(X, Y) & FootballClub(Y)) => FootballCoach(X)).
! [W] : ! [X] : ! [Y] : ! [Z] : ((PlayPositionFor(X, W, Y, Z) & InNFL(Y, Z)) => PlayInNFL(X)).
FootballClub(minnesotaVikings).
Coach(dennisGreen, minnesotaVikings).
ReceiveTD(crisCarter, num13).
InNFL(minnesotaVikings, yr1997).
PlayPositionFor(johnRandle, defensiveTackle, minnesotaVikings, yr1997).

[CONCLUSION]:
John Randle didn't play in the National Football League.

[CONCLUSION (FOL)]:
¬PlayInNFL(johnRandle)

[CONCLUSION (GK)]:
-PlayInNFL(johnRandle).


===

['w', 'x', 'y', 'z']
['w', 'x', 'y', 'z']
[PREMISE]:
If a person coaches a football club, the person is a football coach.
If a person has a position in a club in a year, and the club is in NFL in the same year, the person plays in NFL.
Minnesota Vikings is a football club.
Dennis Green coached Minnesota Vikings.
Cris Carter had 13 touchdown receptions.
Minnesota Vikings were in the National Football League in 1997.
John Randle was Minnesota Vikings defensive tackle in 1997.

[PREMISE (FOL)]:
∀x ∀y ((Coach(x, y) ∧ FootballClub(y)) → FootballCoach(x))
∀w ∀x ∀y ∀z ((PlayPositionFor(x, w, y, z) ∧ InNFL(y, z)) → PlayInNFL(x))
FootballClub(minnesotaVikings)
Coach(dennisGreen, minnesotaVikings)
ReceiveTD(crisCarter, num13)
InNFL(minnesotaVikings, yr1997)
PlayPositionFor(johnRandle, defensiveTackle, minnesotaVikings, yr1997)

[PREMISE (GK)]:
! [X] : ! [Y] : ((Coach(X, Y) & FootballClub(Y)) => FootballCoach(X)).
! [W] : ! [X] : ! [Y] : ! [Z] : ((PlayPositionFor(X, W, Y, Z) & InNFL(Y, Z)) => PlayInNFL(X)).
FootballClub(minnesotaVikings).
Coach(dennisGreen, minnesotaVikings).
ReceiveTD(crisCarter, num13).
InNFL(minnesotaVikings, yr1997).
PlayPositionFor(johnRandle, defensiveTackle, minnesotaVikings, yr1997).

[CONCLUSION]:
Cris Carter played for Minnesota Vikings.

[CONCLUSION (FOL)]:
PlayPositionFor(crisCarter, wr, minnesotaVikings, year1997)

[CONCLUSION (GK)]:
PlayPositionFor(crisCarter, wr, minnesotaVikings, year1997).


===

['x']
['x']
[PREMISE]:
All classrooms in William L. Harkness Hall that are used for lectures are booked during the day. 
None of the classrooms in William L. Harkness Hall are private study spots.
All classrooms in William L. Harkness Hall are used for lectures or used for office hours.
If a classroom in William L. Harkness Hall is booked in the evening, then it is not freely usable at night.
If a classroom in William L. Harkness Hall is used for office hours, then it is booked in the evening.
Room 116 is a classroom in William L. Harkness Hall that is either both used for lecture and used for office hours or not used for either.

[PREMISE (FOL)]:
∀x (ClassroomIn(x, williamLHarknessHall) ∧ UsedFor(x, lecture) → BookedDuring(x, day))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ ¬PrivateStudySpot(x))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ (UsedFor(x, lecture) ∨ UsedFor(x, officeHours)))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ BookedIn(x, evening) → ¬FreelyUsableAtNight(x))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ UsedFor(x, officeHours) → BookedIn(x, evening))
ClassroomIn(116, williamLHarknessHall) ∧ ¬(UsedFor(116, lecture) ⊕ UsedFor(116, officeHours))

[PREMISE (GK)]:
! [X] : (ClassroomIn(X, williamLHarknessHall) & UsedFor(X, lecture) => BookedDuring(X, day)).
! [X] : (ClassroomIn(X, williamLHarknessHall) & -PrivateStudySpot(X)).
! [X] : (ClassroomIn(X, williamLHarknessHall) & (UsedFor(X, lecture) | UsedFor(X, officeHours))).
! [X] : (ClassroomIn(X, williamLHarknessHall) & BookedIn(X, evening) => -FreelyUsableAtNight(X)).
! [X] : (ClassroomIn(X, williamLHarknessHall) & UsedFor(X, officeHours) => BookedIn(X, evening)).
ClassroomIn(116, williamLHarknessHall) & -(UsedFor(116, lecture) <~> UsedFor(116, officeHours)).

[CONCLUSION]:
Room 116 is a private study spot.

[CONCLUSION (FOL)]:
PrivateStudySpot(room116)

[CONCLUSION (GK)]:
PrivateStudySpot(room116).


===

['x']
['x']
[PREMISE]:
All classrooms in William L. Harkness Hall that are used for lectures are booked during the day. 
None of the classrooms in William L. Harkness Hall are private study spots.
All classrooms in William L. Harkness Hall are used for lectures or used for office hours.
If a classroom in William L. Harkness Hall is booked in the evening, then it is not freely usable at night.
If a classroom in William L. Harkness Hall is used for office hours, then it is booked in the evening.
Room 116 is a classroom in William L. Harkness Hall that is either both used for lecture and used for office hours or not used for either.

[PREMISE (FOL)]:
∀x (ClassroomIn(x, williamLHarknessHall) ∧ UsedFor(x, lecture) → BookedDuring(x, day))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ ¬PrivateStudySpot(x))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ (UsedFor(x, lecture) ∨ UsedFor(x, officeHours)))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ BookedIn(x, evening) → ¬FreelyUsableAtNight(x))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ UsedFor(x, officeHours) → BookedIn(x, evening))
ClassroomIn(116, williamLHarknessHall) ∧ ¬(UsedFor(116, lecture) ⊕ UsedFor(116, officeHours))

[PREMISE (GK)]:
! [X] : (ClassroomIn(X, williamLHarknessHall) & UsedFor(X, lecture) => BookedDuring(X, day)).
! [X] : (ClassroomIn(X, williamLHarknessHall) & -PrivateStudySpot(X)).
! [X] : (ClassroomIn(X, williamLHarknessHall) & (UsedFor(X, lecture) | UsedFor(X, officeHours))).
! [X] : (ClassroomIn(X, williamLHarknessHall) & BookedIn(X, evening) => -FreelyUsableAtNight(X)).
! [X] : (ClassroomIn(X, williamLHarknessHall) & UsedFor(X, officeHours) => BookedIn(X, evening)).
ClassroomIn(116, williamLHarknessHall) & -(UsedFor(116, lecture) <~> UsedFor(116, officeHours)).

[CONCLUSION]:
If Room 116 is either both booked during the day and freely usable at night, or neither, then it is either used for office hours or for private study spots.

[CONCLUSION (FOL)]:
¬(BookedDuring(room116, day) ⊕ FreelyUsableAtNight(room116) → (UsedFor(room116, officeHour) ⊕ PrivateStudySpot(room116))

[CONCLUSION (GK)]:
-(BookedDuring(room116, day) <~> FreelyUsableAtNight(room116) => (UsedFor(room116, officeHour) <~> PrivateStudySpot(room116)).


===

['x']
['x']
[PREMISE]:
All classrooms in William L. Harkness Hall that are used for lectures are booked during the day. 
None of the classrooms in William L. Harkness Hall are private study spots.
All classrooms in William L. Harkness Hall are used for lectures or used for office hours.
If a classroom in William L. Harkness Hall is booked in the evening, then it is not freely usable at night.
If a classroom in William L. Harkness Hall is used for office hours, then it is booked in the evening.
Room 116 is a classroom in William L. Harkness Hall that is either both used for lecture and used for office hours or not used for either.

[PREMISE (FOL)]:
∀x (ClassroomIn(x, williamLHarknessHall) ∧ UsedFor(x, lecture) → BookedDuring(x, day))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ ¬PrivateStudySpot(x))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ (UsedFor(x, lecture) ∨ UsedFor(x, officeHours)))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ BookedIn(x, evening) → ¬FreelyUsableAtNight(x))
∀x (ClassroomIn(x, williamLHarknessHall) ∧ UsedFor(x, officeHours) → BookedIn(x, evening))
ClassroomIn(116, williamLHarknessHall) ∧ ¬(UsedFor(116, lecture) ⊕ UsedFor(116, officeHours))

[PREMISE (GK)]:
! [X] : (ClassroomIn(X, williamLHarknessHall) & UsedFor(X, lecture) => BookedDuring(X, day)).
! [X] : (ClassroomIn(X, williamLHarknessHall) & -PrivateStudySpot(X)).
! [X] : (ClassroomIn(X, williamLHarknessHall) & (UsedFor(X, lecture) | UsedFor(X, officeHours))).
! [X] : (ClassroomIn(X, williamLHarknessHall) & BookedIn(X, evening) => -FreelyUsableAtNight(X)).
! [X] : (ClassroomIn(X, williamLHarknessHall) & UsedFor(X, officeHours) => BookedIn(X, evening)).
ClassroomIn(116, williamLHarknessHall) & -(UsedFor(116, lecture) <~> UsedFor(116, officeHours)).

[CONCLUSION]:
If Room 116 is not both a private study spot and freely useable at night, then it is either used for lectures or booked during the day.

[CONCLUSION (FOL)]:
¬(PrivateStudySpot(room116) ∧ FreelyUsableAtNight(room116)) → (UsedFor(room116, lecture) ∨ BookedIn(room116, evening))

[CONCLUSION (GK)]:
-(PrivateStudySpot(room116) & FreelyUsableAtNight(room116)) => (UsedFor(room116, lecture) | BookedIn(room116, evening)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.
Baku is northwest of Shafaq-Asiman.
If place A is northwest of place B, then place B is southeast of place A.

[PREMISE (FOL)]:
LargeComplex(shafaq-asiman) ∧ LargeComplex(shafaq-asiman) ∧ Offshore(shafaq-asiman) ∧ GeologicalStructures(shafaq-asiman) ∧ In(shafaq-asiman, caspiansea)
NorthwestOf(baku, shafaq-asiman)
∀x ∀y (NorthwestOf(x, y) → SoutheastOf(y, x))

[PREMISE (GK)]:
LargeComplex(shafaq-asiman) & LargeComplex(shafaq-asiman) & Offshore(shafaq-asiman) & GeologicalStructures(shafaq-asiman) & In(shafaq-asiman, caspiansea).
NorthwestOf(baku, shafaq-asiman).
! [X] : ! [Y] : (NorthwestOf(X, Y) => SoutheastOf(Y, X)).

[CONCLUSION]:
Baku is southeast of Shafaq-Asiman.

[CONCLUSION (FOL)]:
SoutheastOf(baku, shafaq-asiman)

[CONCLUSION (GK)]:
SoutheastOf(baku, shafaq-asiman).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.
Baku is northwest of Shafaq-Asiman.
If place A is northwest of place B, then place B is southeast of place A.

[PREMISE (FOL)]:
LargeComplex(shafaq-asiman) ∧ LargeComplex(shafaq-asiman) ∧ Offshore(shafaq-asiman) ∧ GeologicalStructures(shafaq-asiman) ∧ In(shafaq-asiman, caspiansea)
NorthwestOf(baku, shafaq-asiman)
∀x ∀y (NorthwestOf(x, y) → SoutheastOf(y, x))

[PREMISE (GK)]:
LargeComplex(shafaq-asiman) & LargeComplex(shafaq-asiman) & Offshore(shafaq-asiman) & GeologicalStructures(shafaq-asiman) & In(shafaq-asiman, caspiansea).
NorthwestOf(baku, shafaq-asiman).
! [X] : ! [Y] : (NorthwestOf(X, Y) => SoutheastOf(Y, X)).

[CONCLUSION]:
A large complex is southeast of Baku.

[CONCLUSION (FOL)]:
∃x (LargeComplex(x) ∧ SoutheastOf(x, baku))

[CONCLUSION (GK)]:
? [X] : (LargeComplex(X) & SoutheastOf(X, baku)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.
Baku is northwest of Shafaq-Asiman.
If place A is northwest of place B, then place B is southeast of place A.

[PREMISE (FOL)]:
LargeComplex(shafaq-asiman) ∧ LargeComplex(shafaq-asiman) ∧ Offshore(shafaq-asiman) ∧ GeologicalStructures(shafaq-asiman) ∧ In(shafaq-asiman, caspiansea)
NorthwestOf(baku, shafaq-asiman)
∀x ∀y (NorthwestOf(x, y) → SoutheastOf(y, x))

[PREMISE (GK)]:
LargeComplex(shafaq-asiman) & LargeComplex(shafaq-asiman) & Offshore(shafaq-asiman) & GeologicalStructures(shafaq-asiman) & In(shafaq-asiman, caspiansea).
NorthwestOf(baku, shafaq-asiman).
! [X] : ! [Y] : (NorthwestOf(X, Y) => SoutheastOf(Y, X)).

[CONCLUSION]:
Baku is not northwest of offshore geological structures.

[CONCLUSION (FOL)]:
∀x (GeologicalStructures(x) ∧ Offshore(x) → ¬NorthwestOf(baku, x))

[CONCLUSION (GK)]:
! [X] : (GeologicalStructures(X) & Offshore(X) => -NorthwestOf(baku, X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Herodicus was a Greek physician, dietician, sophist, and gymnast.
Herodicus was born in the city of Selymbria.
Selymbria is a colony of the city-state Megara.
One of the tutors of Hippocrates was Herodicus.
Massages were recommended by Herodicus.
Some of the theories of Herodicus are considered to be the foundation of sports medicine.

[PREMISE (FOL)]:
Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ Gymnast(herodicus)
Born(herodicus, selymbia) ∧ City(selymbia)
Colony(selymbia, megara) ∧ CityState(megara)
Tutor(herodicus, hippocrates)
Recommend(herodicus, massages)
∃x ∃y (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine) ∧ (¬(x=y)) ∧ Theory(y) ∧ From(y, herodicus) ∧ FoundationOf(y, sportsMedicine))

[PREMISE (GK)]:
Greek(herodicus) & Physician(herodicus) & Dietician(herodicus) & Sophist(herodicus) & Gymnast(herodicus).
Born(herodicus, selymbia) & City(selymbia).
Colony(selymbia, megara) & CityState(megara).
Tutor(herodicus, hippocrates).
Recommend(herodicus, massages).
? [X] : ? [Y] : (Theory(X) & From(X, herodicus) & FoundationOf(X, sportsMedicine) & (-(X=Y)) & Theory(Y) & From(Y, herodicus) & FoundationOf(Y, sportsMedicine)).

[CONCLUSION]:
Herodicus tutored Hippocrates.

[CONCLUSION (FOL)]:
Tutor(herodicus, hippocrates)

[CONCLUSION (GK)]:
Tutor(herodicus, hippocrates).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Herodicus was a Greek physician, dietician, sophist, and gymnast.
Herodicus was born in the city of Selymbria.
Selymbria is a colony of the city-state Megara.
One of the tutors of Hippocrates was Herodicus.
Massages were recommended by Herodicus.
Some of the theories of Herodicus are considered to be the foundation of sports medicine.

[PREMISE (FOL)]:
Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ Gymnast(herodicus)
Born(herodicus, selymbia) ∧ City(selymbia)
Colony(selymbia, megara) ∧ CityState(megara)
Tutor(herodicus, hippocrates)
Recommend(herodicus, massages)
∃x ∃y (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine) ∧ (¬(x=y)) ∧ Theory(y) ∧ From(y, herodicus) ∧ FoundationOf(y, sportsMedicine))

[PREMISE (GK)]:
Greek(herodicus) & Physician(herodicus) & Dietician(herodicus) & Sophist(herodicus) & Gymnast(herodicus).
Born(herodicus, selymbia) & City(selymbia).
Colony(selymbia, megara) & CityState(megara).
Tutor(herodicus, hippocrates).
Recommend(herodicus, massages).
? [X] : ? [Y] : (Theory(X) & From(X, herodicus) & FoundationOf(X, sportsMedicine) & (-(X=Y)) & Theory(Y) & From(Y, herodicus) & FoundationOf(Y, sportsMedicine)).

[CONCLUSION]:
Herodicus was tutored by Hippocrates.

[CONCLUSION (FOL)]:
Tutor(hippocrates, herodicus)

[CONCLUSION (GK)]:
Tutor(hippocrates, herodicus).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Herodicus was a Greek physician, dietician, sophist, and gymnast.
Herodicus was born in the city of Selymbria.
Selymbria is a colony of the city-state Megara.
One of the tutors of Hippocrates was Herodicus.
Massages were recommended by Herodicus.
Some of the theories of Herodicus are considered to be the foundation of sports medicine.

[PREMISE (FOL)]:
Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ Gymnast(herodicus)
Born(herodicus, selymbia) ∧ City(selymbia)
Colony(selymbia, megara) ∧ CityState(megara)
Tutor(herodicus, hippocrates)
Recommend(herodicus, massages)
∃x ∃y (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine) ∧ (¬(x=y)) ∧ Theory(y) ∧ From(y, herodicus) ∧ FoundationOf(y, sportsMedicine))

[PREMISE (GK)]:
Greek(herodicus) & Physician(herodicus) & Dietician(herodicus) & Sophist(herodicus) & Gymnast(herodicus).
Born(herodicus, selymbia) & City(selymbia).
Colony(selymbia, megara) & CityState(megara).
Tutor(herodicus, hippocrates).
Recommend(herodicus, massages).
? [X] : ? [Y] : (Theory(X) & From(X, herodicus) & FoundationOf(X, sportsMedicine) & (-(X=Y)) & Theory(Y) & From(Y, herodicus) & FoundationOf(Y, sportsMedicine)).

[CONCLUSION]:
Herodicus was born in a city-state.

[CONCLUSION (FOL)]:
∃x (Born(herodicus, x) ∧ CityState(x))

[CONCLUSION (GK)]:
? [X] : (Born(herodicus, X) & CityState(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Herodicus was a Greek physician, dietician, sophist, and gymnast.
Herodicus was born in the city of Selymbria.
Selymbria is a colony of the city-state Megara.
One of the tutors of Hippocrates was Herodicus.
Massages were recommended by Herodicus.
Some of the theories of Herodicus are considered to be the foundation of sports medicine.

[PREMISE (FOL)]:
Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ Gymnast(herodicus)
Born(herodicus, selymbia) ∧ City(selymbia)
Colony(selymbia, megara) ∧ CityState(megara)
Tutor(herodicus, hippocrates)
Recommend(herodicus, massages)
∃x ∃y (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine) ∧ (¬(x=y)) ∧ Theory(y) ∧ From(y, herodicus) ∧ FoundationOf(y, sportsMedicine))

[PREMISE (GK)]:
Greek(herodicus) & Physician(herodicus) & Dietician(herodicus) & Sophist(herodicus) & Gymnast(herodicus).
Born(herodicus, selymbia) & City(selymbia).
Colony(selymbia, megara) & CityState(megara).
Tutor(herodicus, hippocrates).
Recommend(herodicus, massages).
? [X] : ? [Y] : (Theory(X) & From(X, herodicus) & FoundationOf(X, sportsMedicine) & (-(X=Y)) & Theory(Y) & From(Y, herodicus) & FoundationOf(Y, sportsMedicine)).

[CONCLUSION]:
Herodicus did not recommend massages.

[CONCLUSION (FOL)]:
¬Recommend(herodicus, massages)

[CONCLUSION (GK)]:
-Recommend(herodicus, massages).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Herodicus was a Greek physician, dietician, sophist, and gymnast.
Herodicus was born in the city of Selymbria.
Selymbria is a colony of the city-state Megara.
One of the tutors of Hippocrates was Herodicus.
Massages were recommended by Herodicus.
Some of the theories of Herodicus are considered to be the foundation of sports medicine.

[PREMISE (FOL)]:
Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ Gymnast(herodicus)
Born(herodicus, selymbia) ∧ City(selymbia)
Colony(selymbia, megara) ∧ CityState(megara)
Tutor(herodicus, hippocrates)
Recommend(herodicus, massages)
∃x ∃y (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine) ∧ (¬(x=y)) ∧ Theory(y) ∧ From(y, herodicus) ∧ FoundationOf(y, sportsMedicine))

[PREMISE (GK)]:
Greek(herodicus) & Physician(herodicus) & Dietician(herodicus) & Sophist(herodicus) & Gymnast(herodicus).
Born(herodicus, selymbia) & City(selymbia).
Colony(selymbia, megara) & CityState(megara).
Tutor(herodicus, hippocrates).
Recommend(herodicus, massages).
? [X] : ? [Y] : (Theory(X) & From(X, herodicus) & FoundationOf(X, sportsMedicine) & (-(X=Y)) & Theory(Y) & From(Y, herodicus) & FoundationOf(Y, sportsMedicine)).

[CONCLUSION]:
Herodicus was born in a colony of a city-state.

[CONCLUSION (FOL)]:
∃x ∃y (Born(herodicus, x) ∧ Colony(x, y) ∧ CityState(y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Born(herodicus, X) & Colony(X, Y) & CityState(Y)).


===

['x']
['x']
[PREMISE]:
None of the kids in our family love the opera.
All of the adults in our family love the opera.
If someone in our family is a scientist, then they are an adult.
Some students in our family are kids.
Billy is a kid in our family.

[PREMISE (FOL)]:
∀x ((Kid(x) ∧ In(x, ourFamily)) → ¬Love(x, opera))
∀x ((Adult(x) ∧ In(x, ourFamily)) → Love(x, opera))
∀x ((Scientist(x) ∧ In(x, ourFamily)) → Adult(x))
∃x (Student(x) ∧ In(x, ourFamily) ∧ Kid(x))
Kid(billy) ∧ In(billy, ourFamily) 

[PREMISE (GK)]:
! [X] : ((Kid(X) & In(X, ourFamily)) => -Love(X, opera)).
! [X] : ((Adult(X) & In(X, ourFamily)) => Love(X, opera)).
! [X] : ((Scientist(X) & In(X, ourFamily)) => Adult(X)).
? [X] : (Student(X) & In(X, ourFamily) & Kid(X)).
Kid(billy) & In(billy, ourFamily) .

[CONCLUSION]:
Billy is a student.

[CONCLUSION (FOL)]:
Student(billy)

[CONCLUSION (GK)]:
Student(billy).


===

['x']
['x']
[PREMISE]:
None of the kids in our family love the opera.
All of the adults in our family love the opera.
If someone in our family is a scientist, then they are an adult.
Some students in our family are kids.
Billy is a kid in our family.

[PREMISE (FOL)]:
∀x ((Kid(x) ∧ In(x, ourFamily)) → ¬Love(x, opera))
∀x ((Adult(x) ∧ In(x, ourFamily)) → Love(x, opera))
∀x ((Scientist(x) ∧ In(x, ourFamily)) → Adult(x))
∃x (Student(x) ∧ In(x, ourFamily) ∧ Kid(x))
Kid(billy) ∧ In(billy, ourFamily) 

[PREMISE (GK)]:
! [X] : ((Kid(X) & In(X, ourFamily)) => -Love(X, opera)).
! [X] : ((Adult(X) & In(X, ourFamily)) => Love(X, opera)).
! [X] : ((Scientist(X) & In(X, ourFamily)) => Adult(X)).
? [X] : (Student(X) & In(X, ourFamily) & Kid(X)).
Kid(billy) & In(billy, ourFamily) .

[CONCLUSION]:
Billy is a student and a scientist.

[CONCLUSION (FOL)]:
Student(billy)  ∧ Scientist(billy)

[CONCLUSION (GK)]:
Student(billy)  & Scientist(billy).


===

['x']
['x']
[PREMISE]:
None of the kids in our family love the opera.
All of the adults in our family love the opera.
If someone in our family is a scientist, then they are an adult.
Some students in our family are kids.
Billy is a kid in our family.

[PREMISE (FOL)]:
∀x ((Kid(x) ∧ In(x, ourFamily)) → ¬Love(x, opera))
∀x ((Adult(x) ∧ In(x, ourFamily)) → Love(x, opera))
∀x ((Scientist(x) ∧ In(x, ourFamily)) → Adult(x))
∃x (Student(x) ∧ In(x, ourFamily) ∧ Kid(x))
Kid(billy) ∧ In(billy, ourFamily) 

[PREMISE (GK)]:
! [X] : ((Kid(X) & In(X, ourFamily)) => -Love(X, opera)).
! [X] : ((Adult(X) & In(X, ourFamily)) => Love(X, opera)).
! [X] : ((Scientist(X) & In(X, ourFamily)) => Adult(X)).
? [X] : (Student(X) & In(X, ourFamily) & Kid(X)).
Kid(billy) & In(billy, ourFamily) .

[CONCLUSION]:
If Billy is a student or a scientist, then Billy is a student and a kid.

[CONCLUSION (FOL)]:
(Student(billy) ∨ Scientist(billy)) → (Student(billy) ∧ Kid(billy))

[CONCLUSION (GK)]:
(Student(billy) | Scientist(billy)) => (Student(billy) & Kid(billy)).


===

['x']
['x', 'y']
[PREMISE]:
Brian Winter is a Scottish football referee.
After being injured, Brian Winter retired in 2012.
Brian Winter was appointed as a referee observer after his retirement.
Some football referees become referee observers.
The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.

[PREMISE (FOL)]:
Scottish(brianWinter) ∧ FootballReferee(brianWinter)
Retired(brianWinter) ∧ RetiredIn(brianWinter, yr2012)
RefereeObserver(brianWinter)
∃x (FootballReferee(x) ∧ RefereeObserver(x))
SonOf(andyWinter, brianWinter) ∧ FootballPlayer(andyWinter) ∧ PlaysFor(andyWinter, hamiltonAcademical)

[PREMISE (GK)]:
Scottish(brianWinter) & FootballReferee(brianWinter).
Retired(brianWinter) & RetiredIn(brianWinter, yr2012).
RefereeObserver(brianWinter).
? [X] : (FootballReferee(X) & RefereeObserver(X)).
SonOf(andyWinter, brianWinter) & FootballPlayer(andyWinter) & PlaysFor(andyWinter, hamiltonAcademical).

[CONCLUSION]:
There is a son of a referee observer that plays football.

[CONCLUSION (FOL)]:
∃x ∃y(SonOf(x, y) ∧ RefereeObserver(y) ∧ FootballPlayer(x))

[CONCLUSION (GK)]:
? [X] : ? [Y] :(SonOf(X, Y) & RefereeObserver(Y) & FootballPlayer(X)).


===

['x']
['x']
[PREMISE]:
Brian Winter is a Scottish football referee.
After being injured, Brian Winter retired in 2012.
Brian Winter was appointed as a referee observer after his retirement.
Some football referees become referee observers.
The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.

[PREMISE (FOL)]:
Scottish(brianWinter) ∧ FootballReferee(brianWinter)
Retired(brianWinter) ∧ RetiredIn(brianWinter, yr2012)
RefereeObserver(brianWinter)
∃x (FootballReferee(x) ∧ RefereeObserver(x))
SonOf(andyWinter, brianWinter) ∧ FootballPlayer(andyWinter) ∧ PlaysFor(andyWinter, hamiltonAcademical)

[PREMISE (GK)]:
Scottish(brianWinter) & FootballReferee(brianWinter).
Retired(brianWinter) & RetiredIn(brianWinter, yr2012).
RefereeObserver(brianWinter).
? [X] : (FootballReferee(X) & RefereeObserver(X)).
SonOf(andyWinter, brianWinter) & FootballPlayer(andyWinter) & PlaysFor(andyWinter, hamiltonAcademical).

[CONCLUSION]:
Brian Winter was not a referee observer.

[CONCLUSION (FOL)]:
¬RefereeObserver(brianwinter)

[CONCLUSION (GK)]:
-RefereeObserver(brianwinter).


===

['x']
['x']
[PREMISE]:
Brian Winter is a Scottish football referee.
After being injured, Brian Winter retired in 2012.
Brian Winter was appointed as a referee observer after his retirement.
Some football referees become referee observers.
The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.

[PREMISE (FOL)]:
Scottish(brianWinter) ∧ FootballReferee(brianWinter)
Retired(brianWinter) ∧ RetiredIn(brianWinter, yr2012)
RefereeObserver(brianWinter)
∃x (FootballReferee(x) ∧ RefereeObserver(x))
SonOf(andyWinter, brianWinter) ∧ FootballPlayer(andyWinter) ∧ PlaysFor(andyWinter, hamiltonAcademical)

[PREMISE (GK)]:
Scottish(brianWinter) & FootballReferee(brianWinter).
Retired(brianWinter) & RetiredIn(brianWinter, yr2012).
RefereeObserver(brianWinter).
? [X] : (FootballReferee(X) & RefereeObserver(X)).
SonOf(andyWinter, brianWinter) & FootballPlayer(andyWinter) & PlaysFor(andyWinter, hamiltonAcademical).

[CONCLUSION]:
Brian Winter is retired.

[CONCLUSION (FOL)]:
Retired(brianwinter)

[CONCLUSION (GK)]:
Retired(brianwinter).


===

['x']
['x']
[PREMISE]:
Brian Winter is a Scottish football referee.
After being injured, Brian Winter retired in 2012.
Brian Winter was appointed as a referee observer after his retirement.
Some football referees become referee observers.
The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.

[PREMISE (FOL)]:
Scottish(brianWinter) ∧ FootballReferee(brianWinter)
Retired(brianWinter) ∧ RetiredIn(brianWinter, yr2012)
RefereeObserver(brianWinter)
∃x (FootballReferee(x) ∧ RefereeObserver(x))
SonOf(andyWinter, brianWinter) ∧ FootballPlayer(andyWinter) ∧ PlaysFor(andyWinter, hamiltonAcademical)

[PREMISE (GK)]:
Scottish(brianWinter) & FootballReferee(brianWinter).
Retired(brianWinter) & RetiredIn(brianWinter, yr2012).
RefereeObserver(brianWinter).
? [X] : (FootballReferee(X) & RefereeObserver(X)).
SonOf(andyWinter, brianWinter) & FootballPlayer(andyWinter) & PlaysFor(andyWinter, hamiltonAcademical).

[CONCLUSION]:
Andy Winter is a referee.

[CONCLUSION (FOL)]:
Referee(andywinter)

[CONCLUSION (GK)]:
Referee(andywinter).


===

['x']
['x']
[PREMISE]:
Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.
If a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.
There is a person at 'Board Game night' who is either a planner or a creative person.
Erica is at 'Board Game night,' and she is someone who plays a lot of chess.
If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.

[PREMISE (FOL)]:
∀x (At(x, boardGameNight) → (InterestedIn(x, puzzle) ∨ BadAt(x, chess)))
∀x ((At(x, boardGameNight) ∧ BadAt(x, chess)) → ¬PlaysOften(x, chess))
∃x (At(x, boardGameNight) ∧ (Planner(x) ∨ Creative(x)))
At(erica, boardGameNight) ∧ PlaysOften(erica, chess)
(At(erica, boardGameNight) ∧ (¬(BadAt(erica, chess) ∨ Creative(erica)))) → ¬(Planner(erica) ⊕  Creative(erica))

[PREMISE (GK)]:
! [X] : (At(X, boardGameNight) => (InterestedIn(X, puzzle) | BadAt(X, chess))).
! [X] : ((At(X, boardGameNight) & BadAt(X, chess)) => -PlaysOften(X, chess)).
? [X] : (At(X, boardGameNight) & (Planner(X) | Creative(X))).
At(erica, boardGameNight) & PlaysOften(erica, chess).
(At(erica, boardGameNight) & (-(BadAt(erica, chess) | Creative(erica)))) => -(Planner(erica) <~>  Creative(erica)).

[CONCLUSION]:
Erica plans.

[CONCLUSION (FOL)]:
Planner(erica)

[CONCLUSION (GK)]:
Planner(erica).


===

['x']
['x']
[PREMISE]:
Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.
If a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.
There is a person at 'Board Game night' who is either a planner or a creative person.
Erica is at 'Board Game night,' and she is someone who plays a lot of chess.
If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.

[PREMISE (FOL)]:
∀x (At(x, boardGameNight) → (InterestedIn(x, puzzle) ∨ BadAt(x, chess)))
∀x ((At(x, boardGameNight) ∧ BadAt(x, chess)) → ¬PlaysOften(x, chess))
∃x (At(x, boardGameNight) ∧ (Planner(x) ∨ Creative(x)))
At(erica, boardGameNight) ∧ PlaysOften(erica, chess)
(At(erica, boardGameNight) ∧ (¬(BadAt(erica, chess) ∨ Creative(erica)))) → ¬(Planner(erica) ⊕  Creative(erica))

[PREMISE (GK)]:
! [X] : (At(X, boardGameNight) => (InterestedIn(X, puzzle) | BadAt(X, chess))).
! [X] : ((At(X, boardGameNight) & BadAt(X, chess)) => -PlaysOften(X, chess)).
? [X] : (At(X, boardGameNight) & (Planner(X) | Creative(X))).
At(erica, boardGameNight) & PlaysOften(erica, chess).
(At(erica, boardGameNight) & (-(BadAt(erica, chess) | Creative(erica)))) => -(Planner(erica) <~>  Creative(erica)).

[CONCLUSION]:
Erica is interested in puzzles and is creative.

[CONCLUSION (FOL)]:
InterestedIn(erica, puzzle) ∧ Creative(erica)

[CONCLUSION (GK)]:
InterestedIn(erica, puzzle) & Creative(erica).


===

['x']
['x']
[PREMISE]:
Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.
If a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.
There is a person at 'Board Game night' who is either a planner or a creative person.
Erica is at 'Board Game night,' and she is someone who plays a lot of chess.
If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.

[PREMISE (FOL)]:
∀x (At(x, boardGameNight) → (InterestedIn(x, puzzle) ∨ BadAt(x, chess)))
∀x ((At(x, boardGameNight) ∧ BadAt(x, chess)) → ¬PlaysOften(x, chess))
∃x (At(x, boardGameNight) ∧ (Planner(x) ∨ Creative(x)))
At(erica, boardGameNight) ∧ PlaysOften(erica, chess)
(At(erica, boardGameNight) ∧ (¬(BadAt(erica, chess) ∨ Creative(erica)))) → ¬(Planner(erica) ⊕  Creative(erica))

[PREMISE (GK)]:
! [X] : (At(X, boardGameNight) => (InterestedIn(X, puzzle) | BadAt(X, chess))).
! [X] : ((At(X, boardGameNight) & BadAt(X, chess)) => -PlaysOften(X, chess)).
? [X] : (At(X, boardGameNight) & (Planner(X) | Creative(X))).
At(erica, boardGameNight) & PlaysOften(erica, chess).
(At(erica, boardGameNight) & (-(BadAt(erica, chess) | Creative(erica)))) => -(Planner(erica) <~>  Creative(erica)).

[CONCLUSION]:
Erica is either interested in puzzles or is creative.

[CONCLUSION (FOL)]:
InterestedIn(erica, puzzle) ⊕ Creative(erica)

[CONCLUSION (GK)]:
InterestedIn(erica, puzzle) <~> Creative(erica).


===

['x']
['x']
[PREMISE]:
Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.
If a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.
There is a person at 'Board Game night' who is either a planner or a creative person.
Erica is at 'Board Game night,' and she is someone who plays a lot of chess.
If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.

[PREMISE (FOL)]:
∀x (At(x, boardGameNight) → (InterestedIn(x, puzzle) ∨ BadAt(x, chess)))
∀x ((At(x, boardGameNight) ∧ BadAt(x, chess)) → ¬PlaysOften(x, chess))
∃x (At(x, boardGameNight) ∧ (Planner(x) ∨ Creative(x)))
At(erica, boardGameNight) ∧ PlaysOften(erica, chess)
(At(erica, boardGameNight) ∧ (¬(BadAt(erica, chess) ∨ Creative(erica)))) → ¬(Planner(erica) ⊕  Creative(erica))

[PREMISE (GK)]:
! [X] : (At(X, boardGameNight) => (InterestedIn(X, puzzle) | BadAt(X, chess))).
! [X] : ((At(X, boardGameNight) & BadAt(X, chess)) => -PlaysOften(X, chess)).
? [X] : (At(X, boardGameNight) & (Planner(X) | Creative(X))).
At(erica, boardGameNight) & PlaysOften(erica, chess).
(At(erica, boardGameNight) & (-(BadAt(erica, chess) | Creative(erica)))) => -(Planner(erica) <~>  Creative(erica)).

[CONCLUSION]:
If Erica plans ahead or plays a lot of chess matches, then Erica is not interested in puzzles and creative.

[CONCLUSION (FOL)]:
Planner(erica) ∨ PlaysOften(erica, chess))) → (¬(InterestedIn(erica, puzzle) ∧ Creative(erica))

[CONCLUSION (GK)]:
Planner(erica) | PlaysOften(erica, chess))) => (-(InterestedIn(erica, puzzle) & Creative(erica)).


===

['x']
['x']
[PREMISE]:
Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.
If a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.
There is a person at 'Board Game night' who is either a planner or a creative person.
Erica is at 'Board Game night,' and she is someone who plays a lot of chess.
If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.

[PREMISE (FOL)]:
∀x (At(x, boardGameNight) → (InterestedIn(x, puzzle) ∨ BadAt(x, chess)))
∀x ((At(x, boardGameNight) ∧ BadAt(x, chess)) → ¬PlaysOften(x, chess))
∃x (At(x, boardGameNight) ∧ (Planner(x) ∨ Creative(x)))
At(erica, boardGameNight) ∧ PlaysOften(erica, chess)
(At(erica, boardGameNight) ∧ (¬(BadAt(erica, chess) ∨ Creative(erica)))) → ¬(Planner(erica) ⊕  Creative(erica))

[PREMISE (GK)]:
! [X] : (At(X, boardGameNight) => (InterestedIn(X, puzzle) | BadAt(X, chess))).
! [X] : ((At(X, boardGameNight) & BadAt(X, chess)) => -PlaysOften(X, chess)).
? [X] : (At(X, boardGameNight) & (Planner(X) | Creative(X))).
At(erica, boardGameNight) & PlaysOften(erica, chess).
(At(erica, boardGameNight) & (-(BadAt(erica, chess) | Creative(erica)))) => -(Planner(erica) <~>  Creative(erica)).

[CONCLUSION]:
If Erica is creative, then Erica is not interested in puzzles and creative.

[CONCLUSION (FOL)]:
Creative(erica)) → (¬(InterestedIn(erica, puzzle) ∧ Creative(erica))

[CONCLUSION (GK)]:
Creative(erica)) => (-(InterestedIn(erica, puzzle) & Creative(erica)).


===

['x']
['x']
[PREMISE]:
Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.
If a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.
There is a person at 'Board Game night' who is either a planner or a creative person.
Erica is at 'Board Game night,' and she is someone who plays a lot of chess.
If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.

[PREMISE (FOL)]:
∀x (At(x, boardGameNight) → (InterestedIn(x, puzzle) ∨ BadAt(x, chess)))
∀x ((At(x, boardGameNight) ∧ BadAt(x, chess)) → ¬PlaysOften(x, chess))
∃x (At(x, boardGameNight) ∧ (Planner(x) ∨ Creative(x)))
At(erica, boardGameNight) ∧ PlaysOften(erica, chess)
(At(erica, boardGameNight) ∧ (¬(BadAt(erica, chess) ∨ Creative(erica)))) → ¬(Planner(erica) ⊕  Creative(erica))

[PREMISE (GK)]:
! [X] : (At(X, boardGameNight) => (InterestedIn(X, puzzle) | BadAt(X, chess))).
! [X] : ((At(X, boardGameNight) & BadAt(X, chess)) => -PlaysOften(X, chess)).
? [X] : (At(X, boardGameNight) & (Planner(X) | Creative(X))).
At(erica, boardGameNight) & PlaysOften(erica, chess).
(At(erica, boardGameNight) & (-(BadAt(erica, chess) | Creative(erica)))) => -(Planner(erica) <~>  Creative(erica)).

[CONCLUSION]:
If Erica is interested in puzzles and is creative, then Erica is not creative.

[CONCLUSION (FOL)]:
InterestedIn(erica, puzzle) ∧ Creative(erica)) → ¬Creative(erica)

[CONCLUSION (GK)]:
InterestedIn(erica, puzzle) & Creative(erica)) => -Creative(erica).


===

['x']
['x']
[PREMISE]:
Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.
If a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.
There is a person at 'Board Game night' who is either a planner or a creative person.
Erica is at 'Board Game night,' and she is someone who plays a lot of chess.
If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.

[PREMISE (FOL)]:
∀x (At(x, boardGameNight) → (InterestedIn(x, puzzle) ∨ BadAt(x, chess)))
∀x ((At(x, boardGameNight) ∧ BadAt(x, chess)) → ¬PlaysOften(x, chess))
∃x (At(x, boardGameNight) ∧ (Planner(x) ∨ Creative(x)))
At(erica, boardGameNight) ∧ PlaysOften(erica, chess)
(At(erica, boardGameNight) ∧ (¬(BadAt(erica, chess) ∨ Creative(erica)))) → ¬(Planner(erica) ⊕  Creative(erica))

[PREMISE (GK)]:
! [X] : (At(X, boardGameNight) => (InterestedIn(X, puzzle) | BadAt(X, chess))).
! [X] : ((At(X, boardGameNight) & BadAt(X, chess)) => -PlaysOften(X, chess)).
? [X] : (At(X, boardGameNight) & (Planner(X) | Creative(X))).
At(erica, boardGameNight) & PlaysOften(erica, chess).
(At(erica, boardGameNight) & (-(BadAt(erica, chess) | Creative(erica)))) => -(Planner(erica) <~>  Creative(erica)).

[CONCLUSION]:
If Erica either plays a lot of chess matches or is creative, then Erica is neither interested in puzzles nor a person who plays a lot of chess matches.

[CONCLUSION (FOL)]:
PlaysOften(erica, chess) ⊕ InterestedIn(erica, puzzle) → ¬(InterestedIn(erica, puzzle) ∨ PlaysOften(erica, chess))

[CONCLUSION (GK)]:
PlaysOften(erica, chess) <~> InterestedIn(erica, puzzle) => -(InterestedIn(erica, puzzle) | PlaysOften(erica, chess)).


===

['x']
['x']
[PREMISE]:
Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.
If a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.
There is a person at 'Board Game night' who is either a planner or a creative person.
Erica is at 'Board Game night,' and she is someone who plays a lot of chess.
If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.

[PREMISE (FOL)]:
∀x (At(x, boardGameNight) → (InterestedIn(x, puzzle) ∨ BadAt(x, chess)))
∀x ((At(x, boardGameNight) ∧ BadAt(x, chess)) → ¬PlaysOften(x, chess))
∃x (At(x, boardGameNight) ∧ (Planner(x) ∨ Creative(x)))
At(erica, boardGameNight) ∧ PlaysOften(erica, chess)
(At(erica, boardGameNight) ∧ (¬(BadAt(erica, chess) ∨ Creative(erica)))) → ¬(Planner(erica) ⊕  Creative(erica))

[PREMISE (GK)]:
! [X] : (At(X, boardGameNight) => (InterestedIn(X, puzzle) | BadAt(X, chess))).
! [X] : ((At(X, boardGameNight) & BadAt(X, chess)) => -PlaysOften(X, chess)).
? [X] : (At(X, boardGameNight) & (Planner(X) | Creative(X))).
At(erica, boardGameNight) & PlaysOften(erica, chess).
(At(erica, boardGameNight) & (-(BadAt(erica, chess) | Creative(erica)))) => -(Planner(erica) <~>  Creative(erica)).

[CONCLUSION]:
If Erica is interested in puzzles and plays a lot of chess matches, then Erica is either a person who plays a lot of chess matches or a person that is creative.

[CONCLUSION (FOL)]:
PlaysOften(erica, chess) ⊕ InterestedIn(erica, puzzle)) → ¬(InterestedIn(erica, puzzle) ∨ PlaysOften(erica, chess)

[CONCLUSION (GK)]:
PlaysOften(erica, chess) <~> InterestedIn(erica, puzzle)) => -(InterestedIn(erica, puzzle) | PlaysOften(erica, chess).


===

['x']
['x']
[PREMISE]:
Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.
If a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.
There is a person at 'Board Game night' who is either a planner or a creative person.
Erica is at 'Board Game night,' and she is someone who plays a lot of chess.
If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.

[PREMISE (FOL)]:
∀x (At(x, boardGameNight) → (InterestedIn(x, puzzle) ∨ BadAt(x, chess)))
∀x ((At(x, boardGameNight) ∧ BadAt(x, chess)) → ¬PlaysOften(x, chess))
∃x (At(x, boardGameNight) ∧ (Planner(x) ∨ Creative(x)))
At(erica, boardGameNight) ∧ PlaysOften(erica, chess)
(At(erica, boardGameNight) ∧ (¬(BadAt(erica, chess) ∨ Creative(erica)))) → ¬(Planner(erica) ⊕  Creative(erica))

[PREMISE (GK)]:
! [X] : (At(X, boardGameNight) => (InterestedIn(X, puzzle) | BadAt(X, chess))).
! [X] : ((At(X, boardGameNight) & BadAt(X, chess)) => -PlaysOften(X, chess)).
? [X] : (At(X, boardGameNight) & (Planner(X) | Creative(X))).
At(erica, boardGameNight) & PlaysOften(erica, chess).
(At(erica, boardGameNight) & (-(BadAt(erica, chess) | Creative(erica)))) => -(Planner(erica) <~>  Creative(erica)).

[CONCLUSION]:
If Erica plans ahead or is interested in puzzles, then Erica is creative.

[CONCLUSION (FOL)]:
Planner(erica) ∨ InterestedIn(erica, puzzle) → Creative(erica)

[CONCLUSION (GK)]:
Planner(erica) | InterestedIn(erica, puzzle) => Creative(erica).


===

['x']
['x']
[PREMISE]:
Everyone at 'Board Game night' is interested in puzzles, or they are bad at chess, or both.
If a person at 'Board Game night' is bad at chess, then they don't play a lot of chess.
There is a person at 'Board Game night' who is either a planner or a creative person.
Erica is at 'Board Game night,' and she is someone who plays a lot of chess.
If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or she is neither of these things.

[PREMISE (FOL)]:
∀x (At(x, boardGameNight) → (InterestedIn(x, puzzle) ∨ BadAt(x, chess)))
∀x ((At(x, boardGameNight) ∧ BadAt(x, chess)) → ¬PlaysOften(x, chess))
∃x (At(x, boardGameNight) ∧ (Planner(x) ∨ Creative(x)))
At(erica, boardGameNight) ∧ PlaysOften(erica, chess)
(At(erica, boardGameNight) ∧ (¬(BadAt(erica, chess) ∨ Creative(erica)))) → ¬(Planner(erica) ⊕  Creative(erica))

[PREMISE (GK)]:
! [X] : (At(X, boardGameNight) => (InterestedIn(X, puzzle) | BadAt(X, chess))).
! [X] : ((At(X, boardGameNight) & BadAt(X, chess)) => -PlaysOften(X, chess)).
? [X] : (At(X, boardGameNight) & (Planner(X) | Creative(X))).
At(erica, boardGameNight) & PlaysOften(erica, chess).
(At(erica, boardGameNight) & (-(BadAt(erica, chess) | Creative(erica)))) => -(Planner(erica) <~>  Creative(erica)).

[CONCLUSION]:
If Erica is either bad at chess or interested in puzzles, then Erica is not a person who plays a lot of chess matches and creative.

[CONCLUSION (FOL)]:
BadAt(erica, chess) ⊕ InterestedIn(erica, puzzle) → ¬(PlaysOften(erica, chess) ∧ Creative(erica))

[CONCLUSION (GK)]:
BadAt(erica, chess) <~> InterestedIn(erica, puzzle) => -(PlaysOften(erica, chess) & Creative(erica)).


===

['x']
['x']
[PREMISE]:
Soccer players have a right foot and a left foot.
Top soccer players are soccer players who can use both the left foot and right foot very efficiently.
If a soccer player can score many goals using the left foot, they can use that foot very efficiently.
If a soccer player can score many goals using the right foot, they can use that foot very efficiently.
Cristiano Ronaldo is a soccer player.
Cristiano Ronaldo can use his right foot very efficiently.
Cristiano Ronaldo has scored many goals using his left foot.

[PREMISE (FOL)]:
∀x (SoccerPlayer(x) → Have(x, leftFoot) ∧ Have(x, rightFoot))
∀x (SoccerPlayer(x) ∧ UseEfficiently(x, leftFoot) ∧ UseEfficiently(x, rightFoot) → TopSoccerPlayer(x))
∀x (SoccerPlayer(x) ∧ ScoreUsing(x, manyGoals, leftFoot) → UseEfficiently(x, leftFoot))
∀x (SoccerPlayer(x) ∧ ScoreUsing(x, manyGoals, rightFoot) → UseEfficiently(x, rightFoot))
SoccerPlayer(ronaldo)
UseEfficiently(ronaldo, rightFoot)
ScoreUsing(ronaldo, manyGoals, leftFoot)

[PREMISE (GK)]:
! [X] : (SoccerPlayer(X) => Have(X, leftFoot) & Have(X, rightFoot)).
! [X] : (SoccerPlayer(X) & UseEfficiently(X, leftFoot) & UseEfficiently(X, rightFoot) => TopSoccerPlayer(X)).
! [X] : (SoccerPlayer(X) & ScoreUsing(X, manyGoals, leftFoot) => UseEfficiently(X, leftFoot)).
! [X] : (SoccerPlayer(X) & ScoreUsing(X, manyGoals, rightFoot) => UseEfficiently(X, rightFoot)).
SoccerPlayer(ronaldo).
UseEfficiently(ronaldo, rightFoot).
ScoreUsing(ronaldo, manyGoals, leftFoot).

[CONCLUSION]:
Cristiano Ronaldo is a top soccer player.

[CONCLUSION (FOL)]:
TopSoccerPlayer(ronaldo)

[CONCLUSION (GK)]:
TopSoccerPlayer(ronaldo).


===

['x']
['x']
[PREMISE]:
Soccer players have a right foot and a left foot.
Top soccer players are soccer players who can use both the left foot and right foot very efficiently.
If a soccer player can score many goals using the left foot, they can use that foot very efficiently.
If a soccer player can score many goals using the right foot, they can use that foot very efficiently.
Cristiano Ronaldo is a soccer player.
Cristiano Ronaldo can use his right foot very efficiently.
Cristiano Ronaldo has scored many goals using his left foot.

[PREMISE (FOL)]:
∀x (SoccerPlayer(x) → Have(x, leftFoot) ∧ Have(x, rightFoot))
∀x (SoccerPlayer(x) ∧ UseEfficiently(x, leftFoot) ∧ UseEfficiently(x, rightFoot) → TopSoccerPlayer(x))
∀x (SoccerPlayer(x) ∧ ScoreUsing(x, manyGoals, leftFoot) → UseEfficiently(x, leftFoot))
∀x (SoccerPlayer(x) ∧ ScoreUsing(x, manyGoals, rightFoot) → UseEfficiently(x, rightFoot))
SoccerPlayer(ronaldo)
UseEfficiently(ronaldo, rightFoot)
ScoreUsing(ronaldo, manyGoals, leftFoot)

[PREMISE (GK)]:
! [X] : (SoccerPlayer(X) => Have(X, leftFoot) & Have(X, rightFoot)).
! [X] : (SoccerPlayer(X) & UseEfficiently(X, leftFoot) & UseEfficiently(X, rightFoot) => TopSoccerPlayer(X)).
! [X] : (SoccerPlayer(X) & ScoreUsing(X, manyGoals, leftFoot) => UseEfficiently(X, leftFoot)).
! [X] : (SoccerPlayer(X) & ScoreUsing(X, manyGoals, rightFoot) => UseEfficiently(X, rightFoot)).
SoccerPlayer(ronaldo).
UseEfficiently(ronaldo, rightFoot).
ScoreUsing(ronaldo, manyGoals, leftFoot).

[CONCLUSION]:
Cristiano Ronaldo is not a top soccer player.

[CONCLUSION (FOL)]:
¬TopSoccerPlayer(ronaldo)

[CONCLUSION (GK)]:
-TopSoccerPlayer(ronaldo).


===

['x']
['x']
[PREMISE]:
The National Lobster Hatchery is a hatchery located in Padstow, England.
The National Lobster Hatchery is open to visitors.
A hatchery is either for profit or for conservation.
If a hatchery is for conservation, it might release animals into the wild.
The National Lobster Hatchery is not for profit.

[PREMISE (FOL)]:
Hatchery(nationalLobsterHatchery) ∧ LocatedIn(nationalLobsterHatchery, padstowEngland)
OpenToVisitor(nationalLobsterHatchery)
∀x (Hatchery(x) → ForConservation(x) ⊕ ForProfit(x))
∃x (Hatchery(x) ∧ ForConservation(x) ∧ ReleaseAnimalToWild(x))
¬ForProfit(nationalLobsterHatchery)

[PREMISE (GK)]:
Hatchery(nationalLobsterHatchery) & LocatedIn(nationalLobsterHatchery, padstowEngland).
OpenToVisitor(nationalLobsterHatchery).
! [X] : (Hatchery(X) => ForConservation(X) <~> ForProfit(X)).
? [X] : (Hatchery(X) & ForConservation(X) & ReleaseAnimalToWild(X)).
-ForProfit(nationalLobsterHatchery).

[CONCLUSION]:
The National Lobster Hatchery is for conservation.

[CONCLUSION (FOL)]:
ForConservation(nationalLobsterhatchery)

[CONCLUSION (GK)]:
ForConservation(nationalLobsterhatchery).


===

['x']
['x']
[PREMISE]:
The National Lobster Hatchery is a hatchery located in Padstow, England.
The National Lobster Hatchery is open to visitors.
A hatchery is either for profit or for conservation.
If a hatchery is for conservation, it might release animals into the wild.
The National Lobster Hatchery is not for profit.

[PREMISE (FOL)]:
Hatchery(nationalLobsterHatchery) ∧ LocatedIn(nationalLobsterHatchery, padstowEngland)
OpenToVisitor(nationalLobsterHatchery)
∀x (Hatchery(x) → ForConservation(x) ⊕ ForProfit(x))
∃x (Hatchery(x) ∧ ForConservation(x) ∧ ReleaseAnimalToWild(x))
¬ForProfit(nationalLobsterHatchery)

[PREMISE (GK)]:
Hatchery(nationalLobsterHatchery) & LocatedIn(nationalLobsterHatchery, padstowEngland).
OpenToVisitor(nationalLobsterHatchery).
! [X] : (Hatchery(X) => ForConservation(X) <~> ForProfit(X)).
? [X] : (Hatchery(X) & ForConservation(X) & ReleaseAnimalToWild(X)).
-ForProfit(nationalLobsterHatchery).

[CONCLUSION]:
All hatcheries are open to visitors.

[CONCLUSION (FOL)]:
∀x (Hatchery(x) → OpenToVisitors(x))

[CONCLUSION (GK)]:
! [X] : (Hatchery(X) => OpenToVisitors(X)).


===

['x']
['x']
[PREMISE]:
The National Lobster Hatchery is a hatchery located in Padstow, England.
The National Lobster Hatchery is open to visitors.
A hatchery is either for profit or for conservation.
If a hatchery is for conservation, it might release animals into the wild.
The National Lobster Hatchery is not for profit.

[PREMISE (FOL)]:
Hatchery(nationalLobsterHatchery) ∧ LocatedIn(nationalLobsterHatchery, padstowEngland)
OpenToVisitor(nationalLobsterHatchery)
∀x (Hatchery(x) → ForConservation(x) ⊕ ForProfit(x))
∃x (Hatchery(x) ∧ ForConservation(x) ∧ ReleaseAnimalToWild(x))
¬ForProfit(nationalLobsterHatchery)

[PREMISE (GK)]:
Hatchery(nationalLobsterHatchery) & LocatedIn(nationalLobsterHatchery, padstowEngland).
OpenToVisitor(nationalLobsterHatchery).
! [X] : (Hatchery(X) => ForConservation(X) <~> ForProfit(X)).
? [X] : (Hatchery(X) & ForConservation(X) & ReleaseAnimalToWild(X)).
-ForProfit(nationalLobsterHatchery).

[CONCLUSION]:
The National Lobster Hatchery releases animals into the wild.

[CONCLUSION (FOL)]:
ReleaseAnimalToWild(nationalLobsterhatchery)

[CONCLUSION (GK)]:
ReleaseAnimalToWild(nationalLobsterhatchery).


===

['x']
['x']
[PREMISE]:
Rhos Aelwyd F.C. is a Welsh football club.
Rhos Aelwyd F.C. is the only football club located in Ponciau. 
The Premier Division was won in June 2005 by a team from Ponciau. 
The winner of the Premier Division in October 2009 was promoted to the Cymru Alliance.
The Premier Division in October 2009 was won by the same team that won in June 2005. 

[PREMISE (FOL)]:
∀x (Rhosaelwydfc(x) → FootballClub(x) ∧ Welsh(x))
∀x (FootballClub(x) ∧ LocatedIn(x, ponciau) ↔ Rhosaelwydfc(x))
∃x (LocatedIn(x, ponciau) ∧ WonPremierDivisionDuring(x, year2005MonthJune))
∀x (WonPremierDivisionDuring(x, year2009MonthOctober) → PromotedTo(x, cymruAlliance))
∀x (WonPremierDivisionDuring(x, year2009MonthOctober) ↔ WonPremierDivisionDuring(x, y2005MonthJune))

[PREMISE (GK)]:
! [X] : (Rhosaelwydfc(X) => FootballClub(X) & Welsh(X)).
! [X] : (FootballClub(X) & LocatedIn(X, ponciau) ↔ Rhosaelwydfc(X)).
? [X] : (LocatedIn(X, ponciau) & WonPremierDivisionDuring(X, year2005MonthJune)).
! [X] : (WonPremierDivisionDuring(X, year2009MonthOctober) => PromotedTo(X, cymruAlliance)).
! [X] : (WonPremierDivisionDuring(X, year2009MonthOctober) ↔ WonPremierDivisionDuring(X, y2005MonthJune)).

[CONCLUSION]:
Rhos Aelwyd F.C. won Premier Division in June 2005.

[CONCLUSION (FOL)]:
∃x (Rhosaelwydfc(x) ∧ WonPremierDivisionDuring(x, year2005MonthJune))

[CONCLUSION (GK)]:
? [X] : (Rhosaelwydfc(X) & WonPremierDivisionDuring(X, year2005MonthJune)).


===

['x']
['x']
[PREMISE]:
Rhos Aelwyd F.C. is a Welsh football club.
Rhos Aelwyd F.C. is the only football club located in Ponciau. 
The Premier Division was won in June 2005 by a team from Ponciau. 
The winner of the Premier Division in October 2009 was promoted to the Cymru Alliance.
The Premier Division in October 2009 was won by the same team that won in June 2005. 

[PREMISE (FOL)]:
∀x (Rhosaelwydfc(x) → FootballClub(x) ∧ Welsh(x))
∀x (FootballClub(x) ∧ LocatedIn(x, ponciau) ↔ Rhosaelwydfc(x))
∃x (LocatedIn(x, ponciau) ∧ WonPremierDivisionDuring(x, year2005MonthJune))
∀x (WonPremierDivisionDuring(x, year2009MonthOctober) → PromotedTo(x, cymruAlliance))
∀x (WonPremierDivisionDuring(x, year2009MonthOctober) ↔ WonPremierDivisionDuring(x, y2005MonthJune))

[PREMISE (GK)]:
! [X] : (Rhosaelwydfc(X) => FootballClub(X) & Welsh(X)).
! [X] : (FootballClub(X) & LocatedIn(X, ponciau) ↔ Rhosaelwydfc(X)).
? [X] : (LocatedIn(X, ponciau) & WonPremierDivisionDuring(X, year2005MonthJune)).
! [X] : (WonPremierDivisionDuring(X, year2009MonthOctober) => PromotedTo(X, cymruAlliance)).
! [X] : (WonPremierDivisionDuring(X, year2009MonthOctober) ↔ WonPremierDivisionDuring(X, y2005MonthJune)).

[CONCLUSION]:
Rhos Aelwyd F.C. was promoted to the Cymru Alliance.

[CONCLUSION (FOL)]:
∃x (Rhosaelwydfc(x) ∧ PromotedTo(x, cymruAlliance))

[CONCLUSION (GK)]:
? [X] : (Rhosaelwydfc(X) & PromotedTo(X, cymruAlliance)).


===

['x']
['x']
[PREMISE]:
A Unix operating system used in the lab computers is a piece of software.
All versions of MacOS used in the lab computer are based on Unix operating systems.
A lab computer uses either MacOS or Linux. 
All Linux computers in the lab are convenient.
All software used in the lab computers is written with code.
If something is convenient in the lab computer, then it is popular.
Burger is used in the lab computer, and it is written with code and a new version of MacOS.
PyTorch is used in the lab computer, and PyTorch is neither a Linux system nor a piece of software.

[PREMISE (FOL)]:
∀x (UsedIn(x, labComputer) ∧ UnixOperatingSystem(x) → Software(x))
∀x (UsedIn(x, labComputer) ∧ MacOS(x) → UnixOperatingSystem(x))
∀x (UsedIn(x, labComputer) → MacOS(x) ⊕ Linux(x))
∀x (UsedIn(x, labComputer) ∧ Linux(x) → Convenient(x))
∀x (UsedIn(x, labComputer) ∧ Software(x) → WrittenWithCode(x))
∀x (UsedIn(x, labComputer) ∧ Convenient(x) → Popular(x))
UsedIn(burger, labComputer) ∧ WrittenWithCode(burger) ∧ MacOS(burger))
UsedIn(pytorch, labComputer) ∧ ¬(Linux(pytorch) ⊕ Software(pytorch))

[PREMISE (GK)]:
! [X] : (UsedIn(X, labComputer) & UnixOperatingSystem(X) => Software(X)).
! [X] : (UsedIn(X, labComputer) & MacOS(X) => UnixOperatingSystem(X)).
! [X] : (UsedIn(X, labComputer) => MacOS(X) <~> Linux(X)).
! [X] : (UsedIn(X, labComputer) & Linux(X) => Convenient(X)).
! [X] : (UsedIn(X, labComputer) & Software(X) => WrittenWithCode(X)).
! [X] : (UsedIn(X, labComputer) & Convenient(X) => Popular(X)).
UsedIn(burger, labComputer) & WrittenWithCode(burger) & MacOS(burger)).
UsedIn(pytorch, labComputer) & -(Linux(pytorch) <~> Software(pytorch)).

[CONCLUSION]:
Burger is popular.

[CONCLUSION (FOL)]:
Popular(burger)

[CONCLUSION (GK)]:
Popular(burger).


===

['x']
['x']
[PREMISE]:
A Unix operating system used in the lab computers is a piece of software.
All versions of MacOS used in the lab computer are based on Unix operating systems.
A lab computer uses either MacOS or Linux. 
All Linux computers in the lab are convenient.
All software used in the lab computers is written with code.
If something is convenient in the lab computer, then it is popular.
Burger is used in the lab computer, and it is written with code and a new version of MacOS.
PyTorch is used in the lab computer, and PyTorch is neither a Linux system nor a piece of software.

[PREMISE (FOL)]:
∀x (UsedIn(x, labComputer) ∧ UnixOperatingSystem(x) → Software(x))
∀x (UsedIn(x, labComputer) ∧ MacOS(x) → UnixOperatingSystem(x))
∀x (UsedIn(x, labComputer) → MacOS(x) ⊕ Linux(x))
∀x (UsedIn(x, labComputer) ∧ Linux(x) → Convenient(x))
∀x (UsedIn(x, labComputer) ∧ Software(x) → WrittenWithCode(x))
∀x (UsedIn(x, labComputer) ∧ Convenient(x) → Popular(x))
UsedIn(burger, labComputer) ∧ WrittenWithCode(burger) ∧ MacOS(burger))
UsedIn(pytorch, labComputer) ∧ ¬(Linux(pytorch) ⊕ Software(pytorch))

[PREMISE (GK)]:
! [X] : (UsedIn(X, labComputer) & UnixOperatingSystem(X) => Software(X)).
! [X] : (UsedIn(X, labComputer) & MacOS(X) => UnixOperatingSystem(X)).
! [X] : (UsedIn(X, labComputer) => MacOS(X) <~> Linux(X)).
! [X] : (UsedIn(X, labComputer) & Linux(X) => Convenient(X)).
! [X] : (UsedIn(X, labComputer) & Software(X) => WrittenWithCode(X)).
! [X] : (UsedIn(X, labComputer) & Convenient(X) => Popular(X)).
UsedIn(burger, labComputer) & WrittenWithCode(burger) & MacOS(burger)).
UsedIn(pytorch, labComputer) & -(Linux(pytorch) <~> Software(pytorch)).

[CONCLUSION]:
Burger is not popular.

[CONCLUSION (FOL)]:
¬Popular(burger)

[CONCLUSION (GK)]:
-Popular(burger).


===

['x']
['x']
[PREMISE]:
A Unix operating system used in the lab computers is a piece of software.
All versions of MacOS used in the lab computer are based on Unix operating systems.
A lab computer uses either MacOS or Linux. 
All Linux computers in the lab are convenient.
All software used in the lab computers is written with code.
If something is convenient in the lab computer, then it is popular.
Burger is used in the lab computer, and it is written with code and a new version of MacOS.
PyTorch is used in the lab computer, and PyTorch is neither a Linux system nor a piece of software.

[PREMISE (FOL)]:
∀x (UsedIn(x, labComputer) ∧ UnixOperatingSystem(x) → Software(x))
∀x (UsedIn(x, labComputer) ∧ MacOS(x) → UnixOperatingSystem(x))
∀x (UsedIn(x, labComputer) → MacOS(x) ⊕ Linux(x))
∀x (UsedIn(x, labComputer) ∧ Linux(x) → Convenient(x))
∀x (UsedIn(x, labComputer) ∧ Software(x) → WrittenWithCode(x))
∀x (UsedIn(x, labComputer) ∧ Convenient(x) → Popular(x))
UsedIn(burger, labComputer) ∧ WrittenWithCode(burger) ∧ MacOS(burger))
UsedIn(pytorch, labComputer) ∧ ¬(Linux(pytorch) ⊕ Software(pytorch))

[PREMISE (GK)]:
! [X] : (UsedIn(X, labComputer) & UnixOperatingSystem(X) => Software(X)).
! [X] : (UsedIn(X, labComputer) & MacOS(X) => UnixOperatingSystem(X)).
! [X] : (UsedIn(X, labComputer) => MacOS(X) <~> Linux(X)).
! [X] : (UsedIn(X, labComputer) & Linux(X) => Convenient(X)).
! [X] : (UsedIn(X, labComputer) & Software(X) => WrittenWithCode(X)).
! [X] : (UsedIn(X, labComputer) & Convenient(X) => Popular(X)).
UsedIn(burger, labComputer) & WrittenWithCode(burger) & MacOS(burger)).
UsedIn(pytorch, labComputer) & -(Linux(pytorch) <~> Software(pytorch)).

[CONCLUSION]:
PyTorch is popular and written with code.

[CONCLUSION (FOL)]:
Popular(pytorch) ∧ WrittenWithCode(pytorch)

[CONCLUSION (GK)]:
Popular(pytorch) & WrittenWithCode(pytorch).


===

['x']
['x']
[PREMISE]:
A Unix operating system used in the lab computers is a piece of software.
All versions of MacOS used in the lab computer are based on Unix operating systems.
A lab computer uses either MacOS or Linux. 
All Linux computers in the lab are convenient.
All software used in the lab computers is written with code.
If something is convenient in the lab computer, then it is popular.
Burger is used in the lab computer, and it is written with code and a new version of MacOS.
PyTorch is used in the lab computer, and PyTorch is neither a Linux system nor a piece of software.

[PREMISE (FOL)]:
∀x (UsedIn(x, labComputer) ∧ UnixOperatingSystem(x) → Software(x))
∀x (UsedIn(x, labComputer) ∧ MacOS(x) → UnixOperatingSystem(x))
∀x (UsedIn(x, labComputer) → MacOS(x) ⊕ Linux(x))
∀x (UsedIn(x, labComputer) ∧ Linux(x) → Convenient(x))
∀x (UsedIn(x, labComputer) ∧ Software(x) → WrittenWithCode(x))
∀x (UsedIn(x, labComputer) ∧ Convenient(x) → Popular(x))
UsedIn(burger, labComputer) ∧ WrittenWithCode(burger) ∧ MacOS(burger))
UsedIn(pytorch, labComputer) ∧ ¬(Linux(pytorch) ⊕ Software(pytorch))

[PREMISE (GK)]:
! [X] : (UsedIn(X, labComputer) & UnixOperatingSystem(X) => Software(X)).
! [X] : (UsedIn(X, labComputer) & MacOS(X) => UnixOperatingSystem(X)).
! [X] : (UsedIn(X, labComputer) => MacOS(X) <~> Linux(X)).
! [X] : (UsedIn(X, labComputer) & Linux(X) => Convenient(X)).
! [X] : (UsedIn(X, labComputer) & Software(X) => WrittenWithCode(X)).
! [X] : (UsedIn(X, labComputer) & Convenient(X) => Popular(X)).
UsedIn(burger, labComputer) & WrittenWithCode(burger) & MacOS(burger)).
UsedIn(pytorch, labComputer) & -(Linux(pytorch) <~> Software(pytorch)).

[CONCLUSION]:
PyTorch is not popular and it is not written with code.

[CONCLUSION (FOL)]:
¬(Popular(pytorch) ∧ WrittenWithCode(pytorch))

[CONCLUSION (GK)]:
-(Popular(pytorch) & WrittenWithCode(pytorch)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Roads are made of either concrete or asphalt.
Roads made of concrete last longer than roads made with asphalt.
Roads made of asphalt are smoother than roads made of concrete.
Everyone prefers the smoother of two roads. 
The first road is made of concrete, and the second road is made of asphalt.

[PREMISE (FOL)]:
∀x (Road(x) → (MadeOf(x, concrete) ⊕ MadeOf(x, asphalt))
∀x ∀y (Road(x) ∧ MadeOf(x, concrete) ∧ Road(y) ∧ MadeOf(y, asphalt) → LastLonger(x, y))
∀x ∀y (Road(x) ∧ MadeOf(x, asphalt) ∧ Road(y) ∧ MadeOf(y, concrete) → Smoother(x, y))
∀x ∀y ∀z (Road(x) ∧ Road(y) ∧ Smoother(x, y) → Prefer(z, x))
Road(firstRoad) ∧ MadeOf(secondRoad, concrete) ∧ Road(firstRoad) ∧ MadeOf(secondRoad, asphalt)

[PREMISE (GK)]:
! [X] : (Road(X) => (MadeOf(X, concrete) <~> MadeOf(X, asphalt)).
! [X] : ! [Y] : (Road(X) & MadeOf(X, concrete) & Road(Y) & MadeOf(Y, asphalt) => LastLonger(X, Y)).
! [X] : ! [Y] : (Road(X) & MadeOf(X, asphalt) & Road(Y) & MadeOf(Y, concrete) => Smoother(X, Y)).
! [X] : ! [Y] : ! [Z] : (Road(X) & Road(Y) & Smoother(X, Y) => Prefer(Z, X)).
Road(firstRoad) & MadeOf(secondRoad, concrete) & Road(firstRoad) & MadeOf(secondRoad, asphalt).

[CONCLUSION]:
The first road will last longer than the second road.

[CONCLUSION (FOL)]:
LastLonger(firstRoad, secondRoad)

[CONCLUSION (GK)]:
LastLonger(firstRoad, secondRoad).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Roads are made of either concrete or asphalt.
Roads made of concrete last longer than roads made with asphalt.
Roads made of asphalt are smoother than roads made of concrete.
Everyone prefers the smoother of two roads. 
The first road is made of concrete, and the second road is made of asphalt.

[PREMISE (FOL)]:
∀x (Road(x) → (MadeOf(x, concrete) ⊕ MadeOf(x, asphalt))
∀x ∀y (Road(x) ∧ MadeOf(x, concrete) ∧ Road(y) ∧ MadeOf(y, asphalt) → LastLonger(x, y))
∀x ∀y (Road(x) ∧ MadeOf(x, asphalt) ∧ Road(y) ∧ MadeOf(y, concrete) → Smoother(x, y))
∀x ∀y ∀z (Road(x) ∧ Road(y) ∧ Smoother(x, y) → Prefer(z, x))
Road(firstRoad) ∧ MadeOf(secondRoad, concrete) ∧ Road(firstRoad) ∧ MadeOf(secondRoad, asphalt)

[PREMISE (GK)]:
! [X] : (Road(X) => (MadeOf(X, concrete) <~> MadeOf(X, asphalt)).
! [X] : ! [Y] : (Road(X) & MadeOf(X, concrete) & Road(Y) & MadeOf(Y, asphalt) => LastLonger(X, Y)).
! [X] : ! [Y] : (Road(X) & MadeOf(X, asphalt) & Road(Y) & MadeOf(Y, concrete) => Smoother(X, Y)).
! [X] : ! [Y] : ! [Z] : (Road(X) & Road(Y) & Smoother(X, Y) => Prefer(Z, X)).
Road(firstRoad) & MadeOf(secondRoad, concrete) & Road(firstRoad) & MadeOf(secondRoad, asphalt).

[CONCLUSION]:
The second road is not smoother than the first one.

[CONCLUSION (FOL)]:
¬Smoother(firstRoad, secondRoad)

[CONCLUSION (GK)]:
-Smoother(firstRoad, secondRoad).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Roads are made of either concrete or asphalt.
Roads made of concrete last longer than roads made with asphalt.
Roads made of asphalt are smoother than roads made of concrete.
Everyone prefers the smoother of two roads. 
The first road is made of concrete, and the second road is made of asphalt.

[PREMISE (FOL)]:
∀x (Road(x) → (MadeOf(x, concrete) ⊕ MadeOf(x, asphalt))
∀x ∀y (Road(x) ∧ MadeOf(x, concrete) ∧ Road(y) ∧ MadeOf(y, asphalt) → LastLonger(x, y))
∀x ∀y (Road(x) ∧ MadeOf(x, asphalt) ∧ Road(y) ∧ MadeOf(y, concrete) → Smoother(x, y))
∀x ∀y ∀z (Road(x) ∧ Road(y) ∧ Smoother(x, y) → Prefer(z, x))
Road(firstRoad) ∧ MadeOf(secondRoad, concrete) ∧ Road(firstRoad) ∧ MadeOf(secondRoad, asphalt)

[PREMISE (GK)]:
! [X] : (Road(X) => (MadeOf(X, concrete) <~> MadeOf(X, asphalt)).
! [X] : ! [Y] : (Road(X) & MadeOf(X, concrete) & Road(Y) & MadeOf(Y, asphalt) => LastLonger(X, Y)).
! [X] : ! [Y] : (Road(X) & MadeOf(X, asphalt) & Road(Y) & MadeOf(Y, concrete) => Smoother(X, Y)).
! [X] : ! [Y] : ! [Z] : (Road(X) & Road(Y) & Smoother(X, Y) => Prefer(Z, X)).
Road(firstRoad) & MadeOf(secondRoad, concrete) & Road(firstRoad) & MadeOf(secondRoad, asphalt).

[CONCLUSION]:
John prefers the second road.

[CONCLUSION (FOL)]:
Prefer(john, secondRoad)

[CONCLUSION (GK)]:
Prefer(john, secondRoad).


===

[]
['x']
[PREMISE]:
Camp Davern is a traditional summer camp for boys and girls.
Camp Davern was established in the year 1946.
Camp Davern was operated by the YMCA until the year 2015.
Camp Davern is an old summer camp.

[PREMISE (FOL)]:
TraditionalSummerCamp(campDavern) ∧ ForBoysAndGirls(campDavern)
EstablishedIn(campDavern, year1946)
OperatedUntil(yMCA, campDavern, year2015)
Old(campDavern)

[PREMISE (GK)]:
TraditionalSummerCamp(campDavern) & ForBoysAndGirls(campDavern).
EstablishedIn(campDavern, year1946).
OperatedUntil(yMCA, campDavern, year2015).
Old(campDavern).

[CONCLUSION]:
One of Ontario's oldest summer camps is a traditional summer camp for boys and girls.

[CONCLUSION (FOL)]:
∃x (Old(x) ∧ TraditionalSummerCamp(x) ∧ ForBoysAndGirls(x))

[CONCLUSION (GK)]:
? [X] : (Old(X) & TraditionalSummerCamp(X) & ForBoysAndGirls(X)).


===

[]
['x']
[PREMISE]:
Camp Davern is a traditional summer camp for boys and girls.
Camp Davern was established in the year 1946.
Camp Davern was operated by the YMCA until the year 2015.
Camp Davern is an old summer camp.

[PREMISE (FOL)]:
TraditionalSummerCamp(campDavern) ∧ ForBoysAndGirls(campDavern)
EstablishedIn(campDavern, year1946)
OperatedUntil(yMCA, campDavern, year2015)
Old(campDavern)

[PREMISE (GK)]:
TraditionalSummerCamp(campDavern) & ForBoysAndGirls(campDavern).
EstablishedIn(campDavern, year1946).
OperatedUntil(yMCA, campDavern, year2015).
Old(campDavern).

[CONCLUSION]:
A traditional summer camp for boys and girls was operated by the YMCA until the year 2015.

[CONCLUSION (FOL)]:
∃x (TraditionalSummerCamp(x) ∧ ForBoysAndGirls(x) ∧ OperatedUntil(YMCA, x, year2015))

[CONCLUSION (GK)]:
? [X] : (TraditionalSummerCamp(X) & ForBoysAndGirls(X) & OperatedUntil(YMCA, X, year2015)).


===

[]
[]
[PREMISE]:
Camp Davern is a traditional summer camp for boys and girls.
Camp Davern was established in the year 1946.
Camp Davern was operated by the YMCA until the year 2015.
Camp Davern is an old summer camp.

[PREMISE (FOL)]:
TraditionalSummerCamp(campDavern) ∧ ForBoysAndGirls(campDavern)
EstablishedIn(campDavern, year1946)
OperatedUntil(yMCA, campDavern, year2015)
Old(campDavern)

[PREMISE (GK)]:
TraditionalSummerCamp(campDavern) & ForBoysAndGirls(campDavern).
EstablishedIn(campDavern, year1946).
OperatedUntil(yMCA, campDavern, year2015).
Old(campDavern).

[CONCLUSION]:
Camp Davern was established in 1989.

[CONCLUSION (FOL)]:
EstablishedIn(campdavern, year1989)

[CONCLUSION (GK)]:
EstablishedIn(campdavern, year1989).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If Emily's friends publish journals, then they do not work in the entertainment industry.
All of Emily's friends who are award-winning novelists publish journals.
Emily's friends work in the entertainment industry or are highly acclaimed in their profession.
If Emily's friends are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.
If Emily's friends are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.
Taylor is Emily's friend.
It is not true that Taylor both holds highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace.

[PREMISE (FOL)]:
∀x (EmilysFriend(x) ∧ Publish(x, journal) → ¬WorkIn(x, entertainmentIndustry))
∀x (EmilysFriend(x) ∧ AwardWinningNovelist(x) → Publish(x, journal))
∀x (EmilysFriend(x) → WorkIn(x, entertainmentIndustry) ∨ HighlyAcclaimedIn(x, theirProfession))
∀x (EmilysFriend(x) ∧ HighlyAcclaimedIn(x, theirProfession) → ∃y (HoldAt(x, y, workPlace) ∧ Tenured(y) ∧ HighRanking(y) ∧ Position(y)))
∀x (EmilysFriend(x) ∧ HighlyAcclaimedIn(x, theirProfession) → ReceiveFrom(x, glowingFeedback, colleague) ∧ ReceiveFrom(x, glowingRecommendation, colleague))
EmilysFriends(taylor) 
¬(HighlyAcclaimedIn(taylor, theirProfession) ∧ (∃y (HoldAt(taylor, y, workPlace) ∧ Tenured(y) ∧ HighRanking(y) ∧ Position(y)))

[PREMISE (GK)]:
! [X] : (EmilysFriend(X) & Publish(X, journal) => -WorkIn(X, entertainmentIndustry)).
! [X] : (EmilysFriend(X) & AwardWinningNovelist(X) => Publish(X, journal)).
! [X] : (EmilysFriend(X) => WorkIn(X, entertainmentIndustry) | HighlyAcclaimedIn(X, theirProfession)).
! [X] : (EmilysFriend(X) & HighlyAcclaimedIn(X, theirProfession) => ? [Y] : (HoldAt(X, Y, workPlace) & Tenured(Y) & HighRanking(Y) & Position(Y))).
! [X] : (EmilysFriend(X) & HighlyAcclaimedIn(X, theirProfession) => ReceiveFrom(X, glowingFeedback, colleague) & ReceiveFrom(X, glowingRecommendation, colleague)).
EmilysFriends(taylor) .
-(HighlyAcclaimedIn(taylor, theirProfession) & (? [Y] : (HoldAt(taylor, Y, workPlace) & Tenured(Y) & HighRanking(Y) & Position(Y))).

[CONCLUSION]:
Taylor is Emily's friend and she often holds tenured and high-ranking positions at her workplace.

[CONCLUSION (FOL)]:
EmilysFriends(taylor) ∧ (∃y (HoldAt(taylor, y, workPlace) ∧ Tenured(y) ∧ HighRanking(y) ∧ Position(y)))

[CONCLUSION (GK)]:
EmilysFriends(taylor) & (? [Y] : (HoldAt(taylor, Y, workPlace) & Tenured(Y) & HighRanking(Y) & Position(Y))).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If Emily's friends publish journals, then they do not work in the entertainment industry.
All of Emily's friends who are award-winning novelists publish journals.
Emily's friends work in the entertainment industry or are highly acclaimed in their profession.
If Emily's friends are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.
If Emily's friends are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.
Taylor is Emily's friend.
It is not true that Taylor both holds highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace.

[PREMISE (FOL)]:
∀x (EmilysFriend(x) ∧ Publish(x, journal) → ¬WorkIn(x, entertainmentIndustry))
∀x (EmilysFriend(x) ∧ AwardWinningNovelist(x) → Publish(x, journal))
∀x (EmilysFriend(x) → WorkIn(x, entertainmentIndustry) ∨ HighlyAcclaimedIn(x, theirProfession))
∀x (EmilysFriend(x) ∧ HighlyAcclaimedIn(x, theirProfession) → ∃y (HoldAt(x, y, workPlace) ∧ Tenured(y) ∧ HighRanking(y) ∧ Position(y)))
∀x (EmilysFriend(x) ∧ HighlyAcclaimedIn(x, theirProfession) → ReceiveFrom(x, glowingFeedback, colleague) ∧ ReceiveFrom(x, glowingRecommendation, colleague))
EmilysFriends(taylor) 
¬(HighlyAcclaimedIn(taylor, theirProfession) ∧ (∃y (HoldAt(taylor, y, workPlace) ∧ Tenured(y) ∧ HighRanking(y) ∧ Position(y)))

[PREMISE (GK)]:
! [X] : (EmilysFriend(X) & Publish(X, journal) => -WorkIn(X, entertainmentIndustry)).
! [X] : (EmilysFriend(X) & AwardWinningNovelist(X) => Publish(X, journal)).
! [X] : (EmilysFriend(X) => WorkIn(X, entertainmentIndustry) | HighlyAcclaimedIn(X, theirProfession)).
! [X] : (EmilysFriend(X) & HighlyAcclaimedIn(X, theirProfession) => ? [Y] : (HoldAt(X, Y, workPlace) & Tenured(Y) & HighRanking(Y) & Position(Y))).
! [X] : (EmilysFriend(X) & HighlyAcclaimedIn(X, theirProfession) => ReceiveFrom(X, glowingFeedback, colleague) & ReceiveFrom(X, glowingRecommendation, colleague)).
EmilysFriends(taylor) .
-(HighlyAcclaimedIn(taylor, theirProfession) & (? [Y] : (HoldAt(taylor, Y, workPlace) & Tenured(Y) & HighRanking(Y) & Position(Y))).

[CONCLUSION]:
Taylor is Emily's friend and she often receives glowing feedback and recommendations from their colleagues and is an award-winning novelist.

[CONCLUSION (FOL)]:
EmilysFriends(taylor) ∧ (Receive(taylor, glowingFeedback, colleague) ∧ Receive(taylor, glowingRecommendation, colleague) ∧ AwardWinningNovelist(taylor))

[CONCLUSION (GK)]:
EmilysFriends(taylor) & (Receive(taylor, glowingFeedback, colleague) & Receive(taylor, glowingRecommendation, colleague) & AwardWinningNovelist(taylor)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
If Emily's friends publish journals, then they do not work in the entertainment industry.
All of Emily's friends who are award-winning novelists publish journals.
Emily's friends work in the entertainment industry or are highly acclaimed in their profession.
If Emily's friends are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.
If Emily's friends are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.
Taylor is Emily's friend.
It is not true that Taylor both holds highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace.

[PREMISE (FOL)]:
∀x (EmilysFriend(x) ∧ Publish(x, journal) → ¬WorkIn(x, entertainmentIndustry))
∀x (EmilysFriend(x) ∧ AwardWinningNovelist(x) → Publish(x, journal))
∀x (EmilysFriend(x) → WorkIn(x, entertainmentIndustry) ∨ HighlyAcclaimedIn(x, theirProfession))
∀x (EmilysFriend(x) ∧ HighlyAcclaimedIn(x, theirProfession) → ∃y (HoldAt(x, y, workPlace) ∧ Tenured(y) ∧ HighRanking(y) ∧ Position(y)))
∀x (EmilysFriend(x) ∧ HighlyAcclaimedIn(x, theirProfession) → ReceiveFrom(x, glowingFeedback, colleague) ∧ ReceiveFrom(x, glowingRecommendation, colleague))
EmilysFriends(taylor) 
¬(HighlyAcclaimedIn(taylor, theirProfession) ∧ (∃y (HoldAt(taylor, y, workPlace) ∧ Tenured(y) ∧ HighRanking(y) ∧ Position(y)))

[PREMISE (GK)]:
! [X] : (EmilysFriend(X) & Publish(X, journal) => -WorkIn(X, entertainmentIndustry)).
! [X] : (EmilysFriend(X) & AwardWinningNovelist(X) => Publish(X, journal)).
! [X] : (EmilysFriend(X) => WorkIn(X, entertainmentIndustry) | HighlyAcclaimedIn(X, theirProfession)).
! [X] : (EmilysFriend(X) & HighlyAcclaimedIn(X, theirProfession) => ? [Y] : (HoldAt(X, Y, workPlace) & Tenured(Y) & HighRanking(Y) & Position(Y))).
! [X] : (EmilysFriend(X) & HighlyAcclaimedIn(X, theirProfession) => ReceiveFrom(X, glowingFeedback, colleague) & ReceiveFrom(X, glowingRecommendation, colleague)).
EmilysFriends(taylor) .
-(HighlyAcclaimedIn(taylor, theirProfession) & (? [Y] : (HoldAt(taylor, Y, workPlace) & Tenured(Y) & HighRanking(Y) & Position(Y))).

[CONCLUSION]:
Taylor is Emily's friend and she does not both publish journals and is an award-winning novelist.

[CONCLUSION (FOL)]:
EmilysFriends(taylor) ∧ ¬(Publish(taylor, journal) ∧ AwardWinningNovelist(taylor))

[CONCLUSION (GK)]:
EmilysFriends(taylor) & -(Publish(taylor, journal) & AwardWinningNovelist(taylor)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Thick as Thieves is a young adult fantasy novel written by Megan Whalen Turner.
Thick as Thieves was published by Greenwillow Books.
If a book was published by a company, then the author of that book worked with the company that published the book.
The fictional Mede Empire is where Thick as Thieves is set.
The Mede Empire plots to swallow up some nearby countries.
Attolia and Sounis are countries near the Mede Empire.
Thick as Thieves was sold both as a hardcover and an e-book.

[PREMISE (FOL)]:
YoungAdultFantasy(thickAsTheives) ∧ Novel(thickAsTheives) ∧ WrittenBy(thickAsTheives, meganWhalenTurner)
PublishedBy(thickAsTheives, greenWillowBooks)
∀x ∀y ∀z ((WrittenBy(x, y) ∧ PublishedBy(x, z)) → WorkedWith(y, z))
Fictional(medeEmpire) ∧ SetIn(thickAsTheives, medeEmpire)
∃x ∃y ((Country(x) ∧ Near(x, medeEmpire) ∧ PlotsToSwallowUp(medeEmpire, x)) ∧ (¬(x=y) ∧ Near(y, medeEmpire) ∧ PlotsToSwallowUp(medeEmpire, y)))
Country(attolia) ∧ Near(attolia, medeEmpire) ∧ Country(sounis) ∧ Near(sounis, medeEmpire)
SoldAs(thickAsTheives, hardCover) ∧ SoldAs(thickAsTheives, softCover)

[PREMISE (GK)]:
YoungAdultFantasy(thickAsTheives) & Novel(thickAsTheives) & WrittenBy(thickAsTheives, meganWhalenTurner).
PublishedBy(thickAsTheives, greenWillowBooks).
! [X] : ! [Y] : ! [Z] : ((WrittenBy(X, Y) & PublishedBy(X, Z)) => WorkedWith(Y, Z)).
Fictional(medeEmpire) & SetIn(thickAsTheives, medeEmpire).
? [X] : ? [Y] : ((Country(X) & Near(X, medeEmpire) & PlotsToSwallowUp(medeEmpire, X)) & (-(X=Y) & Near(Y, medeEmpire) & PlotsToSwallowUp(medeEmpire, Y))).
Country(attolia) & Near(attolia, medeEmpire) & Country(sounis) & Near(sounis, medeEmpire).
SoldAs(thickAsTheives, hardCover) & SoldAs(thickAsTheives, softCover).

[CONCLUSION]:
Megan Whalen Turner worked with Greenwillow Books.

[CONCLUSION (FOL)]:
WorkedWith(WhalenTurner, greenWillowbooks)

[CONCLUSION (GK)]:
WorkedWith(WhalenTurner, greenWillowbooks).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Thick as Thieves is a young adult fantasy novel written by Megan Whalen Turner.
Thick as Thieves was published by Greenwillow Books.
If a book was published by a company, then the author of that book worked with the company that published the book.
The fictional Mede Empire is where Thick as Thieves is set.
The Mede Empire plots to swallow up some nearby countries.
Attolia and Sounis are countries near the Mede Empire.
Thick as Thieves was sold both as a hardcover and an e-book.

[PREMISE (FOL)]:
YoungAdultFantasy(thickAsTheives) ∧ Novel(thickAsTheives) ∧ WrittenBy(thickAsTheives, meganWhalenTurner)
PublishedBy(thickAsTheives, greenWillowBooks)
∀x ∀y ∀z ((WrittenBy(x, y) ∧ PublishedBy(x, z)) → WorkedWith(y, z))
Fictional(medeEmpire) ∧ SetIn(thickAsTheives, medeEmpire)
∃x ∃y ((Country(x) ∧ Near(x, medeEmpire) ∧ PlotsToSwallowUp(medeEmpire, x)) ∧ (¬(x=y) ∧ Near(y, medeEmpire) ∧ PlotsToSwallowUp(medeEmpire, y)))
Country(attolia) ∧ Near(attolia, medeEmpire) ∧ Country(sounis) ∧ Near(sounis, medeEmpire)
SoldAs(thickAsTheives, hardCover) ∧ SoldAs(thickAsTheives, softCover)

[PREMISE (GK)]:
YoungAdultFantasy(thickAsTheives) & Novel(thickAsTheives) & WrittenBy(thickAsTheives, meganWhalenTurner).
PublishedBy(thickAsTheives, greenWillowBooks).
! [X] : ! [Y] : ! [Z] : ((WrittenBy(X, Y) & PublishedBy(X, Z)) => WorkedWith(Y, Z)).
Fictional(medeEmpire) & SetIn(thickAsTheives, medeEmpire).
? [X] : ? [Y] : ((Country(X) & Near(X, medeEmpire) & PlotsToSwallowUp(medeEmpire, X)) & (-(X=Y) & Near(Y, medeEmpire) & PlotsToSwallowUp(medeEmpire, Y))).
Country(attolia) & Near(attolia, medeEmpire) & Country(sounis) & Near(sounis, medeEmpire).
SoldAs(thickAsTheives, hardCover) & SoldAs(thickAsTheives, softCover).

[CONCLUSION]:
The Mede Empire plans to swallow up Attolia.

[CONCLUSION (FOL)]:
PlotsToSwallowUp(medeEmpire, attolia)

[CONCLUSION (GK)]:
PlotsToSwallowUp(medeEmpire, attolia).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Thick as Thieves is a young adult fantasy novel written by Megan Whalen Turner.
Thick as Thieves was published by Greenwillow Books.
If a book was published by a company, then the author of that book worked with the company that published the book.
The fictional Mede Empire is where Thick as Thieves is set.
The Mede Empire plots to swallow up some nearby countries.
Attolia and Sounis are countries near the Mede Empire.
Thick as Thieves was sold both as a hardcover and an e-book.

[PREMISE (FOL)]:
YoungAdultFantasy(thickAsTheives) ∧ Novel(thickAsTheives) ∧ WrittenBy(thickAsTheives, meganWhalenTurner)
PublishedBy(thickAsTheives, greenWillowBooks)
∀x ∀y ∀z ((WrittenBy(x, y) ∧ PublishedBy(x, z)) → WorkedWith(y, z))
Fictional(medeEmpire) ∧ SetIn(thickAsTheives, medeEmpire)
∃x ∃y ((Country(x) ∧ Near(x, medeEmpire) ∧ PlotsToSwallowUp(medeEmpire, x)) ∧ (¬(x=y) ∧ Near(y, medeEmpire) ∧ PlotsToSwallowUp(medeEmpire, y)))
Country(attolia) ∧ Near(attolia, medeEmpire) ∧ Country(sounis) ∧ Near(sounis, medeEmpire)
SoldAs(thickAsTheives, hardCover) ∧ SoldAs(thickAsTheives, softCover)

[PREMISE (GK)]:
YoungAdultFantasy(thickAsTheives) & Novel(thickAsTheives) & WrittenBy(thickAsTheives, meganWhalenTurner).
PublishedBy(thickAsTheives, greenWillowBooks).
! [X] : ! [Y] : ! [Z] : ((WrittenBy(X, Y) & PublishedBy(X, Z)) => WorkedWith(Y, Z)).
Fictional(medeEmpire) & SetIn(thickAsTheives, medeEmpire).
? [X] : ? [Y] : ((Country(X) & Near(X, medeEmpire) & PlotsToSwallowUp(medeEmpire, X)) & (-(X=Y) & Near(Y, medeEmpire) & PlotsToSwallowUp(medeEmpire, Y))).
Country(attolia) & Near(attolia, medeEmpire) & Country(sounis) & Near(sounis, medeEmpire).
SoldAs(thickAsTheives, hardCover) & SoldAs(thickAsTheives, softCover).

[CONCLUSION]:
Thick as Thieves is not set in the Mede Empire.

[CONCLUSION (FOL)]:
¬SetIn(thickAsTheives, medeEmpire)

[CONCLUSION (GK)]:
-SetIn(thickAsTheives, medeEmpire).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Thick as Thieves is a young adult fantasy novel written by Megan Whalen Turner.
Thick as Thieves was published by Greenwillow Books.
If a book was published by a company, then the author of that book worked with the company that published the book.
The fictional Mede Empire is where Thick as Thieves is set.
The Mede Empire plots to swallow up some nearby countries.
Attolia and Sounis are countries near the Mede Empire.
Thick as Thieves was sold both as a hardcover and an e-book.

[PREMISE (FOL)]:
YoungAdultFantasy(thickAsTheives) ∧ Novel(thickAsTheives) ∧ WrittenBy(thickAsTheives, meganWhalenTurner)
PublishedBy(thickAsTheives, greenWillowBooks)
∀x ∀y ∀z ((WrittenBy(x, y) ∧ PublishedBy(x, z)) → WorkedWith(y, z))
Fictional(medeEmpire) ∧ SetIn(thickAsTheives, medeEmpire)
∃x ∃y ((Country(x) ∧ Near(x, medeEmpire) ∧ PlotsToSwallowUp(medeEmpire, x)) ∧ (¬(x=y) ∧ Near(y, medeEmpire) ∧ PlotsToSwallowUp(medeEmpire, y)))
Country(attolia) ∧ Near(attolia, medeEmpire) ∧ Country(sounis) ∧ Near(sounis, medeEmpire)
SoldAs(thickAsTheives, hardCover) ∧ SoldAs(thickAsTheives, softCover)

[PREMISE (GK)]:
YoungAdultFantasy(thickAsTheives) & Novel(thickAsTheives) & WrittenBy(thickAsTheives, meganWhalenTurner).
PublishedBy(thickAsTheives, greenWillowBooks).
! [X] : ! [Y] : ! [Z] : ((WrittenBy(X, Y) & PublishedBy(X, Z)) => WorkedWith(Y, Z)).
Fictional(medeEmpire) & SetIn(thickAsTheives, medeEmpire).
? [X] : ? [Y] : ((Country(X) & Near(X, medeEmpire) & PlotsToSwallowUp(medeEmpire, X)) & (-(X=Y) & Near(Y, medeEmpire) & PlotsToSwallowUp(medeEmpire, Y))).
Country(attolia) & Near(attolia, medeEmpire) & Country(sounis) & Near(sounis, medeEmpire).
SoldAs(thickAsTheives, hardCover) & SoldAs(thickAsTheives, softCover).

[CONCLUSION]:
Megan Whalen Turner did not work with Greenwillow Books.

[CONCLUSION (FOL)]:
¬WorkedWith(megan, greenWillowbooks)

[CONCLUSION (GK)]:
-WorkedWith(megan, greenWillowbooks).


===

['x']
['x', 'y']
[PREMISE]:
WeTab is a MeeGo-based tablet computer.
WeTab was announced by Neofonie.
Neofonie is a German producer.
Germans live in Germany or abroad. 

[PREMISE (FOL)]:
MeeGoBased(weTab) ∧ TabletComputer(weTab)
∀x (AnnouncedBy(weTab, neofonie))
German(neofonie) ∧ Producer(neofonie)
∀x (German(x) → LiveIn(x, german) ⊕ LiveAbroad(x))

[PREMISE (GK)]:
MeeGoBased(weTab) & TabletComputer(weTab).
! [X] : (AnnouncedBy(weTab, neofonie)).
German(neofonie) & Producer(neofonie).
! [X] : (German(X) => LiveIn(X, german) <~> LiveAbroad(X)).

[CONCLUSION]:
There is a tablet computer announced by a German producer.

[CONCLUSION (FOL)]:
∃x ∃y (TabletComputer(x) ∧ German(y) ∧ Producer(y) ∧ AnnouncedBy(x, y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (TabletComputer(X) & German(Y) & Producer(Y) & AnnouncedBy(X, Y)).


===

['x']
['x']
[PREMISE]:
WeTab is a MeeGo-based tablet computer.
WeTab was announced by Neofonie.
Neofonie is a German producer.
Germans live in Germany or abroad. 

[PREMISE (FOL)]:
MeeGoBased(weTab) ∧ TabletComputer(weTab)
∀x (AnnouncedBy(weTab, neofonie))
German(neofonie) ∧ Producer(neofonie)
∀x (German(x) → LiveIn(x, german) ⊕ LiveAbroad(x))

[PREMISE (GK)]:
MeeGoBased(weTab) & TabletComputer(weTab).
! [X] : (AnnouncedBy(weTab, neofonie)).
German(neofonie) & Producer(neofonie).
! [X] : (German(X) => LiveIn(X, german) <~> LiveAbroad(X)).

[CONCLUSION]:
Neofonie doesn't speak English or German.

[CONCLUSION (FOL)]:
¬Speak(neofonie, english) ∧ ¬Speak(neofonie, german)

[CONCLUSION (GK)]:
-Speak(neofonie, english) & -Speak(neofonie, german).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some employees in James's town who work in business analysis are good at math. 
All of the employees in James's town who work in business analysis are working for this company. 
None of the employees in James's town who work for this company are from China. 
All of the employees in James's town working in software engineering are from China. 
Leif is an employee in James's town, and he is working in software engineering.  

[PREMISE (FOL)]:
∃x ∃y (EmployeeIn(x, jamesSTown) ∧ WorkIn(x, businessAnalysis) ∧ GoodAt(x, math) ∧ (¬(x=y)) ∧ EmployeeIn(y, jamesSTown) ∧ WorkIn(y, businessAnalysis) ∧ GoodAt(y, math))
∀x ((EmployeeIn(x, jamesSTown) ∧ WorkIn(x, businessAnalysis)) → WorkFor(x, thisCompany))
∀x ((EmployeeIn(x, jamesSTown) ∧ WorkFor(x, thisCompany)) → ¬From(x, china))
∀x (EmployeeIn(x, jamesSTown) ∧ WorkIn(x, softwareEngineering) → From(x, china))
EmployeeIn(leif, jamesSTown) ∧ WorkIn(leif, softwareEngineering)

[PREMISE (GK)]:
? [X] : ? [Y] : (EmployeeIn(X, jamesSTown) & WorkIn(X, businessAnalysis) & GoodAt(X, math) & (-(X=Y)) & EmployeeIn(Y, jamesSTown) & WorkIn(Y, businessAnalysis) & GoodAt(Y, math)).
! [X] : ((EmployeeIn(X, jamesSTown) & WorkIn(X, businessAnalysis)) => WorkFor(X, thisCompany)).
! [X] : ((EmployeeIn(X, jamesSTown) & WorkFor(X, thisCompany)) => -From(X, china)).
! [X] : (EmployeeIn(X, jamesSTown) & WorkIn(X, softwareEngineering) => From(X, china)).
EmployeeIn(leif, jamesSTown) & WorkIn(leif, softwareEngineering).

[CONCLUSION]:
Leif is good at math.

[CONCLUSION (FOL)]:
EmployeesInJamesSTown(leif) ∧ GoodAt(leif, math)

[CONCLUSION (GK)]:
EmployeesInJamesSTown(leif) & GoodAt(leif, math).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some employees in James's town who work in business analysis are good at math. 
All of the employees in James's town who work in business analysis are working for this company. 
None of the employees in James's town who work for this company are from China. 
All of the employees in James's town working in software engineering are from China. 
Leif is an employee in James's town, and he is working in software engineering.  

[PREMISE (FOL)]:
∃x ∃y (EmployeeIn(x, jamesSTown) ∧ WorkIn(x, businessAnalysis) ∧ GoodAt(x, math) ∧ (¬(x=y)) ∧ EmployeeIn(y, jamesSTown) ∧ WorkIn(y, businessAnalysis) ∧ GoodAt(y, math))
∀x ((EmployeeIn(x, jamesSTown) ∧ WorkIn(x, businessAnalysis)) → WorkFor(x, thisCompany))
∀x ((EmployeeIn(x, jamesSTown) ∧ WorkFor(x, thisCompany)) → ¬From(x, china))
∀x (EmployeeIn(x, jamesSTown) ∧ WorkIn(x, softwareEngineering) → From(x, china))
EmployeeIn(leif, jamesSTown) ∧ WorkIn(leif, softwareEngineering)

[PREMISE (GK)]:
? [X] : ? [Y] : (EmployeeIn(X, jamesSTown) & WorkIn(X, businessAnalysis) & GoodAt(X, math) & (-(X=Y)) & EmployeeIn(Y, jamesSTown) & WorkIn(Y, businessAnalysis) & GoodAt(Y, math)).
! [X] : ((EmployeeIn(X, jamesSTown) & WorkIn(X, businessAnalysis)) => WorkFor(X, thisCompany)).
! [X] : ((EmployeeIn(X, jamesSTown) & WorkFor(X, thisCompany)) => -From(X, china)).
! [X] : (EmployeeIn(X, jamesSTown) & WorkIn(X, softwareEngineering) => From(X, china)).
EmployeeIn(leif, jamesSTown) & WorkIn(leif, softwareEngineering).

[CONCLUSION]:
Leif is not both good at math and working in business analysis.

[CONCLUSION (FOL)]:
¬(GoodAt(leif, math) ∧ WorkIn(leif, businessAnalysis))

[CONCLUSION (GK)]:
-(GoodAt(leif, math) & WorkIn(leif, businessAnalysis)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some employees in James's town who work in business analysis are good at math. 
All of the employees in James's town who work in business analysis are working for this company. 
None of the employees in James's town who work for this company are from China. 
All of the employees in James's town working in software engineering are from China. 
Leif is an employee in James's town, and he is working in software engineering.  

[PREMISE (FOL)]:
∃x ∃y (EmployeeIn(x, jamesSTown) ∧ WorkIn(x, businessAnalysis) ∧ GoodAt(x, math) ∧ (¬(x=y)) ∧ EmployeeIn(y, jamesSTown) ∧ WorkIn(y, businessAnalysis) ∧ GoodAt(y, math))
∀x ((EmployeeIn(x, jamesSTown) ∧ WorkIn(x, businessAnalysis)) → WorkFor(x, thisCompany))
∀x ((EmployeeIn(x, jamesSTown) ∧ WorkFor(x, thisCompany)) → ¬From(x, china))
∀x (EmployeeIn(x, jamesSTown) ∧ WorkIn(x, softwareEngineering) → From(x, china))
EmployeeIn(leif, jamesSTown) ∧ WorkIn(leif, softwareEngineering)

[PREMISE (GK)]:
? [X] : ? [Y] : (EmployeeIn(X, jamesSTown) & WorkIn(X, businessAnalysis) & GoodAt(X, math) & (-(X=Y)) & EmployeeIn(Y, jamesSTown) & WorkIn(Y, businessAnalysis) & GoodAt(Y, math)).
! [X] : ((EmployeeIn(X, jamesSTown) & WorkIn(X, businessAnalysis)) => WorkFor(X, thisCompany)).
! [X] : ((EmployeeIn(X, jamesSTown) & WorkFor(X, thisCompany)) => -From(X, china)).
! [X] : (EmployeeIn(X, jamesSTown) & WorkIn(X, softwareEngineering) => From(X, china)).
EmployeeIn(leif, jamesSTown) & WorkIn(leif, softwareEngineering).

[CONCLUSION]:
If Leif is not both good at math and in business analysis, then he is neither working in this company nor working in software engineering.

[CONCLUSION (FOL)]:
¬(GoodAt(leif, math) ∧ WorkIn(leif, businessAnalysis)) → (¬WorkFor(x, thisCompany) ∧ ¬WorkIn(x, softwareEngineering))

[CONCLUSION (GK)]:
-(GoodAt(leif, math) & WorkIn(leif, businessAnalysis)) => (-WorkFor(X, thisCompany) & -WorkIn(X, softwareEngineering)).


===

['x']
['x']
[PREMISE]:
The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.
If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.
At the end of the party, strawberries had the lowest remaining weight.
At the end of the party, the number of leftover blueberries was lower than that of cherries.
Benjamin only ate oranges and grapes at the party.

[PREMISE (FOL)]:
Provide(party, strawberry) ∧ Provide(party, orange) ∧ Provide(party, blueberry) ∧ Provide(party, grape) ∧ Provide(party, cherry) 
∀x (LowestWeightRemainingAt(x, endOfParty) → MostPopular(x)) 
LowestWeightRemainingAt(strawberries, endOfParty)
LowerWeightAt(blueberry, cherry, endOfParty)
Eat(benjamin, orange) ∧ Eat(benjamin, grape) ∧ ¬Eat(benjamin, blueberry) ∧ ¬Eat(benjamin, cherry) ∧ ¬Eat(benjamin, strawberry)

[PREMISE (GK)]:
Provide(party, strawberry) & Provide(party, orange) & Provide(party, blueberry) & Provide(party, grape) & Provide(party, cherry) .
! [X] : (LowestWeightRemainingAt(X, endOfParty) => MostPopular(X)) .
LowestWeightRemainingAt(strawberries, endOfParty).
LowerWeightAt(blueberry, cherry, endOfParty).
Eat(benjamin, orange) & Eat(benjamin, grape) & -Eat(benjamin, blueberry) & -Eat(benjamin, cherry) & -Eat(benjamin, strawberry).

[CONCLUSION]:
Blueberries were the most popular fruit at the party.

[CONCLUSION (FOL)]:
MostPopular(blueberry)

[CONCLUSION (GK)]:
MostPopular(blueberry).


===

['x']
['x']
[PREMISE]:
The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.
If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.
At the end of the party, strawberries had the lowest remaining weight.
At the end of the party, the number of leftover blueberries was lower than that of cherries.
Benjamin only ate oranges and grapes at the party.

[PREMISE (FOL)]:
Provide(party, strawberry) ∧ Provide(party, orange) ∧ Provide(party, blueberry) ∧ Provide(party, grape) ∧ Provide(party, cherry) 
∀x (LowestWeightRemainingAt(x, endOfParty) → MostPopular(x)) 
LowestWeightRemainingAt(strawberries, endOfParty)
LowerWeightAt(blueberry, cherry, endOfParty)
Eat(benjamin, orange) ∧ Eat(benjamin, grape) ∧ ¬Eat(benjamin, blueberry) ∧ ¬Eat(benjamin, cherry) ∧ ¬Eat(benjamin, strawberry)

[PREMISE (GK)]:
Provide(party, strawberry) & Provide(party, orange) & Provide(party, blueberry) & Provide(party, grape) & Provide(party, cherry) .
! [X] : (LowestWeightRemainingAt(X, endOfParty) => MostPopular(X)) .
LowestWeightRemainingAt(strawberries, endOfParty).
LowerWeightAt(blueberry, cherry, endOfParty).
Eat(benjamin, orange) & Eat(benjamin, grape) & -Eat(benjamin, blueberry) & -Eat(benjamin, cherry) & -Eat(benjamin, strawberry).

[CONCLUSION]:
Cherries were the most popular fruit at the party.

[CONCLUSION (FOL)]:
MostPopular(cherry)

[CONCLUSION (GK)]:
MostPopular(cherry).


===

['x']
['x']
[PREMISE]:
The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.
If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.
At the end of the party, strawberries had the lowest remaining weight.
At the end of the party, the number of leftover blueberries was lower than that of cherries.
Benjamin only ate oranges and grapes at the party.

[PREMISE (FOL)]:
Provide(party, strawberry) ∧ Provide(party, orange) ∧ Provide(party, blueberry) ∧ Provide(party, grape) ∧ Provide(party, cherry) 
∀x (LowestWeightRemainingAt(x, endOfParty) → MostPopular(x)) 
LowestWeightRemainingAt(strawberries, endOfParty)
LowerWeightAt(blueberry, cherry, endOfParty)
Eat(benjamin, orange) ∧ Eat(benjamin, grape) ∧ ¬Eat(benjamin, blueberry) ∧ ¬Eat(benjamin, cherry) ∧ ¬Eat(benjamin, strawberry)

[PREMISE (GK)]:
Provide(party, strawberry) & Provide(party, orange) & Provide(party, blueberry) & Provide(party, grape) & Provide(party, cherry) .
! [X] : (LowestWeightRemainingAt(X, endOfParty) => MostPopular(X)) .
LowestWeightRemainingAt(strawberries, endOfParty).
LowerWeightAt(blueberry, cherry, endOfParty).
Eat(benjamin, orange) & Eat(benjamin, grape) & -Eat(benjamin, blueberry) & -Eat(benjamin, cherry) & -Eat(benjamin, strawberry).

[CONCLUSION]:
Benjamin ate blueberries at the party.

[CONCLUSION (FOL)]:
Eat(blueberry, benjamin)

[CONCLUSION (GK)]:
Eat(blueberry, benjamin).


===

['x']
['x']
[PREMISE]:
All students who attend in person have registered for the conference. 
Students either attend the conference in person or remotely. 
No students from China attend the conference remotely. 
James attends the conference, but he does not attend the conference remotely.
Jack attends the conference, and he is a student from China.

[PREMISE (FOL)]:
∀x (AttendInPerson(x) → Registered(x))
∀x (Attend(x) → (AttendInPerson(x) ⊕ AttendRemotely(x)))
∀x ((Attend(x) ∧ FromChina(x)) → ¬AttendRemotely(x))
Attend(james) ∧ (¬AttendRemotely(james))
FromChina(jack) ∧ Attend(jack)

[PREMISE (GK)]:
! [X] : (AttendInPerson(X) => Registered(X)).
! [X] : (Attend(X) => (AttendInPerson(X) <~> AttendRemotely(X))).
! [X] : ((Attend(X) & FromChina(X)) => -AttendRemotely(X)).
Attend(james) & (-AttendRemotely(james)).
FromChina(jack) & Attend(jack).

[CONCLUSION]:
James attends the conference but not in person.

[CONCLUSION (FOL)]:
Attend(james) ∧ (¬AttendInPerson(james))

[CONCLUSION (GK)]:
Attend(james) & (-AttendInPerson(james)).


===

['x']
['x']
[PREMISE]:
All students who attend in person have registered for the conference. 
Students either attend the conference in person or remotely. 
No students from China attend the conference remotely. 
James attends the conference, but he does not attend the conference remotely.
Jack attends the conference, and he is a student from China.

[PREMISE (FOL)]:
∀x (AttendInPerson(x) → Registered(x))
∀x (Attend(x) → (AttendInPerson(x) ⊕ AttendRemotely(x)))
∀x ((Attend(x) ∧ FromChina(x)) → ¬AttendRemotely(x))
Attend(james) ∧ (¬AttendRemotely(james))
FromChina(jack) ∧ Attend(jack)

[PREMISE (GK)]:
! [X] : (AttendInPerson(X) => Registered(X)).
! [X] : (Attend(X) => (AttendInPerson(X) <~> AttendRemotely(X))).
! [X] : ((Attend(X) & FromChina(X)) => -AttendRemotely(X)).
Attend(james) & (-AttendRemotely(james)).
FromChina(jack) & Attend(jack).

[CONCLUSION]:
Jack attends the conference in person.

[CONCLUSION (FOL)]:
Attend(jack) ∧ AttendInPerson(jack)

[CONCLUSION (GK)]:
Attend(jack) & AttendInPerson(jack).


===

['x']
['x']
[PREMISE]:
All students who attend in person have registered for the conference. 
Students either attend the conference in person or remotely. 
No students from China attend the conference remotely. 
James attends the conference, but he does not attend the conference remotely.
Jack attends the conference, and he is a student from China.

[PREMISE (FOL)]:
∀x (AttendInPerson(x) → Registered(x))
∀x (Attend(x) → (AttendInPerson(x) ⊕ AttendRemotely(x)))
∀x ((Attend(x) ∧ FromChina(x)) → ¬AttendRemotely(x))
Attend(james) ∧ (¬AttendRemotely(james))
FromChina(jack) ∧ Attend(jack)

[PREMISE (GK)]:
! [X] : (AttendInPerson(X) => Registered(X)).
! [X] : (Attend(X) => (AttendInPerson(X) <~> AttendRemotely(X))).
! [X] : ((Attend(X) & FromChina(X)) => -AttendRemotely(X)).
Attend(james) & (-AttendRemotely(james)).
FromChina(jack) & Attend(jack).

[CONCLUSION]:
Jack has registered for the conference.

[CONCLUSION (FOL)]:
Registered(jack)

[CONCLUSION (GK)]:
Registered(jack).


===

['x', 'y']
['x', 'y']
[PREMISE]:
David Ha'ivri is a political strategist. 
If you are born in Israel to at least one Israeli parent, you receive Israeli citizenship at birth. 
David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents. 
Several Zionist leaders have been elected to the Shomron Regional Municipal council. 
David Ha'ivri is a Zionist leader.

[PREMISE (FOL)]:
PoliticalStrategist(davidHaivri)
∀x ∃y (BornInIsrael(x) ∧ ParentOf(y, x) ∧ Israeli(y) → Israeli(x))
∃x (EmigratedTo(davidHaivri, america) ∧ BornInIsrael(davidHaivri) ∧ ParentOf(davidHaivri, x) ∧ Israeli(x))
∃x (ZionistLeader(x) ∧ ElectedTo(x, shomronMunicipalCouncil))
ZionstLeader(davidHaivri)

[PREMISE (GK)]:
PoliticalStrategist(davidHaivri).
! [X] : ? [Y] : (BornInIsrael(X) & ParentOf(Y, X) & Israeli(Y) => Israeli(X)).
? [X] : (EmigratedTo(davidHaivri, america) & BornInIsrael(davidHaivri) & ParentOf(davidHaivri, X) & Israeli(X)).
? [X] : (ZionistLeader(X) & ElectedTo(X, shomronMunicipalCouncil)).
ZionstLeader(davidHaivri).

[CONCLUSION]:
David Ha'ivri is an Israeli citizen.

[CONCLUSION (FOL)]:
IsraeliCitizen(davidHaivri)

[CONCLUSION (GK)]:
IsraeliCitizen(davidHaivri).


===

['x', 'y']
['x', 'y']
[PREMISE]:
David Ha'ivri is a political strategist. 
If you are born in Israel to at least one Israeli parent, you receive Israeli citizenship at birth. 
David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents. 
Several Zionist leaders have been elected to the Shomron Regional Municipal council. 
David Ha'ivri is a Zionist leader.

[PREMISE (FOL)]:
PoliticalStrategist(davidHaivri)
∀x ∃y (BornInIsrael(x) ∧ ParentOf(y, x) ∧ Israeli(y) → Israeli(x))
∃x (EmigratedTo(davidHaivri, america) ∧ BornInIsrael(davidHaivri) ∧ ParentOf(davidHaivri, x) ∧ Israeli(x))
∃x (ZionistLeader(x) ∧ ElectedTo(x, shomronMunicipalCouncil))
ZionstLeader(davidHaivri)

[PREMISE (GK)]:
PoliticalStrategist(davidHaivri).
! [X] : ? [Y] : (BornInIsrael(X) & ParentOf(Y, X) & Israeli(Y) => Israeli(X)).
? [X] : (EmigratedTo(davidHaivri, america) & BornInIsrael(davidHaivri) & ParentOf(davidHaivri, X) & Israeli(X)).
? [X] : (ZionistLeader(X) & ElectedTo(X, shomronMunicipalCouncil)).
ZionstLeader(davidHaivri).

[CONCLUSION]:
David Ha'ivri is a United States citizen.

[CONCLUSION (FOL)]:
American(davidHaivri)

[CONCLUSION (GK)]:
American(davidHaivri).


===

['x', 'y']
['x', 'y']
[PREMISE]:
David Ha'ivri is a political strategist. 
If you are born in Israel to at least one Israeli parent, you receive Israeli citizenship at birth. 
David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents. 
Several Zionist leaders have been elected to the Shomron Regional Municipal council. 
David Ha'ivri is a Zionist leader.

[PREMISE (FOL)]:
PoliticalStrategist(davidHaivri)
∀x ∃y (BornInIsrael(x) ∧ ParentOf(y, x) ∧ Israeli(y) → Israeli(x))
∃x (EmigratedTo(davidHaivri, america) ∧ BornInIsrael(davidHaivri) ∧ ParentOf(davidHaivri, x) ∧ Israeli(x))
∃x (ZionistLeader(x) ∧ ElectedTo(x, shomronMunicipalCouncil))
ZionstLeader(davidHaivri)

[PREMISE (GK)]:
PoliticalStrategist(davidHaivri).
! [X] : ? [Y] : (BornInIsrael(X) & ParentOf(Y, X) & Israeli(Y) => Israeli(X)).
? [X] : (EmigratedTo(davidHaivri, america) & BornInIsrael(davidHaivri) & ParentOf(davidHaivri, X) & Israeli(X)).
? [X] : (ZionistLeader(X) & ElectedTo(X, shomronMunicipalCouncil)).
ZionstLeader(davidHaivri).

[CONCLUSION]:
David Ha'ivri has been elected to the Shomron Regional Municipal council.

[CONCLUSION (FOL)]:
ElectedTo(davidHaivri, shomronMunicipalCouncil)

[CONCLUSION (GK)]:
ElectedTo(davidHaivri, shomronMunicipalCouncil).


===

['x']
['x']
[PREMISE]:
Mary has the flu.
If someone has the flu, then they have influenza.
Susan doesn't have influenza.

[PREMISE (FOL)]:
Has(mary, flu)
∀x (Has(x, flu) → Has(x, influenza))
¬Has(susan, influenza)

[PREMISE (GK)]:
Has(mary, flu).
! [X] : (Has(X, flu) => Has(X, influenza)).
-Has(susan, influenza).

[CONCLUSION]:
Either Mary or Susan has influenza.

[CONCLUSION (FOL)]:
Has(mary, influenza) ⊕ Has(susan, influenza)

[CONCLUSION (GK)]:
Has(mary, influenza) <~> Has(susan, influenza).


===

['x', 'y']
['x', 'y']
[PREMISE]:
James Cocks was a British lawyer.
James Cocks was a Whig politician who sat in the House of Commons.
A British is a European.
Any lawyer is familiar with laws.
Some Whigs speak French.

[PREMISE (FOL)]:
British(james) ∧ Lawyer(james)
Whig(james) ∧ Politician(james) ∧ SatInHouseOfCommons(james)
∀x (British(x) → European(x))
∀x (Lawyer(x) → FamiliarWithLaws(x))
∃x ∃y (Whig(x) ∧ SpeakFrench(x)) ∧ (¬(x=y)) ∧ (Whig(y) ∧ SpeakFrench(y))

[PREMISE (GK)]:
British(james) & Lawyer(james).
Whig(james) & Politician(james) & SatInHouseOfCommons(james).
! [X] : (British(X) => European(X)).
! [X] : (Lawyer(X) => FamiliarWithLaws(X)).
? [X] : ? [Y] : (Whig(X) & SpeakFrench(X)) & (-(X=Y)) & (Whig(Y) & SpeakFrench(Y)).

[CONCLUSION]:
No lawyer ever sat in the House of Commons.

[CONCLUSION (FOL)]:
∀x (Lawyer(x) → ¬SatInHouseOfCommons(x))

[CONCLUSION (GK)]:
! [X] : (Lawyer(X) => -SatInHouseOfCommons(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
James Cocks was a British lawyer.
James Cocks was a Whig politician who sat in the House of Commons.
A British is a European.
Any lawyer is familiar with laws.
Some Whigs speak French.

[PREMISE (FOL)]:
British(james) ∧ Lawyer(james)
Whig(james) ∧ Politician(james) ∧ SatInHouseOfCommons(james)
∀x (British(x) → European(x))
∀x (Lawyer(x) → FamiliarWithLaws(x))
∃x ∃y (Whig(x) ∧ SpeakFrench(x)) ∧ (¬(x=y)) ∧ (Whig(y) ∧ SpeakFrench(y))

[PREMISE (GK)]:
British(james) & Lawyer(james).
Whig(james) & Politician(james) & SatInHouseOfCommons(james).
! [X] : (British(X) => European(X)).
! [X] : (Lawyer(X) => FamiliarWithLaws(X)).
? [X] : ? [Y] : (Whig(X) & SpeakFrench(X)) & (-(X=Y)) & (Whig(Y) & SpeakFrench(Y)).

[CONCLUSION]:
Some European was familiar with laws.

[CONCLUSION (FOL)]:
∃x (European(x) ∧ FamiliarWithLaws(x))

[CONCLUSION (GK)]:
? [X] : (European(X) & FamiliarWithLaws(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
James Cocks was a British lawyer.
James Cocks was a Whig politician who sat in the House of Commons.
A British is a European.
Any lawyer is familiar with laws.
Some Whigs speak French.

[PREMISE (FOL)]:
British(james) ∧ Lawyer(james)
Whig(james) ∧ Politician(james) ∧ SatInHouseOfCommons(james)
∀x (British(x) → European(x))
∀x (Lawyer(x) → FamiliarWithLaws(x))
∃x ∃y (Whig(x) ∧ SpeakFrench(x)) ∧ (¬(x=y)) ∧ (Whig(y) ∧ SpeakFrench(y))

[PREMISE (GK)]:
British(james) & Lawyer(james).
Whig(james) & Politician(james) & SatInHouseOfCommons(james).
! [X] : (British(X) => European(X)).
! [X] : (Lawyer(X) => FamiliarWithLaws(X)).
? [X] : ? [Y] : (Whig(X) & SpeakFrench(X)) & (-(X=Y)) & (Whig(Y) & SpeakFrench(Y)).

[CONCLUSION]:
James Cocks speaks French.

[CONCLUSION (FOL)]:
SpeakFrench(james)

[CONCLUSION (GK)]:
SpeakFrench(james).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Beasts of Prey is a fantasy novel or a science fiction novel, or both.
Science fiction novels are not about mythological creatures
Beasts of Prey Is about a creature known as the Shetani.
Shetanis are mythological.

[PREMISE (FOL)]:
Novel(beastsOfPrey) → (Fantasy(beastsOfPrey) ∨ ScienceFiction(beastsOfPrey))
∀x ∀y (ScienceFiction(x) ∧ Mythological(y) ∧ Creature(y) → ¬About(x, y))
About(beastsOfPrey, shetani) ∧ Creature(shetani)
Mythological(shetani)

[PREMISE (GK)]:
Novel(beastsOfPrey) => (Fantasy(beastsOfPrey) | ScienceFiction(beastsOfPrey)).
! [X] : ! [Y] : (ScienceFiction(X) & Mythological(Y) & Creature(Y) => -About(X, Y)).
About(beastsOfPrey, shetani) & Creature(shetani).
Mythological(shetani).

[CONCLUSION]:
Beasts of prey is a fantasy novel.

[CONCLUSION (FOL)]:
Fantasy(beastsOfpPrey) ∧ Novel(beastsOfPrey)

[CONCLUSION (GK)]:
Fantasy(beastsOfpPrey) & Novel(beastsOfPrey).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Beasts of Prey is a fantasy novel or a science fiction novel, or both.
Science fiction novels are not about mythological creatures
Beasts of Prey Is about a creature known as the Shetani.
Shetanis are mythological.

[PREMISE (FOL)]:
Novel(beastsOfPrey) → (Fantasy(beastsOfPrey) ∨ ScienceFiction(beastsOfPrey))
∀x ∀y (ScienceFiction(x) ∧ Mythological(y) ∧ Creature(y) → ¬About(x, y))
About(beastsOfPrey, shetani) ∧ Creature(shetani)
Mythological(shetani)

[PREMISE (GK)]:
Novel(beastsOfPrey) => (Fantasy(beastsOfPrey) | ScienceFiction(beastsOfPrey)).
! [X] : ! [Y] : (ScienceFiction(X) & Mythological(Y) & Creature(Y) => -About(X, Y)).
About(beastsOfPrey, shetani) & Creature(shetani).
Mythological(shetani).

[CONCLUSION]:
Beasts of prey isn't a science fiction novel.

[CONCLUSION (FOL)]:
¬ScienceFiction(beastsofprey) ∧ Novel(beastsOfPrey)

[CONCLUSION (GK)]:
-ScienceFiction(beastsofprey) & Novel(beastsOfPrey).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Beasts of Prey is a fantasy novel or a science fiction novel, or both.
Science fiction novels are not about mythological creatures
Beasts of Prey Is about a creature known as the Shetani.
Shetanis are mythological.

[PREMISE (FOL)]:
Novel(beastsOfPrey) → (Fantasy(beastsOfPrey) ∨ ScienceFiction(beastsOfPrey))
∀x ∀y (ScienceFiction(x) ∧ Mythological(y) ∧ Creature(y) → ¬About(x, y))
About(beastsOfPrey, shetani) ∧ Creature(shetani)
Mythological(shetani)

[PREMISE (GK)]:
Novel(beastsOfPrey) => (Fantasy(beastsOfPrey) | ScienceFiction(beastsOfPrey)).
! [X] : ! [Y] : (ScienceFiction(X) & Mythological(Y) & Creature(Y) => -About(X, Y)).
About(beastsOfPrey, shetani) & Creature(shetani).
Mythological(shetani).

[CONCLUSION]:
A shetani is either mythological or a creature.

[CONCLUSION (FOL)]:
Mythological(shetani) ⊕ Creature(shetani)

[CONCLUSION (GK)]:
Mythological(shetani) <~> Creature(shetani).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Odell is an English surname originating in Odell, Bedfordshire.
In some families, Odell is spelled O'Dell in a mistaken Irish adaptation.
Notable people with surnames include Amy Odell, Jack Odell, and Mats Odell.
Amy Odell is a British singer-songwriter.
Jack Odell is an English toy inventor.

[PREMISE (FOL)]:
Surname(nameODell) ∧ From(nameODell, oDellBedfordshire)
MistakenSpellingOf(nameO'Dell, nameODell) ∧ (∃x∃y(Family(x) ∧ Named(x, nameO'Dell) ∧ (¬(x=y)) ∧ Family(y) ∧ Named(y, nameO'Dell))
Named(amyODell, nameODell) ∧ NotablePerson(amyODell) ∧ Named(jackODell, nameODell) ∧ NotablePerson(jackODell) ∧ Named(matsODell, nameODell) ∧ NotablePerson(matsODell)
British(amyODell) ∧ Singer(amyODell) ∧ SongWriter(amyODell)
English(jackODell) ∧ ToyInventor(jackODell)

[PREMISE (GK)]:
Surname(nameODell) & From(nameODell, oDellBedfordshire).
MistakenSpellingOf(nameO'Dell, nameODell) & (? [X] :? [Y] :(Family(X) & Named(X, nameO'Dell) & (-(X=Y)) & Family(Y) & Named(Y, nameO'Dell)).
Named(amyODell, nameODell) & NotablePerson(amyODell) & Named(jackODell, nameODell) & NotablePerson(jackODell) & Named(matsODell, nameODell) & NotablePerson(matsODell).
British(amyODell) & Singer(amyODell) & SongWriter(amyODell).
English(jackODell) & ToyInventor(jackODell).

[CONCLUSION]:
Jack Odell is a notable person.

[CONCLUSION (FOL)]:
NotablePerson(jackODell)

[CONCLUSION (GK)]:
NotablePerson(jackODell).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Odell is an English surname originating in Odell, Bedfordshire.
In some families, Odell is spelled O'Dell in a mistaken Irish adaptation.
Notable people with surnames include Amy Odell, Jack Odell, and Mats Odell.
Amy Odell is a British singer-songwriter.
Jack Odell is an English toy inventor.

[PREMISE (FOL)]:
Surname(nameODell) ∧ From(nameODell, oDellBedfordshire)
MistakenSpellingOf(nameO'Dell, nameODell) ∧ (∃x∃y(Family(x) ∧ Named(x, nameO'Dell) ∧ (¬(x=y)) ∧ Family(y) ∧ Named(y, nameO'Dell))
Named(amyODell, nameODell) ∧ NotablePerson(amyODell) ∧ Named(jackODell, nameODell) ∧ NotablePerson(jackODell) ∧ Named(matsODell, nameODell) ∧ NotablePerson(matsODell)
British(amyODell) ∧ Singer(amyODell) ∧ SongWriter(amyODell)
English(jackODell) ∧ ToyInventor(jackODell)

[PREMISE (GK)]:
Surname(nameODell) & From(nameODell, oDellBedfordshire).
MistakenSpellingOf(nameO'Dell, nameODell) & (? [X] :? [Y] :(Family(X) & Named(X, nameO'Dell) & (-(X=Y)) & Family(Y) & Named(Y, nameO'Dell)).
Named(amyODell, nameODell) & NotablePerson(amyODell) & Named(jackODell, nameODell) & NotablePerson(jackODell) & Named(matsODell, nameODell) & NotablePerson(matsODell).
British(amyODell) & Singer(amyODell) & SongWriter(amyODell).
English(jackODell) & ToyInventor(jackODell).

[CONCLUSION]:
Odell is Amy Odell's surname.

[CONCLUSION (FOL)]:
Named(amyODell, nameODell)

[CONCLUSION (GK)]:
Named(amyODell, nameODell).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Odell is an English surname originating in Odell, Bedfordshire.
In some families, Odell is spelled O'Dell in a mistaken Irish adaptation.
Notable people with surnames include Amy Odell, Jack Odell, and Mats Odell.
Amy Odell is a British singer-songwriter.
Jack Odell is an English toy inventor.

[PREMISE (FOL)]:
Surname(nameODell) ∧ From(nameODell, oDellBedfordshire)
MistakenSpellingOf(nameO'Dell, nameODell) ∧ (∃x∃y(Family(x) ∧ Named(x, nameO'Dell) ∧ (¬(x=y)) ∧ Family(y) ∧ Named(y, nameO'Dell))
Named(amyODell, nameODell) ∧ NotablePerson(amyODell) ∧ Named(jackODell, nameODell) ∧ NotablePerson(jackODell) ∧ Named(matsODell, nameODell) ∧ NotablePerson(matsODell)
British(amyODell) ∧ Singer(amyODell) ∧ SongWriter(amyODell)
English(jackODell) ∧ ToyInventor(jackODell)

[PREMISE (GK)]:
Surname(nameODell) & From(nameODell, oDellBedfordshire).
MistakenSpellingOf(nameO'Dell, nameODell) & (? [X] :? [Y] :(Family(X) & Named(X, nameO'Dell) & (-(X=Y)) & Family(Y) & Named(Y, nameO'Dell)).
Named(amyODell, nameODell) & NotablePerson(amyODell) & Named(jackODell, nameODell) & NotablePerson(jackODell) & Named(matsODell, nameODell) & NotablePerson(matsODell).
British(amyODell) & Singer(amyODell) & SongWriter(amyODell).
English(jackODell) & ToyInventor(jackODell).

[CONCLUSION]:
Amy Odell is an English toy inventor.

[CONCLUSION (FOL)]:
English(amyODell) ∧ ToyInventor(amyODell)

[CONCLUSION (GK)]:
English(amyODell) & ToyInventor(amyODell).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Odell is an English surname originating in Odell, Bedfordshire.
In some families, Odell is spelled O'Dell in a mistaken Irish adaptation.
Notable people with surnames include Amy Odell, Jack Odell, and Mats Odell.
Amy Odell is a British singer-songwriter.
Jack Odell is an English toy inventor.

[PREMISE (FOL)]:
Surname(nameODell) ∧ From(nameODell, oDellBedfordshire)
MistakenSpellingOf(nameO'Dell, nameODell) ∧ (∃x∃y(Family(x) ∧ Named(x, nameO'Dell) ∧ (¬(x=y)) ∧ Family(y) ∧ Named(y, nameO'Dell))
Named(amyODell, nameODell) ∧ NotablePerson(amyODell) ∧ Named(jackODell, nameODell) ∧ NotablePerson(jackODell) ∧ Named(matsODell, nameODell) ∧ NotablePerson(matsODell)
British(amyODell) ∧ Singer(amyODell) ∧ SongWriter(amyODell)
English(jackODell) ∧ ToyInventor(jackODell)

[PREMISE (GK)]:
Surname(nameODell) & From(nameODell, oDellBedfordshire).
MistakenSpellingOf(nameO'Dell, nameODell) & (? [X] :? [Y] :(Family(X) & Named(X, nameO'Dell) & (-(X=Y)) & Family(Y) & Named(Y, nameO'Dell)).
Named(amyODell, nameODell) & NotablePerson(amyODell) & Named(jackODell, nameODell) & NotablePerson(jackODell) & Named(matsODell, nameODell) & NotablePerson(matsODell).
British(amyODell) & Singer(amyODell) & SongWriter(amyODell).
English(jackODell) & ToyInventor(jackODell).

[CONCLUSION]:
Amy Odell is also Amy O'Dell.

[CONCLUSION (FOL)]:
Named(amyODell, nameODell) ∧ Named(amyODell, nameO'Dell)

[CONCLUSION (GK)]:
Named(amyODell, nameODell) & Named(amyODell, nameO'Dell).


===

['x']
['x']
[PREMISE]:
If you go somewhere by train, you will not lose time.
If you go somewhere by car and meet a traffic jam, you will lose time.
If you lose time, you will be late for work.
Mary can get from New Haven to New York City either by train or car.
Mary is late for work.

[PREMISE (FOL)]:
∀x (GoByTrain(x) → ¬LoseTime(x))
∀x((GoByCar(x) ∧ Meet(x, trafficJam)) → LoseTime(x))
∀x (LoseTime(x) → LateForWork(x))
FromAndTo(newHaven, newYork) ∧ (GoByTrain(mary) ⊕ GoByCar(mary))
LateForWork(mary)

[PREMISE (GK)]:
! [X] : (GoByTrain(X) => -LoseTime(X)).
! [X] :((GoByCar(X) & Meet(X, trafficJam)) => LoseTime(X)).
! [X] : (LoseTime(X) => LateForWork(X)).
FromAndTo(newHaven, newYork) & (GoByTrain(mary) <~> GoByCar(mary)).
LateForWork(mary).

[CONCLUSION]:
Mary gets from New Haven to New York City by train.

[CONCLUSION (FOL)]:
FromAndTo(newHaven, newYork) ∧ GoByTrain(mary)

[CONCLUSION (GK)]:
FromAndTo(newHaven, newYork) & GoByTrain(mary).


===

['x']
['x']
[PREMISE]:
If you go somewhere by train, you will not lose time.
If you go somewhere by car and meet a traffic jam, you will lose time.
If you lose time, you will be late for work.
Mary can get from New Haven to New York City either by train or car.
Mary is late for work.

[PREMISE (FOL)]:
∀x (GoByTrain(x) → ¬LoseTime(x))
∀x((GoByCar(x) ∧ Meet(x, trafficJam)) → LoseTime(x))
∀x (LoseTime(x) → LateForWork(x))
FromAndTo(newHaven, newYork) ∧ (GoByTrain(mary) ⊕ GoByCar(mary))
LateForWork(mary)

[PREMISE (GK)]:
! [X] : (GoByTrain(X) => -LoseTime(X)).
! [X] :((GoByCar(X) & Meet(X, trafficJam)) => LoseTime(X)).
! [X] : (LoseTime(X) => LateForWork(X)).
FromAndTo(newHaven, newYork) & (GoByTrain(mary) <~> GoByCar(mary)).
LateForWork(mary).

[CONCLUSION]:
Mary gets from New Haven to New York City by car.

[CONCLUSION (FOL)]:
FromAndTo(newHaven, newYork) ∧ GoByCar(mary)

[CONCLUSION (GK)]:
FromAndTo(newHaven, newYork) & GoByCar(mary).


===

['x']
['x']
[PREMISE]:
If you go somewhere by train, you will not lose time.
If you go somewhere by car and meet a traffic jam, you will lose time.
If you lose time, you will be late for work.
Mary can get from New Haven to New York City either by train or car.
Mary is late for work.

[PREMISE (FOL)]:
∀x (GoByTrain(x) → ¬LoseTime(x))
∀x((GoByCar(x) ∧ Meet(x, trafficJam)) → LoseTime(x))
∀x (LoseTime(x) → LateForWork(x))
FromAndTo(newHaven, newYork) ∧ (GoByTrain(mary) ⊕ GoByCar(mary))
LateForWork(mary)

[PREMISE (GK)]:
! [X] : (GoByTrain(X) => -LoseTime(X)).
! [X] :((GoByCar(X) & Meet(X, trafficJam)) => LoseTime(X)).
! [X] : (LoseTime(X) => LateForWork(X)).
FromAndTo(newHaven, newYork) & (GoByTrain(mary) <~> GoByCar(mary)).
LateForWork(mary).

[CONCLUSION]:
Mary meets a traffic jam.

[CONCLUSION (FOL)]:
Meet(mary, trafficJam)

[CONCLUSION (GK)]:
Meet(mary, trafficJam).


===

['x']
['x']
[PREMISE]:
If a person is hungry, the person is uncomfortable.
If a person is uncomfortable, the person is unhappy.

[PREMISE (FOL)]:
∀x (Hungry(x) → Uncomfortable(x))
∀x (Uncomfortable(x) → ¬Happy(x))

[PREMISE (GK)]:
! [X] : (Hungry(X) => Uncomfortable(X)).
! [X] : (Uncomfortable(X) => -Happy(X)).

[CONCLUSION]:
If a person is not hungry, the person is unhappy.

[CONCLUSION (FOL)]:
∀x (¬Hungry(x) → ¬Happy(x))

[CONCLUSION (GK)]:
! [X] : (-Hungry(X) => -Happy(X)).


===

['x']
['x']
[PREMISE]:
Tipped employees are not entitled to be paid the federal minimum wage by their employees. 
If a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. 
All lawyers are white-collar workers.
Every advocate is a lawyer.
Mary is not a lawyer or a tipped employee.

[PREMISE (FOL)]:
∀x (TippedEmployee(x) → ¬EntitledTo(x, federalMinimumWage))
∀x (WhiteCollarWorker(x) → EntitledTo(x, federalMinimumWage))
∀x (Lawyer(x) → WhiteCollarWorker(x))
∀x (Advocate(x) → Lawyer(x))
¬(Lawyer(mary) ⊕ TippedEmployee(mary))

[PREMISE (GK)]:
! [X] : (TippedEmployee(X) => -EntitledTo(X, federalMinimumWage)).
! [X] : (WhiteCollarWorker(X) => EntitledTo(X, federalMinimumWage)).
! [X] : (Lawyer(X) => WhiteCollarWorker(X)).
! [X] : (Advocate(X) => Lawyer(X)).
-(Lawyer(mary) <~> TippedEmployee(mary)).

[CONCLUSION]:
Mary is a white-collar worker.

[CONCLUSION (FOL)]:
WhiteCollarWorker(mary)

[CONCLUSION (GK)]:
WhiteCollarWorker(mary).


===

['x']
['x']
[PREMISE]:
Tipped employees are not entitled to be paid the federal minimum wage by their employees. 
If a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. 
All lawyers are white-collar workers.
Every advocate is a lawyer.
Mary is not a lawyer or a tipped employee.

[PREMISE (FOL)]:
∀x (TippedEmployee(x) → ¬EntitledTo(x, federalMinimumWage))
∀x (WhiteCollarWorker(x) → EntitledTo(x, federalMinimumWage))
∀x (Lawyer(x) → WhiteCollarWorker(x))
∀x (Advocate(x) → Lawyer(x))
¬(Lawyer(mary) ⊕ TippedEmployee(mary))

[PREMISE (GK)]:
! [X] : (TippedEmployee(X) => -EntitledTo(X, federalMinimumWage)).
! [X] : (WhiteCollarWorker(X) => EntitledTo(X, federalMinimumWage)).
! [X] : (Lawyer(X) => WhiteCollarWorker(X)).
! [X] : (Advocate(X) => Lawyer(X)).
-(Lawyer(mary) <~> TippedEmployee(mary)).

[CONCLUSION]:
Mary is an advocate.

[CONCLUSION (FOL)]:
Advocate(mary)

[CONCLUSION (GK)]:
Advocate(mary).


===

['x']
['x']
[PREMISE]:
Tipped employees are not entitled to be paid the federal minimum wage by their employees. 
If a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. 
All lawyers are white-collar workers.
Every advocate is a lawyer.
Mary is not a lawyer or a tipped employee.

[PREMISE (FOL)]:
∀x (TippedEmployee(x) → ¬EntitledTo(x, federalMinimumWage))
∀x (WhiteCollarWorker(x) → EntitledTo(x, federalMinimumWage))
∀x (Lawyer(x) → WhiteCollarWorker(x))
∀x (Advocate(x) → Lawyer(x))
¬(Lawyer(mary) ⊕ TippedEmployee(mary))

[PREMISE (GK)]:
! [X] : (TippedEmployee(X) => -EntitledTo(X, federalMinimumWage)).
! [X] : (WhiteCollarWorker(X) => EntitledTo(X, federalMinimumWage)).
! [X] : (Lawyer(X) => WhiteCollarWorker(X)).
! [X] : (Advocate(X) => Lawyer(X)).
-(Lawyer(mary) <~> TippedEmployee(mary)).

[CONCLUSION]:
Mary is not an advocate.

[CONCLUSION (FOL)]:
¬Advocate(mary)

[CONCLUSION (GK)]:
-Advocate(mary).


===

['x']
['x']
[PREMISE]:
Tipped employees are not entitled to be paid the federal minimum wage by their employees. 
If a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. 
All lawyers are white-collar workers.
Every advocate is a lawyer.
Mary is not a lawyer or a tipped employee.

[PREMISE (FOL)]:
∀x (TippedEmployee(x) → ¬EntitledTo(x, federalMinimumWage))
∀x (WhiteCollarWorker(x) → EntitledTo(x, federalMinimumWage))
∀x (Lawyer(x) → WhiteCollarWorker(x))
∀x (Advocate(x) → Lawyer(x))
¬(Lawyer(mary) ⊕ TippedEmployee(mary))

[PREMISE (GK)]:
! [X] : (TippedEmployee(X) => -EntitledTo(X, federalMinimumWage)).
! [X] : (WhiteCollarWorker(X) => EntitledTo(X, federalMinimumWage)).
! [X] : (Lawyer(X) => WhiteCollarWorker(X)).
! [X] : (Advocate(X) => Lawyer(X)).
-(Lawyer(mary) <~> TippedEmployee(mary)).

[CONCLUSION]:
Mary is either an advocate or a tipped employee.

[CONCLUSION (FOL)]:
Advocate(mary) ⊕ TippedEmployee(mary)

[CONCLUSION (GK)]:
Advocate(mary) <~> TippedEmployee(mary).


===

['x']
['x']
[PREMISE]:
Tipped employees are not entitled to be paid the federal minimum wage by their employees. 
If a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. 
All lawyers are white-collar workers.
Every advocate is a lawyer.
Mary is not a lawyer or a tipped employee.

[PREMISE (FOL)]:
∀x (TippedEmployee(x) → ¬EntitledTo(x, federalMinimumWage))
∀x (WhiteCollarWorker(x) → EntitledTo(x, federalMinimumWage))
∀x (Lawyer(x) → WhiteCollarWorker(x))
∀x (Advocate(x) → Lawyer(x))
¬(Lawyer(mary) ⊕ TippedEmployee(mary))

[PREMISE (GK)]:
! [X] : (TippedEmployee(X) => -EntitledTo(X, federalMinimumWage)).
! [X] : (WhiteCollarWorker(X) => EntitledTo(X, federalMinimumWage)).
! [X] : (Lawyer(X) => WhiteCollarWorker(X)).
! [X] : (Advocate(X) => Lawyer(X)).
-(Lawyer(mary) <~> TippedEmployee(mary)).

[CONCLUSION]:
If Mary is not both an advocate and is entitled to be paid the federal minimum wage by their employees, she is not a tipped employee.

[CONCLUSION (FOL)]:
(¬(Advocate(mary) ∧ EntitledTo(mary, federalMinimumWage))) → ¬TippedEmployee(mary)

[CONCLUSION (GK)]:
(-(Advocate(mary) & EntitledTo(mary, federalMinimumWage))) => -TippedEmployee(mary).


===

['x']
['x']
[PREMISE]:
Tipped employees are not entitled to be paid the federal minimum wage by their employees. 
If a person is a white-collar worker, they are entitled to be paid the federal minimum wage by their employees. 
All lawyers are white-collar workers.
Every advocate is a lawyer.
Mary is not a lawyer or a tipped employee.

[PREMISE (FOL)]:
∀x (TippedEmployee(x) → ¬EntitledTo(x, federalMinimumWage))
∀x (WhiteCollarWorker(x) → EntitledTo(x, federalMinimumWage))
∀x (Lawyer(x) → WhiteCollarWorker(x))
∀x (Advocate(x) → Lawyer(x))
¬(Lawyer(mary) ⊕ TippedEmployee(mary))

[PREMISE (GK)]:
! [X] : (TippedEmployee(X) => -EntitledTo(X, federalMinimumWage)).
! [X] : (WhiteCollarWorker(X) => EntitledTo(X, federalMinimumWage)).
! [X] : (Lawyer(X) => WhiteCollarWorker(X)).
! [X] : (Advocate(X) => Lawyer(X)).
-(Lawyer(mary) <~> TippedEmployee(mary)).

[CONCLUSION]:
If Mary is either an advocate or a tipped employee, she is an advocate.

[CONCLUSION (FOL)]:
(Advocate(mary) ⊕ TippedEmployee(mary)) → Advocate(mary)

[CONCLUSION (GK)]:
(Advocate(mary) <~> TippedEmployee(mary)) => Advocate(mary).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Asa Hoffmann was born in New York City.
Asa Hoffman lives in Manhattan.
Asa Hoffman is a chess player.
Some chess players are grandmasters.
People born and living in New York City are New Yorkers.
People living in Manhattan live in New York City.

[PREMISE (FOL)]:
BornIn(asaHoffmann, newYorkCity)
LiveIn(asaHoffmann, manhattan)
ChessPlayer(asaHoffmann)
∃x ∃y (ChessPlayer(x) ∧ GrandMaster(x) ∧ (¬(x=y)) ∧ ChessPlayer(y) ∧ GrandMaster(y))
∀x ((BornIn(x, newYorkCity) ∧ LiveIn(x, newYorkCity)) → NewYorker(x))
∀x (LiveIn(x, manhattan) → LiveIn(x, newYorkCity))

[PREMISE (GK)]:
BornIn(asaHoffmann, newYorkCity).
LiveIn(asaHoffmann, manhattan).
ChessPlayer(asaHoffmann).
? [X] : ? [Y] : (ChessPlayer(X) & GrandMaster(X) & (-(X=Y)) & ChessPlayer(Y) & GrandMaster(Y)).
! [X] : ((BornIn(X, newYorkCity) & LiveIn(X, newYorkCity)) => NewYorker(X)).
! [X] : (LiveIn(X, manhattan) => LiveIn(X, newYorkCity)).

[CONCLUSION]:
Asa Hoffmann is a New Yorker.

[CONCLUSION (FOL)]:
NewYorker(asaHoffmann)

[CONCLUSION (GK)]:
NewYorker(asaHoffmann).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Asa Hoffmann was born in New York City.
Asa Hoffman lives in Manhattan.
Asa Hoffman is a chess player.
Some chess players are grandmasters.
People born and living in New York City are New Yorkers.
People living in Manhattan live in New York City.

[PREMISE (FOL)]:
BornIn(asaHoffmann, newYorkCity)
LiveIn(asaHoffmann, manhattan)
ChessPlayer(asaHoffmann)
∃x ∃y (ChessPlayer(x) ∧ GrandMaster(x) ∧ (¬(x=y)) ∧ ChessPlayer(y) ∧ GrandMaster(y))
∀x ((BornIn(x, newYorkCity) ∧ LiveIn(x, newYorkCity)) → NewYorker(x))
∀x (LiveIn(x, manhattan) → LiveIn(x, newYorkCity))

[PREMISE (GK)]:
BornIn(asaHoffmann, newYorkCity).
LiveIn(asaHoffmann, manhattan).
ChessPlayer(asaHoffmann).
? [X] : ? [Y] : (ChessPlayer(X) & GrandMaster(X) & (-(X=Y)) & ChessPlayer(Y) & GrandMaster(Y)).
! [X] : ((BornIn(X, newYorkCity) & LiveIn(X, newYorkCity)) => NewYorker(X)).
! [X] : (LiveIn(X, manhattan) => LiveIn(X, newYorkCity)).

[CONCLUSION]:
Asa Hoffmann is a grandmaster.

[CONCLUSION (FOL)]:
GrandMaster(asaHoffmann)

[CONCLUSION (GK)]:
GrandMaster(asaHoffmann).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Asa Hoffmann was born in New York City.
Asa Hoffman lives in Manhattan.
Asa Hoffman is a chess player.
Some chess players are grandmasters.
People born and living in New York City are New Yorkers.
People living in Manhattan live in New York City.

[PREMISE (FOL)]:
BornIn(asaHoffmann, newYorkCity)
LiveIn(asaHoffmann, manhattan)
ChessPlayer(asaHoffmann)
∃x ∃y (ChessPlayer(x) ∧ GrandMaster(x) ∧ (¬(x=y)) ∧ ChessPlayer(y) ∧ GrandMaster(y))
∀x ((BornIn(x, newYorkCity) ∧ LiveIn(x, newYorkCity)) → NewYorker(x))
∀x (LiveIn(x, manhattan) → LiveIn(x, newYorkCity))

[PREMISE (GK)]:
BornIn(asaHoffmann, newYorkCity).
LiveIn(asaHoffmann, manhattan).
ChessPlayer(asaHoffmann).
? [X] : ? [Y] : (ChessPlayer(X) & GrandMaster(X) & (-(X=Y)) & ChessPlayer(Y) & GrandMaster(Y)).
! [X] : ((BornIn(X, newYorkCity) & LiveIn(X, newYorkCity)) => NewYorker(X)).
! [X] : (LiveIn(X, manhattan) => LiveIn(X, newYorkCity)).

[CONCLUSION]:
Asa Hoffmann does not live in New York.

[CONCLUSION (FOL)]:
¬LiveIn(asaHoffmann, newYorkCity)

[CONCLUSION (GK)]:
-LiveIn(asaHoffmann, newYorkCity).


===

['x']
['x']
[PREMISE]:
Some of those who apply for a Schengen visa get it.
To apply for a Schengen Visa, you need to provide financial guarantees.
If you need to provide financial guarantees, you must request documents from the bank.
Do not close your bank account if you request documents from the bank.
Philip closed his bank account.

[PREMISE (FOL)]:
∃x (Apply(x, schengenVisa) → Get(x, schengenVisa))
∀x (Apply(x, schengenVisa) → Provide(x, financialGuarantees))
∀x (Provide(x, financialGuarantees) → Request(x, documentsFromBank))
∀x (Request(x, documentsFromBank) → ¬Close(x, bankAccount))
Close(philip, bankAccount)

[PREMISE (GK)]:
? [X] : (Apply(X, schengenVisa) => Get(X, schengenVisa)).
! [X] : (Apply(X, schengenVisa) => Provide(X, financialGuarantees)).
! [X] : (Provide(X, financialGuarantees) => Request(X, documentsFromBank)).
! [X] : (Request(X, documentsFromBank) => -Close(X, bankAccount)).
Close(philip, bankAccount).

[CONCLUSION]:
Philip got a Schengen visa.

[CONCLUSION (FOL)]:
Get(philip, schengenVisa)

[CONCLUSION (GK)]:
Get(philip, schengenVisa).


===

['x']
['x']
[PREMISE]:
Some of those who apply for a Schengen visa get it.
To apply for a Schengen Visa, you need to provide financial guarantees.
If you need to provide financial guarantees, you must request documents from the bank.
Do not close your bank account if you request documents from the bank.
Philip closed his bank account.

[PREMISE (FOL)]:
∃x (Apply(x, schengenVisa) → Get(x, schengenVisa))
∀x (Apply(x, schengenVisa) → Provide(x, financialGuarantees))
∀x (Provide(x, financialGuarantees) → Request(x, documentsFromBank))
∀x (Request(x, documentsFromBank) → ¬Close(x, bankAccount))
Close(philip, bankAccount)

[PREMISE (GK)]:
? [X] : (Apply(X, schengenVisa) => Get(X, schengenVisa)).
! [X] : (Apply(X, schengenVisa) => Provide(X, financialGuarantees)).
! [X] : (Provide(X, financialGuarantees) => Request(X, documentsFromBank)).
! [X] : (Request(X, documentsFromBank) => -Close(X, bankAccount)).
Close(philip, bankAccount).

[CONCLUSION]:
Philip applied for a Schengen visa and got it.

[CONCLUSION (FOL)]:
Apply(philip, schengenVisa) ∧ Get(philip, schengenVisa)

[CONCLUSION (GK)]:
Apply(philip, schengenVisa) & Get(philip, schengenVisa).


===

['x']
['x']
[PREMISE]:
Some of those who apply for a Schengen visa get it.
To apply for a Schengen Visa, you need to provide financial guarantees.
If you need to provide financial guarantees, you must request documents from the bank.
Do not close your bank account if you request documents from the bank.
Philip closed his bank account.

[PREMISE (FOL)]:
∃x (Apply(x, schengenVisa) → Get(x, schengenVisa))
∀x (Apply(x, schengenVisa) → Provide(x, financialGuarantees))
∀x (Provide(x, financialGuarantees) → Request(x, documentsFromBank))
∀x (Request(x, documentsFromBank) → ¬Close(x, bankAccount))
Close(philip, bankAccount)

[PREMISE (GK)]:
? [X] : (Apply(X, schengenVisa) => Get(X, schengenVisa)).
! [X] : (Apply(X, schengenVisa) => Provide(X, financialGuarantees)).
! [X] : (Provide(X, financialGuarantees) => Request(X, documentsFromBank)).
! [X] : (Request(X, documentsFromBank) => -Close(X, bankAccount)).
Close(philip, bankAccount).

[CONCLUSION]:
If Philip did not request documents from the bank or get a Schengen visa, he didn’t apply for a Schengen visa.

[CONCLUSION (FOL)]:
(¬Request(philip, documentsFromBank) ∧ ¬Get(x, schengenVisa)) → Apply(x, schengenVisa)

[CONCLUSION (GK)]:
(-Request(philip, documentsFromBank) & -Get(X, schengenVisa)) => Apply(X, schengenVisa).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Some fears lead to anxiety.
Some anxiety leads to terror.

[PREMISE (FOL)]:
∃x ∃y (Fear(x) ∧ Anxiety(y) ∧ LeadTo(x, y) ∧ ¬(x=y))
∃x ∃y (Anxiety(x) ∧ Terror(y) ∧ LeadTo(x, y))

[PREMISE (GK)]:
? [X] : ? [Y] : (Fear(X) & Anxiety(Y) & LeadTo(X, Y) & -(X=Y)).
? [X] : ? [Y] : (Anxiety(X) & Terror(Y) & LeadTo(X, Y)).

[CONCLUSION]:
No fears lead to terror.

[CONCLUSION (FOL)]:
∀x ∀y (Fear(x) → ¬(Terror(y) ∧ LeadTo(x, y)))

[CONCLUSION (GK)]:
! [X] : ! [Y] : (Fear(X) => -(Terror(Y) & LeadTo(X, Y))).


===

['x', 'y']
['x', 'y']
[PREMISE]:
The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.
Some major settlements of Lake Erie are in NY, PA, OH, and MI.
NY, PA, OH, and MI are states in the US.
ON is a state of Canada.
There is a major settlement of Lake Huron in ON. 
All states are in their country.
The US is in North America.
The Great Lakes began to form at the end of the Last Glacial Period.

[PREMISE (FOL)]:
∀x (GreatLake(x) → Superior(x) ⊕ Michigan(x) ⊕ Huron(x) ⊕ Erie(x) ⊕ Ontario(x))
∀x (Erie (x) ∧ MajorSettlement(x) → In(x, nY) ∨ In(x, pA) ∨ In(x, oH) ∨ In(x, mI))
StateOf(nY, uS) ∧ StateOf(pA, uS) ∧ StateOf(oH, uS) ∧ StateOf(mI, uS)
StateOf(oN, canada)
∃x (Huron(x) ∧ MajorSettlement(x) ∧ In(x, oN))
∀x ∀y (StateOf(x, y) → In(x, y))
In(us, northAmerica)
∀x (GreatLake(x) → FormAtEndOf(x, lastGlacialPeriod))

[PREMISE (GK)]:
! [X] : (GreatLake(X) => Superior(X) <~> Michigan(X) <~> Huron(X) <~> Erie(X) <~> Ontario(X)).
! [X] : (Erie (X) & MajorSettlement(X) => In(X, nY) | In(X, pA) | In(X, oH) | In(X, mI)).
StateOf(nY, uS) & StateOf(pA, uS) & StateOf(oH, uS) & StateOf(mI, uS).
StateOf(oN, canada).
? [X] : (Huron(X) & MajorSettlement(X) & In(X, oN)).
! [X] : ! [Y] : (StateOf(X, Y) => In(X, Y)).
In(us, northAmerica).
! [X] : (GreatLake(X) => FormAtEndOf(X, lastGlacialPeriod)).

[CONCLUSION]:
Lake Erie has a major settlement.

[CONCLUSION (FOL)]:
∃x ∃y (Erie(y) ∧ MajorSettlementOf(x, y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Erie(Y) & MajorSettlementOf(X, Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.
Some major settlements of Lake Erie are in NY, PA, OH, and MI.
NY, PA, OH, and MI are states in the US.
ON is a state of Canada.
There is a major settlement of Lake Huron in ON. 
All states are in their country.
The US is in North America.
The Great Lakes began to form at the end of the Last Glacial Period.

[PREMISE (FOL)]:
∀x (GreatLake(x) → Superior(x) ⊕ Michigan(x) ⊕ Huron(x) ⊕ Erie(x) ⊕ Ontario(x))
∀x (Erie (x) ∧ MajorSettlement(x) → In(x, nY) ∨ In(x, pA) ∨ In(x, oH) ∨ In(x, mI))
StateOf(nY, uS) ∧ StateOf(pA, uS) ∧ StateOf(oH, uS) ∧ StateOf(mI, uS)
StateOf(oN, canada)
∃x (Huron(x) ∧ MajorSettlement(x) ∧ In(x, oN))
∀x ∀y (StateOf(x, y) → In(x, y))
In(us, northAmerica)
∀x (GreatLake(x) → FormAtEndOf(x, lastGlacialPeriod))

[PREMISE (GK)]:
! [X] : (GreatLake(X) => Superior(X) <~> Michigan(X) <~> Huron(X) <~> Erie(X) <~> Ontario(X)).
! [X] : (Erie (X) & MajorSettlement(X) => In(X, nY) | In(X, pA) | In(X, oH) | In(X, mI)).
StateOf(nY, uS) & StateOf(pA, uS) & StateOf(oH, uS) & StateOf(mI, uS).
StateOf(oN, canada).
? [X] : (Huron(X) & MajorSettlement(X) & In(X, oN)).
! [X] : ! [Y] : (StateOf(X, Y) => In(X, Y)).
In(us, northAmerica).
! [X] : (GreatLake(X) => FormAtEndOf(X, lastGlacialPeriod)).

[CONCLUSION]:
There is a great lake that did not form at the end of the Last Glacial Period.

[CONCLUSION (FOL)]:
∃x (GreatLake(x) ∧ ¬FormAtEndOf(x, lastGlacialPeriod))

[CONCLUSION (GK)]:
? [X] : (GreatLake(X) & -FormAtEndOf(X, lastGlacialPeriod)).


===

['x']
['x']
[PREMISE]:
All professional soccer defenders are professional soccer players.
No professional soccer players are professional basketball players.
All professional centerbacks are professional soccer defenders.
All NBA players are professional basketball players.
Stephen Curry is an NBA player.

[PREMISE (FOL)]:
∀x ((Professional(x) ∧ Defender(x)) → (Professional(x) ∧ SoccerPlayer(x)))
∀x ((Professional(x) ∧ SoccerPlayer(x)) → ¬(Professional(x) ∧ BasketballPlayer(x)))
∀x ((Professional(x) ∧ CenterBack(x)) → (Professional(x) ∧ Defender(x))
∀x (NBAPlayer(x) → (Professional(x) ∧ BasketballPlayer(x)))
NBAPlayer(stephenCurry)

[PREMISE (GK)]:
! [X] : ((Professional(X) & Defender(X)) => (Professional(X) & SoccerPlayer(X))).
! [X] : ((Professional(X) & SoccerPlayer(X)) => -(Professional(X) & BasketballPlayer(X))).
! [X] : ((Professional(X) & CenterBack(X)) => (Professional(X) & Defender(X)).
! [X] : (NBAPlayer(X) => (Professional(X) & BasketballPlayer(X))).
NBAPlayer(stephenCurry).

[CONCLUSION]:
Stephen Curry is a professional basketball player.

[CONCLUSION (FOL)]:
Professional(stephenCurry) ∧ BasketballPlayer(stephenCurry)

[CONCLUSION (GK)]:
Professional(stephenCurry) & BasketballPlayer(stephenCurry).


===

['x']
['x']
[PREMISE]:
All professional soccer defenders are professional soccer players.
No professional soccer players are professional basketball players.
All professional centerbacks are professional soccer defenders.
All NBA players are professional basketball players.
Stephen Curry is an NBA player.

[PREMISE (FOL)]:
∀x ((Professional(x) ∧ Defender(x)) → (Professional(x) ∧ SoccerPlayer(x)))
∀x ((Professional(x) ∧ SoccerPlayer(x)) → ¬(Professional(x) ∧ BasketballPlayer(x)))
∀x ((Professional(x) ∧ CenterBack(x)) → (Professional(x) ∧ Defender(x))
∀x (NBAPlayer(x) → (Professional(x) ∧ BasketballPlayer(x)))
NBAPlayer(stephenCurry)

[PREMISE (GK)]:
! [X] : ((Professional(X) & Defender(X)) => (Professional(X) & SoccerPlayer(X))).
! [X] : ((Professional(X) & SoccerPlayer(X)) => -(Professional(X) & BasketballPlayer(X))).
! [X] : ((Professional(X) & CenterBack(X)) => (Professional(X) & Defender(X)).
! [X] : (NBAPlayer(X) => (Professional(X) & BasketballPlayer(X))).
NBAPlayer(stephenCurry).

[CONCLUSION]:
Stephen Curry is a professional centerback.

[CONCLUSION (FOL)]:
Professional(stephenCurry) ∧ CenterBack(stephenCurry)

[CONCLUSION (GK)]:
Professional(stephenCurry) & CenterBack(stephenCurry).


===

['x']
['x']
[PREMISE]:
All professional soccer defenders are professional soccer players.
No professional soccer players are professional basketball players.
All professional centerbacks are professional soccer defenders.
All NBA players are professional basketball players.
Stephen Curry is an NBA player.

[PREMISE (FOL)]:
∀x ((Professional(x) ∧ Defender(x)) → (Professional(x) ∧ SoccerPlayer(x)))
∀x ((Professional(x) ∧ SoccerPlayer(x)) → ¬(Professional(x) ∧ BasketballPlayer(x)))
∀x ((Professional(x) ∧ CenterBack(x)) → (Professional(x) ∧ Defender(x))
∀x (NBAPlayer(x) → (Professional(x) ∧ BasketballPlayer(x)))
NBAPlayer(stephenCurry)

[PREMISE (GK)]:
! [X] : ((Professional(X) & Defender(X)) => (Professional(X) & SoccerPlayer(X))).
! [X] : ((Professional(X) & SoccerPlayer(X)) => -(Professional(X) & BasketballPlayer(X))).
! [X] : ((Professional(X) & CenterBack(X)) => (Professional(X) & Defender(X)).
! [X] : (NBAPlayer(X) => (Professional(X) & BasketballPlayer(X))).
NBAPlayer(stephenCurry).

[CONCLUSION]:
Stephen Curry is not a centerback.

[CONCLUSION (FOL)]:
¬(Professional(stephenCurry) ∧ CenterBack(stephenCurry))

[CONCLUSION (GK)]:
-(Professional(stephenCurry) & CenterBack(stephenCurry)).


===

['y']
['y']
[PREMISE]:
Naive cynicism was proposed by Justin Kruger and a colleague.
Thomas Gilovich is a colleague of Justin Kruger. 
Naive cynicism is a philosophy of mind.

[PREMISE (FOL)]:
Proposed(justinKruger, naiveCynicism) ∧ ∃y (colleagueOfJustinKruger(y) ∧ Proposed(y, naiveCynicism))
Colleagues(thomasGilovich, justinKruger)
PhilosophyOfMind(naiveCynicism)

[PREMISE (GK)]:
Proposed(justinKruger, naiveCynicism) & ? [Y] : (colleagueOfJustinKruger(Y) & Proposed(Y, naiveCynicism)).
Colleagues(thomasGilovich, justinKruger).
PhilosophyOfMind(naiveCynicism).

[CONCLUSION]:
Thomas Gilovich proposed naive cynicism.

[CONCLUSION (FOL)]:
Proposed(thomasGilovich, naiveCynicism)

[CONCLUSION (GK)]:
Proposed(thomasGilovich, naiveCynicism).


===

['y']
['x', 'y']
[PREMISE]:
Naive cynicism was proposed by Justin Kruger and a colleague.
Thomas Gilovich is a colleague of Justin Kruger. 
Naive cynicism is a philosophy of mind.

[PREMISE (FOL)]:
Proposed(justinKruger, naiveCynicism) ∧ ∃y (colleagueOfJustinKruger(y) ∧ Proposed(y, naiveCynicism))
Colleagues(thomasGilovich, justinKruger)
PhilosophyOfMind(naiveCynicism)

[PREMISE (GK)]:
Proposed(justinKruger, naiveCynicism) & ? [Y] : (colleagueOfJustinKruger(Y) & Proposed(Y, naiveCynicism)).
Colleagues(thomasGilovich, justinKruger).
PhilosophyOfMind(naiveCynicism).

[CONCLUSION]:
Justin Kruger proposed a philosophy of mind.

[CONCLUSION (FOL)]:
∃x (Proposed(justinKruger, x) ∧ PhilosophyOfMind(x))

[CONCLUSION (GK)]:
? [X] : (Proposed(justinKruger, X) & PhilosophyOfMind(X)).


===

['y']
['x', 'y']
[PREMISE]:
Naive cynicism was proposed by Justin Kruger and a colleague.
Thomas Gilovich is a colleague of Justin Kruger. 
Naive cynicism is a philosophy of mind.

[PREMISE (FOL)]:
Proposed(justinKruger, naiveCynicism) ∧ ∃y (colleagueOfJustinKruger(y) ∧ Proposed(y, naiveCynicism))
Colleagues(thomasGilovich, justinKruger)
PhilosophyOfMind(naiveCynicism)

[PREMISE (GK)]:
Proposed(justinKruger, naiveCynicism) & ? [Y] : (colleagueOfJustinKruger(Y) & Proposed(Y, naiveCynicism)).
Colleagues(thomasGilovich, justinKruger).
PhilosophyOfMind(naiveCynicism).

[CONCLUSION]:
Thomas Gilovich worked on philosophies of mind.

[CONCLUSION (FOL)]:
∃x (WorkedOn(thomasGilovich, x) ∧ PhilosophyOfMind(x))

[CONCLUSION (GK)]:
? [X] : (WorkedOn(thomasGilovich, X) & PhilosophyOfMind(X)).


===

[]
['x', 'y']
[PREMISE]:
The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming, and John McCarthy. 
Donald Knuth made contributions to the analysis of algorithms.
Marvin Minsky is recognized for his contributions to the field of artificial intelligence.
Richard Hamming researched numerical methods.
John McCarthy made contributions to the field of artificial intelligence. 

[PREMISE (FOL)]:
AwardedTo(turingAward, donaldKnuth) ∧ AwardedTo(turingAward, marvinMinsky) ∧ AwardedTo(turingAward, richardHamming) ∧ AwardedTo(turingAward, johnMccarthy)
ContributedTo(donaldKnuth, analysisOfAlgorithms)
ContributedTo(marvinMinsky, artificialIntelligence)
ContributedTo(richardHamming, numericalMethods)
ContributedTo(johnMccarthy, artificialIntelligence)

[PREMISE (GK)]:
AwardedTo(turingAward, donaldKnuth) & AwardedTo(turingAward, marvinMinsky) & AwardedTo(turingAward, richardHamming) & AwardedTo(turingAward, johnMccarthy).
ContributedTo(donaldKnuth, analysisOfAlgorithms).
ContributedTo(marvinMinsky, artificialIntelligence).
ContributedTo(richardHamming, numericalMethods).
ContributedTo(johnMccarthy, artificialIntelligence).

[CONCLUSION]:
At least two people who have won the Turing Award worked in artificial intelligence.

[CONCLUSION (FOL)]:
∃x ∃y (¬(x=y) ∧ AwardedTo(turingAward, x) ∧ AwardedTo(turingAward, y) ∧ ContributedTo(x, artificialIntelligence)  ∧ ContributedTo(y, artificialIntelligence))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (-(X=Y) & AwardedTo(turingAward, X) & AwardedTo(turingAward, Y) & ContributedTo(X, artificialIntelligence)  & ContributedTo(Y, artificialIntelligence)).


===

[]
['x', 'y']
[PREMISE]:
The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming, and John McCarthy. 
Donald Knuth made contributions to the analysis of algorithms.
Marvin Minsky is recognized for his contributions to the field of artificial intelligence.
Richard Hamming researched numerical methods.
John McCarthy made contributions to the field of artificial intelligence. 

[PREMISE (FOL)]:
AwardedTo(turingAward, donaldKnuth) ∧ AwardedTo(turingAward, marvinMinsky) ∧ AwardedTo(turingAward, richardHamming) ∧ AwardedTo(turingAward, johnMccarthy)
ContributedTo(donaldKnuth, analysisOfAlgorithms)
ContributedTo(marvinMinsky, artificialIntelligence)
ContributedTo(richardHamming, numericalMethods)
ContributedTo(johnMccarthy, artificialIntelligence)

[PREMISE (GK)]:
AwardedTo(turingAward, donaldKnuth) & AwardedTo(turingAward, marvinMinsky) & AwardedTo(turingAward, richardHamming) & AwardedTo(turingAward, johnMccarthy).
ContributedTo(donaldKnuth, analysisOfAlgorithms).
ContributedTo(marvinMinsky, artificialIntelligence).
ContributedTo(richardHamming, numericalMethods).
ContributedTo(johnMccarthy, artificialIntelligence).

[CONCLUSION]:
At least two people who worked in artificial intelligence have won the Turing Award.

[CONCLUSION (FOL)]:
∃x ∃y (¬(x=y) ∧ ContributedTo(x, artificialIntelligence) ∧ ContributedTo(x, artificialIntelligence) ∧ AwardedTo(turingAward, x) ∧ AwardedTo(turingAward, y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (-(X=Y) & ContributedTo(X, artificialIntelligence) & ContributedTo(X, artificialIntelligence) & AwardedTo(turingAward, X) & AwardedTo(turingAward, Y)).


===

[]
['x', 'y']
[PREMISE]:
The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming, and John McCarthy. 
Donald Knuth made contributions to the analysis of algorithms.
Marvin Minsky is recognized for his contributions to the field of artificial intelligence.
Richard Hamming researched numerical methods.
John McCarthy made contributions to the field of artificial intelligence. 

[PREMISE (FOL)]:
AwardedTo(turingAward, donaldKnuth) ∧ AwardedTo(turingAward, marvinMinsky) ∧ AwardedTo(turingAward, richardHamming) ∧ AwardedTo(turingAward, johnMccarthy)
ContributedTo(donaldKnuth, analysisOfAlgorithms)
ContributedTo(marvinMinsky, artificialIntelligence)
ContributedTo(richardHamming, numericalMethods)
ContributedTo(johnMccarthy, artificialIntelligence)

[PREMISE (GK)]:
AwardedTo(turingAward, donaldKnuth) & AwardedTo(turingAward, marvinMinsky) & AwardedTo(turingAward, richardHamming) & AwardedTo(turingAward, johnMccarthy).
ContributedTo(donaldKnuth, analysisOfAlgorithms).
ContributedTo(marvinMinsky, artificialIntelligence).
ContributedTo(richardHamming, numericalMethods).
ContributedTo(johnMccarthy, artificialIntelligence).

[CONCLUSION]:
Only one person who won the Turing Award made significant contributions to the analysis of algorithms.

[CONCLUSION (FOL)]:
∃x ∀y ((AwardedTo(turingAward, x) ∧ AwardedTo(turingAward, y) ∧ ContributedTo(y, algorithms) ∧ ¬(x=y)) → ¬ContributedTo(y, algorithms))

[CONCLUSION (GK)]:
? [X] : ! [Y] : ((AwardedTo(turingAward, X) & AwardedTo(turingAward, Y) & ContributedTo(Y, algorithms) & -(X=Y)) => -ContributedTo(Y, algorithms)).


===

[]
['x']
[PREMISE]:
The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming, and John McCarthy. 
Donald Knuth made contributions to the analysis of algorithms.
Marvin Minsky is recognized for his contributions to the field of artificial intelligence.
Richard Hamming researched numerical methods.
John McCarthy made contributions to the field of artificial intelligence. 

[PREMISE (FOL)]:
AwardedTo(turingAward, donaldKnuth) ∧ AwardedTo(turingAward, marvinMinsky) ∧ AwardedTo(turingAward, richardHamming) ∧ AwardedTo(turingAward, johnMccarthy)
ContributedTo(donaldKnuth, analysisOfAlgorithms)
ContributedTo(marvinMinsky, artificialIntelligence)
ContributedTo(richardHamming, numericalMethods)
ContributedTo(johnMccarthy, artificialIntelligence)

[PREMISE (GK)]:
AwardedTo(turingAward, donaldKnuth) & AwardedTo(turingAward, marvinMinsky) & AwardedTo(turingAward, richardHamming) & AwardedTo(turingAward, johnMccarthy).
ContributedTo(donaldKnuth, analysisOfAlgorithms).
ContributedTo(marvinMinsky, artificialIntelligence).
ContributedTo(richardHamming, numericalMethods).
ContributedTo(johnMccarthy, artificialIntelligence).

[CONCLUSION]:
No Turing Award winners worked in the field of numerical methods.

[CONCLUSION (FOL)]:
∀x (AwardedTo(turingAward, x) → ¬ContributedTo(x, numericalMethods))

[CONCLUSION (GK)]:
! [X] : (AwardedTo(turingAward, X) => -ContributedTo(X, numericalMethods)).


===

['x']
['x']
[PREMISE]:
None of the easy Leetcode problems have an AC rate lower than 20 percent. 
All Leetcode problems recommended to novices are easy. 
Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. 
All hard Leetcode problems are starred by more than 1,000 users. 
No Leetcode problems published after 2022 are starred by more than 1,000 users. 
'2Sum' is not both hard and also recommended to novices.
'4Sum' is either starred by more than 1,000 users and published after 2022, or it is neither. 

[PREMISE (FOL)]:
∀x ((LeetcodeProblems(x) ∧ Easy(x)) → ¬HaveAnACRateLowerThan(x, percent20))
∀x ((LeetcodeProblems(x) ∧ RecommendedTo(x, novices)) → Easy(x))
∀x (LeetcodeProblems(x) → HaveAnACRateLowerThan(x, percent20) ⊕ StarredByMoreThan(x, num1000))
∀x ((LeetcodeProblems(x) ∧ Hard(x)) → StarredByMoreThan(x, num1000))
∀x ((LeetcodeProblems(x) ∧ PublishedAfter(x, yr2022)) → (¬StarredByMoreThan(x, num1000)))
¬(RecommendedTo(twosum, novices) ∧ Hard(twosum)) ∧ LeetcodeProblems(twosum)
¬(StarredByMoreThan(foursum, num1000) ⊕ PublishedAfter(foursum, yr2022)) ∧ LeetcodeProblems(twosum)

[PREMISE (GK)]:
! [X] : ((LeetcodeProblems(X) & Easy(X)) => -HaveAnACRateLowerThan(X, percent20)).
! [X] : ((LeetcodeProblems(X) & RecommendedTo(X, novices)) => Easy(X)).
! [X] : (LeetcodeProblems(X) => HaveAnACRateLowerThan(X, percent20) <~> StarredByMoreThan(X, num1000)).
! [X] : ((LeetcodeProblems(X) & Hard(X)) => StarredByMoreThan(X, num1000)).
! [X] : ((LeetcodeProblems(X) & PublishedAfter(X, yr2022)) => (-StarredByMoreThan(X, num1000))).
-(RecommendedTo(twosum, novices) & Hard(twosum)) & LeetcodeProblems(twosum).
-(StarredByMoreThan(foursum, num1000) <~> PublishedAfter(foursum, yr2022)) & LeetcodeProblems(twosum).

[CONCLUSION]:
2Sum is an easy Leetcode problem.

[CONCLUSION (FOL)]:
LeetcodeProblems(twosum) ∧ Easy(twosum)

[CONCLUSION (GK)]:
LeetcodeProblems(twosum) & Easy(twosum).


===

['x']
['x']
[PREMISE]:
None of the easy Leetcode problems have an AC rate lower than 20 percent. 
All Leetcode problems recommended to novices are easy. 
Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. 
All hard Leetcode problems are starred by more than 1,000 users. 
No Leetcode problems published after 2022 are starred by more than 1,000 users. 
'2Sum' is not both hard and also recommended to novices.
'4Sum' is either starred by more than 1,000 users and published after 2022, or it is neither. 

[PREMISE (FOL)]:
∀x ((LeetcodeProblems(x) ∧ Easy(x)) → ¬HaveAnACRateLowerThan(x, percent20))
∀x ((LeetcodeProblems(x) ∧ RecommendedTo(x, novices)) → Easy(x))
∀x (LeetcodeProblems(x) → HaveAnACRateLowerThan(x, percent20) ⊕ StarredByMoreThan(x, num1000))
∀x ((LeetcodeProblems(x) ∧ Hard(x)) → StarredByMoreThan(x, num1000))
∀x ((LeetcodeProblems(x) ∧ PublishedAfter(x, yr2022)) → (¬StarredByMoreThan(x, num1000)))
¬(RecommendedTo(twosum, novices) ∧ Hard(twosum)) ∧ LeetcodeProblems(twosum)
¬(StarredByMoreThan(foursum, num1000) ⊕ PublishedAfter(foursum, yr2022)) ∧ LeetcodeProblems(twosum)

[PREMISE (GK)]:
! [X] : ((LeetcodeProblems(X) & Easy(X)) => -HaveAnACRateLowerThan(X, percent20)).
! [X] : ((LeetcodeProblems(X) & RecommendedTo(X, novices)) => Easy(X)).
! [X] : (LeetcodeProblems(X) => HaveAnACRateLowerThan(X, percent20) <~> StarredByMoreThan(X, num1000)).
! [X] : ((LeetcodeProblems(X) & Hard(X)) => StarredByMoreThan(X, num1000)).
! [X] : ((LeetcodeProblems(X) & PublishedAfter(X, yr2022)) => (-StarredByMoreThan(X, num1000))).
-(RecommendedTo(twosum, novices) & Hard(twosum)) & LeetcodeProblems(twosum).
-(StarredByMoreThan(foursum, num1000) <~> PublishedAfter(foursum, yr2022)) & LeetcodeProblems(twosum).

[CONCLUSION]:
2Sum is not an easy Leetcode problem.

[CONCLUSION (FOL)]:
¬(LeetcodeProblems(twosum) ∧ Easy(twosum))

[CONCLUSION (GK)]:
-(LeetcodeProblems(twosum) & Easy(twosum)).


===

['x']
['x']
[PREMISE]:
None of the easy Leetcode problems have an AC rate lower than 20 percent. 
All Leetcode problems recommended to novices are easy. 
Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. 
All hard Leetcode problems are starred by more than 1,000 users. 
No Leetcode problems published after 2022 are starred by more than 1,000 users. 
'2Sum' is not both hard and also recommended to novices.
'4Sum' is either starred by more than 1,000 users and published after 2022, or it is neither. 

[PREMISE (FOL)]:
∀x ((LeetcodeProblems(x) ∧ Easy(x)) → ¬HaveAnACRateLowerThan(x, percent20))
∀x ((LeetcodeProblems(x) ∧ RecommendedTo(x, novices)) → Easy(x))
∀x (LeetcodeProblems(x) → HaveAnACRateLowerThan(x, percent20) ⊕ StarredByMoreThan(x, num1000))
∀x ((LeetcodeProblems(x) ∧ Hard(x)) → StarredByMoreThan(x, num1000))
∀x ((LeetcodeProblems(x) ∧ PublishedAfter(x, yr2022)) → (¬StarredByMoreThan(x, num1000)))
¬(RecommendedTo(twosum, novices) ∧ Hard(twosum)) ∧ LeetcodeProblems(twosum)
¬(StarredByMoreThan(foursum, num1000) ⊕ PublishedAfter(foursum, yr2022)) ∧ LeetcodeProblems(twosum)

[PREMISE (GK)]:
! [X] : ((LeetcodeProblems(X) & Easy(X)) => -HaveAnACRateLowerThan(X, percent20)).
! [X] : ((LeetcodeProblems(X) & RecommendedTo(X, novices)) => Easy(X)).
! [X] : (LeetcodeProblems(X) => HaveAnACRateLowerThan(X, percent20) <~> StarredByMoreThan(X, num1000)).
! [X] : ((LeetcodeProblems(X) & Hard(X)) => StarredByMoreThan(X, num1000)).
! [X] : ((LeetcodeProblems(X) & PublishedAfter(X, yr2022)) => (-StarredByMoreThan(X, num1000))).
-(RecommendedTo(twosum, novices) & Hard(twosum)) & LeetcodeProblems(twosum).
-(StarredByMoreThan(foursum, num1000) <~> PublishedAfter(foursum, yr2022)) & LeetcodeProblems(twosum).

[CONCLUSION]:
4Sum is recommended to novices or is hard.

[CONCLUSION (FOL)]:
RecommendedTo(foursum, novices) ∨ Hard(foursum)

[CONCLUSION (GK)]:
RecommendedTo(foursum, novices) | Hard(foursum).


===

['x']
['x']
[PREMISE]:
None of the easy Leetcode problems have an AC rate lower than 20 percent. 
All Leetcode problems recommended to novices are easy. 
Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users. 
All hard Leetcode problems are starred by more than 1,000 users. 
No Leetcode problems published after 2022 are starred by more than 1,000 users. 
'2Sum' is not both hard and also recommended to novices.
'4Sum' is either starred by more than 1,000 users and published after 2022, or it is neither. 

[PREMISE (FOL)]:
∀x ((LeetcodeProblems(x) ∧ Easy(x)) → ¬HaveAnACRateLowerThan(x, percent20))
∀x ((LeetcodeProblems(x) ∧ RecommendedTo(x, novices)) → Easy(x))
∀x (LeetcodeProblems(x) → HaveAnACRateLowerThan(x, percent20) ⊕ StarredByMoreThan(x, num1000))
∀x ((LeetcodeProblems(x) ∧ Hard(x)) → StarredByMoreThan(x, num1000))
∀x ((LeetcodeProblems(x) ∧ PublishedAfter(x, yr2022)) → (¬StarredByMoreThan(x, num1000)))
¬(RecommendedTo(twosum, novices) ∧ Hard(twosum)) ∧ LeetcodeProblems(twosum)
¬(StarredByMoreThan(foursum, num1000) ⊕ PublishedAfter(foursum, yr2022)) ∧ LeetcodeProblems(twosum)

[PREMISE (GK)]:
! [X] : ((LeetcodeProblems(X) & Easy(X)) => -HaveAnACRateLowerThan(X, percent20)).
! [X] : ((LeetcodeProblems(X) & RecommendedTo(X, novices)) => Easy(X)).
! [X] : (LeetcodeProblems(X) => HaveAnACRateLowerThan(X, percent20) <~> StarredByMoreThan(X, num1000)).
! [X] : ((LeetcodeProblems(X) & Hard(X)) => StarredByMoreThan(X, num1000)).
! [X] : ((LeetcodeProblems(X) & PublishedAfter(X, yr2022)) => (-StarredByMoreThan(X, num1000))).
-(RecommendedTo(twosum, novices) & Hard(twosum)) & LeetcodeProblems(twosum).
-(StarredByMoreThan(foursum, num1000) <~> PublishedAfter(foursum, yr2022)) & LeetcodeProblems(twosum).

[CONCLUSION]:
4Sum is neither recommended to the novice nor a Leetcode problem that's hard.

[CONCLUSION (FOL)]:
¬RecommendedTo(foursum, novices) ∧ ¬Hard(foursum)

[CONCLUSION (GK)]:
-RecommendedTo(foursum, novices) & -Hard(foursum).


===

[]
['x', 'y']
[PREMISE]:
Show Your Love is a song recorded by the South Korean boy band BtoB 4u.
The lead single of the extended play Inside is Show Your Love.
Show Your Love contains a hopeful message.
BtoB 4u member Hyunsik wrote Show Your Love.
There is a music video for Show Your Love.

[PREMISE (FOL)]:
Song(showYourLove) ∧ RecordedBy(showYourLove, bToB4u) ∧ SouthKorean(bToB4u) ∧ BoyBand(bToB4u)
ExtendedPlay(inside) ∧ LeadSingleOf(showYourLove, inside)
Contains(showYourLove, hopefulMessage)
Member(hyunsik, btob4u) ∧ Wrote(hyunsik, showYourLove)
Have(showYourLove, musicVideo)

[PREMISE (GK)]:
Song(showYourLove) & RecordedBy(showYourLove, bToB4u) & SouthKorean(bToB4u) & BoyBand(bToB4u).
ExtendedPlay(inside) & LeadSingleOf(showYourLove, inside).
Contains(showYourLove, hopefulMessage).
Member(hyunsik, btob4u) & Wrote(hyunsik, showYourLove).
Have(showYourLove, musicVideo).

[CONCLUSION]:
Show Your Love wasn't written by a member of a boy band.

[CONCLUSION (FOL)]:
∀x ∀y (Wrote(x, showYourLove) → ¬(BoyBand(y) ∧ MemberOf(x, y)))

[CONCLUSION (GK)]:
! [X] : ! [Y] : (Wrote(X, showYourLove) => -(BoyBand(Y) & MemberOf(X, Y))).


===

[]
['x']
[PREMISE]:
Show Your Love is a song recorded by the South Korean boy band BtoB 4u.
The lead single of the extended play Inside is Show Your Love.
Show Your Love contains a hopeful message.
BtoB 4u member Hyunsik wrote Show Your Love.
There is a music video for Show Your Love.

[PREMISE (FOL)]:
Song(showYourLove) ∧ RecordedBy(showYourLove, bToB4u) ∧ SouthKorean(bToB4u) ∧ BoyBand(bToB4u)
ExtendedPlay(inside) ∧ LeadSingleOf(showYourLove, inside)
Contains(showYourLove, hopefulMessage)
Member(hyunsik, btob4u) ∧ Wrote(hyunsik, showYourLove)
Have(showYourLove, musicVideo)

[PREMISE (GK)]:
Song(showYourLove) & RecordedBy(showYourLove, bToB4u) & SouthKorean(bToB4u) & BoyBand(bToB4u).
ExtendedPlay(inside) & LeadSingleOf(showYourLove, inside).
Contains(showYourLove, hopefulMessage).
Member(hyunsik, btob4u) & Wrote(hyunsik, showYourLove).
Have(showYourLove, musicVideo).

[CONCLUSION]:
A lead single of Inside contains a hopeful message.

[CONCLUSION (FOL)]:
∃x (LeadSingleOf(x, inside) ∧ Contains(x, hopefulMessage))

[CONCLUSION (GK)]:
? [X] : (LeadSingleOf(X, inside) & Contains(X, hopefulMessage)).


===

[]
[]
[PREMISE]:
Show Your Love is a song recorded by the South Korean boy band BtoB 4u.
The lead single of the extended play Inside is Show Your Love.
Show Your Love contains a hopeful message.
BtoB 4u member Hyunsik wrote Show Your Love.
There is a music video for Show Your Love.

[PREMISE (FOL)]:
Song(showYourLove) ∧ RecordedBy(showYourLove, bToB4u) ∧ SouthKorean(bToB4u) ∧ BoyBand(bToB4u)
ExtendedPlay(inside) ∧ LeadSingleOf(showYourLove, inside)
Contains(showYourLove, hopefulMessage)
Member(hyunsik, btob4u) ∧ Wrote(hyunsik, showYourLove)
Have(showYourLove, musicVideo)

[PREMISE (GK)]:
Song(showYourLove) & RecordedBy(showYourLove, bToB4u) & SouthKorean(bToB4u) & BoyBand(bToB4u).
ExtendedPlay(inside) & LeadSingleOf(showYourLove, inside).
Contains(showYourLove, hopefulMessage).
Member(hyunsik, btob4u) & Wrote(hyunsik, showYourLove).
Have(showYourLove, musicVideo).

[CONCLUSION]:
Hyunsik is Korean.

[CONCLUSION (FOL)]:
Korean(hyunsik)

[CONCLUSION (GK)]:
Korean(hyunsik).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All tables are round.
Some pieces of furniture are tables.

[PREMISE (FOL)]:
∀x (Table(x) → Round(x))
∃x ∃y (Furniture(x) ∧ Furniture(y) ∧ Table(x) ∧ Table(y) ∧ ¬(x=y))

[PREMISE (GK)]:
! [X] : (Table(X) => Round(X)).
? [X] : ? [Y] : (Furniture(X) & Furniture(Y) & Table(X) & Table(Y) & -(X=Y)).

[CONCLUSION]:
Some pieces of furniture are round.

[CONCLUSION (FOL)]:
∃x ∃y (Furniture(x) ∧ Furniture(y) ∧ Round(x) ∧ Round(y) ∧ ¬(x=y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Furniture(X) & Furniture(Y) & Round(X) & Round(Y) & -(X=Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All juvenile delinquents have committed a crime.
Some juvenile delinquents are products of broken homes.

[PREMISE (FOL)]:
∀x (JuvenileDelinquent(x) → Commited(x, crime))
∃x ∃y (JuvenileDelinquent(x) ∧ JuvenileDelinquent(y) ∧ ProductOf(x, brokenHome) ∧ ProductOf(y, brokenHome) ∧ ¬(x=y))

[PREMISE (GK)]:
! [X] : (JuvenileDelinquent(X) => Commited(X, crime)).
? [X] : ? [Y] : (JuvenileDelinquent(X) & JuvenileDelinquent(Y) & ProductOf(X, brokenHome) & ProductOf(Y, brokenHome) & -(X=Y)).

[CONCLUSION]:
Some people who have committed a crime are products of broken homes.

[CONCLUSION (FOL)]:
∃x ∃y (Commited(x, crime) ∧ Commited(y, crime) ∧ ProductOf(x, brokenHome) ∧ ProductOf(y, brokenHome) ∧ ¬(x=y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Commited(X, crime) & Commited(Y, crime) & ProductOf(X, brokenHome) & ProductOf(Y, brokenHome) & -(X=Y)).


===

['x']
['x']
[PREMISE]:
All mind-reading is either brain reading or brain decoding. 
All brain decoding that is mind-reading is extracting information from BOLD signals.
No studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. 
Writing a novel is without statistical pattern analysis.
If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.
Multivoxel (pattern) analysis is a type of mind-reading.

[PREMISE (FOL)]:
∀x (MindReading(x) ∧ (BrainReading(x) ⊕ BrainDecoding(x)))
∀x ((MindReading(x) ∧ BrainDecoding(x)) → ExtractingFrom(x, information, bOLDSignals))
∀x ((MindReading(x) ∧ ExtractingFrom(x, information, bOLDSignals)) → Uses(x, statisticalPatternAnalysis))
∀x (NovelWriting(x) → ¬Uses(x, statisticalPatternAnalysis)) 
MindReading(multivoxelPatternAnalysis) ∧ (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis)) →  (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ (¬BrainDecoding(multivoxelPatternAnalysis)))
MindReading(multivoxelPatternAnalysis) 

[PREMISE (GK)]:
! [X] : (MindReading(X) & (BrainReading(X) <~> BrainDecoding(X))).
! [X] : ((MindReading(X) & BrainDecoding(X)) => ExtractingFrom(X, information, bOLDSignals)).
! [X] : ((MindReading(X) & ExtractingFrom(X, information, bOLDSignals)) => Uses(X, statisticalPatternAnalysis)).
! [X] : (NovelWriting(X) => -Uses(X, statisticalPatternAnalysis)) .
MindReading(multivoxelPatternAnalysis) & (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & BrainReading(multivoxelPatternAnalysis)) =>  (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & (-BrainDecoding(multivoxelPatternAnalysis))).
MindReading(multivoxelPatternAnalysis) .

[CONCLUSION]:
Multivoxel (pattern) analysis is a brain decoding.

[CONCLUSION (FOL)]:
MindReading(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)

[CONCLUSION (GK)]:
MindReading(multivoxelPatternAnalysis) & BrainDecoding(multivoxelPatternAnalysis).


===

['x']
['x']
[PREMISE]:
All mind-reading is either brain reading or brain decoding. 
All brain decoding that is mind-reading is extracting information from BOLD signals.
No studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. 
Writing a novel is without statistical pattern analysis.
If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.
Multivoxel (pattern) analysis is a type of mind-reading.

[PREMISE (FOL)]:
∀x (MindReading(x) ∧ (BrainReading(x) ⊕ BrainDecoding(x)))
∀x ((MindReading(x) ∧ BrainDecoding(x)) → ExtractingFrom(x, information, bOLDSignals))
∀x ((MindReading(x) ∧ ExtractingFrom(x, information, bOLDSignals)) → Uses(x, statisticalPatternAnalysis))
∀x (NovelWriting(x) → ¬Uses(x, statisticalPatternAnalysis)) 
MindReading(multivoxelPatternAnalysis) ∧ (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis)) →  (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ (¬BrainDecoding(multivoxelPatternAnalysis)))
MindReading(multivoxelPatternAnalysis) 

[PREMISE (GK)]:
! [X] : (MindReading(X) & (BrainReading(X) <~> BrainDecoding(X))).
! [X] : ((MindReading(X) & BrainDecoding(X)) => ExtractingFrom(X, information, bOLDSignals)).
! [X] : ((MindReading(X) & ExtractingFrom(X, information, bOLDSignals)) => Uses(X, statisticalPatternAnalysis)).
! [X] : (NovelWriting(X) => -Uses(X, statisticalPatternAnalysis)) .
MindReading(multivoxelPatternAnalysis) & (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & BrainReading(multivoxelPatternAnalysis)) =>  (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & (-BrainDecoding(multivoxelPatternAnalysis))).
MindReading(multivoxelPatternAnalysis) .

[CONCLUSION]:
Multivoxel (pattern) analysis is the writing of a novel.

[CONCLUSION (FOL)]:
MindReading(multivoxelPatternAnalysis) ∧ NovelWriting(multivoxelPatternAnalysis)

[CONCLUSION (GK)]:
MindReading(multivoxelPatternAnalysis) & NovelWriting(multivoxelPatternAnalysis).


===

['x']
['x']
[PREMISE]:
All mind-reading is either brain reading or brain decoding. 
All brain decoding that is mind-reading is extracting information from BOLD signals.
No studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. 
Writing a novel is without statistical pattern analysis.
If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.
Multivoxel (pattern) analysis is a type of mind-reading.

[PREMISE (FOL)]:
∀x (MindReading(x) ∧ (BrainReading(x) ⊕ BrainDecoding(x)))
∀x ((MindReading(x) ∧ BrainDecoding(x)) → ExtractingFrom(x, information, bOLDSignals))
∀x ((MindReading(x) ∧ ExtractingFrom(x, information, bOLDSignals)) → Uses(x, statisticalPatternAnalysis))
∀x (NovelWriting(x) → ¬Uses(x, statisticalPatternAnalysis)) 
MindReading(multivoxelPatternAnalysis) ∧ (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis)) →  (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ (¬BrainDecoding(multivoxelPatternAnalysis)))
MindReading(multivoxelPatternAnalysis) 

[PREMISE (GK)]:
! [X] : (MindReading(X) & (BrainReading(X) <~> BrainDecoding(X))).
! [X] : ((MindReading(X) & BrainDecoding(X)) => ExtractingFrom(X, information, bOLDSignals)).
! [X] : ((MindReading(X) & ExtractingFrom(X, information, bOLDSignals)) => Uses(X, statisticalPatternAnalysis)).
! [X] : (NovelWriting(X) => -Uses(X, statisticalPatternAnalysis)) .
MindReading(multivoxelPatternAnalysis) & (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & BrainReading(multivoxelPatternAnalysis)) =>  (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & (-BrainDecoding(multivoxelPatternAnalysis))).
MindReading(multivoxelPatternAnalysis) .

[CONCLUSION]:
Multivoxel (pattern) analysis is without statistical pattern analysis and writing a novel.

[CONCLUSION (FOL)]:
¬(Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ NovelWriting(multivoxelPatternAnalysis))

[CONCLUSION (GK)]:
-(Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & NovelWriting(multivoxelPatternAnalysis)).


===

['x']
['x']
[PREMISE]:
All mind-reading is either brain reading or brain decoding. 
All brain decoding that is mind-reading is extracting information from BOLD signals.
No studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. 
Writing a novel is without statistical pattern analysis.
If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.
Multivoxel (pattern) analysis is a type of mind-reading.

[PREMISE (FOL)]:
∀x (MindReading(x) ∧ (BrainReading(x) ⊕ BrainDecoding(x)))
∀x ((MindReading(x) ∧ BrainDecoding(x)) → ExtractingFrom(x, information, bOLDSignals))
∀x ((MindReading(x) ∧ ExtractingFrom(x, information, bOLDSignals)) → Uses(x, statisticalPatternAnalysis))
∀x (NovelWriting(x) → ¬Uses(x, statisticalPatternAnalysis)) 
MindReading(multivoxelPatternAnalysis) ∧ (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis)) →  (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ (¬BrainDecoding(multivoxelPatternAnalysis)))
MindReading(multivoxelPatternAnalysis) 

[PREMISE (GK)]:
! [X] : (MindReading(X) & (BrainReading(X) <~> BrainDecoding(X))).
! [X] : ((MindReading(X) & BrainDecoding(X)) => ExtractingFrom(X, information, bOLDSignals)).
! [X] : ((MindReading(X) & ExtractingFrom(X, information, bOLDSignals)) => Uses(X, statisticalPatternAnalysis)).
! [X] : (NovelWriting(X) => -Uses(X, statisticalPatternAnalysis)) .
MindReading(multivoxelPatternAnalysis) & (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & BrainReading(multivoxelPatternAnalysis)) =>  (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & (-BrainDecoding(multivoxelPatternAnalysis))).
MindReading(multivoxelPatternAnalysis) .

[CONCLUSION]:
Multivoxel (pattern) analysis is without statistical pattern analysis or writing a novel.

[CONCLUSION (FOL)]:
¬(Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∨ NovelWriting(multivoxelPatternAnalysis))

[CONCLUSION (GK)]:
-(Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) | NovelWriting(multivoxelPatternAnalysis)).


===

['x']
['x']
[PREMISE]:
All mind-reading is either brain reading or brain decoding. 
All brain decoding that is mind-reading is extracting information from BOLD signals.
No studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. 
Writing a novel is without statistical pattern analysis.
If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.
Multivoxel (pattern) analysis is a type of mind-reading.

[PREMISE (FOL)]:
∀x (MindReading(x) ∧ (BrainReading(x) ⊕ BrainDecoding(x)))
∀x ((MindReading(x) ∧ BrainDecoding(x)) → ExtractingFrom(x, information, bOLDSignals))
∀x ((MindReading(x) ∧ ExtractingFrom(x, information, bOLDSignals)) → Uses(x, statisticalPatternAnalysis))
∀x (NovelWriting(x) → ¬Uses(x, statisticalPatternAnalysis)) 
MindReading(multivoxelPatternAnalysis) ∧ (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis)) →  (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ (¬BrainDecoding(multivoxelPatternAnalysis)))
MindReading(multivoxelPatternAnalysis) 

[PREMISE (GK)]:
! [X] : (MindReading(X) & (BrainReading(X) <~> BrainDecoding(X))).
! [X] : ((MindReading(X) & BrainDecoding(X)) => ExtractingFrom(X, information, bOLDSignals)).
! [X] : ((MindReading(X) & ExtractingFrom(X, information, bOLDSignals)) => Uses(X, statisticalPatternAnalysis)).
! [X] : (NovelWriting(X) => -Uses(X, statisticalPatternAnalysis)) .
MindReading(multivoxelPatternAnalysis) & (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & BrainReading(multivoxelPatternAnalysis)) =>  (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & (-BrainDecoding(multivoxelPatternAnalysis))).
MindReading(multivoxelPatternAnalysis) .

[CONCLUSION]:
Multivoxel (pattern) analysis is either without statistical pattern analysis or writing a novel.

[CONCLUSION (FOL)]:
¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ⊕ Writing(multivoxelPatternAnalysis, aNovel)

[CONCLUSION (GK)]:
-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) <~> Writing(multivoxelPatternAnalysis, aNovel).


===

['x']
['x']
[PREMISE]:
All mind-reading is either brain reading or brain decoding. 
All brain decoding that is mind-reading is extracting information from BOLD signals.
No studies that are mind-reading and extract information from BOLD signals are without statistical pattern analysis. 
Writing a novel is without statistical pattern analysis.
If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.
Multivoxel (pattern) analysis is a type of mind-reading.

[PREMISE (FOL)]:
∀x (MindReading(x) ∧ (BrainReading(x) ⊕ BrainDecoding(x)))
∀x ((MindReading(x) ∧ BrainDecoding(x)) → ExtractingFrom(x, information, bOLDSignals))
∀x ((MindReading(x) ∧ ExtractingFrom(x, information, bOLDSignals)) → Uses(x, statisticalPatternAnalysis))
∀x (NovelWriting(x) → ¬Uses(x, statisticalPatternAnalysis)) 
MindReading(multivoxelPatternAnalysis) ∧ (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis)) →  (¬Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∧ (¬BrainDecoding(multivoxelPatternAnalysis)))
MindReading(multivoxelPatternAnalysis) 

[PREMISE (GK)]:
! [X] : (MindReading(X) & (BrainReading(X) <~> BrainDecoding(X))).
! [X] : ((MindReading(X) & BrainDecoding(X)) => ExtractingFrom(X, information, bOLDSignals)).
! [X] : ((MindReading(X) & ExtractingFrom(X, information, bOLDSignals)) => Uses(X, statisticalPatternAnalysis)).
! [X] : (NovelWriting(X) => -Uses(X, statisticalPatternAnalysis)) .
MindReading(multivoxelPatternAnalysis) & (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & BrainReading(multivoxelPatternAnalysis)) =>  (-Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) & (-BrainDecoding(multivoxelPatternAnalysis))).
MindReading(multivoxelPatternAnalysis) .

[CONCLUSION]:
If multivoxel (pattern) analysis is writing a novel, then multivoxel (pattern) analysis is neither without statistical pattern analysis nor writing a novel.

[CONCLUSION (FOL)]:
(MindReading(multivoxelPatternAnalysis) ∧ NovelWriting(multivoxelPatternAnalysis)) → (Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) ∨ ¬NovelWriting(multivoxelPatternAnalysis))

[CONCLUSION (GK)]:
(MindReading(multivoxelPatternAnalysis) & NovelWriting(multivoxelPatternAnalysis)) => (Uses(multivoxelPatternAnalysis, statisticalPatternAnalysis) | -NovelWriting(multivoxelPatternAnalysis)).


===

['x']
['x']
[PREMISE]:
If you have room for dessert, you have room for broccoli.
Everyone at Luis's dinner party has room for dessert, including Luis.
Mauricia does not have room for broccoli.
Luis's dinner party is the first ever dinner party that Allison has attended.
Gustave has room for both broccoli and asparagus.
Broccoli and asparagus are both vegetables.

[PREMISE (FOL)]:
∀x (RoomFor(x, dessert) → RoomFor(x, broccoli))
∀x (AtLuisParty(x) → RoomFor(x, dessert))
¬RoomFor(mauricia, broccoli)
AtLuisParty(allison) ∧ FirstDinnerPartyFor(luisparty, allison) 
RoomFor(gustave, broccoli) ∧ RoomFor(gustave, asparagus)
Vegetable(broccoli) ∧ Vegetable(asparagus)

[PREMISE (GK)]:
! [X] : (RoomFor(X, dessert) => RoomFor(X, broccoli)).
! [X] : (AtLuisParty(X) => RoomFor(X, dessert)).
-RoomFor(mauricia, broccoli).
AtLuisParty(allison) & FirstDinnerPartyFor(luisparty, allison) .
RoomFor(gustave, broccoli) & RoomFor(gustave, asparagus).
Vegetable(broccoli) & Vegetable(asparagus).

[CONCLUSION]:
Allison has room for broccoli.

[CONCLUSION (FOL)]:
RoomFor(allison, broccoli)

[CONCLUSION (GK)]:
RoomFor(allison, broccoli).


===

['x']
['x']
[PREMISE]:
If you have room for dessert, you have room for broccoli.
Everyone at Luis's dinner party has room for dessert, including Luis.
Mauricia does not have room for broccoli.
Luis's dinner party is the first ever dinner party that Allison has attended.
Gustave has room for both broccoli and asparagus.
Broccoli and asparagus are both vegetables.

[PREMISE (FOL)]:
∀x (RoomFor(x, dessert) → RoomFor(x, broccoli))
∀x (AtLuisParty(x) → RoomFor(x, dessert))
¬RoomFor(mauricia, broccoli)
AtLuisParty(allison) ∧ FirstDinnerPartyFor(luisparty, allison) 
RoomFor(gustave, broccoli) ∧ RoomFor(gustave, asparagus)
Vegetable(broccoli) ∧ Vegetable(asparagus)

[PREMISE (GK)]:
! [X] : (RoomFor(X, dessert) => RoomFor(X, broccoli)).
! [X] : (AtLuisParty(X) => RoomFor(X, dessert)).
-RoomFor(mauricia, broccoli).
AtLuisParty(allison) & FirstDinnerPartyFor(luisparty, allison) .
RoomFor(gustave, broccoli) & RoomFor(gustave, asparagus).
Vegetable(broccoli) & Vegetable(asparagus).

[CONCLUSION]:
Mauricia is at Luis's dinner party.

[CONCLUSION (FOL)]:
AtLuisParty(mauricia)

[CONCLUSION (GK)]:
AtLuisParty(mauricia).


===

['x']
['x']
[PREMISE]:
If you have room for dessert, you have room for broccoli.
Everyone at Luis's dinner party has room for dessert, including Luis.
Mauricia does not have room for broccoli.
Luis's dinner party is the first ever dinner party that Allison has attended.
Gustave has room for both broccoli and asparagus.
Broccoli and asparagus are both vegetables.

[PREMISE (FOL)]:
∀x (RoomFor(x, dessert) → RoomFor(x, broccoli))
∀x (AtLuisParty(x) → RoomFor(x, dessert))
¬RoomFor(mauricia, broccoli)
AtLuisParty(allison) ∧ FirstDinnerPartyFor(luisparty, allison) 
RoomFor(gustave, broccoli) ∧ RoomFor(gustave, asparagus)
Vegetable(broccoli) ∧ Vegetable(asparagus)

[PREMISE (GK)]:
! [X] : (RoomFor(X, dessert) => RoomFor(X, broccoli)).
! [X] : (AtLuisParty(X) => RoomFor(X, dessert)).
-RoomFor(mauricia, broccoli).
AtLuisParty(allison) & FirstDinnerPartyFor(luisparty, allison) .
RoomFor(gustave, broccoli) & RoomFor(gustave, asparagus).
Vegetable(broccoli) & Vegetable(asparagus).

[CONCLUSION]:
Gustav has room for dessert.

[CONCLUSION (FOL)]:
RoomFor(gustave, dessert)

[CONCLUSION (GK)]:
RoomFor(gustave, dessert).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Imagine Dragons are an American pop-rock band.
The lead singer of Imagine Dragons is Dan.
Dan is also a songwriter.
All lead singers are singers.
All singers are musicians.
Demons is one of the most popular singles of Imagine Dragons.
Some singles of Imagine Dragons have been on Billboard Hot 100.

[PREMISE (FOL)]:
American(imagineDragon) ∧ RockBand(imagineDragon)
LeadSinger(imagineDragon, dan)
SongWriter(dan)
∀x ∀y (LeadSinger(x, y) → Singer(y))
∀x (Singer(x) → Musician(x))
PopularSingle(imagineDragon, demons)
∃x ∃y (PopularSingle(imagineDragon, x) ∧ BillboardHot100(x)) ∧ (¬(x=y)) ∧ (PopularSingle(imagineDragon, y) ∧ BillboardHot100(y))

[PREMISE (GK)]:
American(imagineDragon) & RockBand(imagineDragon).
LeadSinger(imagineDragon, dan).
SongWriter(dan).
! [X] : ! [Y] : (LeadSinger(X, Y) => Singer(Y)).
! [X] : (Singer(X) => Musician(X)).
PopularSingle(imagineDragon, demons).
? [X] : ? [Y] : (PopularSingle(imagineDragon, X) & BillboardHot100(X)) & (-(X=Y)) & (PopularSingle(imagineDragon, Y) & BillboardHot100(Y)).

[CONCLUSION]:
Some rock band has a lead singer who is also a songwriter.

[CONCLUSION (FOL)]:
∃x ∃y (RockBand(x) ∧ LeadSinger(x, y) ∧ SongWriter(y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (RockBand(X) & LeadSinger(X, Y) & SongWriter(Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Imagine Dragons are an American pop-rock band.
The lead singer of Imagine Dragons is Dan.
Dan is also a songwriter.
All lead singers are singers.
All singers are musicians.
Demons is one of the most popular singles of Imagine Dragons.
Some singles of Imagine Dragons have been on Billboard Hot 100.

[PREMISE (FOL)]:
American(imagineDragon) ∧ RockBand(imagineDragon)
LeadSinger(imagineDragon, dan)
SongWriter(dan)
∀x ∀y (LeadSinger(x, y) → Singer(y))
∀x (Singer(x) → Musician(x))
PopularSingle(imagineDragon, demons)
∃x ∃y (PopularSingle(imagineDragon, x) ∧ BillboardHot100(x)) ∧ (¬(x=y)) ∧ (PopularSingle(imagineDragon, y) ∧ BillboardHot100(y))

[PREMISE (GK)]:
American(imagineDragon) & RockBand(imagineDragon).
LeadSinger(imagineDragon, dan).
SongWriter(dan).
! [X] : ! [Y] : (LeadSinger(X, Y) => Singer(Y)).
! [X] : (Singer(X) => Musician(X)).
PopularSingle(imagineDragon, demons).
? [X] : ? [Y] : (PopularSingle(imagineDragon, X) & BillboardHot100(X)) & (-(X=Y)) & (PopularSingle(imagineDragon, Y) & BillboardHot100(Y)).

[CONCLUSION]:
Dan is not a musician.

[CONCLUSION (FOL)]:
¬Musician(dan)

[CONCLUSION (GK)]:
-Musician(dan).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Imagine Dragons are an American pop-rock band.
The lead singer of Imagine Dragons is Dan.
Dan is also a songwriter.
All lead singers are singers.
All singers are musicians.
Demons is one of the most popular singles of Imagine Dragons.
Some singles of Imagine Dragons have been on Billboard Hot 100.

[PREMISE (FOL)]:
American(imagineDragon) ∧ RockBand(imagineDragon)
LeadSinger(imagineDragon, dan)
SongWriter(dan)
∀x ∀y (LeadSinger(x, y) → Singer(y))
∀x (Singer(x) → Musician(x))
PopularSingle(imagineDragon, demons)
∃x ∃y (PopularSingle(imagineDragon, x) ∧ BillboardHot100(x)) ∧ (¬(x=y)) ∧ (PopularSingle(imagineDragon, y) ∧ BillboardHot100(y))

[PREMISE (GK)]:
American(imagineDragon) & RockBand(imagineDragon).
LeadSinger(imagineDragon, dan).
SongWriter(dan).
! [X] : ! [Y] : (LeadSinger(X, Y) => Singer(Y)).
! [X] : (Singer(X) => Musician(X)).
PopularSingle(imagineDragon, demons).
? [X] : ? [Y] : (PopularSingle(imagineDragon, X) & BillboardHot100(X)) & (-(X=Y)) & (PopularSingle(imagineDragon, Y) & BillboardHot100(Y)).

[CONCLUSION]:
Demons has been on Billboard Hot 100.

[CONCLUSION (FOL)]:
BillboardHot100(demons)

[CONCLUSION (GK)]:
BillboardHot100(demons).


===

['x']
['x']
[PREMISE]:
All philosophers reason. 
Some sophists reason. 
All who can reason can distinguish truth from falsehood.
Nobody who can distinguish truth from falsehood is morally perfect.  
The theistic God is morally perfect.

[PREMISE (FOL)]:
∀x (Philosopher(x) → Reason(x))
∃x (Sophist(x) ∧ Reason(x))
∀x (Reason(x) → CanDistinguishFrom(x, truth, falsehood))
∀x (CanDistinguishFrom(x, truth, falsehood) → ¬MorallyPerfect(x))
MorallyPerfect(theisticGod)

[PREMISE (GK)]:
! [X] : (Philosopher(X) => Reason(X)).
? [X] : (Sophist(X) & Reason(X)).
! [X] : (Reason(X) => CanDistinguishFrom(X, truth, falsehood)).
! [X] : (CanDistinguishFrom(X, truth, falsehood) => -MorallyPerfect(X)).
MorallyPerfect(theisticGod).

[CONCLUSION]:
The theistic God is a sophist.

[CONCLUSION (FOL)]:
Sophist(theisticGod)

[CONCLUSION (GK)]:
Sophist(theisticGod).


===

['x']
['x']
[PREMISE]:
All philosophers reason. 
Some sophists reason. 
All who can reason can distinguish truth from falsehood.
Nobody who can distinguish truth from falsehood is morally perfect.  
The theistic God is morally perfect.

[PREMISE (FOL)]:
∀x (Philosopher(x) → Reason(x))
∃x (Sophist(x) ∧ Reason(x))
∀x (Reason(x) → CanDistinguishFrom(x, truth, falsehood))
∀x (CanDistinguishFrom(x, truth, falsehood) → ¬MorallyPerfect(x))
MorallyPerfect(theisticGod)

[PREMISE (GK)]:
! [X] : (Philosopher(X) => Reason(X)).
? [X] : (Sophist(X) & Reason(X)).
! [X] : (Reason(X) => CanDistinguishFrom(X, truth, falsehood)).
! [X] : (CanDistinguishFrom(X, truth, falsehood) => -MorallyPerfect(X)).
MorallyPerfect(theisticGod).

[CONCLUSION]:
The theistic God is a sophist and a philosopher.

[CONCLUSION (FOL)]:
Sophist(theisticGod) ∧ Philosopher(theisticGod)

[CONCLUSION (GK)]:
Sophist(theisticGod) & Philosopher(theisticGod).


===

['x']
['x']
[PREMISE]:
All philosophers reason. 
Some sophists reason. 
All who can reason can distinguish truth from falsehood.
Nobody who can distinguish truth from falsehood is morally perfect.  
The theistic God is morally perfect.

[PREMISE (FOL)]:
∀x (Philosopher(x) → Reason(x))
∃x (Sophist(x) ∧ Reason(x))
∀x (Reason(x) → CanDistinguishFrom(x, truth, falsehood))
∀x (CanDistinguishFrom(x, truth, falsehood) → ¬MorallyPerfect(x))
MorallyPerfect(theisticGod)

[PREMISE (GK)]:
! [X] : (Philosopher(X) => Reason(X)).
? [X] : (Sophist(X) & Reason(X)).
! [X] : (Reason(X) => CanDistinguishFrom(X, truth, falsehood)).
! [X] : (CanDistinguishFrom(X, truth, falsehood) => -MorallyPerfect(X)).
MorallyPerfect(theisticGod).

[CONCLUSION]:
if the theistic God is a philosopher, then he is not a sophist.

[CONCLUSION (FOL)]:
Philosopher(theisticGod) → ¬Sophist(theisticGod)

[CONCLUSION (GK)]:
Philosopher(theisticGod) => -Sophist(theisticGod).


===

['x']
['x']
[PREMISE]:
Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.
Many apartment rents cover the cost of water and electricity.
Susan lives in an apartment where the rent covers all utilities.
The rent of the apartment where Ava lives does not cover any utility expenses.
Noah lives in an apartment where the rent does not cover heating.

[PREMISE (FOL)]:
CommonUtilities(water) ∧ CommonUtilities(electricity) ∧ CommonUtilities(gas) ∧ CommonUtilities(heating)
∃x (Apartment(x) ∧ Cover(x, water) ∧ Cover(x, electricity))
∀x (Apartment(x) ∧ LiveIn(susan, x) ∧ Cover(x, water) ∧ Cover(x, electricity) ∧ Cover(x, gas) ∧ Cover(x, heating))
∀x (Apartment(x) ∧ LiveIn(ava, x) ∧ ¬Cover(x, water) ∧ ¬Cover(x, electricity) ∧ ¬Cover(x, gas) ∧ ¬Cover(x, heating))
∀x (Apartment(x) ∧ LiveIn(noah, x) ∧ ¬Cover(x, heating))

[PREMISE (GK)]:
CommonUtilities(water) & CommonUtilities(electricity) & CommonUtilities(gas) & CommonUtilities(heating).
? [X] : (Apartment(X) & Cover(X, water) & Cover(X, electricity)).
! [X] : (Apartment(X) & LiveIn(susan, X) & Cover(X, water) & Cover(X, electricity) & Cover(X, gas) & Cover(X, heating)).
! [X] : (Apartment(X) & LiveIn(ava, X) & -Cover(X, water) & -Cover(X, electricity) & -Cover(X, gas) & -Cover(X, heating)).
! [X] : (Apartment(X) & LiveIn(noah, X) & -Cover(X, heating)).

[CONCLUSION]:
Noah needs to pay the water bill.

[CONCLUSION (FOL)]:
∀x (Apartment(x) ∧ LiveIn(noah, x) ∧ ¬Cover(x, water))

[CONCLUSION (GK)]:
! [X] : (Apartment(X) & LiveIn(noah, X) & -Cover(X, water)).


===

['x']
['x']
[PREMISE]:
Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.
Many apartment rents cover the cost of water and electricity.
Susan lives in an apartment where the rent covers all utilities.
The rent of the apartment where Ava lives does not cover any utility expenses.
Noah lives in an apartment where the rent does not cover heating.

[PREMISE (FOL)]:
CommonUtilities(water) ∧ CommonUtilities(electricity) ∧ CommonUtilities(gas) ∧ CommonUtilities(heating)
∃x (Apartment(x) ∧ Cover(x, water) ∧ Cover(x, electricity))
∀x (Apartment(x) ∧ LiveIn(susan, x) ∧ Cover(x, water) ∧ Cover(x, electricity) ∧ Cover(x, gas) ∧ Cover(x, heating))
∀x (Apartment(x) ∧ LiveIn(ava, x) ∧ ¬Cover(x, water) ∧ ¬Cover(x, electricity) ∧ ¬Cover(x, gas) ∧ ¬Cover(x, heating))
∀x (Apartment(x) ∧ LiveIn(noah, x) ∧ ¬Cover(x, heating))

[PREMISE (GK)]:
CommonUtilities(water) & CommonUtilities(electricity) & CommonUtilities(gas) & CommonUtilities(heating).
? [X] : (Apartment(X) & Cover(X, water) & Cover(X, electricity)).
! [X] : (Apartment(X) & LiveIn(susan, X) & Cover(X, water) & Cover(X, electricity) & Cover(X, gas) & Cover(X, heating)).
! [X] : (Apartment(X) & LiveIn(ava, X) & -Cover(X, water) & -Cover(X, electricity) & -Cover(X, gas) & -Cover(X, heating)).
! [X] : (Apartment(X) & LiveIn(noah, X) & -Cover(X, heating)).

[CONCLUSION]:
Noah and Ava both need to pay the heating bill.

[CONCLUSION (FOL)]:
¬Cover(noah, heating) ∧ ¬Cover(ava, heating)

[CONCLUSION (GK)]:
-Cover(noah, heating) & -Cover(ava, heating).


===

['x']
['x']
[PREMISE]:
Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.
Many apartment rents cover the cost of water and electricity.
Susan lives in an apartment where the rent covers all utilities.
The rent of the apartment where Ava lives does not cover any utility expenses.
Noah lives in an apartment where the rent does not cover heating.

[PREMISE (FOL)]:
CommonUtilities(water) ∧ CommonUtilities(electricity) ∧ CommonUtilities(gas) ∧ CommonUtilities(heating)
∃x (Apartment(x) ∧ Cover(x, water) ∧ Cover(x, electricity))
∀x (Apartment(x) ∧ LiveIn(susan, x) ∧ Cover(x, water) ∧ Cover(x, electricity) ∧ Cover(x, gas) ∧ Cover(x, heating))
∀x (Apartment(x) ∧ LiveIn(ava, x) ∧ ¬Cover(x, water) ∧ ¬Cover(x, electricity) ∧ ¬Cover(x, gas) ∧ ¬Cover(x, heating))
∀x (Apartment(x) ∧ LiveIn(noah, x) ∧ ¬Cover(x, heating))

[PREMISE (GK)]:
CommonUtilities(water) & CommonUtilities(electricity) & CommonUtilities(gas) & CommonUtilities(heating).
? [X] : (Apartment(X) & Cover(X, water) & Cover(X, electricity)).
! [X] : (Apartment(X) & LiveIn(susan, X) & Cover(X, water) & Cover(X, electricity) & Cover(X, gas) & Cover(X, heating)).
! [X] : (Apartment(X) & LiveIn(ava, X) & -Cover(X, water) & -Cover(X, electricity) & -Cover(X, gas) & -Cover(X, heating)).
! [X] : (Apartment(X) & LiveIn(noah, X) & -Cover(X, heating)).

[CONCLUSION]:
Susan does not need to pay the water bill.

[CONCLUSION (FOL)]:
∀x (Apartment(x) ∧ LiveIn(susan, x) ∧ Cover(x, water))

[CONCLUSION (GK)]:
! [X] : (Apartment(X) & LiveIn(susan, X) & Cover(X, water)).


===

['x']
['x']
[PREMISE]:
All clothes are products. 
No products are perfect. 
All dresses are clothes.
All skirts are dresses. 
If the fabric bundle is a piece of clothing, then the fabric bundle is a perfect dress.

[PREMISE (FOL)]:
∀x (Clothes(x) → Product(x))
∀x (Product(x) → ¬Perfect(x))
∀x (Dress(x) → Clothes(x))
∀x (Skirt(x) → Dress(x))
Clothes(fabricBundle) → Perfect(fabricBundle) ∧ Dress(fabricBundle)

[PREMISE (GK)]:
! [X] : (Clothes(X) => Product(X)).
! [X] : (Product(X) => -Perfect(X)).
! [X] : (Dress(X) => Clothes(X)).
! [X] : (Skirt(X) => Dress(X)).
Clothes(fabricBundle) => Perfect(fabricBundle) & Dress(fabricBundle).

[CONCLUSION]:
The fabric bundle is perfect.

[CONCLUSION (FOL)]:
Perfect(fabricbundle)

[CONCLUSION (GK)]:
Perfect(fabricbundle).


===

['x']
['x']
[PREMISE]:
All clothes are products. 
No products are perfect. 
All dresses are clothes.
All skirts are dresses. 
If the fabric bundle is a piece of clothing, then the fabric bundle is a perfect dress.

[PREMISE (FOL)]:
∀x (Clothes(x) → Product(x))
∀x (Product(x) → ¬Perfect(x))
∀x (Dress(x) → Clothes(x))
∀x (Skirt(x) → Dress(x))
Clothes(fabricBundle) → Perfect(fabricBundle) ∧ Dress(fabricBundle)

[PREMISE (GK)]:
! [X] : (Clothes(X) => Product(X)).
! [X] : (Product(X) => -Perfect(X)).
! [X] : (Dress(X) => Clothes(X)).
! [X] : (Skirt(X) => Dress(X)).
Clothes(fabricBundle) => Perfect(fabricBundle) & Dress(fabricBundle).

[CONCLUSION]:
The fabric bundle is a skirt.

[CONCLUSION (FOL)]:
Skirt(fabricbundle)

[CONCLUSION (GK)]:
Skirt(fabricbundle).


===

['x']
['x']
[PREMISE]:
All clothes are products. 
No products are perfect. 
All dresses are clothes.
All skirts are dresses. 
If the fabric bundle is a piece of clothing, then the fabric bundle is a perfect dress.

[PREMISE (FOL)]:
∀x (Clothes(x) → Product(x))
∀x (Product(x) → ¬Perfect(x))
∀x (Dress(x) → Clothes(x))
∀x (Skirt(x) → Dress(x))
Clothes(fabricBundle) → Perfect(fabricBundle) ∧ Dress(fabricBundle)

[PREMISE (GK)]:
! [X] : (Clothes(X) => Product(X)).
! [X] : (Product(X) => -Perfect(X)).
! [X] : (Dress(X) => Clothes(X)).
! [X] : (Skirt(X) => Dress(X)).
Clothes(fabricBundle) => Perfect(fabricBundle) & Dress(fabricBundle).

[CONCLUSION]:
The fabric bundle is not a skirt.

[CONCLUSION (FOL)]:
¬Skirt(fabricbundle)

[CONCLUSION (GK)]:
-Skirt(fabricbundle).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All pets are animals.
Pets can be either a dog or a cat.
If a person has a pet, they care for that pet. 
Dogs and cats can be naughty. 
Pets who are naughty are not liked as much. 
Charlie has a naughty pet dog named Leo. 

[PREMISE (FOL)]:
∀x (Pet(x) → Animal(x))
∀x (Pet(x) → (Dog(x) ⊕ Cat(x)))
∀x ∀y ((Pet(y) ∧ OwnedBy(x,y)) → Cares(x, y))
∃x ∃y (Cat(x) ∧ Naughty(x) ∧ (¬(x=y)) ∧ Dog(y) ∧ Naughty(y))
∀x ∀y ((Pet(x) ∧ Naughty(x) ∧ OwnedBy(x,y)) → ¬Liked(x, y))
OwnedBy(leo, charlie) ∧ Pet(leo) ∧ Dog(leo) ∧ Naughty(leo)

[PREMISE (GK)]:
! [X] : (Pet(X) => Animal(X)).
! [X] : (Pet(X) => (Dog(X) <~> Cat(X))).
! [X] : ! [Y] : ((Pet(Y) & OwnedBy(X,Y)) => Cares(X, Y)).
? [X] : ? [Y] : (Cat(X) & Naughty(X) & (-(X=Y)) & Dog(Y) & Naughty(Y)).
! [X] : ! [Y] : ((Pet(X) & Naughty(X) & OwnedBy(X,Y)) => -Liked(X, Y)).
OwnedBy(leo, charlie) & Pet(leo) & Dog(leo) & Naughty(leo).

[CONCLUSION]:
Leo is an animal.

[CONCLUSION (FOL)]:
Animal(leo)

[CONCLUSION (GK)]:
Animal(leo).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All pets are animals.
Pets can be either a dog or a cat.
If a person has a pet, they care for that pet. 
Dogs and cats can be naughty. 
Pets who are naughty are not liked as much. 
Charlie has a naughty pet dog named Leo. 

[PREMISE (FOL)]:
∀x (Pet(x) → Animal(x))
∀x (Pet(x) → (Dog(x) ⊕ Cat(x)))
∀x ∀y ((Pet(y) ∧ OwnedBy(x,y)) → Cares(x, y))
∃x ∃y (Cat(x) ∧ Naughty(x) ∧ (¬(x=y)) ∧ Dog(y) ∧ Naughty(y))
∀x ∀y ((Pet(x) ∧ Naughty(x) ∧ OwnedBy(x,y)) → ¬Liked(x, y))
OwnedBy(leo, charlie) ∧ Pet(leo) ∧ Dog(leo) ∧ Naughty(leo)

[PREMISE (GK)]:
! [X] : (Pet(X) => Animal(X)).
! [X] : (Pet(X) => (Dog(X) <~> Cat(X))).
! [X] : ! [Y] : ((Pet(Y) & OwnedBy(X,Y)) => Cares(X, Y)).
? [X] : ? [Y] : (Cat(X) & Naughty(X) & (-(X=Y)) & Dog(Y) & Naughty(Y)).
! [X] : ! [Y] : ((Pet(X) & Naughty(X) & OwnedBy(X,Y)) => -Liked(X, Y)).
OwnedBy(leo, charlie) & Pet(leo) & Dog(leo) & Naughty(leo).

[CONCLUSION]:
Charlie does not like Leo and does not care for Leo.

[CONCLUSION (FOL)]:
¬Liked(leo, charlie) ∧ ¬Cares(charlie, leo)

[CONCLUSION (GK)]:
-Liked(leo, charlie) & -Cares(charlie, leo).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All pets are animals.
Pets can be either a dog or a cat.
If a person has a pet, they care for that pet. 
Dogs and cats can be naughty. 
Pets who are naughty are not liked as much. 
Charlie has a naughty pet dog named Leo. 

[PREMISE (FOL)]:
∀x (Pet(x) → Animal(x))
∀x (Pet(x) → (Dog(x) ⊕ Cat(x)))
∀x ∀y ((Pet(y) ∧ OwnedBy(x,y)) → Cares(x, y))
∃x ∃y (Cat(x) ∧ Naughty(x) ∧ (¬(x=y)) ∧ Dog(y) ∧ Naughty(y))
∀x ∀y ((Pet(x) ∧ Naughty(x) ∧ OwnedBy(x,y)) → ¬Liked(x, y))
OwnedBy(leo, charlie) ∧ Pet(leo) ∧ Dog(leo) ∧ Naughty(leo)

[PREMISE (GK)]:
! [X] : (Pet(X) => Animal(X)).
! [X] : (Pet(X) => (Dog(X) <~> Cat(X))).
! [X] : ! [Y] : ((Pet(Y) & OwnedBy(X,Y)) => Cares(X, Y)).
? [X] : ? [Y] : (Cat(X) & Naughty(X) & (-(X=Y)) & Dog(Y) & Naughty(Y)).
! [X] : ! [Y] : ((Pet(X) & Naughty(X) & OwnedBy(X,Y)) => -Liked(X, Y)).
OwnedBy(leo, charlie) & Pet(leo) & Dog(leo) & Naughty(leo).

[CONCLUSION]:
Dogs are not always naughty.

[CONCLUSION (FOL)]:
∀x (Dog(x) → ¬Naughty(x))

[CONCLUSION (GK)]:
! [X] : (Dog(X) => -Naughty(X)).


===

['x']
['x']
[PREMISE]:
Surprises are either fun or dreadful.
All scares are surprises.

[PREMISE (FOL)]:
∀x (Surprise(x) → (Fun(x) ⊕ Dreadful(x)))
∀x (Scare(x) → Surprise(x))

[PREMISE (GK)]:
! [X] : (Surprise(X) => (Fun(X) <~> Dreadful(X))).
! [X] : (Scare(X) => Surprise(X)).

[CONCLUSION]:
All scares are fun.

[CONCLUSION (FOL)]:
∀x (Scare(x) → Fun(x))

[CONCLUSION (GK)]:
! [X] : (Scare(X) => Fun(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All books written by Cixin Liu have sold more than 1 million copies. 
Some books that have won the Hugo Award were written by Cixin Liu.
All books about the future are forward-looking.
The book Three-Body Problem has sold more than 1 million copies.
The Three-Body Problem is about the future.

[PREMISE (FOL)]:
∀x ((Book(x) ∧ WrittenBy(x, cixinLiu)) → ∃y(MoreThan(y, oneMillion) ∧ Sold(x,y)))
∃x (Won(x, hugoAward) ∧ Book(x) ∧ WrittenBy(x, cixinLiu))
∀x ((Book(x) ∧ AboutFuture(x)) → FowardLooking(x))
Book(threeBodyProblem) ∧ ∃y(MoreThan(y, oneMillion) ∧ Sold(threeBodyProblem,y))
AboutFuture(threeBodyProblem)

[PREMISE (GK)]:
! [X] : ((Book(X) & WrittenBy(X, cixinLiu)) => ? [Y] :(MoreThan(Y, oneMillion) & Sold(X,Y))).
? [X] : (Won(X, hugoAward) & Book(X) & WrittenBy(X, cixinLiu)).
! [X] : ((Book(X) & AboutFuture(X)) => FowardLooking(X)).
Book(threeBodyProblem) & ? [Y] :(MoreThan(Y, oneMillion) & Sold(threeBodyProblem,Y)).
AboutFuture(threeBodyProblem).

[CONCLUSION]:
The Three-Body Problem won the Hugo Award.

[CONCLUSION (FOL)]:
Won(threeBodyProblem, hugoAward)

[CONCLUSION (GK)]:
Won(threeBodyProblem, hugoAward).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All books written by Cixin Liu have sold more than 1 million copies. 
Some books that have won the Hugo Award were written by Cixin Liu.
All books about the future are forward-looking.
The book Three-Body Problem has sold more than 1 million copies.
The Three-Body Problem is about the future.

[PREMISE (FOL)]:
∀x ((Book(x) ∧ WrittenBy(x, cixinLiu)) → ∃y(MoreThan(y, oneMillion) ∧ Sold(x,y)))
∃x (Won(x, hugoAward) ∧ Book(x) ∧ WrittenBy(x, cixinLiu))
∀x ((Book(x) ∧ AboutFuture(x)) → FowardLooking(x))
Book(threeBodyProblem) ∧ ∃y(MoreThan(y, oneMillion) ∧ Sold(threeBodyProblem,y))
AboutFuture(threeBodyProblem)

[PREMISE (GK)]:
! [X] : ((Book(X) & WrittenBy(X, cixinLiu)) => ? [Y] :(MoreThan(Y, oneMillion) & Sold(X,Y))).
? [X] : (Won(X, hugoAward) & Book(X) & WrittenBy(X, cixinLiu)).
! [X] : ((Book(X) & AboutFuture(X)) => FowardLooking(X)).
Book(threeBodyProblem) & ? [Y] :(MoreThan(Y, oneMillion) & Sold(threeBodyProblem,Y)).
AboutFuture(threeBodyProblem).

[CONCLUSION]:
The Three-Body Problem is forward-looking.

[CONCLUSION (FOL)]:
AboutFuture(threeBodyProblem)

[CONCLUSION (GK)]:
AboutFuture(threeBodyProblem).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All books written by Cixin Liu have sold more than 1 million copies. 
Some books that have won the Hugo Award were written by Cixin Liu.
All books about the future are forward-looking.
The book Three-Body Problem has sold more than 1 million copies.
The Three-Body Problem is about the future.

[PREMISE (FOL)]:
∀x ((Book(x) ∧ WrittenBy(x, cixinLiu)) → ∃y(MoreThan(y, oneMillion) ∧ Sold(x,y)))
∃x (Won(x, hugoAward) ∧ Book(x) ∧ WrittenBy(x, cixinLiu))
∀x ((Book(x) ∧ AboutFuture(x)) → FowardLooking(x))
Book(threeBodyProblem) ∧ ∃y(MoreThan(y, oneMillion) ∧ Sold(threeBodyProblem,y))
AboutFuture(threeBodyProblem)

[PREMISE (GK)]:
! [X] : ((Book(X) & WrittenBy(X, cixinLiu)) => ? [Y] :(MoreThan(Y, oneMillion) & Sold(X,Y))).
? [X] : (Won(X, hugoAward) & Book(X) & WrittenBy(X, cixinLiu)).
! [X] : ((Book(X) & AboutFuture(X)) => FowardLooking(X)).
Book(threeBodyProblem) & ? [Y] :(MoreThan(Y, oneMillion) & Sold(threeBodyProblem,Y)).
AboutFuture(threeBodyProblem).

[CONCLUSION]:
The Three-Body Problem was written by Cixin Liu.

[CONCLUSION (FOL)]:
WrittenBy(threeBodyProblem, cixinLiu)

[CONCLUSION (GK)]:
WrittenBy(threeBodyProblem, cixinLiu).


===

['x']
['x']
[PREMISE]:
Some people are both late-night and early-morning people.
If a person is an earl- morning person, they have early-morning habits.
Everyone who has early-morning habits gets up early.
Everyone who gets up early catches the sunrise.
James doesn't catch the sunrise.

[PREMISE (FOL)]:
∃x (LateNightPerson(x) ∧ EarlyMorningPerson(x))
∀x (EarlyMorningPerson(x) → Have(x, earlyMorningHabit))
∀x (Have(x, earlyMorningHabit) → GetUpEarly(x))
∀x (GetUpEarly(x) → CatchTheSunrise(x))
¬CatchTheSunrise(james)

[PREMISE (GK)]:
? [X] : (LateNightPerson(X) & EarlyMorningPerson(X)).
! [X] : (EarlyMorningPerson(X) => Have(X, earlyMorningHabit)).
! [X] : (Have(X, earlyMorningHabit) => GetUpEarly(X)).
! [X] : (GetUpEarly(X) => CatchTheSunrise(X)).
-CatchTheSunrise(james).

[CONCLUSION]:
James is a late night person.

[CONCLUSION (FOL)]:
LateNightPerson(james)

[CONCLUSION (GK)]:
LateNightPerson(james).


===

['x']
['x']
[PREMISE]:
Some people are both late-night and early-morning people.
If a person is an earl- morning person, they have early-morning habits.
Everyone who has early-morning habits gets up early.
Everyone who gets up early catches the sunrise.
James doesn't catch the sunrise.

[PREMISE (FOL)]:
∃x (LateNightPerson(x) ∧ EarlyMorningPerson(x))
∀x (EarlyMorningPerson(x) → Have(x, earlyMorningHabit))
∀x (Have(x, earlyMorningHabit) → GetUpEarly(x))
∀x (GetUpEarly(x) → CatchTheSunrise(x))
¬CatchTheSunrise(james)

[PREMISE (GK)]:
? [X] : (LateNightPerson(X) & EarlyMorningPerson(X)).
! [X] : (EarlyMorningPerson(X) => Have(X, earlyMorningHabit)).
! [X] : (Have(X, earlyMorningHabit) => GetUpEarly(X)).
! [X] : (GetUpEarly(X) => CatchTheSunrise(X)).
-CatchTheSunrise(james).

[CONCLUSION]:
James is a late night person and an early-morning person.

[CONCLUSION (FOL)]:
LateNightPerson(james) ∧ EarlyMorningPerson(james)

[CONCLUSION (GK)]:
LateNightPerson(james) & EarlyMorningPerson(james).


===

['x']
['x']
[PREMISE]:
Some people are both late-night and early-morning people.
If a person is an earl- morning person, they have early-morning habits.
Everyone who has early-morning habits gets up early.
Everyone who gets up early catches the sunrise.
James doesn't catch the sunrise.

[PREMISE (FOL)]:
∃x (LateNightPerson(x) ∧ EarlyMorningPerson(x))
∀x (EarlyMorningPerson(x) → Have(x, earlyMorningHabit))
∀x (Have(x, earlyMorningHabit) → GetUpEarly(x))
∀x (GetUpEarly(x) → CatchTheSunrise(x))
¬CatchTheSunrise(james)

[PREMISE (GK)]:
? [X] : (LateNightPerson(X) & EarlyMorningPerson(X)).
! [X] : (EarlyMorningPerson(X) => Have(X, earlyMorningHabit)).
! [X] : (Have(X, earlyMorningHabit) => GetUpEarly(X)).
! [X] : (GetUpEarly(X) => CatchTheSunrise(X)).
-CatchTheSunrise(james).

[CONCLUSION]:
If James is an early-morning person, then he is a late night person.

[CONCLUSION (FOL)]:
EarlyMorningPerson(james) → LateNightPerson(james)

[CONCLUSION (GK)]:
EarlyMorningPerson(james) => LateNightPerson(james).


===

['x', 'y']
['x', 'y']
[PREMISE]:
There is no dog on the roof.
If there is a dog on the roof, something went wrong.

[PREMISE (FOL)]:
∀x (Dog(x) → ¬OnRoof(x)))
∀x ∃y ((Dog(x) ∧ OnRoof(x)) → GoWrong(y))

[PREMISE (GK)]:
! [X] : (Dog(X) => -OnRoof(X))).
! [X] : ? [Y] : ((Dog(X) & OnRoof(X)) => GoWrong(Y)).

[CONCLUSION]:
Something went wrong.

[CONCLUSION (FOL)]:
∃x (GoWrong(x))

[CONCLUSION (GK)]:
? [X] : (GoWrong(X)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Elephantopus is a genus of perennial plants in the daisy family.
Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.
Several species of Elephantopus are native to the southeastern United States.
Elephantopus scaber is a traditional medicine.

[PREMISE (FOL)]:
∀x (Elephantopus(x) → (Genus(x, perennialplants) ∧ BelongTo(x, daisyfamily)))
∃x ∃y ∃z(Elephantopus(x) ∧ In(x,africa) ∧ (¬(x=y)) ∧ Elephantopus(y) ∧ In(y, southernasia) ∧ (¬(x=z)) ∧ (¬(y=z)) ∧ Elephantopus(z) ∧ In(z, australia))
∃x ∃y (Elephantopus(x) ∧ NativeTo(x, southeasternunitedstates) ∧ (¬(x=y)) ∧ Elephantopus(y) ∧ NativeTo(y, southeasternunitedstates))
∀x (ElephantopusScaber(x) → TraditionalMedicine(x))

[PREMISE (GK)]:
! [X] : (Elephantopus(X) => (Genus(X, perennialplants) & BelongTo(X, daisyfamily))).
? [X] : ? [Y] : ? [Z] :(Elephantopus(X) & In(X,africa) & (-(X=Y)) & Elephantopus(Y) & In(Y, southernasia) & (-(X=Z)) & (-(Y=Z)) & Elephantopus(Z) & In(Z, australia)).
? [X] : ? [Y] : (Elephantopus(X) & NativeTo(X, southeasternunitedstates) & (-(X=Y)) & Elephantopus(Y) & NativeTo(Y, southeasternunitedstates)).
! [X] : (ElephantopusScaber(X) => TraditionalMedicine(X)).

[CONCLUSION]:
Elephantopus is found in Australia and Southern Asia.

[CONCLUSION (FOL)]:
∃x∃y(Elephantopus(x) ∧ In(x,africa) ∧ Elephantopus(y) ∧ In(y,africa))

[CONCLUSION (GK)]:
? [X] :? [Y] :(Elephantopus(X) & In(X,africa) & Elephantopus(Y) & In(Y,africa)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Elephantopus is a genus of perennial plants in the daisy family.
Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.
Several species of Elephantopus are native to the southeastern United States.
Elephantopus scaber is a traditional medicine.

[PREMISE (FOL)]:
∀x (Elephantopus(x) → (Genus(x, perennialplants) ∧ BelongTo(x, daisyfamily)))
∃x ∃y ∃z(Elephantopus(x) ∧ In(x,africa) ∧ (¬(x=y)) ∧ Elephantopus(y) ∧ In(y, southernasia) ∧ (¬(x=z)) ∧ (¬(y=z)) ∧ Elephantopus(z) ∧ In(z, australia))
∃x ∃y (Elephantopus(x) ∧ NativeTo(x, southeasternunitedstates) ∧ (¬(x=y)) ∧ Elephantopus(y) ∧ NativeTo(y, southeasternunitedstates))
∀x (ElephantopusScaber(x) → TraditionalMedicine(x))

[PREMISE (GK)]:
! [X] : (Elephantopus(X) => (Genus(X, perennialplants) & BelongTo(X, daisyfamily))).
? [X] : ? [Y] : ? [Z] :(Elephantopus(X) & In(X,africa) & (-(X=Y)) & Elephantopus(Y) & In(Y, southernasia) & (-(X=Z)) & (-(Y=Z)) & Elephantopus(Z) & In(Z, australia)).
? [X] : ? [Y] : (Elephantopus(X) & NativeTo(X, southeasternunitedstates) & (-(X=Y)) & Elephantopus(Y) & NativeTo(Y, southeasternunitedstates)).
! [X] : (ElephantopusScaber(X) => TraditionalMedicine(X)).

[CONCLUSION]:
No Elephantopus is native to the southeastern United States.

[CONCLUSION (FOL)]:
∀x (Elephantopus(x) → ¬NativeTo(x, southeasternunitedstates))

[CONCLUSION (GK)]:
! [X] : (Elephantopus(X) => -NativeTo(X, southeasternunitedstates)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Elephantopus is a genus of perennial plants in the daisy family.
Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.
Several species of Elephantopus are native to the southeastern United States.
Elephantopus scaber is a traditional medicine.

[PREMISE (FOL)]:
∀x (Elephantopus(x) → (Genus(x, perennialplants) ∧ BelongTo(x, daisyfamily)))
∃x ∃y ∃z(Elephantopus(x) ∧ In(x,africa) ∧ (¬(x=y)) ∧ Elephantopus(y) ∧ In(y, southernasia) ∧ (¬(x=z)) ∧ (¬(y=z)) ∧ Elephantopus(z) ∧ In(z, australia))
∃x ∃y (Elephantopus(x) ∧ NativeTo(x, southeasternunitedstates) ∧ (¬(x=y)) ∧ Elephantopus(y) ∧ NativeTo(y, southeasternunitedstates))
∀x (ElephantopusScaber(x) → TraditionalMedicine(x))

[PREMISE (GK)]:
! [X] : (Elephantopus(X) => (Genus(X, perennialplants) & BelongTo(X, daisyfamily))).
? [X] : ? [Y] : ? [Z] :(Elephantopus(X) & In(X,africa) & (-(X=Y)) & Elephantopus(Y) & In(Y, southernasia) & (-(X=Z)) & (-(Y=Z)) & Elephantopus(Z) & In(Z, australia)).
? [X] : ? [Y] : (Elephantopus(X) & NativeTo(X, southeasternunitedstates) & (-(X=Y)) & Elephantopus(Y) & NativeTo(Y, southeasternunitedstates)).
! [X] : (ElephantopusScaber(X) => TraditionalMedicine(X)).

[CONCLUSION]:
Elephantopus is a traditional medicine.

[CONCLUSION (FOL)]:
∀x (Elephantopus(x) → TraditionalMedicine(x))

[CONCLUSION (GK)]:
! [X] : (Elephantopus(X) => TraditionalMedicine(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All Yale dormitories are located on the Yale campus. 
All Yale buildings managed by Yale Housing are dormitories. 
All Yale buildings operated by Yale Housing staff are managed by Yale Housing. 
None of the Yale buildings open to students were built before 1701. 
All Yale buildings located on the Yale campus are open to students. 
Harkness is either a Yale building operated by Yale Housing staff, or it is located on York Street. 

[PREMISE (FOL)]:
∀x (YaleDormitory(x) → LocatedOn(x, yaleCampus))
∀x ((YaleBuildings(x) ∧ ManagedBy(x, yaleHousing)) → YaleDormitory(x))
∀x ((YaleBuildings(x) ∧ OperatedBy(x, yaleHousingStaff)) → ManagedBy(x, yaleHousing))
∀x ((YaleBuildings(x) ∧ OpenToStudents(x)) → (¬∃y(Before(y, yr1701) ∧ Established(x, y))))
∀x ((YaleBuildings(x) ∧ LocatedOn(x, yaleCampus)) → OpenToStudents(x))
YaleBuildings(harkness) ∧ (OperatedBy(x, harkness) ⊕ LocatedOn(harkness, yaleCampus))

[PREMISE (GK)]:
! [X] : (YaleDormitory(X) => LocatedOn(X, yaleCampus)).
! [X] : ((YaleBuildings(X) & ManagedBy(X, yaleHousing)) => YaleDormitory(X)).
! [X] : ((YaleBuildings(X) & OperatedBy(X, yaleHousingStaff)) => ManagedBy(X, yaleHousing)).
! [X] : ((YaleBuildings(X) & OpenToStudents(X)) => (-? [Y] :(Before(Y, yr1701) & Established(X, Y)))).
! [X] : ((YaleBuildings(X) & LocatedOn(X, yaleCampus)) => OpenToStudents(X)).
YaleBuildings(harkness) & (OperatedBy(x, harkness) <~> LocatedOn(harkness, yaleCampus)).

[CONCLUSION]:
Harkness is a Yale dormitory.

[CONCLUSION (FOL)]:
YaleDormitory(harkness)

[CONCLUSION (GK)]:
YaleDormitory(harkness).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All Yale dormitories are located on the Yale campus. 
All Yale buildings managed by Yale Housing are dormitories. 
All Yale buildings operated by Yale Housing staff are managed by Yale Housing. 
None of the Yale buildings open to students were built before 1701. 
All Yale buildings located on the Yale campus are open to students. 
Harkness is either a Yale building operated by Yale Housing staff, or it is located on York Street. 

[PREMISE (FOL)]:
∀x (YaleDormitory(x) → LocatedOn(x, yaleCampus))
∀x ((YaleBuildings(x) ∧ ManagedBy(x, yaleHousing)) → YaleDormitory(x))
∀x ((YaleBuildings(x) ∧ OperatedBy(x, yaleHousingStaff)) → ManagedBy(x, yaleHousing))
∀x ((YaleBuildings(x) ∧ OpenToStudents(x)) → (¬∃y(Before(y, yr1701) ∧ Established(x, y))))
∀x ((YaleBuildings(x) ∧ LocatedOn(x, yaleCampus)) → OpenToStudents(x))
YaleBuildings(harkness) ∧ (OperatedBy(x, harkness) ⊕ LocatedOn(harkness, yaleCampus))

[PREMISE (GK)]:
! [X] : (YaleDormitory(X) => LocatedOn(X, yaleCampus)).
! [X] : ((YaleBuildings(X) & ManagedBy(X, yaleHousing)) => YaleDormitory(X)).
! [X] : ((YaleBuildings(X) & OperatedBy(X, yaleHousingStaff)) => ManagedBy(X, yaleHousing)).
! [X] : ((YaleBuildings(X) & OpenToStudents(X)) => (-? [Y] :(Before(Y, yr1701) & Established(X, Y)))).
! [X] : ((YaleBuildings(X) & LocatedOn(X, yaleCampus)) => OpenToStudents(X)).
YaleBuildings(harkness) & (OperatedBy(x, harkness) <~> LocatedOn(harkness, yaleCampus)).

[CONCLUSION]:
Harkness is not a Yale dormitory.

[CONCLUSION (FOL)]:
¬YaleDormitory(harkness)

[CONCLUSION (GK)]:
-YaleDormitory(harkness).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All Yale dormitories are located on the Yale campus. 
All Yale buildings managed by Yale Housing are dormitories. 
All Yale buildings operated by Yale Housing staff are managed by Yale Housing. 
None of the Yale buildings open to students were built before 1701. 
All Yale buildings located on the Yale campus are open to students. 
Harkness is either a Yale building operated by Yale Housing staff, or it is located on York Street. 

[PREMISE (FOL)]:
∀x (YaleDormitory(x) → LocatedOn(x, yaleCampus))
∀x ((YaleBuildings(x) ∧ ManagedBy(x, yaleHousing)) → YaleDormitory(x))
∀x ((YaleBuildings(x) ∧ OperatedBy(x, yaleHousingStaff)) → ManagedBy(x, yaleHousing))
∀x ((YaleBuildings(x) ∧ OpenToStudents(x)) → (¬∃y(Before(y, yr1701) ∧ Established(x, y))))
∀x ((YaleBuildings(x) ∧ LocatedOn(x, yaleCampus)) → OpenToStudents(x))
YaleBuildings(harkness) ∧ (OperatedBy(x, harkness) ⊕ LocatedOn(harkness, yaleCampus))

[PREMISE (GK)]:
! [X] : (YaleDormitory(X) => LocatedOn(X, yaleCampus)).
! [X] : ((YaleBuildings(X) & ManagedBy(X, yaleHousing)) => YaleDormitory(X)).
! [X] : ((YaleBuildings(X) & OperatedBy(X, yaleHousingStaff)) => ManagedBy(X, yaleHousing)).
! [X] : ((YaleBuildings(X) & OpenToStudents(X)) => (-? [Y] :(Before(Y, yr1701) & Established(X, Y)))).
! [X] : ((YaleBuildings(X) & LocatedOn(X, yaleCampus)) => OpenToStudents(X)).
YaleBuildings(harkness) & (OperatedBy(x, harkness) <~> LocatedOn(harkness, yaleCampus)).

[CONCLUSION]:
Harkness is established before 1701.

[CONCLUSION (FOL)]:
∃y(Before(y, year1701) ∧ Established(x, y))

[CONCLUSION (GK)]:
? [Y] :(Before(Y, year1701) & Established(X, Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
All Yale dormitories are located on the Yale campus. 
All Yale buildings managed by Yale Housing are dormitories. 
All Yale buildings operated by Yale Housing staff are managed by Yale Housing. 
None of the Yale buildings open to students were built before 1701. 
All Yale buildings located on the Yale campus are open to students. 
Harkness is either a Yale building operated by Yale Housing staff, or it is located on York Street. 

[PREMISE (FOL)]:
∀x (YaleDormitory(x) → LocatedOn(x, yaleCampus))
∀x ((YaleBuildings(x) ∧ ManagedBy(x, yaleHousing)) → YaleDormitory(x))
∀x ((YaleBuildings(x) ∧ OperatedBy(x, yaleHousingStaff)) → ManagedBy(x, yaleHousing))
∀x ((YaleBuildings(x) ∧ OpenToStudents(x)) → (¬∃y(Before(y, yr1701) ∧ Established(x, y))))
∀x ((YaleBuildings(x) ∧ LocatedOn(x, yaleCampus)) → OpenToStudents(x))
YaleBuildings(harkness) ∧ (OperatedBy(x, harkness) ⊕ LocatedOn(harkness, yaleCampus))

[PREMISE (GK)]:
! [X] : (YaleDormitory(X) => LocatedOn(X, yaleCampus)).
! [X] : ((YaleBuildings(X) & ManagedBy(X, yaleHousing)) => YaleDormitory(X)).
! [X] : ((YaleBuildings(X) & OperatedBy(X, yaleHousingStaff)) => ManagedBy(X, yaleHousing)).
! [X] : ((YaleBuildings(X) & OpenToStudents(X)) => (-? [Y] :(Before(Y, yr1701) & Established(X, Y)))).
! [X] : ((YaleBuildings(X) & LocatedOn(X, yaleCampus)) => OpenToStudents(X)).
YaleBuildings(harkness) & (OperatedBy(x, harkness) <~> LocatedOn(harkness, yaleCampus)).

[CONCLUSION]:
Harkness is not established before 1701.

[CONCLUSION (FOL)]:
¬∃y(Before(y, year1701) ∧ Established(x, y))

[CONCLUSION (GK)]:
-? [Y] :(Before(Y, year1701) & Established(X, Y)).


===

['x']
['x']
[PREMISE]:
There are no mansion houses in an urban area.
All skyscrapers are in urban areas.
Every creepy haunted house is a mansion house.
Every terrifying building on Halloween is a creepy haunted house.
The LaLaurie House is a creepy haunted house or a terrifying building on Halloween.

[PREMISE (FOL)]:
∀x (InUrbanArea(x) → ¬MansionHouse(x))
∀x (Skyscraper(x) → InUrbanArea(x))
∀x (CreepyHauntedHouse(x) → MansionHouse(x))
∀x (TerrifyingBuilding(x) ∧ OnHalloween(x) → CreepyHauntedHouse(x))
CreepyHauntedHouse(laLaurieHouse) ∨ TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse)

[PREMISE (GK)]:
! [X] : (InUrbanArea(X) => -MansionHouse(X)).
! [X] : (Skyscraper(X) => InUrbanArea(X)).
! [X] : (CreepyHauntedHouse(X) => MansionHouse(X)).
! [X] : (TerrifyingBuilding(X) & OnHalloween(X) => CreepyHauntedHouse(X)).
CreepyHauntedHouse(laLaurieHouse) | TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse).

[CONCLUSION]:
The LaLaurie House is a skyscraper.

[CONCLUSION (FOL)]:
Skyscraper(laLaurieHouse)

[CONCLUSION (GK)]:
Skyscraper(laLaurieHouse).


===

['x']
['x']
[PREMISE]:
There are no mansion houses in an urban area.
All skyscrapers are in urban areas.
Every creepy haunted house is a mansion house.
Every terrifying building on Halloween is a creepy haunted house.
The LaLaurie House is a creepy haunted house or a terrifying building on Halloween.

[PREMISE (FOL)]:
∀x (InUrbanArea(x) → ¬MansionHouse(x))
∀x (Skyscraper(x) → InUrbanArea(x))
∀x (CreepyHauntedHouse(x) → MansionHouse(x))
∀x (TerrifyingBuilding(x) ∧ OnHalloween(x) → CreepyHauntedHouse(x))
CreepyHauntedHouse(laLaurieHouse) ∨ TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse)

[PREMISE (GK)]:
! [X] : (InUrbanArea(X) => -MansionHouse(X)).
! [X] : (Skyscraper(X) => InUrbanArea(X)).
! [X] : (CreepyHauntedHouse(X) => MansionHouse(X)).
! [X] : (TerrifyingBuilding(X) & OnHalloween(X) => CreepyHauntedHouse(X)).
CreepyHauntedHouse(laLaurieHouse) | TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse).

[CONCLUSION]:
The LaLaurie House is not a skyscraper.

[CONCLUSION (FOL)]:
¬Skyscraper(laLaurieHouse)

[CONCLUSION (GK)]:
-Skyscraper(laLaurieHouse).


===

['x']
['x']
[PREMISE]:
There are no mansion houses in an urban area.
All skyscrapers are in urban areas.
Every creepy haunted house is a mansion house.
Every terrifying building on Halloween is a creepy haunted house.
The LaLaurie House is a creepy haunted house or a terrifying building on Halloween.

[PREMISE (FOL)]:
∀x (InUrbanArea(x) → ¬MansionHouse(x))
∀x (Skyscraper(x) → InUrbanArea(x))
∀x (CreepyHauntedHouse(x) → MansionHouse(x))
∀x (TerrifyingBuilding(x) ∧ OnHalloween(x) → CreepyHauntedHouse(x))
CreepyHauntedHouse(laLaurieHouse) ∨ TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse)

[PREMISE (GK)]:
! [X] : (InUrbanArea(X) => -MansionHouse(X)).
! [X] : (Skyscraper(X) => InUrbanArea(X)).
! [X] : (CreepyHauntedHouse(X) => MansionHouse(X)).
! [X] : (TerrifyingBuilding(X) & OnHalloween(X) => CreepyHauntedHouse(X)).
CreepyHauntedHouse(laLaurieHouse) | TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse).

[CONCLUSION]:
The LaLaurie House is a terrifying building on Halloween.

[CONCLUSION (FOL)]:
TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse)

[CONCLUSION (GK)]:
TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse).


===

['x']
['x']
[PREMISE]:
There are no mansion houses in an urban area.
All skyscrapers are in urban areas.
Every creepy haunted house is a mansion house.
Every terrifying building on Halloween is a creepy haunted house.
The LaLaurie House is a creepy haunted house or a terrifying building on Halloween.

[PREMISE (FOL)]:
∀x (InUrbanArea(x) → ¬MansionHouse(x))
∀x (Skyscraper(x) → InUrbanArea(x))
∀x (CreepyHauntedHouse(x) → MansionHouse(x))
∀x (TerrifyingBuilding(x) ∧ OnHalloween(x) → CreepyHauntedHouse(x))
CreepyHauntedHouse(laLaurieHouse) ∨ TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse)

[PREMISE (GK)]:
! [X] : (InUrbanArea(X) => -MansionHouse(X)).
! [X] : (Skyscraper(X) => InUrbanArea(X)).
! [X] : (CreepyHauntedHouse(X) => MansionHouse(X)).
! [X] : (TerrifyingBuilding(X) & OnHalloween(X) => CreepyHauntedHouse(X)).
CreepyHauntedHouse(laLaurieHouse) | TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse).

[CONCLUSION]:
The LaLaurie House is either a skyscraper or a mansion house.

[CONCLUSION (FOL)]:
Skyscraper(laLaurieHouse) ⊕ MansionHouse(laLaurieHouse)

[CONCLUSION (GK)]:
Skyscraper(laLaurieHouse) <~> MansionHouse(laLaurieHouse).


===

['x']
['x']
[PREMISE]:
There are no mansion houses in an urban area.
All skyscrapers are in urban areas.
Every creepy haunted house is a mansion house.
Every terrifying building on Halloween is a creepy haunted house.
The LaLaurie House is a creepy haunted house or a terrifying building on Halloween.

[PREMISE (FOL)]:
∀x (InUrbanArea(x) → ¬MansionHouse(x))
∀x (Skyscraper(x) → InUrbanArea(x))
∀x (CreepyHauntedHouse(x) → MansionHouse(x))
∀x (TerrifyingBuilding(x) ∧ OnHalloween(x) → CreepyHauntedHouse(x))
CreepyHauntedHouse(laLaurieHouse) ∨ TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse)

[PREMISE (GK)]:
! [X] : (InUrbanArea(X) => -MansionHouse(X)).
! [X] : (Skyscraper(X) => InUrbanArea(X)).
! [X] : (CreepyHauntedHouse(X) => MansionHouse(X)).
! [X] : (TerrifyingBuilding(X) & OnHalloween(X) => CreepyHauntedHouse(X)).
CreepyHauntedHouse(laLaurieHouse) | TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse).

[CONCLUSION]:
The LaLaurie House is either a skyscraper or in an urban area.

[CONCLUSION (FOL)]:
Skyscraper(laLaurieHouse) ⊕ UrbanArea(laLaurieHouse)

[CONCLUSION (GK)]:
Skyscraper(laLaurieHouse) <~> UrbanArea(laLaurieHouse).


===

['x']
['x']
[PREMISE]:
There are no mansion houses in an urban area.
All skyscrapers are in urban areas.
Every creepy haunted house is a mansion house.
Every terrifying building on Halloween is a creepy haunted house.
The LaLaurie House is a creepy haunted house or a terrifying building on Halloween.

[PREMISE (FOL)]:
∀x (InUrbanArea(x) → ¬MansionHouse(x))
∀x (Skyscraper(x) → InUrbanArea(x))
∀x (CreepyHauntedHouse(x) → MansionHouse(x))
∀x (TerrifyingBuilding(x) ∧ OnHalloween(x) → CreepyHauntedHouse(x))
CreepyHauntedHouse(laLaurieHouse) ∨ TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse)

[PREMISE (GK)]:
! [X] : (InUrbanArea(X) => -MansionHouse(X)).
! [X] : (Skyscraper(X) => InUrbanArea(X)).
! [X] : (CreepyHauntedHouse(X) => MansionHouse(X)).
! [X] : (TerrifyingBuilding(X) & OnHalloween(X) => CreepyHauntedHouse(X)).
CreepyHauntedHouse(laLaurieHouse) | TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse).

[CONCLUSION]:
The LaLaurie House is either a skyscraper or a creepy haunted house.

[CONCLUSION (FOL)]:
Skyscraper(laLaurieHouse) ⊕ CreepyHauntedHouse(laLaurieHouse)

[CONCLUSION (GK)]:
Skyscraper(laLaurieHouse) <~> CreepyHauntedHouse(laLaurieHouse).


===

['x']
['x']
[PREMISE]:
There are no mansion houses in an urban area.
All skyscrapers are in urban areas.
Every creepy haunted house is a mansion house.
Every terrifying building on Halloween is a creepy haunted house.
The LaLaurie House is a creepy haunted house or a terrifying building on Halloween.

[PREMISE (FOL)]:
∀x (InUrbanArea(x) → ¬MansionHouse(x))
∀x (Skyscraper(x) → InUrbanArea(x))
∀x (CreepyHauntedHouse(x) → MansionHouse(x))
∀x (TerrifyingBuilding(x) ∧ OnHalloween(x) → CreepyHauntedHouse(x))
CreepyHauntedHouse(laLaurieHouse) ∨ TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse)

[PREMISE (GK)]:
! [X] : (InUrbanArea(X) => -MansionHouse(X)).
! [X] : (Skyscraper(X) => InUrbanArea(X)).
! [X] : (CreepyHauntedHouse(X) => MansionHouse(X)).
! [X] : (TerrifyingBuilding(X) & OnHalloween(X) => CreepyHauntedHouse(X)).
CreepyHauntedHouse(laLaurieHouse) | TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse).

[CONCLUSION]:
If the LaLaurie House is not a mansion or not in an urban area, then it is either a skyscraper or in an urban area.

[CONCLUSION (FOL)]:
¬(MansionHouse(laLaurieHouse) ∧ InUrbanArea(laLaurieHouse)) → (Skyscraper(laLaurieHouse) ⊕ InUrbanArea(laLaurieHouse))

[CONCLUSION (GK)]:
-(MansionHouse(laLaurieHouse) & InUrbanArea(laLaurieHouse)) => (Skyscraper(laLaurieHouse) <~> InUrbanArea(laLaurieHouse)).


===

['x']
['x']
[PREMISE]:
There are no mansion houses in an urban area.
All skyscrapers are in urban areas.
Every creepy haunted house is a mansion house.
Every terrifying building on Halloween is a creepy haunted house.
The LaLaurie House is a creepy haunted house or a terrifying building on Halloween.

[PREMISE (FOL)]:
∀x (InUrbanArea(x) → ¬MansionHouse(x))
∀x (Skyscraper(x) → InUrbanArea(x))
∀x (CreepyHauntedHouse(x) → MansionHouse(x))
∀x (TerrifyingBuilding(x) ∧ OnHalloween(x) → CreepyHauntedHouse(x))
CreepyHauntedHouse(laLaurieHouse) ∨ TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse)

[PREMISE (GK)]:
! [X] : (InUrbanArea(X) => -MansionHouse(X)).
! [X] : (Skyscraper(X) => InUrbanArea(X)).
! [X] : (CreepyHauntedHouse(X) => MansionHouse(X)).
! [X] : (TerrifyingBuilding(X) & OnHalloween(X) => CreepyHauntedHouse(X)).
CreepyHauntedHouse(laLaurieHouse) | TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse).

[CONCLUSION]:
If the LaLaurie House is either a skyscraper or a mansion house, then it is in an urban area.

[CONCLUSION (FOL)]:
Skyscraper(laLaurieHouse) ⊕ MansionHouse(laLaurieHouse) → InUrbanArea(laLaurieHouse)

[CONCLUSION (GK)]:
Skyscraper(laLaurieHouse) <~> MansionHouse(laLaurieHouse) => InUrbanArea(laLaurieHouse).


===

['x']
['x']
[PREMISE]:
There are no mansion houses in an urban area.
All skyscrapers are in urban areas.
Every creepy haunted house is a mansion house.
Every terrifying building on Halloween is a creepy haunted house.
The LaLaurie House is a creepy haunted house or a terrifying building on Halloween.

[PREMISE (FOL)]:
∀x (InUrbanArea(x) → ¬MansionHouse(x))
∀x (Skyscraper(x) → InUrbanArea(x))
∀x (CreepyHauntedHouse(x) → MansionHouse(x))
∀x (TerrifyingBuilding(x) ∧ OnHalloween(x) → CreepyHauntedHouse(x))
CreepyHauntedHouse(laLaurieHouse) ∨ TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse)

[PREMISE (GK)]:
! [X] : (InUrbanArea(X) => -MansionHouse(X)).
! [X] : (Skyscraper(X) => InUrbanArea(X)).
! [X] : (CreepyHauntedHouse(X) => MansionHouse(X)).
! [X] : (TerrifyingBuilding(X) & OnHalloween(X) => CreepyHauntedHouse(X)).
CreepyHauntedHouse(laLaurieHouse) | TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse).

[CONCLUSION]:
If the LaLaurie House is either a skyscraper or a mansion house, then it is neither a creepy haunted house nor a terrifying building on Halloween.

[CONCLUSION (FOL)]:
Skyscraper(laLaurieHouse) ⊕ MansionHouse(laLaurieHouse) → ¬(CreepyHauntedHouse(laLaurieHouse) ∨ TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse))

[CONCLUSION (GK)]:
Skyscraper(laLaurieHouse) <~> MansionHouse(laLaurieHouse) => -(CreepyHauntedHouse(laLaurieHouse) | TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse)).


===

['x']
['x']
[PREMISE]:
There are no mansion houses in an urban area.
All skyscrapers are in urban areas.
Every creepy haunted house is a mansion house.
Every terrifying building on Halloween is a creepy haunted house.
The LaLaurie House is a creepy haunted house or a terrifying building on Halloween.

[PREMISE (FOL)]:
∀x (InUrbanArea(x) → ¬MansionHouse(x))
∀x (Skyscraper(x) → InUrbanArea(x))
∀x (CreepyHauntedHouse(x) → MansionHouse(x))
∀x (TerrifyingBuilding(x) ∧ OnHalloween(x) → CreepyHauntedHouse(x))
CreepyHauntedHouse(laLaurieHouse) ∨ TerrifyingBuilding(laLaurieHouse) ∧ OnHalloween(laLaurieHouse)

[PREMISE (GK)]:
! [X] : (InUrbanArea(X) => -MansionHouse(X)).
! [X] : (Skyscraper(X) => InUrbanArea(X)).
! [X] : (CreepyHauntedHouse(X) => MansionHouse(X)).
! [X] : (TerrifyingBuilding(X) & OnHalloween(X) => CreepyHauntedHouse(X)).
CreepyHauntedHouse(laLaurieHouse) | TerrifyingBuilding(laLaurieHouse) & OnHalloween(laLaurieHouse).

[CONCLUSION]:
If the LaLaurie House is either a skyscraper or a creepy haunted house, then it is not a mansion house.

[CONCLUSION (FOL)]:
Skyscraper(laLaurieHouse) ⊕ CreepyHauntedHouse(laLaurieHouse) → ¬MansionHouse(laLaurieHouse)

[CONCLUSION (GK)]:
Skyscraper(laLaurieHouse) <~> CreepyHauntedHouse(laLaurieHouse) => -MansionHouse(laLaurieHouse).


===

['x']
['x']
[PREMISE]:
Phuoc Binh national park is a national park in Vietnam. 
Any national park in Vietnam is classified as a nature reserve. 
There is a national park in Vietnam classified as a UNESCO World Heritage Site.
All national parks in Vietnam are either managed by the Ministry of Agriculture or managed by the People's Committee. 
Phuoc Binh is not managed by the Ministry of Agriculture.

[PREMISE (FOL)]:
NationalPark(phuocBinh) ∧ Locatedin(phuocBinh, vietnam)
∀x ((NationalPark(x) ∧ Locatedin(x, vietnam)) → NatureReserve(x))
∃x (NationalPark(x) ∧ Locatedin(x, vietnam) ∧ UNESCOWorldHeritageSite(x))
∀x ((NationalPark(x) ∧ Locatedin(x, vietnam)) → (Mangedby(x, ministryofAgriculture) ⊕ Managedby(x, peoplesCommittee)))
¬Mangedby(phuocBinh, ministryofAgriculture)

[PREMISE (GK)]:
NationalPark(phuocBinh) & Locatedin(phuocBinh, vietnam).
! [X] : ((NationalPark(X) & Locatedin(X, vietnam)) => NatureReserve(X)).
? [X] : (NationalPark(X) & Locatedin(X, vietnam) & UNESCOWorldHeritageSite(X)).
! [X] : ((NationalPark(X) & Locatedin(X, vietnam)) => (Mangedby(X, ministryofAgriculture) <~> Managedby(X, peoplesCommittee))).
-Mangedby(phuocBinh, ministryofAgriculture).

[CONCLUSION]:
There is a nature reserve in Vietnam.

[CONCLUSION (FOL)]:
∃x (NatureReserve(x) ∧ LocatedIn(x, vietnam))

[CONCLUSION (GK)]:
? [X] : (NatureReserve(X) & LocatedIn(X, vietnam)).


===

['x']
['x']
[PREMISE]:
Phuoc Binh national park is a national park in Vietnam. 
Any national park in Vietnam is classified as a nature reserve. 
There is a national park in Vietnam classified as a UNESCO World Heritage Site.
All national parks in Vietnam are either managed by the Ministry of Agriculture or managed by the People's Committee. 
Phuoc Binh is not managed by the Ministry of Agriculture.

[PREMISE (FOL)]:
NationalPark(phuocBinh) ∧ Locatedin(phuocBinh, vietnam)
∀x ((NationalPark(x) ∧ Locatedin(x, vietnam)) → NatureReserve(x))
∃x (NationalPark(x) ∧ Locatedin(x, vietnam) ∧ UNESCOWorldHeritageSite(x))
∀x ((NationalPark(x) ∧ Locatedin(x, vietnam)) → (Mangedby(x, ministryofAgriculture) ⊕ Managedby(x, peoplesCommittee)))
¬Mangedby(phuocBinh, ministryofAgriculture)

[PREMISE (GK)]:
NationalPark(phuocBinh) & Locatedin(phuocBinh, vietnam).
! [X] : ((NationalPark(X) & Locatedin(X, vietnam)) => NatureReserve(X)).
? [X] : (NationalPark(X) & Locatedin(X, vietnam) & UNESCOWorldHeritageSite(X)).
! [X] : ((NationalPark(X) & Locatedin(X, vietnam)) => (Mangedby(X, ministryofAgriculture) <~> Managedby(X, peoplesCommittee))).
-Mangedby(phuocBinh, ministryofAgriculture).

[CONCLUSION]:
Phuoc Binh is a UNESCO Heritage Site.

[CONCLUSION (FOL)]:
UNESCOWorldHeritageSite(phuocBinh))

[CONCLUSION (GK)]:
UNESCOWorldHeritageSite(phuocBinh)).


===

['x']
['x']
[PREMISE]:
Phuoc Binh national park is a national park in Vietnam. 
Any national park in Vietnam is classified as a nature reserve. 
There is a national park in Vietnam classified as a UNESCO World Heritage Site.
All national parks in Vietnam are either managed by the Ministry of Agriculture or managed by the People's Committee. 
Phuoc Binh is not managed by the Ministry of Agriculture.

[PREMISE (FOL)]:
NationalPark(phuocBinh) ∧ Locatedin(phuocBinh, vietnam)
∀x ((NationalPark(x) ∧ Locatedin(x, vietnam)) → NatureReserve(x))
∃x (NationalPark(x) ∧ Locatedin(x, vietnam) ∧ UNESCOWorldHeritageSite(x))
∀x ((NationalPark(x) ∧ Locatedin(x, vietnam)) → (Mangedby(x, ministryofAgriculture) ⊕ Managedby(x, peoplesCommittee)))
¬Mangedby(phuocBinh, ministryofAgriculture)

[PREMISE (GK)]:
NationalPark(phuocBinh) & Locatedin(phuocBinh, vietnam).
! [X] : ((NationalPark(X) & Locatedin(X, vietnam)) => NatureReserve(X)).
? [X] : (NationalPark(X) & Locatedin(X, vietnam) & UNESCOWorldHeritageSite(X)).
! [X] : ((NationalPark(X) & Locatedin(X, vietnam)) => (Mangedby(X, ministryofAgriculture) <~> Managedby(X, peoplesCommittee))).
-Mangedby(phuocBinh, ministryofAgriculture).

[CONCLUSION]:
Phuoc Binh is managed by the People's Committee.

[CONCLUSION (FOL)]:
Mangedby(phuocBinh, peoplesCommittee)

[CONCLUSION (GK)]:
Mangedby(phuocBinh, peoplesCommittee).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Greyhound racing is a competitive sport where spectators bet on greyhounds.
Greyhound racing involves coursing.
Some competitive sports where spectators bet on things are banned.
Coursing involves spectators betting on a hare being pursued by greyhounds.
Spectators betting on a hare is a small game.
If a competitive sport involves spectators betting on small games, then it is banned.

[PREMISE (FOL)]:
∀x (GreyhoundRacing(x) → ∃y (CompetitiveSport(x) ∧ Greyhound(y) ∧ BetOn(spectators, y, x)))
∀x (GreyhoundRacing(x) → Coursing(x))
∃x ∃y (CompetitiveSport(x) ∧ BetOn(spectators, y, x) ∧ Banned(x))
∀x ∃y ∃z (Coursing(x) → Hare(y) ∧ BetOn(spectators, y, x) ∧ GreyHound(z) ∧ PursuedBy(y, z))
∃x ∀y (Hare(x) ∧ BetOn(spectators, x, y) → SmallGame(y))
∀x ∃y (CompetitiveSport(x) ∧ SmallGame(y) ∧ BetOn(spectators, y, x) → Banned(x))

[PREMISE (GK)]:
! [X] : (GreyhoundRacing(X) => ? [Y] : (CompetitiveSport(X) & Greyhound(Y) & BetOn(spectators, Y, X))).
! [X] : (GreyhoundRacing(X) => Coursing(X)).
? [X] : ? [Y] : (CompetitiveSport(X) & BetOn(spectators, Y, X) & Banned(X)).
! [X] : ? [Y] : ? [Z] : (Coursing(X) => Hare(Y) & BetOn(spectators, Y, X) & GreyHound(Z) & PursuedBy(Y, Z)).
? [X] : ! [Y] : (Hare(X) & BetOn(spectators, X, Y) => SmallGame(Y)).
! [X] : ? [Y] : (CompetitiveSport(X) & SmallGame(Y) & BetOn(spectators, Y, X) => Banned(X)).

[CONCLUSION]:
No coursing is banned.

[CONCLUSION (FOL)]:
∀x (Coursing(x) ∧ ¬Banned(x))

[CONCLUSION (GK)]:
! [X] : (Coursing(X) & -Banned(X)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Greyhound racing is a competitive sport where spectators bet on greyhounds.
Greyhound racing involves coursing.
Some competitive sports where spectators bet on things are banned.
Coursing involves spectators betting on a hare being pursued by greyhounds.
Spectators betting on a hare is a small game.
If a competitive sport involves spectators betting on small games, then it is banned.

[PREMISE (FOL)]:
∀x (GreyhoundRacing(x) → ∃y (CompetitiveSport(x) ∧ Greyhound(y) ∧ BetOn(spectators, y, x)))
∀x (GreyhoundRacing(x) → Coursing(x))
∃x ∃y (CompetitiveSport(x) ∧ BetOn(spectators, y, x) ∧ Banned(x))
∀x ∃y ∃z (Coursing(x) → Hare(y) ∧ BetOn(spectators, y, x) ∧ GreyHound(z) ∧ PursuedBy(y, z))
∃x ∀y (Hare(x) ∧ BetOn(spectators, x, y) → SmallGame(y))
∀x ∃y (CompetitiveSport(x) ∧ SmallGame(y) ∧ BetOn(spectators, y, x) → Banned(x))

[PREMISE (GK)]:
! [X] : (GreyhoundRacing(X) => ? [Y] : (CompetitiveSport(X) & Greyhound(Y) & BetOn(spectators, Y, X))).
! [X] : (GreyhoundRacing(X) => Coursing(X)).
? [X] : ? [Y] : (CompetitiveSport(X) & BetOn(spectators, Y, X) & Banned(X)).
! [X] : ? [Y] : ? [Z] : (Coursing(X) => Hare(Y) & BetOn(spectators, Y, X) & GreyHound(Z) & PursuedBy(Y, Z)).
? [X] : ! [Y] : (Hare(X) & BetOn(spectators, X, Y) => SmallGame(Y)).
! [X] : ? [Y] : (CompetitiveSport(X) & SmallGame(Y) & BetOn(spectators, Y, X) => Banned(X)).

[CONCLUSION]:
Greyhound racing is a competitive sport.

[CONCLUSION (FOL)]:
∀x (GreyhoundRacing(x) → CompetitiveSport(x))

[CONCLUSION (GK)]:
! [X] : (GreyhoundRacing(X) => CompetitiveSport(X)).


===

['x']
['x']
[PREMISE]:
If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.
If a soccer player receives one red card in one game, this player will be ejected from the rest of the game.
Henry is a soccer player.
In one game, Henry receives one yellow card and one red card.

[PREMISE (FOL)]:
∀x (SoccerPlayer(x) ∧ Receive(x, twoYellowCard) → EjectFromRestOfGame(x))
∀x (SoccerPlayer(x) ∧ Receive(x, oneRedCard)) → EjectFromRestOfGame(x))   
SoccerPlayer(henry)
Receive(henry, oneYellowCard) ∧ Receive(x, oneRedCard)

[PREMISE (GK)]:
! [X] : (SoccerPlayer(X) & Receive(X, twoYellowCard) => EjectFromRestOfGame(X)).
! [X] : (SoccerPlayer(X) & Receive(X, oneRedCard)) => EjectFromRestOfGame(X))   .
SoccerPlayer(henry).
Receive(henry, oneYellowCard) & Receive(x, oneRedCard).

[CONCLUSION]:
Henry will be ejected from the rest of the game.

[CONCLUSION (FOL)]:
EjectFromRestOfGame(henry)

[CONCLUSION (GK)]:
EjectFromRestOfGame(henry).


===

['x']
['x']
[PREMISE]:
If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.
If a soccer player receives one red card in one game, this player will be ejected from the rest of the game.
Henry is a soccer player.
In one game, Henry receives one yellow card and one red card.

[PREMISE (FOL)]:
∀x (SoccerPlayer(x) ∧ Receive(x, twoYellowCard) → EjectFromRestOfGame(x))
∀x (SoccerPlayer(x) ∧ Receive(x, oneRedCard)) → EjectFromRestOfGame(x))   
SoccerPlayer(henry)
Receive(henry, oneYellowCard) ∧ Receive(x, oneRedCard)

[PREMISE (GK)]:
! [X] : (SoccerPlayer(X) & Receive(X, twoYellowCard) => EjectFromRestOfGame(X)).
! [X] : (SoccerPlayer(X) & Receive(X, oneRedCard)) => EjectFromRestOfGame(X))   .
SoccerPlayer(henry).
Receive(henry, oneYellowCard) & Receive(x, oneRedCard).

[CONCLUSION]:
Henry will not be ejected from the rest of the game.

[CONCLUSION (FOL)]:
¬EjectFromRestOfGame(henry)

[CONCLUSION (GK)]:
-EjectFromRestOfGame(henry).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Trees are plants. 
Some living things are trees.

[PREMISE (FOL)]:
∀x (Tree(x) → Plant(x))
∃x ∃y (Living(x) ∧ Living(y) ∧ Tree(x) ∧ Tree(y) ∧ ¬(x=y))

[PREMISE (GK)]:
! [X] : (Tree(X) => Plant(X)).
? [X] : ? [Y] : (Living(X) & Living(Y) & Tree(X) & Tree(Y) & -(X=Y)).

[CONCLUSION]:
Some living things are plants.

[CONCLUSION (FOL)]:
∃x ∃y (Living(x) ∧ Living(y) ∧ Plant(x) ∧ Plant(y) ∧ ¬(x=y))

[CONCLUSION (GK)]:
? [X] : ? [Y] : (Living(X) & Living(Y) & Plant(X) & Plant(Y) & -(X=Y)).


===

[]
[]
[PREMISE]:
Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.
Dagfinn Aarskog is a Norwegian physician.
Dagfinn Dahl is a Norwegian barrister.

[PREMISE (FOL)]:

GivenName(nameDagfinn) ∧ Named(dagfinnAarskog, nameDagfinn) ∧ NotablePerson(dagfinnAarskog) ∧ Named(dagfinnBakke, nameDagfinn) ∧ NotablePerson(dagfinnBakke)  ∧ Named(dagfinnDahl, nameDagfinn) ∧ NotablePerson(dagfinnDahl)
Norwegian(dagfinnAarskog) ∧ Physician(dagfinnAarskog)
Norwegian(dagfinnDahl) ∧ Barrister(dagfinnDahl)

[PREMISE (GK)]:
.
GivenName(nameDagfinn) & Named(dagfinnAarskog, nameDagfinn) & NotablePerson(dagfinnAarskog) & Named(dagfinnBakke, nameDagfinn) & NotablePerson(dagfinnBakke)  & Named(dagfinnDahl, nameDagfinn) & NotablePerson(dagfinnDahl).
Norwegian(dagfinnAarskog) & Physician(dagfinnAarskog).
Norwegian(dagfinnDahl) & Barrister(dagfinnDahl).

[CONCLUSION]:
Dagfinn Aarskog is a notable person.

[CONCLUSION (FOL)]:
NotablePerson(dagfinnAarskog)

[CONCLUSION (GK)]:
NotablePerson(dagfinnAarskog).


===

[]
[]
[PREMISE]:
Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.
Dagfinn Aarskog is a Norwegian physician.
Dagfinn Dahl is a Norwegian barrister.

[PREMISE (FOL)]:

GivenName(nameDagfinn) ∧ Named(dagfinnAarskog, nameDagfinn) ∧ NotablePerson(dagfinnAarskog) ∧ Named(dagfinnBakke, nameDagfinn) ∧ NotablePerson(dagfinnBakke)  ∧ Named(dagfinnDahl, nameDagfinn) ∧ NotablePerson(dagfinnDahl)
Norwegian(dagfinnAarskog) ∧ Physician(dagfinnAarskog)
Norwegian(dagfinnDahl) ∧ Barrister(dagfinnDahl)

[PREMISE (GK)]:
.
GivenName(nameDagfinn) & Named(dagfinnAarskog, nameDagfinn) & NotablePerson(dagfinnAarskog) & Named(dagfinnBakke, nameDagfinn) & NotablePerson(dagfinnBakke)  & Named(dagfinnDahl, nameDagfinn) & NotablePerson(dagfinnDahl).
Norwegian(dagfinnAarskog) & Physician(dagfinnAarskog).
Norwegian(dagfinnDahl) & Barrister(dagfinnDahl).

[CONCLUSION]:
Dagfinn is Dagfinn Aarskog's given name.

[CONCLUSION (FOL)]:
Named(dagfinnAarskog, nameDagfinn)

[CONCLUSION (GK)]:
Named(dagfinnAarskog, nameDagfinn).


===

[]
[]
[PREMISE]:
Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.
Dagfinn Aarskog is a Norwegian physician.
Dagfinn Dahl is a Norwegian barrister.

[PREMISE (FOL)]:

GivenName(nameDagfinn) ∧ Named(dagfinnAarskog, nameDagfinn) ∧ NotablePerson(dagfinnAarskog) ∧ Named(dagfinnBakke, nameDagfinn) ∧ NotablePerson(dagfinnBakke)  ∧ Named(dagfinnDahl, nameDagfinn) ∧ NotablePerson(dagfinnDahl)
Norwegian(dagfinnAarskog) ∧ Physician(dagfinnAarskog)
Norwegian(dagfinnDahl) ∧ Barrister(dagfinnDahl)

[PREMISE (GK)]:
.
GivenName(nameDagfinn) & Named(dagfinnAarskog, nameDagfinn) & NotablePerson(dagfinnAarskog) & Named(dagfinnBakke, nameDagfinn) & NotablePerson(dagfinnBakke)  & Named(dagfinnDahl, nameDagfinn) & NotablePerson(dagfinnDahl).
Norwegian(dagfinnAarskog) & Physician(dagfinnAarskog).
Norwegian(dagfinnDahl) & Barrister(dagfinnDahl).

[CONCLUSION]:
Dagfinn Dahl is a Norwegian physician.

[CONCLUSION (FOL)]:
Norwegian(dagfinnDahl) ∧ Physician(dagfinnDahl)

[CONCLUSION (GK)]:
Norwegian(dagfinnDahl) & Physician(dagfinnDahl).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
If a movie is popular, some people enjoy watching it.
All things that some people enjoy attract attention.

[PREMISE (FOL)]:
∀x (Movie(x) ∧ Popular(x) → ∃y ∃z (Person(y) ∧ EnjoyWatching(y, x) ∧ Person(z) ∧ EnjoyWatching(z, x) ∧ ¬(y=z)))
∀x (∃y ∃z (Person(y) ∧ EnjoyWatching(y, x) ∧ Person(z) ∧ EnjoyWatching(z, x)) → Attract(x, attention))

[PREMISE (GK)]:
! [X] : (Movie(X) & Popular(X) => ? [Y] : ? [Z] : (Person(Y) & EnjoyWatching(Y, X) & Person(Z) & EnjoyWatching(Z, X) & -(Y=Z))).
! [X] : (? [Y] : ? [Z] : (Person(Y) & EnjoyWatching(Y, X) & Person(Z) & EnjoyWatching(Z, X)) => Attract(X, attention)).

[CONCLUSION]:
If a movie is popular, then it attracts attention.

[CONCLUSION (FOL)]:
∀x (Movie(x) ∧ Popular(x) → Attract(x, attention))

[CONCLUSION (GK)]:
! [X] : (Movie(X) & Popular(X) => Attract(X, attention)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
It is not true that some giant language models do not have good performance. 
All language models with good performance are used by some researchers.
If a language model is used by some researchers, it is popular. 
If BERT is a giant language model, then GPT-3 is also a giant language model. 
BERT is a giant language model. 

[PREMISE (FOL)]:
¬(∃x (LanguageModel(x) ∧ Giant(x) ∧ ¬GoodPerformance(x)))
∀x ∃y ∃z (LanguageModel(x) ∧ GoodPerformance(x) → ¬(x=y) ∧ Researcher(y) ∧ UsedBy(x, y) ∧ Researcher(z) ∧ UsedBy(x, z))
∀x ∃y ∃z (LanguageModel(x) ∧ ¬(x=y) ∧ Researcher(y) ∧ UsedBy(x, y) ∧ Researcher(z) ∧ UsedBy(x, z) → Popular(x))
(LanguageModel(bert) ∧ Giant(bert)) → (LanguageModel(gpt-3) ∧ Giant(gpt-3)).
LanguageModel(bert) ∧ Giant(bert)

[PREMISE (GK)]:
-(? [X] : (LanguageModel(X) & Giant(X) & -GoodPerformance(X))).
! [X] : ? [Y] : ? [Z] : (LanguageModel(X) & GoodPerformance(X) => -(X=Y) & Researcher(Y) & UsedBy(X, Y) & Researcher(Z) & UsedBy(X, Z)).
! [X] : ? [Y] : ? [Z] : (LanguageModel(X) & -(X=Y) & Researcher(Y) & UsedBy(X, Y) & Researcher(Z) & UsedBy(X, Z) => Popular(X)).
(LanguageModel(bert) & Giant(bert)) => (LanguageModel(gpt-3) & Giant(gpt-3))..
LanguageModel(bert) & Giant(bert).

[CONCLUSION]:
GPT-3 is popular.

[CONCLUSION (FOL)]:
Popular(gpt-3)

[CONCLUSION (GK)]:
Popular(gpt-3).


===

['x', 'y']
['x', 'y']
[PREMISE]:
St Johnstone is a Scottish team.
St Johnstone is part of the Scottish Premiership league.
If a team is part of the league, it has joined the league.
St Johnstone and Minsk are different teams.
For two teams, either one team wins, or the other team wins.
Minsk won against St Johnstone.

[PREMISE (FOL)]:
Scottish(stJohnstone) ∧ Team(stJohnstone)
PartOf(stJohnstone, scottishPremiership) ∧ League(scottishPremiership)
∀x ∀y (Team(x) ∧ League(y) ∧ PartOf(x, y) → Joined(x, y))
¬(misnk=stJohnstone)
∀x ∀y (¬(x=y) → WonAgainst(x, y) ⊕ WonAgainst(y, x))
WonAgainst(minsk, stJohnstone)

[PREMISE (GK)]:
Scottish(stJohnstone) & Team(stJohnstone).
PartOf(stJohnstone, scottishPremiership) & League(scottishPremiership).
! [X] : ! [Y] : (Team(X) & League(Y) & PartOf(X, Y) => Joined(X, Y)).
-(misnk=stJohnstone).
! [X] : ! [Y] : (-(X=Y) => WonAgainst(X, Y) <~> WonAgainst(Y, X)).
WonAgainst(minsk, stJohnstone).

[CONCLUSION]:
At least one Scottish team has joined the Scottish Premiership.

[CONCLUSION (FOL)]:
∃x (Scottish(x) ∧ Joined(x, scottishPremiership))

[CONCLUSION (GK)]:
? [X] : (Scottish(X) & Joined(X, scottishPremiership)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
St Johnstone is a Scottish team.
St Johnstone is part of the Scottish Premiership league.
If a team is part of the league, it has joined the league.
St Johnstone and Minsk are different teams.
For two teams, either one team wins, or the other team wins.
Minsk won against St Johnstone.

[PREMISE (FOL)]:
Scottish(stJohnstone) ∧ Team(stJohnstone)
PartOf(stJohnstone, scottishPremiership) ∧ League(scottishPremiership)
∀x ∀y (Team(x) ∧ League(y) ∧ PartOf(x, y) → Joined(x, y))
¬(misnk=stJohnstone)
∀x ∀y (¬(x=y) → WonAgainst(x, y) ⊕ WonAgainst(y, x))
WonAgainst(minsk, stJohnstone)

[PREMISE (GK)]:
Scottish(stJohnstone) & Team(stJohnstone).
PartOf(stJohnstone, scottishPremiership) & League(scottishPremiership).
! [X] : ! [Y] : (Team(X) & League(Y) & PartOf(X, Y) => Joined(X, Y)).
-(misnk=stJohnstone).
! [X] : ! [Y] : (-(X=Y) => WonAgainst(X, Y) <~> WonAgainst(Y, X)).
WonAgainst(minsk, stJohnstone).

[CONCLUSION]:
St Johnstone won against Minsk.

[CONCLUSION (FOL)]:
WonGame(stJohnstone, minsk)

[CONCLUSION (GK)]:
WonGame(stJohnstone, minsk).


===

['x', 'y']
['x', 'y']
[PREMISE]:
St Johnstone is a Scottish team.
St Johnstone is part of the Scottish Premiership league.
If a team is part of the league, it has joined the league.
St Johnstone and Minsk are different teams.
For two teams, either one team wins, or the other team wins.
Minsk won against St Johnstone.

[PREMISE (FOL)]:
Scottish(stJohnstone) ∧ Team(stJohnstone)
PartOf(stJohnstone, scottishPremiership) ∧ League(scottishPremiership)
∀x ∀y (Team(x) ∧ League(y) ∧ PartOf(x, y) → Joined(x, y))
¬(misnk=stJohnstone)
∀x ∀y (¬(x=y) → WonAgainst(x, y) ⊕ WonAgainst(y, x))
WonAgainst(minsk, stJohnstone)

[PREMISE (GK)]:
Scottish(stJohnstone) & Team(stJohnstone).
PartOf(stJohnstone, scottishPremiership) & League(scottishPremiership).
! [X] : ! [Y] : (Team(X) & League(Y) & PartOf(X, Y) => Joined(X, Y)).
-(misnk=stJohnstone).
! [X] : ! [Y] : (-(X=Y) => WonAgainst(X, Y) <~> WonAgainst(Y, X)).
WonAgainst(minsk, stJohnstone).

[CONCLUSION]:
Minsk joined the Scottish Premiership.

[CONCLUSION (FOL)]:
Joined(minsk, scottishPremiership))

[CONCLUSION (GK)]:
Joined(minsk, scottishPremiership)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
No Boeing-737 plane has more than 300 seats. 
All of the planes acquired by Delta in this batch are Boeing-737. 
Planes either have more than 300 seats or have a capacity of 100 passengers. 
All planes with a capacity of 100 passengers are scheduled for a short-distance flight. 
All planes with a capacity of 100 passengers are produced before 2010. 
Jake32 is either a Boeing-737 plane or a plane acquired by Delta in this batch.
T10 is either both a Boeing-737 plane and acquired by Delta in this batch, or it is neither.

[PREMISE (FOL)]:
∀x (Plane(x) ∧ Boeing737(x) → (¬∃y(GreaterThan(y, num300) ∧ EquippedWithSeats(x,y)))
∀x (Plane(x) ∧ AcquiredBy(x, delta) → Boeing737(x))
∀x (Plane(x) → ((∃y(GreaterThan(y, num300) ∧ EquippedWithSeats(x,y))) ⊕ (∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y))))
∀x (Plane(x) ∧ ∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y)) → ScheduledFor(x, shortdistanceflight))
∀x (Plane(x) ∧ ∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y)) → ∃z(Before(z, yr2010) ∧ Produced(x, z))
(Boeing737(jake32) ∧ Plane(jake32)) ⊕ (AcquiredByDeltaInThisBatch(jake32) ∧ Plane(jake32))
¬((Boeing737(t10) ∧ Plane(t10)) ⊕ (AcquiredByDeltaInThisBatch(t10) ∧ Plane(t10)))

[PREMISE (GK)]:
! [X] : (Plane(X) & Boeing737(X) => (-? [Y] :(GreaterThan(Y, num300) & EquippedWithSeats(X,Y))).
! [X] : (Plane(X) & AcquiredBy(X, delta) => Boeing737(X)).
! [X] : (Plane(X) => ((? [Y] :(GreaterThan(Y, num300) & EquippedWithSeats(X,Y))) <~> (? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)))).
! [X] : (Plane(X) & ? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)) => ScheduledFor(X, shortdistanceflight)).
! [X] : (Plane(X) & ? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)) => ? [Z] :(Before(Z, yr2010) & Produced(X, Z)).
(Boeing737(jake32) & Plane(jake32)) <~> (AcquiredByDeltaInThisBatch(jake32) & Plane(jake32)).
-((Boeing737(t10) & Plane(t10)) <~> (AcquiredByDeltaInThisBatch(t10) & Plane(t10))).

[CONCLUSION]:
Jake32 was produced before 2010 and is scheduled for a short-distance flight.

[CONCLUSION (FOL)]:
∃z(Before(z, year2010) ∧ Produced(jake32, z)) ∧ ScheduledFor(jake32, shortdistanceflight))

[CONCLUSION (GK)]:
? [Z] :(Before(Z, year2010) & Produced(jake32, Z)) & ScheduledFor(jake32, shortdistanceflight)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
No Boeing-737 plane has more than 300 seats. 
All of the planes acquired by Delta in this batch are Boeing-737. 
Planes either have more than 300 seats or have a capacity of 100 passengers. 
All planes with a capacity of 100 passengers are scheduled for a short-distance flight. 
All planes with a capacity of 100 passengers are produced before 2010. 
Jake32 is either a Boeing-737 plane or a plane acquired by Delta in this batch.
T10 is either both a Boeing-737 plane and acquired by Delta in this batch, or it is neither.

[PREMISE (FOL)]:
∀x (Plane(x) ∧ Boeing737(x) → (¬∃y(GreaterThan(y, num300) ∧ EquippedWithSeats(x,y)))
∀x (Plane(x) ∧ AcquiredBy(x, delta) → Boeing737(x))
∀x (Plane(x) → ((∃y(GreaterThan(y, num300) ∧ EquippedWithSeats(x,y))) ⊕ (∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y))))
∀x (Plane(x) ∧ ∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y)) → ScheduledFor(x, shortdistanceflight))
∀x (Plane(x) ∧ ∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y)) → ∃z(Before(z, yr2010) ∧ Produced(x, z))
(Boeing737(jake32) ∧ Plane(jake32)) ⊕ (AcquiredByDeltaInThisBatch(jake32) ∧ Plane(jake32))
¬((Boeing737(t10) ∧ Plane(t10)) ⊕ (AcquiredByDeltaInThisBatch(t10) ∧ Plane(t10)))

[PREMISE (GK)]:
! [X] : (Plane(X) & Boeing737(X) => (-? [Y] :(GreaterThan(Y, num300) & EquippedWithSeats(X,Y))).
! [X] : (Plane(X) & AcquiredBy(X, delta) => Boeing737(X)).
! [X] : (Plane(X) => ((? [Y] :(GreaterThan(Y, num300) & EquippedWithSeats(X,Y))) <~> (? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)))).
! [X] : (Plane(X) & ? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)) => ScheduledFor(X, shortdistanceflight)).
! [X] : (Plane(X) & ? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)) => ? [Z] :(Before(Z, yr2010) & Produced(X, Z)).
(Boeing737(jake32) & Plane(jake32)) <~> (AcquiredByDeltaInThisBatch(jake32) & Plane(jake32)).
-((Boeing737(t10) & Plane(t10)) <~> (AcquiredByDeltaInThisBatch(t10) & Plane(t10))).

[CONCLUSION]:
Jake32 is not produced before 2010 and is not scheduled for a short-distance flight.

[CONCLUSION (FOL)]:
¬(∃z(Before(z, year2010) ∧ Produced(jake32, z)) ∧ ScheduledFor(jake32, shortdistanceflight)))

[CONCLUSION (GK)]:
-(? [Z] :(Before(Z, year2010) & Produced(jake32, Z)) & ScheduledFor(jake32, shortdistanceflight))).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
No Boeing-737 plane has more than 300 seats. 
All of the planes acquired by Delta in this batch are Boeing-737. 
Planes either have more than 300 seats or have a capacity of 100 passengers. 
All planes with a capacity of 100 passengers are scheduled for a short-distance flight. 
All planes with a capacity of 100 passengers are produced before 2010. 
Jake32 is either a Boeing-737 plane or a plane acquired by Delta in this batch.
T10 is either both a Boeing-737 plane and acquired by Delta in this batch, or it is neither.

[PREMISE (FOL)]:
∀x (Plane(x) ∧ Boeing737(x) → (¬∃y(GreaterThan(y, num300) ∧ EquippedWithSeats(x,y)))
∀x (Plane(x) ∧ AcquiredBy(x, delta) → Boeing737(x))
∀x (Plane(x) → ((∃y(GreaterThan(y, num300) ∧ EquippedWithSeats(x,y))) ⊕ (∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y))))
∀x (Plane(x) ∧ ∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y)) → ScheduledFor(x, shortdistanceflight))
∀x (Plane(x) ∧ ∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y)) → ∃z(Before(z, yr2010) ∧ Produced(x, z))
(Boeing737(jake32) ∧ Plane(jake32)) ⊕ (AcquiredByDeltaInThisBatch(jake32) ∧ Plane(jake32))
¬((Boeing737(t10) ∧ Plane(t10)) ⊕ (AcquiredByDeltaInThisBatch(t10) ∧ Plane(t10)))

[PREMISE (GK)]:
! [X] : (Plane(X) & Boeing737(X) => (-? [Y] :(GreaterThan(Y, num300) & EquippedWithSeats(X,Y))).
! [X] : (Plane(X) & AcquiredBy(X, delta) => Boeing737(X)).
! [X] : (Plane(X) => ((? [Y] :(GreaterThan(Y, num300) & EquippedWithSeats(X,Y))) <~> (? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)))).
! [X] : (Plane(X) & ? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)) => ScheduledFor(X, shortdistanceflight)).
! [X] : (Plane(X) & ? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)) => ? [Z] :(Before(Z, yr2010) & Produced(X, Z)).
(Boeing737(jake32) & Plane(jake32)) <~> (AcquiredByDeltaInThisBatch(jake32) & Plane(jake32)).
-((Boeing737(t10) & Plane(t10)) <~> (AcquiredByDeltaInThisBatch(t10) & Plane(t10))).

[CONCLUSION]:
Jake32 is produced before 2010 or scheduled for a short-distance flight.

[CONCLUSION (FOL)]:
∃z(Before(z, year2010) ∧ Produced(jake32, z)) ∨ ScheduledFor(jake32, shortdistanceflight))

[CONCLUSION (GK)]:
? [Z] :(Before(Z, year2010) & Produced(jake32, Z)) | ScheduledFor(jake32, shortdistanceflight)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
No Boeing-737 plane has more than 300 seats. 
All of the planes acquired by Delta in this batch are Boeing-737. 
Planes either have more than 300 seats or have a capacity of 100 passengers. 
All planes with a capacity of 100 passengers are scheduled for a short-distance flight. 
All planes with a capacity of 100 passengers are produced before 2010. 
Jake32 is either a Boeing-737 plane or a plane acquired by Delta in this batch.
T10 is either both a Boeing-737 plane and acquired by Delta in this batch, or it is neither.

[PREMISE (FOL)]:
∀x (Plane(x) ∧ Boeing737(x) → (¬∃y(GreaterThan(y, num300) ∧ EquippedWithSeats(x,y)))
∀x (Plane(x) ∧ AcquiredBy(x, delta) → Boeing737(x))
∀x (Plane(x) → ((∃y(GreaterThan(y, num300) ∧ EquippedWithSeats(x,y))) ⊕ (∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y))))
∀x (Plane(x) ∧ ∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y)) → ScheduledFor(x, shortdistanceflight))
∀x (Plane(x) ∧ ∃y(Equals(y, num100) ∧ EquippedWithSeats(x,y)) → ∃z(Before(z, yr2010) ∧ Produced(x, z))
(Boeing737(jake32) ∧ Plane(jake32)) ⊕ (AcquiredByDeltaInThisBatch(jake32) ∧ Plane(jake32))
¬((Boeing737(t10) ∧ Plane(t10)) ⊕ (AcquiredByDeltaInThisBatch(t10) ∧ Plane(t10)))

[PREMISE (GK)]:
! [X] : (Plane(X) & Boeing737(X) => (-? [Y] :(GreaterThan(Y, num300) & EquippedWithSeats(X,Y))).
! [X] : (Plane(X) & AcquiredBy(X, delta) => Boeing737(X)).
! [X] : (Plane(X) => ((? [Y] :(GreaterThan(Y, num300) & EquippedWithSeats(X,Y))) <~> (? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)))).
! [X] : (Plane(X) & ? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)) => ScheduledFor(X, shortdistanceflight)).
! [X] : (Plane(X) & ? [Y] :(Equals(Y, num100) & EquippedWithSeats(X,Y)) => ? [Z] :(Before(Z, yr2010) & Produced(X, Z)).
(Boeing737(jake32) & Plane(jake32)) <~> (AcquiredByDeltaInThisBatch(jake32) & Plane(jake32)).
-((Boeing737(t10) & Plane(t10)) <~> (AcquiredByDeltaInThisBatch(t10) & Plane(t10))).

[CONCLUSION]:
Jake32 is neither produced before 2010 nor scheduled for a short-distance flight.

[CONCLUSION (FOL)]:
¬∃z(Before(z, year2010) ∧ Produced(jake32, z)) ∧ ¬ScheduledFor(jake32, shortdistanceflight))

[CONCLUSION (GK)]:
-? [Z] :(Before(Z, year2010) & Produced(jake32, Z)) & -ScheduledFor(jake32, shortdistanceflight)).


===

['y']
['y']
[PREMISE]:
The SAT test is wholly owned and developed by the College Board.
The SAT test is intended to assess students' readiness for college.
The SAT was originally designed not to be aligned with high school curricula. 
Several adjustments were made to the version of the SAT introduced in 2016 to align with the high school curriculum.

[PREMISE (FOL)]:
OwnedBy(sAT, collegeBoard) ∧ DevelopedBy(sAT, collegeBoard) ∧ ¬(∃y (¬(y=collegeBoard) ∧ (OwnedBy(sAT, y) ∨ DevelopedBy(sAT, y)))
IntendedToAssess(sAT, studentsReadinessForCollege)
OriginallyDesignedToBeAlignedWith(sAT, highSchoolCurricula)
AdjustmentMadeIn(sAT, 2016, toAlignWithHighSchoolCurriculum)

[PREMISE (GK)]:
OwnedBy(sAT, collegeBoard) & DevelopedBy(sAT, collegeBoard) & -(? [Y] : (-(Y=collegeBoard) & (OwnedBy(sAT, Y) | DevelopedBy(sAT, Y))).
IntendedToAssess(sAT, studentsReadinessForCollege).
OriginallyDesignedToBeAlignedWith(sAT, highSchoolCurricula).
AdjustmentMadeIn(sAT, 2016, toAlignWithHighSchoolCurriculum).

[CONCLUSION]:
The SAT test is owned by the College Board and other third parties.

[CONCLUSION (FOL)]:
OwnedBy(sAT, collegeBoard) ∧ OwnedBy(sAT, otherThirdParties)

[CONCLUSION (GK)]:
OwnedBy(sAT, collegeBoard) & OwnedBy(sAT, otherThirdParties).


===

['y']
['y']
[PREMISE]:
The SAT test is wholly owned and developed by the College Board.
The SAT test is intended to assess students' readiness for college.
The SAT was originally designed not to be aligned with high school curricula. 
Several adjustments were made to the version of the SAT introduced in 2016 to align with the high school curriculum.

[PREMISE (FOL)]:
OwnedBy(sAT, collegeBoard) ∧ DevelopedBy(sAT, collegeBoard) ∧ ¬(∃y (¬(y=collegeBoard) ∧ (OwnedBy(sAT, y) ∨ DevelopedBy(sAT, y)))
IntendedToAssess(sAT, studentsReadinessForCollege)
OriginallyDesignedToBeAlignedWith(sAT, highSchoolCurricula)
AdjustmentMadeIn(sAT, 2016, toAlignWithHighSchoolCurriculum)

[PREMISE (GK)]:
OwnedBy(sAT, collegeBoard) & DevelopedBy(sAT, collegeBoard) & -(? [Y] : (-(Y=collegeBoard) & (OwnedBy(sAT, Y) | DevelopedBy(sAT, Y))).
IntendedToAssess(sAT, studentsReadinessForCollege).
OriginallyDesignedToBeAlignedWith(sAT, highSchoolCurricula).
AdjustmentMadeIn(sAT, 2016, toAlignWithHighSchoolCurriculum).

[CONCLUSION]:
The SAT test assesses students' math skills.

[CONCLUSION (FOL)]:
IntendedToAssess(sAT, studentsMathSkill)

[CONCLUSION (GK)]:
IntendedToAssess(sAT, studentsMathSkill).


===

['x']
['x']
[PREMISE]:
Rafa Nadal was born in Mallorca.
Rafa Nadal is a professional tennis player.
Nadal's win ratio is high.
All players in the Big 3 are professionals who have a high win ratio.

[PREMISE (FOL)]:
BornIn(rafaNadal, mallorca)
ProfessionalTennisPlayer(rafaNadal)
HighWinRatio(rafaNadal)
∀x ((ProfessionalTennisPlayer(x) ∧ HighWinRatio(x)) → InBig3(x))

[PREMISE (GK)]:
BornIn(rafaNadal, mallorca).
ProfessionalTennisPlayer(rafaNadal).
HighWinRatio(rafaNadal).
! [X] : ((ProfessionalTennisPlayer(X) & HighWinRatio(X)) => InBig3(X)).

[CONCLUSION]:
Nadal was not born in Mallorca.

[CONCLUSION (FOL)]:
¬BornIn(rafaNadal, mallorca)

[CONCLUSION (GK)]:
-BornIn(rafaNadal, mallorca).


===

['x']
['x']
[PREMISE]:
Rafa Nadal was born in Mallorca.
Rafa Nadal is a professional tennis player.
Nadal's win ratio is high.
All players in the Big 3 are professionals who have a high win ratio.

[PREMISE (FOL)]:
BornIn(rafaNadal, mallorca)
ProfessionalTennisPlayer(rafaNadal)
HighWinRatio(rafaNadal)
∀x ((ProfessionalTennisPlayer(x) ∧ HighWinRatio(x)) → InBig3(x))

[PREMISE (GK)]:
BornIn(rafaNadal, mallorca).
ProfessionalTennisPlayer(rafaNadal).
HighWinRatio(rafaNadal).
! [X] : ((ProfessionalTennisPlayer(X) & HighWinRatio(X)) => InBig3(X)).

[CONCLUSION]:
Nadal is in the Big 3.

[CONCLUSION (FOL)]:
InBig3(rafaNadal)

[CONCLUSION (GK)]:
InBig3(rafaNadal).


===

['x']
['x']
[PREMISE]:
Rafa Nadal was born in Mallorca.
Rafa Nadal is a professional tennis player.
Nadal's win ratio is high.
All players in the Big 3 are professionals who have a high win ratio.

[PREMISE (FOL)]:
BornIn(rafaNadal, mallorca)
ProfessionalTennisPlayer(rafaNadal)
HighWinRatio(rafaNadal)
∀x ((ProfessionalTennisPlayer(x) ∧ HighWinRatio(x)) → InBig3(x))

[PREMISE (GK)]:
BornIn(rafaNadal, mallorca).
ProfessionalTennisPlayer(rafaNadal).
HighWinRatio(rafaNadal).
! [X] : ((ProfessionalTennisPlayer(X) & HighWinRatio(X)) => InBig3(X)).

[CONCLUSION]:
Nadal is the greatest player of all time.

[CONCLUSION (FOL)]:
GreatestOfAllTime(rafaNadal)

[CONCLUSION (GK)]:
GreatestOfAllTime(rafaNadal).


===

['x']
['x']
[PREMISE]:
No sandwich cookies are healthy.
Oreos are sandwich cookies.

[PREMISE (FOL)]:
∀x (SandwichCookie(x) → ¬Healthy(x))
∀x (Oreo(x) → SandwichCookie(x))

[PREMISE (GK)]:
! [X] : (SandwichCookie(X) => -Healthy(X)).
! [X] : (Oreo(X) => SandwichCookie(X)).

[CONCLUSION]:
All sandwich cookies are delicious.

[CONCLUSION (FOL)]:
∀x (SandwichCookie(x) → Delicious(x))

[CONCLUSION (GK)]:
! [X] : (SandwichCookie(X) => Delicious(X)).


===

['x']
['x']
[PREMISE]:
No animals are plants.
All humans are animals.
All pupils are humans.
All flowers are plants.
Bailey is either both a human and a flower or neither a human nor a flower.

[PREMISE (FOL)]:
∀x (Animal(x) → ¬Plant(x))
∀x (Human(x) → Animal(x))
∀x (Pupil(x) → Human(x))
∀x (Flower(x) → Plant(x))
¬(Human(bailey) ⊕ Flower(bailey))

[PREMISE (GK)]:
! [X] : (Animal(X) => -Plant(X)).
! [X] : (Human(X) => Animal(X)).
! [X] : (Pupil(X) => Human(X)).
! [X] : (Flower(X) => Plant(X)).
-(Human(bailey) <~> Flower(bailey)).

[CONCLUSION]:
Bailey is a pupil.

[CONCLUSION (FOL)]:
Pupil(bailey)

[CONCLUSION (GK)]:
Pupil(bailey).


===

['x']
['x']
[PREMISE]:
No animals are plants.
All humans are animals.
All pupils are humans.
All flowers are plants.
Bailey is either both a human and a flower or neither a human nor a flower.

[PREMISE (FOL)]:
∀x (Animal(x) → ¬Plant(x))
∀x (Human(x) → Animal(x))
∀x (Pupil(x) → Human(x))
∀x (Flower(x) → Plant(x))
¬(Human(bailey) ⊕ Flower(bailey))

[PREMISE (GK)]:
! [X] : (Animal(X) => -Plant(X)).
! [X] : (Human(X) => Animal(X)).
! [X] : (Pupil(X) => Human(X)).
! [X] : (Flower(X) => Plant(X)).
-(Human(bailey) <~> Flower(bailey)).

[CONCLUSION]:
Bailey is not a pupil.

[CONCLUSION (FOL)]:
¬Pupil(bailey)

[CONCLUSION (GK)]:
-Pupil(bailey).


===

['x']
['x']
[PREMISE]:
No animals are plants.
All humans are animals.
All pupils are humans.
All flowers are plants.
Bailey is either both a human and a flower or neither a human nor a flower.

[PREMISE (FOL)]:
∀x (Animal(x) → ¬Plant(x))
∀x (Human(x) → Animal(x))
∀x (Pupil(x) → Human(x))
∀x (Flower(x) → Plant(x))
¬(Human(bailey) ⊕ Flower(bailey))

[PREMISE (GK)]:
! [X] : (Animal(X) => -Plant(X)).
! [X] : (Human(X) => Animal(X)).
! [X] : (Pupil(X) => Human(X)).
! [X] : (Flower(X) => Plant(X)).
-(Human(bailey) <~> Flower(bailey)).

[CONCLUSION]:
Bailey is a plant.

[CONCLUSION (FOL)]:
Plant(bailey)

[CONCLUSION (GK)]:
Plant(bailey).


===

['x']
['x']
[PREMISE]:
No animals are plants.
All humans are animals.
All pupils are humans.
All flowers are plants.
Bailey is either both a human and a flower or neither a human nor a flower.

[PREMISE (FOL)]:
∀x (Animal(x) → ¬Plant(x))
∀x (Human(x) → Animal(x))
∀x (Pupil(x) → Human(x))
∀x (Flower(x) → Plant(x))
¬(Human(bailey) ⊕ Flower(bailey))

[PREMISE (GK)]:
! [X] : (Animal(X) => -Plant(X)).
! [X] : (Human(X) => Animal(X)).
! [X] : (Pupil(X) => Human(X)).
! [X] : (Flower(X) => Plant(X)).
-(Human(bailey) <~> Flower(bailey)).

[CONCLUSION]:
If Bailey is a human, then Bailey is not a pupil.

[CONCLUSION (FOL)]:
Human(bailey) → ¬Pupil(bailey)

[CONCLUSION (GK)]:
Human(bailey) => -Pupil(bailey).


===

['x']
['x']
[PREMISE]:
Shoes are not food.
All slippers are shoes.
Any object donated to the homeless charity is either clothes or food.
Wearable things are not edible.
All clothes are wearable. 
The watch is donated to the homeless charify.
If the watch is not both edible and a piece of clothing, then the watch is either both edible and a piece of clothing or the watch is neither of them.

[PREMISE (FOL)]:
∀x (Shoe(x) → ¬Food(x))
∀x (Slipper(x) → Shoe(x))
∀x (DonatedTo(x, homelessCharity) → Food(x) ⊕ Clothes(x))
∀x (Wearable(x) → ¬Edible(x))
∀x (Clothes(x) → Wearable(x))
DonatedTo(watch, homelessCharify)
¬(Edible(watch) ∧ Clothes(watch)) → ¬(Edible(watch) ⊕ Clothes(watch))

[PREMISE (GK)]:
! [X] : (Shoe(X) => -Food(X)).
! [X] : (Slipper(X) => Shoe(X)).
! [X] : (DonatedTo(X, homelessCharity) => Food(X) <~> Clothes(X)).
! [X] : (Wearable(X) => -Edible(X)).
! [X] : (Clothes(X) => Wearable(X)).
DonatedTo(watch, homelessCharify).
-(Edible(watch) & Clothes(watch)) => -(Edible(watch) <~> Clothes(watch)).

[CONCLUSION]:
A watch is wearable.

[CONCLUSION (FOL)]:
Wearable(watch)

[CONCLUSION (GK)]:
Wearable(watch).


===

['x']
['x']
[PREMISE]:
Shoes are not food.
All slippers are shoes.
Any object donated to the homeless charity is either clothes or food.
Wearable things are not edible.
All clothes are wearable. 
The watch is donated to the homeless charify.
If the watch is not both edible and a piece of clothing, then the watch is either both edible and a piece of clothing or the watch is neither of them.

[PREMISE (FOL)]:
∀x (Shoe(x) → ¬Food(x))
∀x (Slipper(x) → Shoe(x))
∀x (DonatedTo(x, homelessCharity) → Food(x) ⊕ Clothes(x))
∀x (Wearable(x) → ¬Edible(x))
∀x (Clothes(x) → Wearable(x))
DonatedTo(watch, homelessCharify)
¬(Edible(watch) ∧ Clothes(watch)) → ¬(Edible(watch) ⊕ Clothes(watch))

[PREMISE (GK)]:
! [X] : (Shoe(X) => -Food(X)).
! [X] : (Slipper(X) => Shoe(X)).
! [X] : (DonatedTo(X, homelessCharity) => Food(X) <~> Clothes(X)).
! [X] : (Wearable(X) => -Edible(X)).
! [X] : (Clothes(X) => Wearable(X)).
DonatedTo(watch, homelessCharify).
-(Edible(watch) & Clothes(watch)) => -(Edible(watch) <~> Clothes(watch)).

[CONCLUSION]:
A watch is a slipper.

[CONCLUSION (FOL)]:
Slipper(watch)

[CONCLUSION (GK)]:
Slipper(watch).


===

['x']
['x']
[PREMISE]:
Shoes are not food.
All slippers are shoes.
Any object donated to the homeless charity is either clothes or food.
Wearable things are not edible.
All clothes are wearable. 
The watch is donated to the homeless charify.
If the watch is not both edible and a piece of clothing, then the watch is either both edible and a piece of clothing or the watch is neither of them.

[PREMISE (FOL)]:
∀x (Shoe(x) → ¬Food(x))
∀x (Slipper(x) → Shoe(x))
∀x (DonatedTo(x, homelessCharity) → Food(x) ⊕ Clothes(x))
∀x (Wearable(x) → ¬Edible(x))
∀x (Clothes(x) → Wearable(x))
DonatedTo(watch, homelessCharify)
¬(Edible(watch) ∧ Clothes(watch)) → ¬(Edible(watch) ⊕ Clothes(watch))

[PREMISE (GK)]:
! [X] : (Shoe(X) => -Food(X)).
! [X] : (Slipper(X) => Shoe(X)).
! [X] : (DonatedTo(X, homelessCharity) => Food(X) <~> Clothes(X)).
! [X] : (Wearable(X) => -Edible(X)).
! [X] : (Clothes(X) => Wearable(X)).
DonatedTo(watch, homelessCharify).
-(Edible(watch) & Clothes(watch)) => -(Edible(watch) <~> Clothes(watch)).

[CONCLUSION]:
A watch is neither edible nor a slipper.

[CONCLUSION (FOL)]:
¬Edible(watch) ∧ ¬Slipper(watch)

[CONCLUSION (GK)]:
-Edible(watch) & -Slipper(watch).


===

['x']
['x']
[PREMISE]:
An Olympian is a person who trains for an Olympic sport and goes to the Olympics.
Carlos Reyes trains for an Olympic sport.
Carlos Reyes went to the Olympics.
Carlos Reyes is a welterweight.
Heavy weights are not welterweights.

[PREMISE (FOL)]:
∀x ((DoesOlympicSport(x) ∧ GoesToOlympicGames(x)) → Olympian(x))
DoesOlympicSport(carlosReyes)
GoesToOlympicGames(carlosReyes)
WelterWeight(carlosReyes)
∀x (WelterWeight(x) → ¬ HeavyWeight(x))

[PREMISE (GK)]:
! [X] : ((DoesOlympicSport(X) & GoesToOlympicGames(X)) => Olympian(X)).
DoesOlympicSport(carlosReyes).
GoesToOlympicGames(carlosReyes).
WelterWeight(carlosReyes).
! [X] : (WelterWeight(X) => - HeavyWeight(X)).

[CONCLUSION]:
Carlos Reyes is an Olympian.

[CONCLUSION (FOL)]:
Olympian(carlosReyes)

[CONCLUSION (GK)]:
Olympian(carlosReyes).


===

['x']
['x']
[PREMISE]:
An Olympian is a person who trains for an Olympic sport and goes to the Olympics.
Carlos Reyes trains for an Olympic sport.
Carlos Reyes went to the Olympics.
Carlos Reyes is a welterweight.
Heavy weights are not welterweights.

[PREMISE (FOL)]:
∀x ((DoesOlympicSport(x) ∧ GoesToOlympicGames(x)) → Olympian(x))
DoesOlympicSport(carlosReyes)
GoesToOlympicGames(carlosReyes)
WelterWeight(carlosReyes)
∀x (WelterWeight(x) → ¬ HeavyWeight(x))

[PREMISE (GK)]:
! [X] : ((DoesOlympicSport(X) & GoesToOlympicGames(X)) => Olympian(X)).
DoesOlympicSport(carlosReyes).
GoesToOlympicGames(carlosReyes).
WelterWeight(carlosReyes).
! [X] : (WelterWeight(X) => - HeavyWeight(X)).

[CONCLUSION]:
Carlos Reyes is a heavy weight.

[CONCLUSION (FOL)]:
HeavyWeight(carlosReyes)

[CONCLUSION (GK)]:
HeavyWeight(carlosReyes).


===

['x']
['x']
[PREMISE]:
An Olympian is a person who trains for an Olympic sport and goes to the Olympics.
Carlos Reyes trains for an Olympic sport.
Carlos Reyes went to the Olympics.
Carlos Reyes is a welterweight.
Heavy weights are not welterweights.

[PREMISE (FOL)]:
∀x ((DoesOlympicSport(x) ∧ GoesToOlympicGames(x)) → Olympian(x))
DoesOlympicSport(carlosReyes)
GoesToOlympicGames(carlosReyes)
WelterWeight(carlosReyes)
∀x (WelterWeight(x) → ¬ HeavyWeight(x))

[PREMISE (GK)]:
! [X] : ((DoesOlympicSport(X) & GoesToOlympicGames(X)) => Olympian(X)).
DoesOlympicSport(carlosReyes).
GoesToOlympicGames(carlosReyes).
WelterWeight(carlosReyes).
! [X] : (WelterWeight(X) => - HeavyWeight(X)).

[CONCLUSION]:
Carlos Reyes won an Olympic medal.

[CONCLUSION (FOL)]:
WonOlympicMedal(carlosReyes)

[CONCLUSION (GK)]:
WonOlympicMedal(carlosReyes).


===

['x']
['x']
[PREMISE]:
If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.
If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.
If people are big fans of pop bands and singers, then they have a lot of music decorations in their room.
All young teenage girls who attend music festival frequently are big fans of pop bands and singers.
If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.

[PREMISE (FOL)]:
∀x (HaveIn(x, aLotOfMusicDecoration, room) → ¬MoveOutEasily(x))
∀x (Ambitious(x) → MoveOutEasily(x))
∀x (BigFanOfMusic(x) → MusicDecorations(x, room))
∀x (AttendFrequently(x, musicFestival) ∧ YoungTeenageGirl(x) → BigFanOfPopBand(x) ∧ BigFanOfPopSinger(x))
Ambitious(sam) → BBigFanOfPopBand(sam) ∧ BigFanOfPopSinger(sam)

[PREMISE (GK)]:
! [X] : (HaveIn(X, aLotOfMusicDecoration, room) => -MoveOutEasily(X)).
! [X] : (Ambitious(X) => MoveOutEasily(X)).
! [X] : (BigFanOfMusic(X) => MusicDecorations(X, room)).
! [X] : (AttendFrequently(X, musicFestival) & YoungTeenageGirl(X) => BigFanOfPopBand(X) & BigFanOfPopSinger(X)).
Ambitious(sam) => BBigFanOfPopBand(sam) & BigFanOfPopSinger(sam).

[CONCLUSION]:
Sam is a young teenage girl who attends music festival frequently

[CONCLUSION (FOL)]:
Attend(sam, festival) ∧ YoungTeenageGirl(sam)

[CONCLUSION (GK)]:
Attend(sam, festival) & YoungTeenageGirl(sam).


===

['x']
['x']
[PREMISE]:
If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.
If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.
If people are big fans of pop bands and singers, then they have a lot of music decorations in their room.
All young teenage girls who attend music festival frequently are big fans of pop bands and singers.
If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.

[PREMISE (FOL)]:
∀x (HaveIn(x, aLotOfMusicDecoration, room) → ¬MoveOutEasily(x))
∀x (Ambitious(x) → MoveOutEasily(x))
∀x (BigFanOfMusic(x) → MusicDecorations(x, room))
∀x (AttendFrequently(x, musicFestival) ∧ YoungTeenageGirl(x) → BigFanOfPopBand(x) ∧ BigFanOfPopSinger(x))
Ambitious(sam) → BBigFanOfPopBand(sam) ∧ BigFanOfPopSinger(sam)

[PREMISE (GK)]:
! [X] : (HaveIn(X, aLotOfMusicDecoration, room) => -MoveOutEasily(X)).
! [X] : (Ambitious(X) => MoveOutEasily(X)).
! [X] : (BigFanOfMusic(X) => MusicDecorations(X, room)).
! [X] : (AttendFrequently(X, musicFestival) & YoungTeenageGirl(X) => BigFanOfPopBand(X) & BigFanOfPopSinger(X)).
Ambitious(sam) => BBigFanOfPopBand(sam) & BigFanOfPopSinger(sam).

[CONCLUSION]:
Sam is not a young teenage girl who attends music festival frequently

[CONCLUSION (FOL)]:
¬(Attend(sam, festival) ∧ YoungTeenageGirl(sam))

[CONCLUSION (GK)]:
-(Attend(sam, festival) & YoungTeenageGirl(sam)).


===

['x']
['x']
[PREMISE]:
If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.
If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.
If people are big fans of pop bands and singers, then they have a lot of music decorations in their room.
All young teenage girls who attend music festival frequently are big fans of pop bands and singers.
If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.

[PREMISE (FOL)]:
∀x (HaveIn(x, aLotOfMusicDecoration, room) → ¬MoveOutEasily(x))
∀x (Ambitious(x) → MoveOutEasily(x))
∀x (BigFanOfMusic(x) → MusicDecorations(x, room))
∀x (AttendFrequently(x, musicFestival) ∧ YoungTeenageGirl(x) → BigFanOfPopBand(x) ∧ BigFanOfPopSinger(x))
Ambitious(sam) → BBigFanOfPopBand(sam) ∧ BigFanOfPopSinger(sam)

[PREMISE (GK)]:
! [X] : (HaveIn(X, aLotOfMusicDecoration, room) => -MoveOutEasily(X)).
! [X] : (Ambitious(X) => MoveOutEasily(X)).
! [X] : (BigFanOfMusic(X) => MusicDecorations(X, room)).
! [X] : (AttendFrequently(X, musicFestival) & YoungTeenageGirl(X) => BigFanOfPopBand(X) & BigFanOfPopSinger(X)).
Ambitious(sam) => BBigFanOfPopBand(sam) & BigFanOfPopSinger(sam).

[CONCLUSION]:
Sam is a big fan of pop bands and singers.

[CONCLUSION (FOL)]:
BigFanOfMusic(sam)

[CONCLUSION (GK)]:
BigFanOfMusic(sam).


===

['x']
['x']
[PREMISE]:
If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.
If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.
If people are big fans of pop bands and singers, then they have a lot of music decorations in their room.
All young teenage girls who attend music festival frequently are big fans of pop bands and singers.
If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.

[PREMISE (FOL)]:
∀x (HaveIn(x, aLotOfMusicDecoration, room) → ¬MoveOutEasily(x))
∀x (Ambitious(x) → MoveOutEasily(x))
∀x (BigFanOfMusic(x) → MusicDecorations(x, room))
∀x (AttendFrequently(x, musicFestival) ∧ YoungTeenageGirl(x) → BigFanOfPopBand(x) ∧ BigFanOfPopSinger(x))
Ambitious(sam) → BBigFanOfPopBand(sam) ∧ BigFanOfPopSinger(sam)

[PREMISE (GK)]:
! [X] : (HaveIn(X, aLotOfMusicDecoration, room) => -MoveOutEasily(X)).
! [X] : (Ambitious(X) => MoveOutEasily(X)).
! [X] : (BigFanOfMusic(X) => MusicDecorations(X, room)).
! [X] : (AttendFrequently(X, musicFestival) & YoungTeenageGirl(X) => BigFanOfPopBand(X) & BigFanOfPopSinger(X)).
Ambitious(sam) => BBigFanOfPopBand(sam) & BigFanOfPopSinger(sam).

[CONCLUSION]:
Sam neither has high ambitions and future career goals nor is she a young teenage girl attending music festival frequently

[CONCLUSION (FOL)]:
¬(Ambitious(sam) ∨ (Attend(sam, festival) ∧ YoungTeenageGirl(sam)))

[CONCLUSION (GK)]:
-(Ambitious(sam) | (Attend(sam, festival) & YoungTeenageGirl(sam))).


===

['x']
['x']
[PREMISE]:
If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.
If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.
If people are big fans of pop bands and singers, then they have a lot of music decorations in their room.
All young teenage girls who attend music festival frequently are big fans of pop bands and singers.
If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.

[PREMISE (FOL)]:
∀x (HaveIn(x, aLotOfMusicDecoration, room) → ¬MoveOutEasily(x))
∀x (Ambitious(x) → MoveOutEasily(x))
∀x (BigFanOfMusic(x) → MusicDecorations(x, room))
∀x (AttendFrequently(x, musicFestival) ∧ YoungTeenageGirl(x) → BigFanOfPopBand(x) ∧ BigFanOfPopSinger(x))
Ambitious(sam) → BBigFanOfPopBand(sam) ∧ BigFanOfPopSinger(sam)

[PREMISE (GK)]:
! [X] : (HaveIn(X, aLotOfMusicDecoration, room) => -MoveOutEasily(X)).
! [X] : (Ambitious(X) => MoveOutEasily(X)).
! [X] : (BigFanOfMusic(X) => MusicDecorations(X, room)).
! [X] : (AttendFrequently(X, musicFestival) & YoungTeenageGirl(X) => BigFanOfPopBand(X) & BigFanOfPopSinger(X)).
Ambitious(sam) => BBigFanOfPopBand(sam) & BigFanOfPopSinger(sam).

[CONCLUSION]:
Sam has high ambitions and future career goals and is a young teenage girl attending music festival frequently.

[CONCLUSION (FOL)]:
Ambitious(sam) ∧ Attend(sam, festival) ∧ YoungTeenageGirl(sam)

[CONCLUSION (GK)]:
Ambitious(sam) & Attend(sam, festival) & YoungTeenageGirl(sam).


===

['x']
['x']
[PREMISE]:
If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.
If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.
If people are big fans of pop bands and singers, then they have a lot of music decorations in their room.
All young teenage girls who attend music festival frequently are big fans of pop bands and singers.
If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.

[PREMISE (FOL)]:
∀x (HaveIn(x, aLotOfMusicDecoration, room) → ¬MoveOutEasily(x))
∀x (Ambitious(x) → MoveOutEasily(x))
∀x (BigFanOfMusic(x) → MusicDecorations(x, room))
∀x (AttendFrequently(x, musicFestival) ∧ YoungTeenageGirl(x) → BigFanOfPopBand(x) ∧ BigFanOfPopSinger(x))
Ambitious(sam) → BBigFanOfPopBand(sam) ∧ BigFanOfPopSinger(sam)

[PREMISE (GK)]:
! [X] : (HaveIn(X, aLotOfMusicDecoration, room) => -MoveOutEasily(X)).
! [X] : (Ambitious(X) => MoveOutEasily(X)).
! [X] : (BigFanOfMusic(X) => MusicDecorations(X, room)).
! [X] : (AttendFrequently(X, musicFestival) & YoungTeenageGirl(X) => BigFanOfPopBand(X) & BigFanOfPopSinger(X)).
Ambitious(sam) => BBigFanOfPopBand(sam) & BigFanOfPopSinger(sam).

[CONCLUSION]:
Sam has high ambitions and future career goals and is a young teenage girl attending college.

[CONCLUSION (FOL)]:
Ambitious(sam) ∧ Attend(sam, festival) ∧ YoungTeenageGirl(sam)

[CONCLUSION (GK)]:
Ambitious(sam) & Attend(sam, festival) & YoungTeenageGirl(sam).


===

['x']
['x']
[PREMISE]:
If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.
If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.
If people are big fans of pop bands and singers, then they have a lot of music decorations in their room.
All young teenage girls who attend music festival frequently are big fans of pop bands and singers.
If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.

[PREMISE (FOL)]:
∀x (HaveIn(x, aLotOfMusicDecoration, room) → ¬MoveOutEasily(x))
∀x (Ambitious(x) → MoveOutEasily(x))
∀x (BigFanOfMusic(x) → MusicDecorations(x, room))
∀x (AttendFrequently(x, musicFestival) ∧ YoungTeenageGirl(x) → BigFanOfPopBand(x) ∧ BigFanOfPopSinger(x))
Ambitious(sam) → BBigFanOfPopBand(sam) ∧ BigFanOfPopSinger(sam)

[PREMISE (GK)]:
! [X] : (HaveIn(X, aLotOfMusicDecoration, room) => -MoveOutEasily(X)).
! [X] : (Ambitious(X) => MoveOutEasily(X)).
! [X] : (BigFanOfMusic(X) => MusicDecorations(X, room)).
! [X] : (AttendFrequently(X, musicFestival) & YoungTeenageGirl(X) => BigFanOfPopBand(X) & BigFanOfPopSinger(X)).
Ambitious(sam) => BBigFanOfPopBand(sam) & BigFanOfPopSinger(sam).

[CONCLUSION]:
If Sam is a young teenage girl attending college, then Sam either does not have high ambitions and future career goals or is a big fan of pop bands and singers.

[CONCLUSION (FOL)]:
Attend(sam, festival) ∧ YoungTeenageGirl(sam) → ¬(Ambitious(sam) ∨ (BigFanOfPopBand(sam) ∧ BigFanOfPopSinger(sam)))

[CONCLUSION (GK)]:
Attend(sam, festival) & YoungTeenageGirl(sam) => -(Ambitious(sam) | (BigFanOfPopBand(sam) & BigFanOfPopSinger(sam))).


===

['x']
['x']
[PREMISE]:
If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.
If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.
If people are big fans of pop bands and singers, then they have a lot of music decorations in their room.
All young teenage girls who attend music festival frequently are big fans of pop bands and singers.
If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.

[PREMISE (FOL)]:
∀x (HaveIn(x, aLotOfMusicDecoration, room) → ¬MoveOutEasily(x))
∀x (Ambitious(x) → MoveOutEasily(x))
∀x (BigFanOfMusic(x) → MusicDecorations(x, room))
∀x (AttendFrequently(x, musicFestival) ∧ YoungTeenageGirl(x) → BigFanOfPopBand(x) ∧ BigFanOfPopSinger(x))
Ambitious(sam) → BBigFanOfPopBand(sam) ∧ BigFanOfPopSinger(sam)

[PREMISE (GK)]:
! [X] : (HaveIn(X, aLotOfMusicDecoration, room) => -MoveOutEasily(X)).
! [X] : (Ambitious(X) => MoveOutEasily(X)).
! [X] : (BigFanOfMusic(X) => MusicDecorations(X, room)).
! [X] : (AttendFrequently(X, musicFestival) & YoungTeenageGirl(X) => BigFanOfPopBand(X) & BigFanOfPopSinger(X)).
Ambitious(sam) => BBigFanOfPopBand(sam) & BigFanOfPopSinger(sam).

[CONCLUSION]:
If Sam has high ambitions and future career goals and is a young teenage girl attending college, then Sam either does not have high ambitions and future career goals or is not a young teenage girl attending college.

[CONCLUSION (FOL)]:
Ambitious(sam) ∧ Attend(sam, festival) ∧ YoungTeenageGirl(sam) → ¬(Ambitious(sam) ∨ (Attend(sam, festival) ∧ YoungTeenageGirl(sam)))

[CONCLUSION (GK)]:
Ambitious(sam) & Attend(sam, festival) & YoungTeenageGirl(sam) => -(Ambitious(sam) | (Attend(sam, festival) & YoungTeenageGirl(sam))).


===

['x']
['x']
[PREMISE]:
If people have a lot of music decorations in their rooms, they cannot pack and move out of their rooms very easily.
If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.
If people are big fans of pop bands and singers, then they have a lot of music decorations in their room.
All young teenage girls who attend music festival frequently are big fans of pop bands and singers.
If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.

[PREMISE (FOL)]:
∀x (HaveIn(x, aLotOfMusicDecoration, room) → ¬MoveOutEasily(x))
∀x (Ambitious(x) → MoveOutEasily(x))
∀x (BigFanOfMusic(x) → MusicDecorations(x, room))
∀x (AttendFrequently(x, musicFestival) ∧ YoungTeenageGirl(x) → BigFanOfPopBand(x) ∧ BigFanOfPopSinger(x))
Ambitious(sam) → BBigFanOfPopBand(sam) ∧ BigFanOfPopSinger(sam)

[PREMISE (GK)]:
! [X] : (HaveIn(X, aLotOfMusicDecoration, room) => -MoveOutEasily(X)).
! [X] : (Ambitious(X) => MoveOutEasily(X)).
! [X] : (BigFanOfMusic(X) => MusicDecorations(X, room)).
! [X] : (AttendFrequently(X, musicFestival) & YoungTeenageGirl(X) => BigFanOfPopBand(X) & BigFanOfPopSinger(X)).
Ambitious(sam) => BBigFanOfPopBand(sam) & BigFanOfPopSinger(sam).

[CONCLUSION]:
If Sam has high ambitions and future career goals, then Sam is a young teenage girl attending college.

[CONCLUSION (FOL)]:
Ambitious(sam) → Attend(sam, festival) ∧ YoungTeenageGirl(sam)

[CONCLUSION (GK)]:
Ambitious(sam) => Attend(sam, festival) & YoungTeenageGirl(sam).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Brita was a cargo ship built for Norwegians.
Brita was impressed into service by Germany.
Ships that have been impressed into service were seized by whoever impressed them into service.
The Britta was sold to Hong Kong.

[PREMISE (FOL)]:
CargoShip(britta) ∧ Ship(britta) ∧ BuiltFor(britta, norwegians)
ImpressedIntoServiceBy(britta, germany)
∀x ∀y (Ship(x) ∧ ImpressedIntoServiceBy(x, y) → SeizedBy(x, y))
SoldTo(britta, hongkong)

[PREMISE (GK)]:
CargoShip(britta) & Ship(britta) & BuiltFor(britta, norwegians).
ImpressedIntoServiceBy(britta, germany).
! [X] : ! [Y] : (Ship(X) & ImpressedIntoServiceBy(X, Y) => SeizedBy(X, Y)).
SoldTo(britta, hongkong).

[CONCLUSION]:
There was a cargo ship seized by Germany that was sold to Hong Kong.

[CONCLUSION (FOL)]:
∃x (CargoShip(x) ∧ SeizedBy(x, germany) ∧ SoldTo(x, hongkong))

[CONCLUSION (GK)]:
? [X] : (CargoShip(X) & SeizedBy(X, germany) & SoldTo(X, hongkong)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Brita was a cargo ship built for Norwegians.
Brita was impressed into service by Germany.
Ships that have been impressed into service were seized by whoever impressed them into service.
The Britta was sold to Hong Kong.

[PREMISE (FOL)]:
CargoShip(britta) ∧ Ship(britta) ∧ BuiltFor(britta, norwegians)
ImpressedIntoServiceBy(britta, germany)
∀x ∀y (Ship(x) ∧ ImpressedIntoServiceBy(x, y) → SeizedBy(x, y))
SoldTo(britta, hongkong)

[PREMISE (GK)]:
CargoShip(britta) & Ship(britta) & BuiltFor(britta, norwegians).
ImpressedIntoServiceBy(britta, germany).
! [X] : ! [Y] : (Ship(X) & ImpressedIntoServiceBy(X, Y) => SeizedBy(X, Y)).
SoldTo(britta, hongkong).

[CONCLUSION]:
Hong Kong hasn't had any seized ships sold to them.

[CONCLUSION (FOL)]:
∀x ∀y (SoldTo(x, hongkong) → ¬SeizedBy(x, y))

[CONCLUSION (GK)]:
! [X] : ! [Y] : (SoldTo(X, hongkong) => -SeizedBy(X, Y)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Brita was a cargo ship built for Norwegians.
Brita was impressed into service by Germany.
Ships that have been impressed into service were seized by whoever impressed them into service.
The Britta was sold to Hong Kong.

[PREMISE (FOL)]:
CargoShip(britta) ∧ Ship(britta) ∧ BuiltFor(britta, norwegians)
ImpressedIntoServiceBy(britta, germany)
∀x ∀y (Ship(x) ∧ ImpressedIntoServiceBy(x, y) → SeizedBy(x, y))
SoldTo(britta, hongkong)

[PREMISE (GK)]:
CargoShip(britta) & Ship(britta) & BuiltFor(britta, norwegians).
ImpressedIntoServiceBy(britta, germany).
! [X] : ! [Y] : (Ship(X) & ImpressedIntoServiceBy(X, Y) => SeizedBy(X, Y)).
SoldTo(britta, hongkong).

[CONCLUSION]:
Hong Kong seized the Britta.

[CONCLUSION (FOL)]:
SeizedBy(britta, hongkong)

[CONCLUSION (GK)]:
SeizedBy(britta, hongkong).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Quincy McDuffie is an American professional wide receiver in Canadian Football.
People who can catch balls are good wide receivers. 
Quincy McDuffie can catch some footballs easily.
Good wide receivers play professionally.
Good wide receivers can catch with both their left and right hand.
All footballs are balls.

[PREMISE (FOL)]:
American(quincyMcduffie) ∧ Professional(quincyMcduffie) ∧ WideReciever(quincyMcduffie) ∧ PlaysIn(quincyMcduffie, cFL)
∀x ((∃y(CanCatch(x, y) ∧ Ball(y))) → GoodWideReceiver(x))
∃x ∃y (Football(x) ∧ CanCatch(quincymcduffie, x)) ∧ (¬(x=y) ∧ (Football(y) ∧ CanCatch(quincymcduffie, y))
∀x (GoodWideReceiver(x) → Professional(x))
∀x (GoodWideReceiver(x) → (CanCatchWith(x, lefthand) ∧ CanCatchWith(x, righthand)))
∀x (Football(x) → Ball(x))

[PREMISE (GK)]:
American(quincyMcduffie) & Professional(quincyMcduffie) & WideReciever(quincyMcduffie) & PlaysIn(quincyMcduffie, cFL).
! [X] : ((? [Y] :(CanCatch(X, Y) & Ball(Y))) => GoodWideReceiver(X)).
? [X] : ? [Y] : (Football(X) & CanCatch(quincymcduffie, X)) & (-(X=Y) & (Football(Y) & CanCatch(quincymcduffie, Y)).
! [X] : (GoodWideReceiver(X) => Professional(X)).
! [X] : (GoodWideReceiver(X) => (CanCatchWith(X, lefthand) & CanCatchWith(X, righthand))).
! [X] : (Football(X) => Ball(X)).

[CONCLUSION]:
Quincy McDuffie is a good wide receiver.

[CONCLUSION (FOL)]:
GoodWideReceiver(quincyMcduffie)

[CONCLUSION (GK)]:
GoodWideReceiver(quincyMcduffie).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Quincy McDuffie is an American professional wide receiver in Canadian Football.
People who can catch balls are good wide receivers. 
Quincy McDuffie can catch some footballs easily.
Good wide receivers play professionally.
Good wide receivers can catch with both their left and right hand.
All footballs are balls.

[PREMISE (FOL)]:
American(quincyMcduffie) ∧ Professional(quincyMcduffie) ∧ WideReciever(quincyMcduffie) ∧ PlaysIn(quincyMcduffie, cFL)
∀x ((∃y(CanCatch(x, y) ∧ Ball(y))) → GoodWideReceiver(x))
∃x ∃y (Football(x) ∧ CanCatch(quincymcduffie, x)) ∧ (¬(x=y) ∧ (Football(y) ∧ CanCatch(quincymcduffie, y))
∀x (GoodWideReceiver(x) → Professional(x))
∀x (GoodWideReceiver(x) → (CanCatchWith(x, lefthand) ∧ CanCatchWith(x, righthand)))
∀x (Football(x) → Ball(x))

[PREMISE (GK)]:
American(quincyMcduffie) & Professional(quincyMcduffie) & WideReciever(quincyMcduffie) & PlaysIn(quincyMcduffie, cFL).
! [X] : ((? [Y] :(CanCatch(X, Y) & Ball(Y))) => GoodWideReceiver(X)).
? [X] : ? [Y] : (Football(X) & CanCatch(quincymcduffie, X)) & (-(X=Y) & (Football(Y) & CanCatch(quincymcduffie, Y)).
! [X] : (GoodWideReceiver(X) => Professional(X)).
! [X] : (GoodWideReceiver(X) => (CanCatchWith(X, lefthand) & CanCatchWith(X, righthand))).
! [X] : (Football(X) => Ball(X)).

[CONCLUSION]:
Quincy McDuffie can catch every ball.

[CONCLUSION (FOL)]:
∀x (Ball(x) → CanCatch(quincymcduffie, x))

[CONCLUSION (GK)]:
! [X] : (Ball(X) => CanCatch(quincymcduffie, X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Quincy McDuffie is an American professional wide receiver in Canadian Football.
People who can catch balls are good wide receivers. 
Quincy McDuffie can catch some footballs easily.
Good wide receivers play professionally.
Good wide receivers can catch with both their left and right hand.
All footballs are balls.

[PREMISE (FOL)]:
American(quincyMcduffie) ∧ Professional(quincyMcduffie) ∧ WideReciever(quincyMcduffie) ∧ PlaysIn(quincyMcduffie, cFL)
∀x ((∃y(CanCatch(x, y) ∧ Ball(y))) → GoodWideReceiver(x))
∃x ∃y (Football(x) ∧ CanCatch(quincymcduffie, x)) ∧ (¬(x=y) ∧ (Football(y) ∧ CanCatch(quincymcduffie, y))
∀x (GoodWideReceiver(x) → Professional(x))
∀x (GoodWideReceiver(x) → (CanCatchWith(x, lefthand) ∧ CanCatchWith(x, righthand)))
∀x (Football(x) → Ball(x))

[PREMISE (GK)]:
American(quincyMcduffie) & Professional(quincyMcduffie) & WideReciever(quincyMcduffie) & PlaysIn(quincyMcduffie, cFL).
! [X] : ((? [Y] :(CanCatch(X, Y) & Ball(Y))) => GoodWideReceiver(X)).
? [X] : ? [Y] : (Football(X) & CanCatch(quincymcduffie, X)) & (-(X=Y) & (Football(Y) & CanCatch(quincymcduffie, Y)).
! [X] : (GoodWideReceiver(X) => Professional(X)).
! [X] : (GoodWideReceiver(X) => (CanCatchWith(X, lefthand) & CanCatchWith(X, righthand))).
! [X] : (Football(X) => Ball(X)).

[CONCLUSION]:
Professional wide receivers are good at catching balls.

[CONCLUSION (FOL)]:
∀x ((Professional(x) ∧ WideReciever(x)) → Good(x, catchingballs))

[CONCLUSION (GK)]:
! [X] : ((Professional(X) & WideReciever(X)) => Good(X, catchingballs)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Boves is a railway station located in France. 
The preceding station of Boves is Longueau.
The preceding station of Dommartin is Boves.
France is a European country.
Dommartin is situated on the Paris–Lille railway. 
Any two contiguous stations are on the same railway.
Boves is served by regional TER Hauts-de-France trains.
If place A is located in place B and place B is located in place C, then place A is located in place C.
If place A precedes place B and place B precedes place C, then place A precedes place C.

[PREMISE (FOL)]:
RailwayStation(boves) ∧ In(boves, france)
Precede(longueau, boves)
Precede(boves, dommartin)
In(france, europe)
SituatedOn(dommartin, pairsLille)
∀x ∀y ∀z ((SituatedOn(x, z) ∧ (Precede(x, y) ∨ Precede(y, x)) → SituatedOn(y, z))
Serve(boves, hautsDeFrance)
∀x ∀y ∀z ((In(x, y) ∧ In(y, z)) → In(x, z))
∀x ∀y ∀z ((Precede(x, y) ∧ Precede(y, z)) → Precede(x, z))

[PREMISE (GK)]:
RailwayStation(boves) & In(boves, france).
Precede(longueau, boves).
Precede(boves, dommartin).
In(france, europe).
SituatedOn(dommartin, pairsLille).
! [X] : ! [Y] : ! [Z] : ((SituatedOn(X, Z) & (Precede(X, Y) | Precede(Y, X)) => SituatedOn(Y, Z)).
Serve(boves, hautsDeFrance).
! [X] : ! [Y] : ! [Z] : ((In(X, Y) & In(Y, Z)) => In(X, Z)).
! [X] : ! [Y] : ! [Z] : ((Precede(X, Y) & Precede(Y, Z)) => Precede(X, Z)).

[CONCLUSION]:
Longueau is situated on the Paris–Lille railway.

[CONCLUSION (FOL)]:
SituatedOn(longueau, pairsLille)

[CONCLUSION (GK)]:
SituatedOn(longueau, pairsLille).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Boves is a railway station located in France. 
The preceding station of Boves is Longueau.
The preceding station of Dommartin is Boves.
France is a European country.
Dommartin is situated on the Paris–Lille railway. 
Any two contiguous stations are on the same railway.
Boves is served by regional TER Hauts-de-France trains.
If place A is located in place B and place B is located in place C, then place A is located in place C.
If place A precedes place B and place B precedes place C, then place A precedes place C.

[PREMISE (FOL)]:
RailwayStation(boves) ∧ In(boves, france)
Precede(longueau, boves)
Precede(boves, dommartin)
In(france, europe)
SituatedOn(dommartin, pairsLille)
∀x ∀y ∀z ((SituatedOn(x, z) ∧ (Precede(x, y) ∨ Precede(y, x)) → SituatedOn(y, z))
Serve(boves, hautsDeFrance)
∀x ∀y ∀z ((In(x, y) ∧ In(y, z)) → In(x, z))
∀x ∀y ∀z ((Precede(x, y) ∧ Precede(y, z)) → Precede(x, z))

[PREMISE (GK)]:
RailwayStation(boves) & In(boves, france).
Precede(longueau, boves).
Precede(boves, dommartin).
In(france, europe).
SituatedOn(dommartin, pairsLille).
! [X] : ! [Y] : ! [Z] : ((SituatedOn(X, Z) & (Precede(X, Y) | Precede(Y, X)) => SituatedOn(Y, Z)).
Serve(boves, hautsDeFrance).
! [X] : ! [Y] : ! [Z] : ((In(X, Y) & In(Y, Z)) => In(X, Z)).
! [X] : ! [Y] : ! [Z] : ((Precede(X, Y) & Precede(Y, Z)) => Precede(X, Z)).

[CONCLUSION]:
Boves is not in Europe.

[CONCLUSION (FOL)]:
¬In(boves, europe)

[CONCLUSION (GK)]:
-In(boves, europe).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Boves is a railway station located in France. 
The preceding station of Boves is Longueau.
The preceding station of Dommartin is Boves.
France is a European country.
Dommartin is situated on the Paris–Lille railway. 
Any two contiguous stations are on the same railway.
Boves is served by regional TER Hauts-de-France trains.
If place A is located in place B and place B is located in place C, then place A is located in place C.
If place A precedes place B and place B precedes place C, then place A precedes place C.

[PREMISE (FOL)]:
RailwayStation(boves) ∧ In(boves, france)
Precede(longueau, boves)
Precede(boves, dommartin)
In(france, europe)
SituatedOn(dommartin, pairsLille)
∀x ∀y ∀z ((SituatedOn(x, z) ∧ (Precede(x, y) ∨ Precede(y, x)) → SituatedOn(y, z))
Serve(boves, hautsDeFrance)
∀x ∀y ∀z ((In(x, y) ∧ In(y, z)) → In(x, z))
∀x ∀y ∀z ((Precede(x, y) ∧ Precede(y, z)) → Precede(x, z))

[PREMISE (GK)]:
RailwayStation(boves) & In(boves, france).
Precede(longueau, boves).
Precede(boves, dommartin).
In(france, europe).
SituatedOn(dommartin, pairsLille).
! [X] : ! [Y] : ! [Z] : ((SituatedOn(X, Z) & (Precede(X, Y) | Precede(Y, X)) => SituatedOn(Y, Z)).
Serve(boves, hautsDeFrance).
! [X] : ! [Y] : ! [Z] : ((In(X, Y) & In(Y, Z)) => In(X, Z)).
! [X] : ! [Y] : ! [Z] : ((Precede(X, Y) & Precede(Y, Z)) => Precede(X, Z)).

[CONCLUSION]:
Longueau is served by regional TER Hauts-de-France trains.

[CONCLUSION (FOL)]:
Serve(longueau, hautsDeFrance)

[CONCLUSION (GK)]:
Serve(longueau, hautsDeFrance).


===

[]
[]
[PREMISE]:
Edwin Smith was a New Zealand rower from Auckland.
Edwin Smith was also known as Ted Smith.
Edwin Smith went to Rose Road Primary School, located in Grey Lynn.
Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.
Broadway Sheetmetals was a business run and owned by Edwin Smith, a sheet metal worker.

[PREMISE (FOL)]:
From(edwinSmith, newZealand) ∧ Rower(edwinSmith) ∧ From(edwinSmith, auckland)
edwinSmith=tedSmith
GoTo(edwinSmith, roseRoadPrimarySchool) ∧ LocatedIn(roseRoadPrimarySchool, greyLynn)
Sergeant(edwinSmith) ∧ ServeWith(edwinSmith, newZealand24thBattalion) ∧ ServeIn(edwinSmith, italy) ∧ ServeIn(edwinSmith, egypt)
Buisness(broadwaySheetmetals) ∧ Run(edwinSmith, broadwaySheetmetals) ∧ Own(edwinSmith, broadwaySheetmetals) ∧ SheetmetalWorker(edwinsmith)

[PREMISE (GK)]:
From(edwinSmith, newZealand) & Rower(edwinSmith) & From(edwinSmith, auckland).
edwinSmith=tedSmith.
GoTo(edwinSmith, roseRoadPrimarySchool) & LocatedIn(roseRoadPrimarySchool, greyLynn).
Sergeant(edwinSmith) & ServeWith(edwinSmith, newZealand24thBattalion) & ServeIn(edwinSmith, italy) & ServeIn(edwinSmith, egypt).
Buisness(broadwaySheetmetals) & Run(edwinSmith, broadwaySheetmetals) & Own(edwinSmith, broadwaySheetmetals) & SheetmetalWorker(edwinsmith).

[CONCLUSION]:
Ted Smith was a sergeant.

[CONCLUSION (FOL)]:
Sergeant(tedSmith)

[CONCLUSION (GK)]:
Sergeant(tedSmith).


===

[]
['x', 'y']
[PREMISE]:
Edwin Smith was a New Zealand rower from Auckland.
Edwin Smith was also known as Ted Smith.
Edwin Smith went to Rose Road Primary School, located in Grey Lynn.
Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.
Broadway Sheetmetals was a business run and owned by Edwin Smith, a sheet metal worker.

[PREMISE (FOL)]:
From(edwinSmith, newZealand) ∧ Rower(edwinSmith) ∧ From(edwinSmith, auckland)
edwinSmith=tedSmith
GoTo(edwinSmith, roseRoadPrimarySchool) ∧ LocatedIn(roseRoadPrimarySchool, greyLynn)
Sergeant(edwinSmith) ∧ ServeWith(edwinSmith, newZealand24thBattalion) ∧ ServeIn(edwinSmith, italy) ∧ ServeIn(edwinSmith, egypt)
Buisness(broadwaySheetmetals) ∧ Run(edwinSmith, broadwaySheetmetals) ∧ Own(edwinSmith, broadwaySheetmetals) ∧ SheetmetalWorker(edwinsmith)

[PREMISE (GK)]:
From(edwinSmith, newZealand) & Rower(edwinSmith) & From(edwinSmith, auckland).
edwinSmith=tedSmith.
GoTo(edwinSmith, roseRoadPrimarySchool) & LocatedIn(roseRoadPrimarySchool, greyLynn).
Sergeant(edwinSmith) & ServeWith(edwinSmith, newZealand24thBattalion) & ServeIn(edwinSmith, italy) & ServeIn(edwinSmith, egypt).
Buisness(broadwaySheetmetals) & Run(edwinSmith, broadwaySheetmetals) & Own(edwinSmith, broadwaySheetmetals) & SheetmetalWorker(edwinsmith).

[CONCLUSION]:
There were no rowers that own a buisness.

[CONCLUSION (FOL)]:
∀x ∀y (Rower(x) ∧ Buisness(y) → ¬Own(x, y))

[CONCLUSION (GK)]:
! [X] : ! [Y] : (Rower(X) & Buisness(Y) => -Own(X, Y)).


===

[]
['x']
[PREMISE]:
Edwin Smith was a New Zealand rower from Auckland.
Edwin Smith was also known as Ted Smith.
Edwin Smith went to Rose Road Primary School, located in Grey Lynn.
Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.
Broadway Sheetmetals was a business run and owned by Edwin Smith, a sheet metal worker.

[PREMISE (FOL)]:
From(edwinSmith, newZealand) ∧ Rower(edwinSmith) ∧ From(edwinSmith, auckland)
edwinSmith=tedSmith
GoTo(edwinSmith, roseRoadPrimarySchool) ∧ LocatedIn(roseRoadPrimarySchool, greyLynn)
Sergeant(edwinSmith) ∧ ServeWith(edwinSmith, newZealand24thBattalion) ∧ ServeIn(edwinSmith, italy) ∧ ServeIn(edwinSmith, egypt)
Buisness(broadwaySheetmetals) ∧ Run(edwinSmith, broadwaySheetmetals) ∧ Own(edwinSmith, broadwaySheetmetals) ∧ SheetmetalWorker(edwinsmith)

[PREMISE (GK)]:
From(edwinSmith, newZealand) & Rower(edwinSmith) & From(edwinSmith, auckland).
edwinSmith=tedSmith.
GoTo(edwinSmith, roseRoadPrimarySchool) & LocatedIn(roseRoadPrimarySchool, greyLynn).
Sergeant(edwinSmith) & ServeWith(edwinSmith, newZealand24thBattalion) & ServeIn(edwinSmith, italy) & ServeIn(edwinSmith, egypt).
Buisness(broadwaySheetmetals) & Run(edwinSmith, broadwaySheetmetals) & Own(edwinSmith, broadwaySheetmetals) & SheetmetalWorker(edwinsmith).

[CONCLUSION]:
No sergeants were from Auckland.

[CONCLUSION (FOL)]:
∀x (Sergeant(x) → ¬From(x, auckland))

[CONCLUSION (GK)]:
! [X] : (Sergeant(X) => -From(X, auckland)).


===

[]
['x', 'y']
[PREMISE]:
Edwin Smith was a New Zealand rower from Auckland.
Edwin Smith was also known as Ted Smith.
Edwin Smith went to Rose Road Primary School, located in Grey Lynn.
Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.
Broadway Sheetmetals was a business run and owned by Edwin Smith, a sheet metal worker.

[PREMISE (FOL)]:
From(edwinSmith, newZealand) ∧ Rower(edwinSmith) ∧ From(edwinSmith, auckland)
edwinSmith=tedSmith
GoTo(edwinSmith, roseRoadPrimarySchool) ∧ LocatedIn(roseRoadPrimarySchool, greyLynn)
Sergeant(edwinSmith) ∧ ServeWith(edwinSmith, newZealand24thBattalion) ∧ ServeIn(edwinSmith, italy) ∧ ServeIn(edwinSmith, egypt)
Buisness(broadwaySheetmetals) ∧ Run(edwinSmith, broadwaySheetmetals) ∧ Own(edwinSmith, broadwaySheetmetals) ∧ SheetmetalWorker(edwinsmith)

[PREMISE (GK)]:
From(edwinSmith, newZealand) & Rower(edwinSmith) & From(edwinSmith, auckland).
edwinSmith=tedSmith.
GoTo(edwinSmith, roseRoadPrimarySchool) & LocatedIn(roseRoadPrimarySchool, greyLynn).
Sergeant(edwinSmith) & ServeWith(edwinSmith, newZealand24thBattalion) & ServeIn(edwinSmith, italy) & ServeIn(edwinSmith, egypt).
Buisness(broadwaySheetmetals) & Run(edwinSmith, broadwaySheetmetals) & Own(edwinSmith, broadwaySheetmetals) & SheetmetalWorker(edwinsmith).

[CONCLUSION]:
No business owner served in Egypt.

[CONCLUSION (FOL)]:
∀x ∀y (Buisness(x) ∧ Own(y, x) → ¬ServeIn(y, egypt))

[CONCLUSION (GK)]:
! [X] : ! [Y] : (Buisness(X) & Own(Y, X) => -ServeIn(Y, egypt)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A werewolf is a human that can turn into a wolf.
A werewolf has been scratched or bitten by another werewolf.
If someone has been scratched or bitten by some entity, they have been attacked by that entity.

[PREMISE (FOL)]:
∀x (Human(x) ∧ CanTurnInto(x, wolf) → Werewolf(x))
∀x ∃y (Werewolf(x) → (BittenBy(x, y) ∨ ScratchedBy(x, y)) ∧ Werewolf(y))
∀x ∃y (BittenBy(x, y) ∨ ScratchedBy(x, y)) → AttackedBy(x,y)

[PREMISE (GK)]:
! [X] : (Human(X) & CanTurnInto(X, wolf) => Werewolf(X)).
! [X] : ? [Y] : (Werewolf(X) => (BittenBy(X, Y) | ScratchedBy(X, Y)) & Werewolf(Y)).
! [X] : ? [Y] : (BittenBy(X, Y) | ScratchedBy(X, Y)) => AttackedBy(X,Y).

[CONCLUSION]:
All humans are werewolves.

[CONCLUSION (FOL)]:
∀x (Human(x) → Werewolf(x))

[CONCLUSION (GK)]:
! [X] : (Human(X) => Werewolf(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A werewolf is a human that can turn into a wolf.
A werewolf has been scratched or bitten by another werewolf.
If someone has been scratched or bitten by some entity, they have been attacked by that entity.

[PREMISE (FOL)]:
∀x (Human(x) ∧ CanTurnInto(x, wolf) → Werewolf(x))
∀x ∃y (Werewolf(x) → (BittenBy(x, y) ∨ ScratchedBy(x, y)) ∧ Werewolf(y))
∀x ∃y (BittenBy(x, y) ∨ ScratchedBy(x, y)) → AttackedBy(x,y)

[PREMISE (GK)]:
! [X] : (Human(X) & CanTurnInto(X, wolf) => Werewolf(X)).
! [X] : ? [Y] : (Werewolf(X) => (BittenBy(X, Y) | ScratchedBy(X, Y)) & Werewolf(Y)).
! [X] : ? [Y] : (BittenBy(X, Y) | ScratchedBy(X, Y)) => AttackedBy(X,Y).

[CONCLUSION]:
A werewolf is a wolf.

[CONCLUSION (FOL)]:
∀x (Werewolf(x) → Wolf(x))

[CONCLUSION (GK)]:
! [X] : (Werewolf(X) => Wolf(X)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
A werewolf is a human that can turn into a wolf.
A werewolf has been scratched or bitten by another werewolf.
If someone has been scratched or bitten by some entity, they have been attacked by that entity.

[PREMISE (FOL)]:
∀x (Human(x) ∧ CanTurnInto(x, wolf) → Werewolf(x))
∀x ∃y (Werewolf(x) → (BittenBy(x, y) ∨ ScratchedBy(x, y)) ∧ Werewolf(y))
∀x ∃y (BittenBy(x, y) ∨ ScratchedBy(x, y)) → AttackedBy(x,y)

[PREMISE (GK)]:
! [X] : (Human(X) & CanTurnInto(X, wolf) => Werewolf(X)).
! [X] : ? [Y] : (Werewolf(X) => (BittenBy(X, Y) | ScratchedBy(X, Y)) & Werewolf(Y)).
! [X] : ? [Y] : (BittenBy(X, Y) | ScratchedBy(X, Y)) => AttackedBy(X,Y).

[CONCLUSION]:
A werewolf has scratched someone before.

[CONCLUSION (FOL)]:
∀x ∃y (Werewolf(x) → ScratchedBy(y, x))

[CONCLUSION (GK)]:
! [X] : ? [Y] : (Werewolf(X) => ScratchedBy(Y, X)).


===

['x']
['x']
[PREMISE]:
UFC Fight Night was a mixed martial arts event held in Sweden.
At UFC Fight Night, Sadollah was scheduled to fight Musoke.
Sadollah fought Akiyama at UFC Fight Night.
Musoke fought Yakovlev at UFC Fight Night.
Jung was injured at UFC Fight Night.
People injured at UFC Fight Night did not fight.

[PREMISE (FOL)]:
Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ HeldIn(uFCFightNight, sweden)
ScheduledToFight(sadollah, musoke,uFCFightNight)
Fight(sadollah, akiyama, uFCFightNight)
Fight(musoke, yakovlev, uFCFightNight)
InjuredAt(jung, uFCFightNight)
∀x (InjuredAt(x, uFCFightNight) → ¬FightIn(x, uFCFightNight))

[PREMISE (GK)]:
Event(uFCFightNight) & MixedMartial(uFCFightNight) & HeldIn(uFCFightNight, sweden).
ScheduledToFight(sadollah, musoke,uFCFightNight).
Fight(sadollah, akiyama, uFCFightNight).
Fight(musoke, yakovlev, uFCFightNight).
InjuredAt(jung, uFCFightNight).
! [X] : (InjuredAt(X, uFCFightNight) => -FightIn(X, uFCFightNight)).

[CONCLUSION]:
Jung fought Sadollah.

[CONCLUSION (FOL)]:
Fight(jung, sadollah, uFCFightNight)

[CONCLUSION (GK)]:
Fight(jung, sadollah, uFCFightNight).


===

['x']
['x']
[PREMISE]:
UFC Fight Night was a mixed martial arts event held in Sweden.
At UFC Fight Night, Sadollah was scheduled to fight Musoke.
Sadollah fought Akiyama at UFC Fight Night.
Musoke fought Yakovlev at UFC Fight Night.
Jung was injured at UFC Fight Night.
People injured at UFC Fight Night did not fight.

[PREMISE (FOL)]:
Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ HeldIn(uFCFightNight, sweden)
ScheduledToFight(sadollah, musoke,uFCFightNight)
Fight(sadollah, akiyama, uFCFightNight)
Fight(musoke, yakovlev, uFCFightNight)
InjuredAt(jung, uFCFightNight)
∀x (InjuredAt(x, uFCFightNight) → ¬FightIn(x, uFCFightNight))

[PREMISE (GK)]:
Event(uFCFightNight) & MixedMartial(uFCFightNight) & HeldIn(uFCFightNight, sweden).
ScheduledToFight(sadollah, musoke,uFCFightNight).
Fight(sadollah, akiyama, uFCFightNight).
Fight(musoke, yakovlev, uFCFightNight).
InjuredAt(jung, uFCFightNight).
! [X] : (InjuredAt(X, uFCFightNight) => -FightIn(X, uFCFightNight)).

[CONCLUSION]:
Jung did not fight at UFC Fight Night.

[CONCLUSION (FOL)]:
Event(uFCFightNight) ∧ ¬FightIn(jung, uFCFightNight)

[CONCLUSION (GK)]:
Event(uFCFightNight) & -FightIn(jung, uFCFightNight).


===

['x']
['x']
[PREMISE]:
UFC Fight Night was a mixed martial arts event held in Sweden.
At UFC Fight Night, Sadollah was scheduled to fight Musoke.
Sadollah fought Akiyama at UFC Fight Night.
Musoke fought Yakovlev at UFC Fight Night.
Jung was injured at UFC Fight Night.
People injured at UFC Fight Night did not fight.

[PREMISE (FOL)]:
Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ HeldIn(uFCFightNight, sweden)
ScheduledToFight(sadollah, musoke,uFCFightNight)
Fight(sadollah, akiyama, uFCFightNight)
Fight(musoke, yakovlev, uFCFightNight)
InjuredAt(jung, uFCFightNight)
∀x (InjuredAt(x, uFCFightNight) → ¬FightIn(x, uFCFightNight))

[PREMISE (GK)]:
Event(uFCFightNight) & MixedMartial(uFCFightNight) & HeldIn(uFCFightNight, sweden).
ScheduledToFight(sadollah, musoke,uFCFightNight).
Fight(sadollah, akiyama, uFCFightNight).
Fight(musoke, yakovlev, uFCFightNight).
InjuredAt(jung, uFCFightNight).
! [X] : (InjuredAt(X, uFCFightNight) => -FightIn(X, uFCFightNight)).

[CONCLUSION]:
Sadollah fought Musoke at UFC Fight Night.

[CONCLUSION (FOL)]:
Fight(sadollah, musoke, uFCFightNight)

[CONCLUSION (GK)]:
Fight(sadollah, musoke, uFCFightNight).


===

['x']
['x']
[PREMISE]:
UFC Fight Night was a mixed martial arts event held in Sweden.
At UFC Fight Night, Sadollah was scheduled to fight Musoke.
Sadollah fought Akiyama at UFC Fight Night.
Musoke fought Yakovlev at UFC Fight Night.
Jung was injured at UFC Fight Night.
People injured at UFC Fight Night did not fight.

[PREMISE (FOL)]:
Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ HeldIn(uFCFightNight, sweden)
ScheduledToFight(sadollah, musoke,uFCFightNight)
Fight(sadollah, akiyama, uFCFightNight)
Fight(musoke, yakovlev, uFCFightNight)
InjuredAt(jung, uFCFightNight)
∀x (InjuredAt(x, uFCFightNight) → ¬FightIn(x, uFCFightNight))

[PREMISE (GK)]:
Event(uFCFightNight) & MixedMartial(uFCFightNight) & HeldIn(uFCFightNight, sweden).
ScheduledToFight(sadollah, musoke,uFCFightNight).
Fight(sadollah, akiyama, uFCFightNight).
Fight(musoke, yakovlev, uFCFightNight).
InjuredAt(jung, uFCFightNight).
! [X] : (InjuredAt(X, uFCFightNight) => -FightIn(X, uFCFightNight)).

[CONCLUSION]:
Nelson fought Story at UFC Fight Night.

[CONCLUSION (FOL)]:
Fight(nelson, story, uFCFightNight)

[CONCLUSION (GK)]:
Fight(nelson, story, uFCFightNight).


===

['x']
['x']
[PREMISE]:
All drinks on the counter are edible. 
All juices on the counter are drinks. 
Orange juice is a type of juice. 
Everything on the counter is either orange juice or apple juice.
All apple juices on the counter are sweet.
The coke is on the counter and if the coke is apple juice, then the coke is a drink.
If the coke is not apple juice, then the coke is not edible.

[PREMISE (FOL)]:
∀x (OnCounter(x) ∧ Drink(x) → Edible(x))
∀x (OnCounter(x) ∧ Juice(x) → Drink(x))
∀x (OrangeJuice(x) → Juice(x))
∀x (OnCounter(x) → OrangeJuice(x) ⊕ AppleJuice(x))
∀x (OnCounter(x) ∧ AppleJuice(x) → Sweet(x))
OnCounter(coke) ∧ (AppleJuice(coke) → Drink(coke))
¬AppleJuice(coke) → ¬Edible(coke)

[PREMISE (GK)]:
! [X] : (OnCounter(X) & Drink(X) => Edible(X)).
! [X] : (OnCounter(X) & Juice(X) => Drink(X)).
! [X] : (OrangeJuice(X) => Juice(X)).
! [X] : (OnCounter(X) => OrangeJuice(X) <~> AppleJuice(X)).
! [X] : (OnCounter(X) & AppleJuice(X) => Sweet(X)).
OnCounter(coke) & (AppleJuice(coke) => Drink(coke)).
-AppleJuice(coke) => -Edible(coke).

[CONCLUSION]:
The coke is orange juice.

[CONCLUSION (FOL)]:
OrangeJuice(coke)

[CONCLUSION (GK)]:
OrangeJuice(coke).


===

['x']
['x']
[PREMISE]:
All drinks on the counter are edible. 
All juices on the counter are drinks. 
Orange juice is a type of juice. 
Everything on the counter is either orange juice or apple juice.
All apple juices on the counter are sweet.
The coke is on the counter and if the coke is apple juice, then the coke is a drink.
If the coke is not apple juice, then the coke is not edible.

[PREMISE (FOL)]:
∀x (OnCounter(x) ∧ Drink(x) → Edible(x))
∀x (OnCounter(x) ∧ Juice(x) → Drink(x))
∀x (OrangeJuice(x) → Juice(x))
∀x (OnCounter(x) → OrangeJuice(x) ⊕ AppleJuice(x))
∀x (OnCounter(x) ∧ AppleJuice(x) → Sweet(x))
OnCounter(coke) ∧ (AppleJuice(coke) → Drink(coke))
¬AppleJuice(coke) → ¬Edible(coke)

[PREMISE (GK)]:
! [X] : (OnCounter(X) & Drink(X) => Edible(X)).
! [X] : (OnCounter(X) & Juice(X) => Drink(X)).
! [X] : (OrangeJuice(X) => Juice(X)).
! [X] : (OnCounter(X) => OrangeJuice(X) <~> AppleJuice(X)).
! [X] : (OnCounter(X) & AppleJuice(X) => Sweet(X)).
OnCounter(coke) & (AppleJuice(coke) => Drink(coke)).
-AppleJuice(coke) => -Edible(coke).

[CONCLUSION]:
The coke is edible and sweet.

[CONCLUSION (FOL)]:
Edible(coke) ∧ Sweet(coke)

[CONCLUSION (GK)]:
Edible(coke) & Sweet(coke).


===

['x']
['x']
[PREMISE]:
All drinks on the counter are edible. 
All juices on the counter are drinks. 
Orange juice is a type of juice. 
Everything on the counter is either orange juice or apple juice.
All apple juices on the counter are sweet.
The coke is on the counter and if the coke is apple juice, then the coke is a drink.
If the coke is not apple juice, then the coke is not edible.

[PREMISE (FOL)]:
∀x (OnCounter(x) ∧ Drink(x) → Edible(x))
∀x (OnCounter(x) ∧ Juice(x) → Drink(x))
∀x (OrangeJuice(x) → Juice(x))
∀x (OnCounter(x) → OrangeJuice(x) ⊕ AppleJuice(x))
∀x (OnCounter(x) ∧ AppleJuice(x) → Sweet(x))
OnCounter(coke) ∧ (AppleJuice(coke) → Drink(coke))
¬AppleJuice(coke) → ¬Edible(coke)

[PREMISE (GK)]:
! [X] : (OnCounter(X) & Drink(X) => Edible(X)).
! [X] : (OnCounter(X) & Juice(X) => Drink(X)).
! [X] : (OrangeJuice(X) => Juice(X)).
! [X] : (OnCounter(X) => OrangeJuice(X) <~> AppleJuice(X)).
! [X] : (OnCounter(X) & AppleJuice(X) => Sweet(X)).
OnCounter(coke) & (AppleJuice(coke) => Drink(coke)).
-AppleJuice(coke) => -Edible(coke).

[CONCLUSION]:
The coke is not edible and sweet.

[CONCLUSION (FOL)]:
¬(Edible(coke) ∧ Sweet(coke))

[CONCLUSION (GK)]:
-(Edible(coke) & Sweet(coke)).


===

['x']
['x']
[PREMISE]:
Federico Garcia Lorca was a talented Spanish poet, and he supported the Popular Front.
The Spanish Nationalists opposed anyone who supported the Popular Front
Talented poets are popular.
Spanish Nationalists killed anyone who they opposed and who was popular.
Daniel supported the Popular Front but was not popular.

[PREMISE (FOL)]:
TalentedPoet(lorca) ∧ Support(lorca, populists)
∀x (Support(x, populists) → Opposed(nationalists, x))
∀x (TalentedPoet(x) → Popular(x))
∀x ((Opposed(nationalists, x) ∧ Popular(x)) → Killed(nationalists, x))
Support(daniel, populists) ∧ (¬Popular(daniel))

[PREMISE (GK)]:
TalentedPoet(lorca) & Support(lorca, populists).
! [X] : (Support(X, populists) => Opposed(nationalists, X)).
! [X] : (TalentedPoet(X) => Popular(X)).
! [X] : ((Opposed(nationalists, X) & Popular(X)) => Killed(nationalists, X)).
Support(daniel, populists) & (-Popular(daniel)).

[CONCLUSION]:
The Spanish Nationalists killed Daniel.

[CONCLUSION (FOL)]:
¬Killed(nationalists, daniel)

[CONCLUSION (GK)]:
-Killed(nationalists, daniel).


===

['x']
['x']
[PREMISE]:
Federico Garcia Lorca was a talented Spanish poet, and he supported the Popular Front.
The Spanish Nationalists opposed anyone who supported the Popular Front
Talented poets are popular.
Spanish Nationalists killed anyone who they opposed and who was popular.
Daniel supported the Popular Front but was not popular.

[PREMISE (FOL)]:
TalentedPoet(lorca) ∧ Support(lorca, populists)
∀x (Support(x, populists) → Opposed(nationalists, x))
∀x (TalentedPoet(x) → Popular(x))
∀x ((Opposed(nationalists, x) ∧ Popular(x)) → Killed(nationalists, x))
Support(daniel, populists) ∧ (¬Popular(daniel))

[PREMISE (GK)]:
TalentedPoet(lorca) & Support(lorca, populists).
! [X] : (Support(X, populists) => Opposed(nationalists, X)).
! [X] : (TalentedPoet(X) => Popular(X)).
! [X] : ((Opposed(nationalists, X) & Popular(X)) => Killed(nationalists, X)).
Support(daniel, populists) & (-Popular(daniel)).

[CONCLUSION]:
The Spanish Nationalists killed Lorca.

[CONCLUSION (FOL)]:
Killed(nationalists, lorca)

[CONCLUSION (GK)]:
Killed(nationalists, lorca).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
People in Franny's family drink kombucha every day or drink Coca-Cola or a Pepsi product.
If people in Franny's family drink Coca-Cola or a Pepsi product every day, then they grew up with extremely busy parents who did not have time to pack them lunch.
If people in Franny's family drink Coca-Cola or another Pepsi product every day, then they have to visit the dentist frequently.
If people in Franny's family grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.
If people in Franny's family have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.
Damon is in Franny's family. 
Damon either both grow up with extremely busy parents who did not have time to pack her lunch and have consistent everyday routines and like sticking to a solid schedule, or Damon did neither.

[PREMISE (FOL)]:
∀x (In(x, frannysFamily) ∧ (Drink(x, kombucha) ∨ (∃y (Drink(x, cocaCola) ∨ (PepsiProduct(y) ∧ Drink(x, y))))))
∀x (In(x, frannysFamily) ∧ (∃y (Drink(x, cocaCola) ∨ (PepsiProduct(y) ∧ Drink(x, y)))) → (∃y ∃z (¬(y=z) ∧ BusyParent(y) ∧ BusyParent(z) ∧ ¬Pack(y, lunch) ∧ ¬Pack(z, lunch) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z))))
∀x (In(x, frannysFamily)) ∧ (∃y (Drink(x, cocaCola) ∨ (PepsiProduct(y) ∧ Drink(x, y)))) → HaveToVisitFrequently(x, dentist))
∀x (In(x, frannysFamily) ∧ (∃y ∃z (¬(y=z) ∧ BusyParent(y) ∧ BusyParent(z) ∧ ¬Pack(y, lunch) ∧ ¬Pack(z, lunch) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z))) → ∃y (Have(x, y) ∧ Erratic(y) ∧ Diverse(y) ∧ EatingHabit(y)))
∀x (In(x, frannysFamily) ∧ ∃y (Have(x, y) ∧ Erratic(y) ∧ Diverse(y) ∧ EatingHabit(y))) → ¬(ConsistentEverydayRoutine(x) ∧ StickTo(damon, solidSchedule)))
In(damon, frannysFamily)
¬((∃y ∃z(¬(y=z) ∧ BusyParent(y) ∧ BusyParent(z) ∧ ¬Pack(y, lunch) ∧ ¬Pack(z, lunch) ∧ GrowUpWith(damon, y) ∧ GrowUpWith(damon, z))) ⊕ (ConsistentEverydayRoutine(damon) ∧ StickTo(damon, solidSchedule)))

[PREMISE (GK)]:
! [X] : (In(X, frannysFamily) & (Drink(X, kombucha) | (? [Y] : (Drink(X, cocaCola) | (PepsiProduct(Y) & Drink(X, Y)))))).
! [X] : (In(X, frannysFamily) & (? [Y] : (Drink(X, cocaCola) | (PepsiProduct(Y) & Drink(X, Y)))) => (? [Y] : ? [Z] : (-(Y=Z) & BusyParent(Y) & BusyParent(Z) & -Pack(Y, lunch) & -Pack(Z, lunch) & GrowUpWith(X, Y) & GrowUpWith(X, Z)))).
! [X] : (In(X, frannysFamily)) & (? [Y] : (Drink(X, cocaCola) | (PepsiProduct(Y) & Drink(X, Y)))) => HaveToVisitFrequently(X, dentist)).
! [X] : (In(X, frannysFamily) & (? [Y] : ? [Z] : (-(Y=Z) & BusyParent(Y) & BusyParent(Z) & -Pack(Y, lunch) & -Pack(Z, lunch) & GrowUpWith(X, Y) & GrowUpWith(X, Z))) => ? [Y] : (Have(X, Y) & Erratic(Y) & Diverse(Y) & EatingHabit(Y))).
! [X] : (In(X, frannysFamily) & ? [Y] : (Have(X, Y) & Erratic(Y) & Diverse(Y) & EatingHabit(Y))) => -(ConsistentEverydayRoutine(X) & StickTo(damon, solidSchedule))).
In(damon, frannysFamily).
-((? [Y] : ? [Z] :(-(Y=Z) & BusyParent(Y) & BusyParent(Z) & -Pack(Y, lunch) & -Pack(Z, lunch) & GrowUpWith(damon, Y) & GrowUpWith(damon, Z))) <~> (ConsistentEverydayRoutine(damon) & StickTo(damon, solidSchedule))).

[CONCLUSION]:
Damon is in Franny's family and he has to visit the dentist frequently.

[CONCLUSION (FOL)]:
HaveToVisitFrequently(damon, dentist)

[CONCLUSION (GK)]:
HaveToVisitFrequently(damon, dentist).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
People in Franny's family drink kombucha every day or drink Coca-Cola or a Pepsi product.
If people in Franny's family drink Coca-Cola or a Pepsi product every day, then they grew up with extremely busy parents who did not have time to pack them lunch.
If people in Franny's family drink Coca-Cola or another Pepsi product every day, then they have to visit the dentist frequently.
If people in Franny's family grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.
If people in Franny's family have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.
Damon is in Franny's family. 
Damon either both grow up with extremely busy parents who did not have time to pack her lunch and have consistent everyday routines and like sticking to a solid schedule, or Damon did neither.

[PREMISE (FOL)]:
∀x (In(x, frannysFamily) ∧ (Drink(x, kombucha) ∨ (∃y (Drink(x, cocaCola) ∨ (PepsiProduct(y) ∧ Drink(x, y))))))
∀x (In(x, frannysFamily) ∧ (∃y (Drink(x, cocaCola) ∨ (PepsiProduct(y) ∧ Drink(x, y)))) → (∃y ∃z (¬(y=z) ∧ BusyParent(y) ∧ BusyParent(z) ∧ ¬Pack(y, lunch) ∧ ¬Pack(z, lunch) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z))))
∀x (In(x, frannysFamily)) ∧ (∃y (Drink(x, cocaCola) ∨ (PepsiProduct(y) ∧ Drink(x, y)))) → HaveToVisitFrequently(x, dentist))
∀x (In(x, frannysFamily) ∧ (∃y ∃z (¬(y=z) ∧ BusyParent(y) ∧ BusyParent(z) ∧ ¬Pack(y, lunch) ∧ ¬Pack(z, lunch) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z))) → ∃y (Have(x, y) ∧ Erratic(y) ∧ Diverse(y) ∧ EatingHabit(y)))
∀x (In(x, frannysFamily) ∧ ∃y (Have(x, y) ∧ Erratic(y) ∧ Diverse(y) ∧ EatingHabit(y))) → ¬(ConsistentEverydayRoutine(x) ∧ StickTo(damon, solidSchedule)))
In(damon, frannysFamily)
¬((∃y ∃z(¬(y=z) ∧ BusyParent(y) ∧ BusyParent(z) ∧ ¬Pack(y, lunch) ∧ ¬Pack(z, lunch) ∧ GrowUpWith(damon, y) ∧ GrowUpWith(damon, z))) ⊕ (ConsistentEverydayRoutine(damon) ∧ StickTo(damon, solidSchedule)))

[PREMISE (GK)]:
! [X] : (In(X, frannysFamily) & (Drink(X, kombucha) | (? [Y] : (Drink(X, cocaCola) | (PepsiProduct(Y) & Drink(X, Y)))))).
! [X] : (In(X, frannysFamily) & (? [Y] : (Drink(X, cocaCola) | (PepsiProduct(Y) & Drink(X, Y)))) => (? [Y] : ? [Z] : (-(Y=Z) & BusyParent(Y) & BusyParent(Z) & -Pack(Y, lunch) & -Pack(Z, lunch) & GrowUpWith(X, Y) & GrowUpWith(X, Z)))).
! [X] : (In(X, frannysFamily)) & (? [Y] : (Drink(X, cocaCola) | (PepsiProduct(Y) & Drink(X, Y)))) => HaveToVisitFrequently(X, dentist)).
! [X] : (In(X, frannysFamily) & (? [Y] : ? [Z] : (-(Y=Z) & BusyParent(Y) & BusyParent(Z) & -Pack(Y, lunch) & -Pack(Z, lunch) & GrowUpWith(X, Y) & GrowUpWith(X, Z))) => ? [Y] : (Have(X, Y) & Erratic(Y) & Diverse(Y) & EatingHabit(Y))).
! [X] : (In(X, frannysFamily) & ? [Y] : (Have(X, Y) & Erratic(Y) & Diverse(Y) & EatingHabit(Y))) => -(ConsistentEverydayRoutine(X) & StickTo(damon, solidSchedule))).
In(damon, frannysFamily).
-((? [Y] : ? [Z] :(-(Y=Z) & BusyParent(Y) & BusyParent(Z) & -Pack(Y, lunch) & -Pack(Z, lunch) & GrowUpWith(damon, Y) & GrowUpWith(damon, Z))) <~> (ConsistentEverydayRoutine(damon) & StickTo(damon, solidSchedule))).

[CONCLUSION]:
If Damon is in Franny's family and he either both grew up with extremely busy parents who did not have time to pack his lunch and drink kombucha every day or neither grew up with extremely busy parents who did not have time to pack his lunch nor drink kombucha every day, then Damon neither visits the dentist frequently nor drinks Coca Cola or Pepsi products.

[CONCLUSION (FOL)]:
¬((¬(y=z) ∧ ∃y ∃z (BusyParent(y) ∧ BusyParent(z) ∧ ¬Pack(y, lunch) ∧ ¬Pack(z, lunch) ∧ GrowUpWith(damon, y) ∧ GrowUpWith(damon, z))) ⊕ Drink(damon, kombucha)) → ¬(HaveToVisitFrequently(damon, dentist) ∨ (∃y (Have(damon, y) ∧ Erratic(y) ∧ Diverse(y) ∧ EatingHabit(y))))

[CONCLUSION (GK)]:
-((-(Y=Z) & ? [Y] : ? [Z] : (BusyParent(Y) & BusyParent(Z) & -Pack(Y, lunch) & -Pack(Z, lunch) & GrowUpWith(damon, Y) & GrowUpWith(damon, Z))) <~> Drink(damon, kombucha)) => -(HaveToVisitFrequently(damon, dentist) | (? [Y] : (Have(damon, Y) & Erratic(Y) & Diverse(Y) & EatingHabit(Y)))).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
People in Franny's family drink kombucha every day or drink Coca-Cola or a Pepsi product.
If people in Franny's family drink Coca-Cola or a Pepsi product every day, then they grew up with extremely busy parents who did not have time to pack them lunch.
If people in Franny's family drink Coca-Cola or another Pepsi product every day, then they have to visit the dentist frequently.
If people in Franny's family grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.
If people in Franny's family have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.
Damon is in Franny's family. 
Damon either both grow up with extremely busy parents who did not have time to pack her lunch and have consistent everyday routines and like sticking to a solid schedule, or Damon did neither.

[PREMISE (FOL)]:
∀x (In(x, frannysFamily) ∧ (Drink(x, kombucha) ∨ (∃y (Drink(x, cocaCola) ∨ (PepsiProduct(y) ∧ Drink(x, y))))))
∀x (In(x, frannysFamily) ∧ (∃y (Drink(x, cocaCola) ∨ (PepsiProduct(y) ∧ Drink(x, y)))) → (∃y ∃z (¬(y=z) ∧ BusyParent(y) ∧ BusyParent(z) ∧ ¬Pack(y, lunch) ∧ ¬Pack(z, lunch) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z))))
∀x (In(x, frannysFamily)) ∧ (∃y (Drink(x, cocaCola) ∨ (PepsiProduct(y) ∧ Drink(x, y)))) → HaveToVisitFrequently(x, dentist))
∀x (In(x, frannysFamily) ∧ (∃y ∃z (¬(y=z) ∧ BusyParent(y) ∧ BusyParent(z) ∧ ¬Pack(y, lunch) ∧ ¬Pack(z, lunch) ∧ GrowUpWith(x, y) ∧ GrowUpWith(x, z))) → ∃y (Have(x, y) ∧ Erratic(y) ∧ Diverse(y) ∧ EatingHabit(y)))
∀x (In(x, frannysFamily) ∧ ∃y (Have(x, y) ∧ Erratic(y) ∧ Diverse(y) ∧ EatingHabit(y))) → ¬(ConsistentEverydayRoutine(x) ∧ StickTo(damon, solidSchedule)))
In(damon, frannysFamily)
¬((∃y ∃z(¬(y=z) ∧ BusyParent(y) ∧ BusyParent(z) ∧ ¬Pack(y, lunch) ∧ ¬Pack(z, lunch) ∧ GrowUpWith(damon, y) ∧ GrowUpWith(damon, z))) ⊕ (ConsistentEverydayRoutine(damon) ∧ StickTo(damon, solidSchedule)))

[PREMISE (GK)]:
! [X] : (In(X, frannysFamily) & (Drink(X, kombucha) | (? [Y] : (Drink(X, cocaCola) | (PepsiProduct(Y) & Drink(X, Y)))))).
! [X] : (In(X, frannysFamily) & (? [Y] : (Drink(X, cocaCola) | (PepsiProduct(Y) & Drink(X, Y)))) => (? [Y] : ? [Z] : (-(Y=Z) & BusyParent(Y) & BusyParent(Z) & -Pack(Y, lunch) & -Pack(Z, lunch) & GrowUpWith(X, Y) & GrowUpWith(X, Z)))).
! [X] : (In(X, frannysFamily)) & (? [Y] : (Drink(X, cocaCola) | (PepsiProduct(Y) & Drink(X, Y)))) => HaveToVisitFrequently(X, dentist)).
! [X] : (In(X, frannysFamily) & (? [Y] : ? [Z] : (-(Y=Z) & BusyParent(Y) & BusyParent(Z) & -Pack(Y, lunch) & -Pack(Z, lunch) & GrowUpWith(X, Y) & GrowUpWith(X, Z))) => ? [Y] : (Have(X, Y) & Erratic(Y) & Diverse(Y) & EatingHabit(Y))).
! [X] : (In(X, frannysFamily) & ? [Y] : (Have(X, Y) & Erratic(Y) & Diverse(Y) & EatingHabit(Y))) => -(ConsistentEverydayRoutine(X) & StickTo(damon, solidSchedule))).
In(damon, frannysFamily).
-((? [Y] : ? [Z] :(-(Y=Z) & BusyParent(Y) & BusyParent(Z) & -Pack(Y, lunch) & -Pack(Z, lunch) & GrowUpWith(damon, Y) & GrowUpWith(damon, Z))) <~> (ConsistentEverydayRoutine(damon) & StickTo(damon, solidSchedule))).

[CONCLUSION]:
If Damon is in Franny's family and he either visits the dentist frequently or drinks kombucha, then Damon both visits the dentist frequently and drinks Coca-Cola or Pepsi products every day.

[CONCLUSION (FOL)]:
HaveToVisitFrequently(damon, dentist) ∨ Drink(damon, kombucha, everyDay) → HaveToVisitFrequently(damon, dentist) ∧ (∃y (Drink(x, cocaCola) ∨ (PepsiProduct(y) ∧ Drink(x, y))))

[CONCLUSION (GK)]:
HaveToVisitFrequently(damon, dentist) | Drink(damon, kombucha, everyDay) => HaveToVisitFrequently(damon, dentist) & (? [Y] : (Drink(X, cocaCola) | (PepsiProduct(Y) & Drink(X, Y)))).


===

['x']
['x']
[PREMISE]:
If a customer subscribes to AMC A-List, then he/she can watch 3 movies every week without any additional fees. 
Some customers go to cinemas every week. 
Customers who prefer TV series will not watch TV series in cinemas.
James watches TV series in cinemas. 
James subscribes to AMC A-List.
Peter prefers TV series.

[PREMISE (FOL)]:
∀x (SubscribedTo(x, aMCAList) → EligibleForThreeFreeMovies(x))
∃x (CinemaEveryWeek(x))
∀x (Prefer(x, tVSeries) → ¬WatchTVIn(x, cinemas))
WatchTVIn(james, cinemas)
SubscribedTo(james, aMCAList)
Prefer(peter, tVSeries)

[PREMISE (GK)]:
! [X] : (SubscribedTo(X, aMCAList) => EligibleForThreeFreeMovies(X)).
? [X] : (CinemaEveryWeek(X)).
! [X] : (Prefer(X, tVSeries) => -WatchTVIn(X, cinemas)).
WatchTVIn(james, cinemas).
SubscribedTo(james, aMCAList).
Prefer(peter, tVSeries).

[CONCLUSION]:
James cannot watch 3 movies every week without any additional fees.

[CONCLUSION (FOL)]:
¬EligibleForThreeFreeMovies(james)

[CONCLUSION (GK)]:
-EligibleForThreeFreeMovies(james).


===

['x']
['x']
[PREMISE]:
If a customer subscribes to AMC A-List, then he/she can watch 3 movies every week without any additional fees. 
Some customers go to cinemas every week. 
Customers who prefer TV series will not watch TV series in cinemas.
James watches TV series in cinemas. 
James subscribes to AMC A-List.
Peter prefers TV series.

[PREMISE (FOL)]:
∀x (SubscribedTo(x, aMCAList) → EligibleForThreeFreeMovies(x))
∃x (CinemaEveryWeek(x))
∀x (Prefer(x, tVSeries) → ¬WatchTVIn(x, cinemas))
WatchTVIn(james, cinemas)
SubscribedTo(james, aMCAList)
Prefer(peter, tVSeries)

[PREMISE (GK)]:
! [X] : (SubscribedTo(X, aMCAList) => EligibleForThreeFreeMovies(X)).
? [X] : (CinemaEveryWeek(X)).
! [X] : (Prefer(X, tVSeries) => -WatchTVIn(X, cinemas)).
WatchTVIn(james, cinemas).
SubscribedTo(james, aMCAList).
Prefer(peter, tVSeries).

[CONCLUSION]:
James goes to cinemas every week.

[CONCLUSION (FOL)]:
CinemaEveryWeek(james)

[CONCLUSION (GK)]:
CinemaEveryWeek(james).


===

['x']
['x']
[PREMISE]:
If a customer subscribes to AMC A-List, then he/she can watch 3 movies every week without any additional fees. 
Some customers go to cinemas every week. 
Customers who prefer TV series will not watch TV series in cinemas.
James watches TV series in cinemas. 
James subscribes to AMC A-List.
Peter prefers TV series.

[PREMISE (FOL)]:
∀x (SubscribedTo(x, aMCAList) → EligibleForThreeFreeMovies(x))
∃x (CinemaEveryWeek(x))
∀x (Prefer(x, tVSeries) → ¬WatchTVIn(x, cinemas))
WatchTVIn(james, cinemas)
SubscribedTo(james, aMCAList)
Prefer(peter, tVSeries)

[PREMISE (GK)]:
! [X] : (SubscribedTo(X, aMCAList) => EligibleForThreeFreeMovies(X)).
? [X] : (CinemaEveryWeek(X)).
! [X] : (Prefer(X, tVSeries) => -WatchTVIn(X, cinemas)).
WatchTVIn(james, cinemas).
SubscribedTo(james, aMCAList).
Prefer(peter, tVSeries).

[CONCLUSION]:
Peter will not watch TV series in cinemas.

[CONCLUSION (FOL)]:
¬WatchTVIn(peter, cinemas)

[CONCLUSION (GK)]:
-WatchTVIn(peter, cinemas).


===

['x']
['x']
[PREMISE]:
Bulbophyllum attenuatum is in the genus Bulbophyllum.
All Bulbophyllum are orchids.

[PREMISE (FOL)]:
GenusBulbophyllum(bulbophyllumAttenuatum)
∀x (GenusBulbophyllum(x) → Orchid(x))

[PREMISE (GK)]:
GenusBulbophyllum(bulbophyllumAttenuatum).
! [X] : (GenusBulbophyllum(X) => Orchid(X)).

[CONCLUSION]:
Bulbophyllum attenuatum is not an orchid.

[CONCLUSION (FOL)]:
¬Orchid(bulbophyllumAttenuatum)

[CONCLUSION (GK)]:
-Orchid(bulbophyllumAttenuatum).


===

['x']
['x']
[PREMISE]:
There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian, and Far Eastern.
The Central federal district has the largest population among all federal districts in Russia.
Moscow is the administrative center of the Central federal district.
Yekaterinburg is the administrative center of the Ural federal district.
Vladivostok is the administrative center of the Far Eastern federal district.
The Far Eastern federal district has the largest area among all federal districts in Russia.
Some federal districts in Russia were established in 2000.

[PREMISE (FOL)]:
FederalDistrictOf(central, russia) ∧ FederalDistrictOf(northwestern, russia) ∧ FederalDistrictOf(southern, russia) ∧ FederalDistrictOf(northcaucasian, russia) ∧ FederalDistrictOf(volga, russia) ∧ FederalDistrictOf(ural, russia) ∧ FederalDistrictOf(siberian, russia) ∧ FederalDistrictOf(fareastern, russia)
LargestPopulation(central) 
AdministrativeCenterOf(moscow, central)
AdministrativeCenterOf(yekaterinburg, ural)
AdministrativeCenterOf(vladivostok, farEastern)
LargestArea(farEastern)
∃x (FederalDistrictOf(x, russia) ∧ EstablishedIn(x, 2000))

[PREMISE (GK)]:
FederalDistrictOf(central, russia) & FederalDistrictOf(northwestern, russia) & FederalDistrictOf(southern, russia) & FederalDistrictOf(northcaucasian, russia) & FederalDistrictOf(volga, russia) & FederalDistrictOf(ural, russia) & FederalDistrictOf(siberian, russia) & FederalDistrictOf(fareastern, russia).
LargestPopulation(central) .
AdministrativeCenterOf(moscow, central).
AdministrativeCenterOf(yekaterinburg, ural).
AdministrativeCenterOf(vladivostok, farEastern).
LargestArea(farEastern).
? [X] : (FederalDistrictOf(X, russia) & EstablishedIn(X, 2000)).

[CONCLUSION]:
Vladivostok is the administrative center of the federal district with the largest area.

[CONCLUSION (FOL)]:
∃x (AdministrativeCenterOf(vladivostok, x) ∧ LargestArea(x))

[CONCLUSION (GK)]:
? [X] : (AdministrativeCenterOf(vladivostok, X) & LargestArea(X)).


===

['x']
['x']
[PREMISE]:
There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian, and Far Eastern.
The Central federal district has the largest population among all federal districts in Russia.
Moscow is the administrative center of the Central federal district.
Yekaterinburg is the administrative center of the Ural federal district.
Vladivostok is the administrative center of the Far Eastern federal district.
The Far Eastern federal district has the largest area among all federal districts in Russia.
Some federal districts in Russia were established in 2000.

[PREMISE (FOL)]:
FederalDistrictOf(central, russia) ∧ FederalDistrictOf(northwestern, russia) ∧ FederalDistrictOf(southern, russia) ∧ FederalDistrictOf(northcaucasian, russia) ∧ FederalDistrictOf(volga, russia) ∧ FederalDistrictOf(ural, russia) ∧ FederalDistrictOf(siberian, russia) ∧ FederalDistrictOf(fareastern, russia)
LargestPopulation(central) 
AdministrativeCenterOf(moscow, central)
AdministrativeCenterOf(yekaterinburg, ural)
AdministrativeCenterOf(vladivostok, farEastern)
LargestArea(farEastern)
∃x (FederalDistrictOf(x, russia) ∧ EstablishedIn(x, 2000))

[PREMISE (GK)]:
FederalDistrictOf(central, russia) & FederalDistrictOf(northwestern, russia) & FederalDistrictOf(southern, russia) & FederalDistrictOf(northcaucasian, russia) & FederalDistrictOf(volga, russia) & FederalDistrictOf(ural, russia) & FederalDistrictOf(siberian, russia) & FederalDistrictOf(fareastern, russia).
LargestPopulation(central) .
AdministrativeCenterOf(moscow, central).
AdministrativeCenterOf(yekaterinburg, ural).
AdministrativeCenterOf(vladivostok, farEastern).
LargestArea(farEastern).
? [X] : (FederalDistrictOf(X, russia) & EstablishedIn(X, 2000)).

[CONCLUSION]:
Moscow is the administrative center of the federal district with the largest population.

[CONCLUSION (FOL)]:
∃x (AdministrativeCenterOf(moscow, x) ∧ LargestPopulationIn(x))

[CONCLUSION (GK)]:
? [X] : (AdministrativeCenterOf(moscow, X) & LargestPopulationIn(X)).


===

['x']
['x']
[PREMISE]:
There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian, and Far Eastern.
The Central federal district has the largest population among all federal districts in Russia.
Moscow is the administrative center of the Central federal district.
Yekaterinburg is the administrative center of the Ural federal district.
Vladivostok is the administrative center of the Far Eastern federal district.
The Far Eastern federal district has the largest area among all federal districts in Russia.
Some federal districts in Russia were established in 2000.

[PREMISE (FOL)]:
FederalDistrictOf(central, russia) ∧ FederalDistrictOf(northwestern, russia) ∧ FederalDistrictOf(southern, russia) ∧ FederalDistrictOf(northcaucasian, russia) ∧ FederalDistrictOf(volga, russia) ∧ FederalDistrictOf(ural, russia) ∧ FederalDistrictOf(siberian, russia) ∧ FederalDistrictOf(fareastern, russia)
LargestPopulation(central) 
AdministrativeCenterOf(moscow, central)
AdministrativeCenterOf(yekaterinburg, ural)
AdministrativeCenterOf(vladivostok, farEastern)
LargestArea(farEastern)
∃x (FederalDistrictOf(x, russia) ∧ EstablishedIn(x, 2000))

[PREMISE (GK)]:
FederalDistrictOf(central, russia) & FederalDistrictOf(northwestern, russia) & FederalDistrictOf(southern, russia) & FederalDistrictOf(northcaucasian, russia) & FederalDistrictOf(volga, russia) & FederalDistrictOf(ural, russia) & FederalDistrictOf(siberian, russia) & FederalDistrictOf(fareastern, russia).
LargestPopulation(central) .
AdministrativeCenterOf(moscow, central).
AdministrativeCenterOf(yekaterinburg, ural).
AdministrativeCenterOf(vladivostok, farEastern).
LargestArea(farEastern).
? [X] : (FederalDistrictOf(X, russia) & EstablishedIn(X, 2000)).

[CONCLUSION]:
The Northwestern federal district was established in 2000.

[CONCLUSION (FOL)]:
EstablishedIn(northwestern, 2000)

[CONCLUSION (GK)]:
EstablishedIn(northwestern, 2000).


===

['x']
['x']
[PREMISE]:
All cancers have mutations.
No mutations can be treated at home.
All colorectal cancers are cancers.
A cold can be treated at home.
Arthritis either is a cold and has mutations or neither is a cold nor has mutations.

[PREMISE (FOL)]:
∀x (Cancer(x) → Have(x, mutation))
∀x (Have(x, mutation) → ¬CanBeTreatedAtHome(x))
∀x (ColorectalCancer(x) → Cancer(x))
∀x (Cold(x) → CanBeTreatedAtHome(x))
¬(Cold(arthritis) ⊕ Have(arthritis, mutation))

[PREMISE (GK)]:
! [X] : (Cancer(X) => Have(X, mutation)).
! [X] : (Have(X, mutation) => -CanBeTreatedAtHome(X)).
! [X] : (ColorectalCancer(X) => Cancer(X)).
! [X] : (Cold(X) => CanBeTreatedAtHome(X)).
-(Cold(arthritis) <~> Have(arthritis, mutation)).

[CONCLUSION]:
Arthritis can be treated at home.

[CONCLUSION (FOL)]:
CanBeTreatedAtHome(arthritis)

[CONCLUSION (GK)]:
CanBeTreatedAtHome(arthritis).


===

['x']
['x']
[PREMISE]:
All cancers have mutations.
No mutations can be treated at home.
All colorectal cancers are cancers.
A cold can be treated at home.
Arthritis either is a cold and has mutations or neither is a cold nor has mutations.

[PREMISE (FOL)]:
∀x (Cancer(x) → Have(x, mutation))
∀x (Have(x, mutation) → ¬CanBeTreatedAtHome(x))
∀x (ColorectalCancer(x) → Cancer(x))
∀x (Cold(x) → CanBeTreatedAtHome(x))
¬(Cold(arthritis) ⊕ Have(arthritis, mutation))

[PREMISE (GK)]:
! [X] : (Cancer(X) => Have(X, mutation)).
! [X] : (Have(X, mutation) => -CanBeTreatedAtHome(X)).
! [X] : (ColorectalCancer(X) => Cancer(X)).
! [X] : (Cold(X) => CanBeTreatedAtHome(X)).
-(Cold(arthritis) <~> Have(arthritis, mutation)).

[CONCLUSION]:
Arthritis is colorectal cancer.

[CONCLUSION (FOL)]:
ColorectalCancer(arthritis)

[CONCLUSION (GK)]:
ColorectalCancer(arthritis).


===

['x']
['x']
[PREMISE]:
All cancers have mutations.
No mutations can be treated at home.
All colorectal cancers are cancers.
A cold can be treated at home.
Arthritis either is a cold and has mutations or neither is a cold nor has mutations.

[PREMISE (FOL)]:
∀x (Cancer(x) → Have(x, mutation))
∀x (Have(x, mutation) → ¬CanBeTreatedAtHome(x))
∀x (ColorectalCancer(x) → Cancer(x))
∀x (Cold(x) → CanBeTreatedAtHome(x))
¬(Cold(arthritis) ⊕ Have(arthritis, mutation))

[PREMISE (GK)]:
! [X] : (Cancer(X) => Have(X, mutation)).
! [X] : (Have(X, mutation) => -CanBeTreatedAtHome(X)).
! [X] : (ColorectalCancer(X) => Cancer(X)).
! [X] : (Cold(X) => CanBeTreatedAtHome(X)).
-(Cold(arthritis) <~> Have(arthritis, mutation)).

[CONCLUSION]:
Arthritis is not colorectal cancer.

[CONCLUSION (FOL)]:
¬ColorectalCancer(arthritis)

[CONCLUSION (GK)]:
-ColorectalCancer(arthritis).


===

['x']
['x']
[PREMISE]:
All cancers have mutations.
No mutations can be treated at home.
All colorectal cancers are cancers.
A cold can be treated at home.
Arthritis either is a cold and has mutations or neither is a cold nor has mutations.

[PREMISE (FOL)]:
∀x (Cancer(x) → Have(x, mutation))
∀x (Have(x, mutation) → ¬CanBeTreatedAtHome(x))
∀x (ColorectalCancer(x) → Cancer(x))
∀x (Cold(x) → CanBeTreatedAtHome(x))
¬(Cold(arthritis) ⊕ Have(arthritis, mutation))

[PREMISE (GK)]:
! [X] : (Cancer(X) => Have(X, mutation)).
! [X] : (Have(X, mutation) => -CanBeTreatedAtHome(X)).
! [X] : (ColorectalCancer(X) => Cancer(X)).
! [X] : (Cold(X) => CanBeTreatedAtHome(X)).
-(Cold(arthritis) <~> Have(arthritis, mutation)).

[CONCLUSION]:
Arthritis is colorectal cancer or has mutations.

[CONCLUSION (FOL)]:
ColorectalCancer(arthritis) ∨ Have(arthritis, mutation)

[CONCLUSION (GK)]:
ColorectalCancer(arthritis) | Have(arthritis, mutation).


===

['x']
['x']
[PREMISE]:
All cancers have mutations.
No mutations can be treated at home.
All colorectal cancers are cancers.
A cold can be treated at home.
Arthritis either is a cold and has mutations or neither is a cold nor has mutations.

[PREMISE (FOL)]:
∀x (Cancer(x) → Have(x, mutation))
∀x (Have(x, mutation) → ¬CanBeTreatedAtHome(x))
∀x (ColorectalCancer(x) → Cancer(x))
∀x (Cold(x) → CanBeTreatedAtHome(x))
¬(Cold(arthritis) ⊕ Have(arthritis, mutation))

[PREMISE (GK)]:
! [X] : (Cancer(X) => Have(X, mutation)).
! [X] : (Have(X, mutation) => -CanBeTreatedAtHome(X)).
! [X] : (ColorectalCancer(X) => Cancer(X)).
! [X] : (Cold(X) => CanBeTreatedAtHome(X)).
-(Cold(arthritis) <~> Have(arthritis, mutation)).

[CONCLUSION]:
Arthritis is colorectal cancer and a cancer.

[CONCLUSION (FOL)]:
ColorectalCancer(arthritisr) ∧ Cancer(arthritis)

[CONCLUSION (GK)]:
ColorectalCancer(arthritisr) & Cancer(arthritis).


===

['x']
['x']
[PREMISE]:
All cancers have mutations.
No mutations can be treated at home.
All colorectal cancers are cancers.
A cold can be treated at home.
Arthritis either is a cold and has mutations or neither is a cold nor has mutations.

[PREMISE (FOL)]:
∀x (Cancer(x) → Have(x, mutation))
∀x (Have(x, mutation) → ¬CanBeTreatedAtHome(x))
∀x (ColorectalCancer(x) → Cancer(x))
∀x (Cold(x) → CanBeTreatedAtHome(x))
¬(Cold(arthritis) ⊕ Have(arthritis, mutation))

[PREMISE (GK)]:
! [X] : (Cancer(X) => Have(X, mutation)).
! [X] : (Have(X, mutation) => -CanBeTreatedAtHome(X)).
! [X] : (ColorectalCancer(X) => Cancer(X)).
! [X] : (Cold(X) => CanBeTreatedAtHome(X)).
-(Cold(arthritis) <~> Have(arthritis, mutation)).

[CONCLUSION]:
If arthritis is not colorectal cancer, then arthritis has mutations.

[CONCLUSION (FOL)]:
¬ColorectalCancer(arthritis) → Have(arthritis, mutation)

[CONCLUSION (GK)]:
-ColorectalCancer(arthritis) => Have(arthritis, mutation).


===

['x']
['x']
[PREMISE]:
Jerry should not worry about things outside of his control.
All traffic is outside of my control.

[PREMISE (FOL)]:
∀x (OutsideOfControl(x) → ¬ShouldWorry(jerry, x))
∀x (Traffic(x) → OutsideControl(x))

[PREMISE (GK)]:
! [X] : (OutsideOfControl(X) => -ShouldWorry(jerry, X)).
! [X] : (Traffic(X) => OutsideControl(X)).

[CONCLUSION]:
Jerry should not worry about traffic.

[CONCLUSION (FOL)]:
¬ShouldWorry(jerry, traffic)

[CONCLUSION (GK)]:
-ShouldWorry(jerry, traffic).


===

['x']
['x']
[PREMISE]:
Roversi is an Italian surname.
Alba Roversi uses Roversi as a surname.
Paolo Roversi uses Roversi as a surname.
Roberto Roversi uses Roversi as a surname.
Paolo Roversi is a photographer.
A photographer is a professional or an amateur.

[PREMISE (FOL)]:
ItalianName(roversi) ∧ Surname(roversi)
UseAsSurname(albaRoversi, roversi)
UseAsSurname(paoloRoversi, roversi)
UseAsSurname(robertoRoversi, roversi)
Photographer(paoloRoversi)
∀x (Photographer(x) → Professional(x) ⊕ Amateur(x))

[PREMISE (GK)]:
ItalianName(roversi) & Surname(roversi).
UseAsSurname(albaRoversi, roversi).
UseAsSurname(paoloRoversi, roversi).
UseAsSurname(robertoRoversi, roversi).
Photographer(paoloRoversi).
! [X] : (Photographer(X) => Professional(X) <~> Amateur(X)).

[CONCLUSION]:
Alba Roversi uses an Italian surname.

[CONCLUSION (FOL)]:
∃x (ItalianName(x) ∧ Surname(x) ∧ UseAsSurname(albaRoversi, x))

[CONCLUSION (GK)]:
? [X] : (ItalianName(X) & Surname(X) & UseAsSurname(albaRoversi, X)).


===

['x']
['x', 'y']
[PREMISE]:
Roversi is an Italian surname.
Alba Roversi uses Roversi as a surname.
Paolo Roversi uses Roversi as a surname.
Roberto Roversi uses Roversi as a surname.
Paolo Roversi is a photographer.
A photographer is a professional or an amateur.

[PREMISE (FOL)]:
ItalianName(roversi) ∧ Surname(roversi)
UseAsSurname(albaRoversi, roversi)
UseAsSurname(paoloRoversi, roversi)
UseAsSurname(robertoRoversi, roversi)
Photographer(paoloRoversi)
∀x (Photographer(x) → Professional(x) ⊕ Amateur(x))

[PREMISE (GK)]:
ItalianName(roversi) & Surname(roversi).
UseAsSurname(albaRoversi, roversi).
UseAsSurname(paoloRoversi, roversi).
UseAsSurname(robertoRoversi, roversi).
Photographer(paoloRoversi).
! [X] : (Photographer(X) => Professional(X) <~> Amateur(X)).

[CONCLUSION]:
There are no photographers using an Italian surname.

[CONCLUSION (FOL)]:
¬(∃x ∃y (Photographer(x) ∧ ItalianName(y) ∧ Surname(y) ∧ UseAsSurname(x, y)))

[CONCLUSION (GK)]:
-(? [X] : ? [Y] : (Photographer(X) & ItalianName(Y) & Surname(Y) & UseAsSurname(X, Y))).


===

['x']
['x']
[PREMISE]:
Roversi is an Italian surname.
Alba Roversi uses Roversi as a surname.
Paolo Roversi uses Roversi as a surname.
Roberto Roversi uses Roversi as a surname.
Paolo Roversi is a photographer.
A photographer is a professional or an amateur.

[PREMISE (FOL)]:
ItalianName(roversi) ∧ Surname(roversi)
UseAsSurname(albaRoversi, roversi)
UseAsSurname(paoloRoversi, roversi)
UseAsSurname(robertoRoversi, roversi)
Photographer(paoloRoversi)
∀x (Photographer(x) → Professional(x) ⊕ Amateur(x))

[PREMISE (GK)]:
ItalianName(roversi) & Surname(roversi).
UseAsSurname(albaRoversi, roversi).
UseAsSurname(paoloRoversi, roversi).
UseAsSurname(robertoRoversi, roversi).
Photographer(paoloRoversi).
! [X] : (Photographer(X) => Professional(X) <~> Amateur(X)).

[CONCLUSION]:
Paolo is an amateur photographer.

[CONCLUSION (FOL)]:
Amateur(paoloRoversi) ∧ Photographer(paoloRoversi)

[CONCLUSION (GK)]:
Amateur(paoloRoversi) & Photographer(paoloRoversi).


===

[]
[]
[PREMISE]:
Zaha Hadid is a British-Iraqi architect, artist, and designer.
Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.
Zaha Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.
Max is an aspiring architecture student and plans to apply to the Yale School of Architecture. 

[PREMISE (FOL)]:
British-Iraqi(zahaHadid) ∧ Architect(zahaHadid) ∧ Artist(zahaHadid) ∧ Designer(zahaHadid)
BornOn(zahaHadid, 31October1950) ∧ BornIn(zahaHadid, baghdadIraq)
VisitingProfessorOf(zahaHadid, architecturalDesign) ∧ VisitingProfessorAt(zahaHadid, yaleSchoolOfArchitecture)
AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)

[PREMISE (GK)]:
British-Iraqi(zahaHadid) & Architect(zahaHadid) & Artist(zahaHadid) & Designer(zahaHadid).
BornOn(zahaHadid, 31October1950) & BornIn(zahaHadid, baghdadIraq).
VisitingProfessorOf(zahaHadid, architecturalDesign) & VisitingProfessorAt(zahaHadid, yaleSchoolOfArchitecture).
AspiringArchitectureStudent(max) & PlansToApplyTo(max, yaleSchoolofArchitecture).

[CONCLUSION]:
Zaha Hadid was a citizen of Britain and Iraq.

[CONCLUSION (FOL)]:
British-Iraqi(zahaHadid)

[CONCLUSION (GK)]:
British-Iraqi(zahaHadid).


===

[]
[]
[PREMISE]:
Zaha Hadid is a British-Iraqi architect, artist, and designer.
Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.
Zaha Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.
Max is an aspiring architecture student and plans to apply to the Yale School of Architecture. 

[PREMISE (FOL)]:
British-Iraqi(zahaHadid) ∧ Architect(zahaHadid) ∧ Artist(zahaHadid) ∧ Designer(zahaHadid)
BornOn(zahaHadid, 31October1950) ∧ BornIn(zahaHadid, baghdadIraq)
VisitingProfessorOf(zahaHadid, architecturalDesign) ∧ VisitingProfessorAt(zahaHadid, yaleSchoolOfArchitecture)
AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)

[PREMISE (GK)]:
British-Iraqi(zahaHadid) & Architect(zahaHadid) & Artist(zahaHadid) & Designer(zahaHadid).
BornOn(zahaHadid, 31October1950) & BornIn(zahaHadid, baghdadIraq).
VisitingProfessorOf(zahaHadid, architecturalDesign) & VisitingProfessorAt(zahaHadid, yaleSchoolOfArchitecture).
AspiringArchitectureStudent(max) & PlansToApplyTo(max, yaleSchoolofArchitecture).

[CONCLUSION]:
Zaha Hadid did some work in interior design.

[CONCLUSION (FOL)]:
DidWorkIn(zahaHadid, interiorDesign)

[CONCLUSION (GK)]:
DidWorkIn(zahaHadid, interiorDesign).


===

[]
[]
[PREMISE]:
Zaha Hadid is a British-Iraqi architect, artist, and designer.
Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.
Zaha Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.
Max is an aspiring architecture student and plans to apply to the Yale School of Architecture. 

[PREMISE (FOL)]:
British-Iraqi(zahaHadid) ∧ Architect(zahaHadid) ∧ Artist(zahaHadid) ∧ Designer(zahaHadid)
BornOn(zahaHadid, 31October1950) ∧ BornIn(zahaHadid, baghdadIraq)
VisitingProfessorOf(zahaHadid, architecturalDesign) ∧ VisitingProfessorAt(zahaHadid, yaleSchoolOfArchitecture)
AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)

[PREMISE (GK)]:
British-Iraqi(zahaHadid) & Architect(zahaHadid) & Artist(zahaHadid) & Designer(zahaHadid).
BornOn(zahaHadid, 31October1950) & BornIn(zahaHadid, baghdadIraq).
VisitingProfessorOf(zahaHadid, architecturalDesign) & VisitingProfessorAt(zahaHadid, yaleSchoolOfArchitecture).
AspiringArchitectureStudent(max) & PlansToApplyTo(max, yaleSchoolofArchitecture).

[CONCLUSION]:
Zaha Hadid was born on the 31st of October in 1982.

[CONCLUSION (FOL)]:
BornOn(zahaHadid, 31October1950)

[CONCLUSION (GK)]:
BornOn(zahaHadid, 31October1950).


===

[]
[]
[PREMISE]:
Zaha Hadid is a British-Iraqi architect, artist, and designer.
Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.
Zaha Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.
Max is an aspiring architecture student and plans to apply to the Yale School of Architecture. 

[PREMISE (FOL)]:
British-Iraqi(zahaHadid) ∧ Architect(zahaHadid) ∧ Artist(zahaHadid) ∧ Designer(zahaHadid)
BornOn(zahaHadid, 31October1950) ∧ BornIn(zahaHadid, baghdadIraq)
VisitingProfessorOf(zahaHadid, architecturalDesign) ∧ VisitingProfessorAt(zahaHadid, yaleSchoolOfArchitecture)
AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)

[PREMISE (GK)]:
British-Iraqi(zahaHadid) & Architect(zahaHadid) & Artist(zahaHadid) & Designer(zahaHadid).
BornOn(zahaHadid, 31October1950) & BornIn(zahaHadid, baghdadIraq).
VisitingProfessorOf(zahaHadid, architecturalDesign) & VisitingProfessorAt(zahaHadid, yaleSchoolOfArchitecture).
AspiringArchitectureStudent(max) & PlansToApplyTo(max, yaleSchoolofArchitecture).

[CONCLUSION]:
Max admires Zaha Hadid.

[CONCLUSION (FOL)]:
Admires(max, zahaHadid)

[CONCLUSION (GK)]:
Admires(max, zahaHadid).


===

['x']
['x']
[PREMISE]:
A neuroimaging technique is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. 
All noninvasive neuroimaging techniques provide a spatial resolution of brains.
If a technique provides a spatial resolution of brains, then it is a measurement of brain activity. 
All measurements of brain activity are used by neuroscience researchers.
FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.
FMRI is a neuroimaging technique.

[PREMISE (FOL)]:
∀x (NeuroimagingTechnique(x) → (Invasive(x) ⊕ Noninvasive(x))) 
∀x (Noninvasive(x) → Provides(x, spatialResolutionOfBrains))
∀x (Provides(x, spatialResolutionOfBrains) → Measure(x, brainActivity))
∀x (Measure(x, brainActivity) → UsedBy(x, neuroscienceResearchers))
Measure(fMRI, brainActivity) ⊕ Noninvasive(fMRI)
NeuroimagingTechnique(fMRI)

[PREMISE (GK)]:
! [X] : (NeuroimagingTechnique(X) => (Invasive(X) <~> Noninvasive(X))) .
! [X] : (Noninvasive(X) => Provides(X, spatialResolutionOfBrains)).
! [X] : (Provides(X, spatialResolutionOfBrains) => Measure(X, brainActivity)).
! [X] : (Measure(X, brainActivity) => UsedBy(X, neuroscienceResearchers)).
Measure(fMRI, brainActivity) <~> Noninvasive(fMRI).
NeuroimagingTechnique(fMRI).

[CONCLUSION]:
FMRI provides a spatial resolution of brains.

[CONCLUSION (FOL)]:
Provides(fMRI, spatialResolutionOfBrains)

[CONCLUSION (GK)]:
Provides(fMRI, spatialResolutionOfBrains).


===

['x']
['x']
[PREMISE]:
A neuroimaging technique is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. 
All noninvasive neuroimaging techniques provide a spatial resolution of brains.
If a technique provides a spatial resolution of brains, then it is a measurement of brain activity. 
All measurements of brain activity are used by neuroscience researchers.
FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.
FMRI is a neuroimaging technique.

[PREMISE (FOL)]:
∀x (NeuroimagingTechnique(x) → (Invasive(x) ⊕ Noninvasive(x))) 
∀x (Noninvasive(x) → Provides(x, spatialResolutionOfBrains))
∀x (Provides(x, spatialResolutionOfBrains) → Measure(x, brainActivity))
∀x (Measure(x, brainActivity) → UsedBy(x, neuroscienceResearchers))
Measure(fMRI, brainActivity) ⊕ Noninvasive(fMRI)
NeuroimagingTechnique(fMRI)

[PREMISE (GK)]:
! [X] : (NeuroimagingTechnique(X) => (Invasive(X) <~> Noninvasive(X))) .
! [X] : (Noninvasive(X) => Provides(X, spatialResolutionOfBrains)).
! [X] : (Provides(X, spatialResolutionOfBrains) => Measure(X, brainActivity)).
! [X] : (Measure(X, brainActivity) => UsedBy(X, neuroscienceResearchers)).
Measure(fMRI, brainActivity) <~> Noninvasive(fMRI).
NeuroimagingTechnique(fMRI).

[CONCLUSION]:
FMRI is an invasive neuroimaging technique and is used by neuroscience researchers.

[CONCLUSION (FOL)]:
Invasive(fMRI) ∧ UsedBy(fMRI, neuroscienceResearchers)

[CONCLUSION (GK)]:
Invasive(fMRI) & UsedBy(fMRI, neuroscienceResearchers).


===

['x']
['x']
[PREMISE]:
A neuroimaging technique is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. 
All noninvasive neuroimaging techniques provide a spatial resolution of brains.
If a technique provides a spatial resolution of brains, then it is a measurement of brain activity. 
All measurements of brain activity are used by neuroscience researchers.
FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.
FMRI is a neuroimaging technique.

[PREMISE (FOL)]:
∀x (NeuroimagingTechnique(x) → (Invasive(x) ⊕ Noninvasive(x))) 
∀x (Noninvasive(x) → Provides(x, spatialResolutionOfBrains))
∀x (Provides(x, spatialResolutionOfBrains) → Measure(x, brainActivity))
∀x (Measure(x, brainActivity) → UsedBy(x, neuroscienceResearchers))
Measure(fMRI, brainActivity) ⊕ Noninvasive(fMRI)
NeuroimagingTechnique(fMRI)

[PREMISE (GK)]:
! [X] : (NeuroimagingTechnique(X) => (Invasive(X) <~> Noninvasive(X))) .
! [X] : (Noninvasive(X) => Provides(X, spatialResolutionOfBrains)).
! [X] : (Provides(X, spatialResolutionOfBrains) => Measure(X, brainActivity)).
! [X] : (Measure(X, brainActivity) => UsedBy(X, neuroscienceResearchers)).
Measure(fMRI, brainActivity) <~> Noninvasive(fMRI).
NeuroimagingTechnique(fMRI).

[CONCLUSION]:
FMRI is either an invasive neuroimaging technique or is used by neuroscience researchers.

[CONCLUSION (FOL)]:
Invasive(fMRI) ⊕ UsedBy(fMRI, neuroscienceResearchers)

[CONCLUSION (GK)]:
Invasive(fMRI) <~> UsedBy(fMRI, neuroscienceResearchers).


===

['x']
['x']
[PREMISE]:
A neuroimaging technique is either an invasive neuroimaging technique or a noninvasive neuroimaging technique. 
All noninvasive neuroimaging techniques provide a spatial resolution of brains.
If a technique provides a spatial resolution of brains, then it is a measurement of brain activity. 
All measurements of brain activity are used by neuroscience researchers.
FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.
FMRI is a neuroimaging technique.

[PREMISE (FOL)]:
∀x (NeuroimagingTechnique(x) → (Invasive(x) ⊕ Noninvasive(x))) 
∀x (Noninvasive(x) → Provides(x, spatialResolutionOfBrains))
∀x (Provides(x, spatialResolutionOfBrains) → Measure(x, brainActivity))
∀x (Measure(x, brainActivity) → UsedBy(x, neuroscienceResearchers))
Measure(fMRI, brainActivity) ⊕ Noninvasive(fMRI)
NeuroimagingTechnique(fMRI)

[PREMISE (GK)]:
! [X] : (NeuroimagingTechnique(X) => (Invasive(X) <~> Noninvasive(X))) .
! [X] : (Noninvasive(X) => Provides(X, spatialResolutionOfBrains)).
! [X] : (Provides(X, spatialResolutionOfBrains) => Measure(X, brainActivity)).
! [X] : (Measure(X, brainActivity) => UsedBy(X, neuroscienceResearchers)).
Measure(fMRI, brainActivity) <~> Noninvasive(fMRI).
NeuroimagingTechnique(fMRI).

[CONCLUSION]:
If fMRI is not an invasive neuroimaging technique used by neuroscience researchers, then fMRI is neither a noninvasive neuroimaging technique nor provides a spatial resolution of brains.

[CONCLUSION (FOL)]:
¬(Invasive(fMRI) ∧ UsedBy(fMRI, neuroscienceResearchers)) → ¬(Noninvasive(fMRI) ∨ Provides(fMRI, spatialResolutionOfBrains))

[CONCLUSION (GK)]:
-(Invasive(fMRI) & UsedBy(fMRI, neuroscienceResearchers)) => -(Noninvasive(fMRI) | Provides(fMRI, spatialResolutionOfBrains)).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Researchers present their work at the conference or provide a tutorial session there.
Everyone who presents their work at the conference will attend in person. 
Everyone providing a tutorial session at the conference will be invited to join the club. 
Everyone who attends the conference in person is provided with souvenirs. 
Everyone invited to join the club is provided with delicious meals. 
Everyone provided with delicious meals is happy to communicate with each other during the dinner. 
Everyone who is provided with delicious meals is invited to take a photo with the audience. 
It is not true that James both attended the conference in person and was provided with souvenirs.

[PREMISE (FOL)]:
∀x (PresentWorkAt(x, conference) ⊕ ProvideAt(x, tutorialSession, conference))
∀x (PresentWorkAt(x, conference) → AttendInPerson(x, conference))
∀x (ProvideSessionAt(x, tutorial, conference) → InvitedToJoin(x, club))
∀x (AttendInPerson(x, conference) → ProvidedWith(x, souvenir))
∀x (InvitedToJoin(x, club) → ProvidedWith(x, deliciousMeal))
∀x (ProvidedWith(x, deliciousMeal) ∧ ProvidedWith(y, deliciousMeal)  → ∃y ∃z (¬(y=x) ∧ ¬(z=x) ∧ ¬(y=z) ∧ HappyToCommunicateWithDuringTheDinner(x, y) ∧ HappyToCommunicateWithDuringTheDinner(x, z)))
∀x (ProvidedWith(x, deliciousMeal) → InvitedToTakePhotoWith(x, audience))
¬(AttendInPerson(james, conference) ∧ ProvidedWith(x, souvenir))

[PREMISE (GK)]:
! [X] : (PresentWorkAt(X, conference) <~> ProvideAt(X, tutorialSession, conference)).
! [X] : (PresentWorkAt(X, conference) => AttendInPerson(X, conference)).
! [X] : (ProvideSessionAt(X, tutorial, conference) => InvitedToJoin(X, club)).
! [X] : (AttendInPerson(X, conference) => ProvidedWith(X, souvenir)).
! [X] : (InvitedToJoin(X, club) => ProvidedWith(X, deliciousMeal)).
! [X] : (ProvidedWith(X, deliciousMeal) & ProvidedWith(Y, deliciousMeal)  => ? [Y] : ? [Z] : (-(Y=X) & -(Z=X) & -(Y=Z) & HappyToCommunicateWithDuringTheDinner(X, Y) & HappyToCommunicateWithDuringTheDinner(X, Z))).
! [X] : (ProvidedWith(X, deliciousMeal) => InvitedToTakePhotoWith(X, audience)).
-(AttendInPerson(james, conference) & ProvidedWith(x, souvenir)).

[CONCLUSION]:
James is provided with souvenirs.

[CONCLUSION (FOL)]:
ProvidedWith(james, souvenir)

[CONCLUSION (GK)]:
ProvidedWith(james, souvenir).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Researchers present their work at the conference or provide a tutorial session there.
Everyone who presents their work at the conference will attend in person. 
Everyone providing a tutorial session at the conference will be invited to join the club. 
Everyone who attends the conference in person is provided with souvenirs. 
Everyone invited to join the club is provided with delicious meals. 
Everyone provided with delicious meals is happy to communicate with each other during the dinner. 
Everyone who is provided with delicious meals is invited to take a photo with the audience. 
It is not true that James both attended the conference in person and was provided with souvenirs.

[PREMISE (FOL)]:
∀x (PresentWorkAt(x, conference) ⊕ ProvideAt(x, tutorialSession, conference))
∀x (PresentWorkAt(x, conference) → AttendInPerson(x, conference))
∀x (ProvideSessionAt(x, tutorial, conference) → InvitedToJoin(x, club))
∀x (AttendInPerson(x, conference) → ProvidedWith(x, souvenir))
∀x (InvitedToJoin(x, club) → ProvidedWith(x, deliciousMeal))
∀x (ProvidedWith(x, deliciousMeal) ∧ ProvidedWith(y, deliciousMeal)  → ∃y ∃z (¬(y=x) ∧ ¬(z=x) ∧ ¬(y=z) ∧ HappyToCommunicateWithDuringTheDinner(x, y) ∧ HappyToCommunicateWithDuringTheDinner(x, z)))
∀x (ProvidedWith(x, deliciousMeal) → InvitedToTakePhotoWith(x, audience))
¬(AttendInPerson(james, conference) ∧ ProvidedWith(x, souvenir))

[PREMISE (GK)]:
! [X] : (PresentWorkAt(X, conference) <~> ProvideAt(X, tutorialSession, conference)).
! [X] : (PresentWorkAt(X, conference) => AttendInPerson(X, conference)).
! [X] : (ProvideSessionAt(X, tutorial, conference) => InvitedToJoin(X, club)).
! [X] : (AttendInPerson(X, conference) => ProvidedWith(X, souvenir)).
! [X] : (InvitedToJoin(X, club) => ProvidedWith(X, deliciousMeal)).
! [X] : (ProvidedWith(X, deliciousMeal) & ProvidedWith(Y, deliciousMeal)  => ? [Y] : ? [Z] : (-(Y=X) & -(Z=X) & -(Y=Z) & HappyToCommunicateWithDuringTheDinner(X, Y) & HappyToCommunicateWithDuringTheDinner(X, Z))).
! [X] : (ProvidedWith(X, deliciousMeal) => InvitedToTakePhotoWith(X, audience)).
-(AttendInPerson(james, conference) & ProvidedWith(x, souvenir)).

[CONCLUSION]:
James is not provided with souvenirs.

[CONCLUSION (FOL)]:
¬ProvidedWith(x, souvenir)

[CONCLUSION (GK)]:
-ProvidedWith(X, souvenir).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Researchers present their work at the conference or provide a tutorial session there.
Everyone who presents their work at the conference will attend in person. 
Everyone providing a tutorial session at the conference will be invited to join the club. 
Everyone who attends the conference in person is provided with souvenirs. 
Everyone invited to join the club is provided with delicious meals. 
Everyone provided with delicious meals is happy to communicate with each other during the dinner. 
Everyone who is provided with delicious meals is invited to take a photo with the audience. 
It is not true that James both attended the conference in person and was provided with souvenirs.

[PREMISE (FOL)]:
∀x (PresentWorkAt(x, conference) ⊕ ProvideAt(x, tutorialSession, conference))
∀x (PresentWorkAt(x, conference) → AttendInPerson(x, conference))
∀x (ProvideSessionAt(x, tutorial, conference) → InvitedToJoin(x, club))
∀x (AttendInPerson(x, conference) → ProvidedWith(x, souvenir))
∀x (InvitedToJoin(x, club) → ProvidedWith(x, deliciousMeal))
∀x (ProvidedWith(x, deliciousMeal) ∧ ProvidedWith(y, deliciousMeal)  → ∃y ∃z (¬(y=x) ∧ ¬(z=x) ∧ ¬(y=z) ∧ HappyToCommunicateWithDuringTheDinner(x, y) ∧ HappyToCommunicateWithDuringTheDinner(x, z)))
∀x (ProvidedWith(x, deliciousMeal) → InvitedToTakePhotoWith(x, audience))
¬(AttendInPerson(james, conference) ∧ ProvidedWith(x, souvenir))

[PREMISE (GK)]:
! [X] : (PresentWorkAt(X, conference) <~> ProvideAt(X, tutorialSession, conference)).
! [X] : (PresentWorkAt(X, conference) => AttendInPerson(X, conference)).
! [X] : (ProvideSessionAt(X, tutorial, conference) => InvitedToJoin(X, club)).
! [X] : (AttendInPerson(X, conference) => ProvidedWith(X, souvenir)).
! [X] : (InvitedToJoin(X, club) => ProvidedWith(X, deliciousMeal)).
! [X] : (ProvidedWith(X, deliciousMeal) & ProvidedWith(Y, deliciousMeal)  => ? [Y] : ? [Z] : (-(Y=X) & -(Z=X) & -(Y=Z) & HappyToCommunicateWithDuringTheDinner(X, Y) & HappyToCommunicateWithDuringTheDinner(X, Z))).
! [X] : (ProvidedWith(X, deliciousMeal) => InvitedToTakePhotoWith(X, audience)).
-(AttendInPerson(james, conference) & ProvidedWith(x, souvenir)).

[CONCLUSION]:
James is invited to take a photo with the audience and is happy to communicate with other guests at the dinner.

[CONCLUSION (FOL)]:
InvitedToTakePhotoWith(james, audience) → ∃y ∃z (¬(y=james) ∧ ¬(z=james) ∧ ¬(y=z) ∧ HappyToCommunicateWithDuringTheDinner(james, y) ∧ HappyToCommunicateWithDuringDinner(james, z)))

[CONCLUSION (GK)]:
InvitedToTakePhotoWith(james, audience) => ? [Y] : ? [Z] : (-(Y=james) & -(Z=james) & -(Y=Z) & HappyToCommunicateWithDuringTheDinner(james, Y) & HappyToCommunicateWithDuringDinner(james, Z))).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Researchers present their work at the conference or provide a tutorial session there.
Everyone who presents their work at the conference will attend in person. 
Everyone providing a tutorial session at the conference will be invited to join the club. 
Everyone who attends the conference in person is provided with souvenirs. 
Everyone invited to join the club is provided with delicious meals. 
Everyone provided with delicious meals is happy to communicate with each other during the dinner. 
Everyone who is provided with delicious meals is invited to take a photo with the audience. 
It is not true that James both attended the conference in person and was provided with souvenirs.

[PREMISE (FOL)]:
∀x (PresentWorkAt(x, conference) ⊕ ProvideAt(x, tutorialSession, conference))
∀x (PresentWorkAt(x, conference) → AttendInPerson(x, conference))
∀x (ProvideSessionAt(x, tutorial, conference) → InvitedToJoin(x, club))
∀x (AttendInPerson(x, conference) → ProvidedWith(x, souvenir))
∀x (InvitedToJoin(x, club) → ProvidedWith(x, deliciousMeal))
∀x (ProvidedWith(x, deliciousMeal) ∧ ProvidedWith(y, deliciousMeal)  → ∃y ∃z (¬(y=x) ∧ ¬(z=x) ∧ ¬(y=z) ∧ HappyToCommunicateWithDuringTheDinner(x, y) ∧ HappyToCommunicateWithDuringTheDinner(x, z)))
∀x (ProvidedWith(x, deliciousMeal) → InvitedToTakePhotoWith(x, audience))
¬(AttendInPerson(james, conference) ∧ ProvidedWith(x, souvenir))

[PREMISE (GK)]:
! [X] : (PresentWorkAt(X, conference) <~> ProvideAt(X, tutorialSession, conference)).
! [X] : (PresentWorkAt(X, conference) => AttendInPerson(X, conference)).
! [X] : (ProvideSessionAt(X, tutorial, conference) => InvitedToJoin(X, club)).
! [X] : (AttendInPerson(X, conference) => ProvidedWith(X, souvenir)).
! [X] : (InvitedToJoin(X, club) => ProvidedWith(X, deliciousMeal)).
! [X] : (ProvidedWith(X, deliciousMeal) & ProvidedWith(Y, deliciousMeal)  => ? [Y] : ? [Z] : (-(Y=X) & -(Z=X) & -(Y=Z) & HappyToCommunicateWithDuringTheDinner(X, Y) & HappyToCommunicateWithDuringTheDinner(X, Z))).
! [X] : (ProvidedWith(X, deliciousMeal) => InvitedToTakePhotoWith(X, audience)).
-(AttendInPerson(james, conference) & ProvidedWith(x, souvenir)).

[CONCLUSION]:
James is invited to take a photo with the audience or is happy to communicate with other guests(?) during the dinner.

[CONCLUSION (FOL)]:
InvitedToTakePhotoWith(james, audience) → ∃y ∃z (¬(y=james) ∧ ¬(z=james) ∧ ¬(y=z) ∧ HappyToCommunicateWithDuringTheDinner(james, y) ∧ HappyToCommunicateWithDuringDinner(james, z)))

[CONCLUSION (GK)]:
InvitedToTakePhotoWith(james, audience) => ? [Y] : ? [Z] : (-(Y=james) & -(Z=james) & -(Y=Z) & HappyToCommunicateWithDuringTheDinner(james, Y) & HappyToCommunicateWithDuringDinner(james, Z))).


===

['x', 'y', 'z']
['x', 'y', 'z']
[PREMISE]:
Researchers present their work at the conference or provide a tutorial session there.
Everyone who presents their work at the conference will attend in person. 
Everyone providing a tutorial session at the conference will be invited to join the club. 
Everyone who attends the conference in person is provided with souvenirs. 
Everyone invited to join the club is provided with delicious meals. 
Everyone provided with delicious meals is happy to communicate with each other during the dinner. 
Everyone who is provided with delicious meals is invited to take a photo with the audience. 
It is not true that James both attended the conference in person and was provided with souvenirs.

[PREMISE (FOL)]:
∀x (PresentWorkAt(x, conference) ⊕ ProvideAt(x, tutorialSession, conference))
∀x (PresentWorkAt(x, conference) → AttendInPerson(x, conference))
∀x (ProvideSessionAt(x, tutorial, conference) → InvitedToJoin(x, club))
∀x (AttendInPerson(x, conference) → ProvidedWith(x, souvenir))
∀x (InvitedToJoin(x, club) → ProvidedWith(x, deliciousMeal))
∀x (ProvidedWith(x, deliciousMeal) ∧ ProvidedWith(y, deliciousMeal)  → ∃y ∃z (¬(y=x) ∧ ¬(z=x) ∧ ¬(y=z) ∧ HappyToCommunicateWithDuringTheDinner(x, y) ∧ HappyToCommunicateWithDuringTheDinner(x, z)))
∀x (ProvidedWith(x, deliciousMeal) → InvitedToTakePhotoWith(x, audience))
¬(AttendInPerson(james, conference) ∧ ProvidedWith(x, souvenir))

[PREMISE (GK)]:
! [X] : (PresentWorkAt(X, conference) <~> ProvideAt(X, tutorialSession, conference)).
! [X] : (PresentWorkAt(X, conference) => AttendInPerson(X, conference)).
! [X] : (ProvideSessionAt(X, tutorial, conference) => InvitedToJoin(X, club)).
! [X] : (AttendInPerson(X, conference) => ProvidedWith(X, souvenir)).
! [X] : (InvitedToJoin(X, club) => ProvidedWith(X, deliciousMeal)).
! [X] : (ProvidedWith(X, deliciousMeal) & ProvidedWith(Y, deliciousMeal)  => ? [Y] : ? [Z] : (-(Y=X) & -(Z=X) & -(Y=Z) & HappyToCommunicateWithDuringTheDinner(X, Y) & HappyToCommunicateWithDuringTheDinner(X, Z))).
! [X] : (ProvidedWith(X, deliciousMeal) => InvitedToTakePhotoWith(X, audience)).
-(AttendInPerson(james, conference) & ProvidedWith(x, souvenir)).

[CONCLUSION]:
James is either invited to take a photo with the audience or happy to communicate with other guests(?) during the dinner.

[CONCLUSION (FOL)]:
InvitedToTakePhotoWith(james, audience) → ∃y ∃z (¬(y=james) ∧ ¬(z=james) ∧ ¬(y=z) ∧ HappyToCommunicateWithDuringTheDinner(james, y) ∧ HappyToCommunicateWithDuringDinner(james, z)))

[CONCLUSION (GK)]:
InvitedToTakePhotoWith(james, audience) => ? [Y] : ? [Z] : (-(Y=james) & -(Z=james) & -(Y=Z) & HappyToCommunicateWithDuringTheDinner(james, Y) & HappyToCommunicateWithDuringDinner(james, Z))).


===

['x']
['x']
[PREMISE]:
The USS Salem is a heavy cruiser built for the United States Navy.
The last heavy cruiser to enter service was the USS Salem.
The USS Salem is a museum ship.
Museum ships are open to the public.
The USS Salem served in the Atlantic and Mediterranean.

[PREMISE (FOL)]:
HeavyCruiser(usssalem) ∧ BuiltFor(usssalem, unitedstatesnavy)
LastHeavyCruiserToEnterService(usssalem)
MuseumShip(usssalem)
∀x (MuseumShip(x) → OpenToPublic(x))
ServedIn(usssalem, atlantic) ∧ ServedIn(usssalem, mediterranean)

[PREMISE (GK)]:
HeavyCruiser(usssalem) & BuiltFor(usssalem, unitedstatesnavy).
LastHeavyCruiserToEnterService(usssalem).
MuseumShip(usssalem).
! [X] : (MuseumShip(X) => OpenToPublic(X)).
ServedIn(usssalem, atlantic) & ServedIn(usssalem, mediterranean).

[CONCLUSION]:
The USS Salem is open to the public.

[CONCLUSION (FOL)]:
OpenToPublic(usssalem)

[CONCLUSION (GK)]:
OpenToPublic(usssalem).


===

['x']
['x']
[PREMISE]:
The USS Salem is a heavy cruiser built for the United States Navy.
The last heavy cruiser to enter service was the USS Salem.
The USS Salem is a museum ship.
Museum ships are open to the public.
The USS Salem served in the Atlantic and Mediterranean.

[PREMISE (FOL)]:
HeavyCruiser(usssalem) ∧ BuiltFor(usssalem, unitedstatesnavy)
LastHeavyCruiserToEnterService(usssalem)
MuseumShip(usssalem)
∀x (MuseumShip(x) → OpenToPublic(x))
ServedIn(usssalem, atlantic) ∧ ServedIn(usssalem, mediterranean)

[PREMISE (GK)]:
HeavyCruiser(usssalem) & BuiltFor(usssalem, unitedstatesnavy).
LastHeavyCruiserToEnterService(usssalem).
MuseumShip(usssalem).
! [X] : (MuseumShip(X) => OpenToPublic(X)).
ServedIn(usssalem, atlantic) & ServedIn(usssalem, mediterranean).

[CONCLUSION]:
There is a museum ship open to the public that served in the Mediterranean.

[CONCLUSION (FOL)]:
∃x (MuseumShip(x) ∧ OpenToPublic(x) ∧ ServedIn(x, mediterranean))

[CONCLUSION (GK)]:
? [X] : (MuseumShip(X) & OpenToPublic(X) & ServedIn(X, mediterranean)).


===

['x']
['x']
[PREMISE]:
The USS Salem is a heavy cruiser built for the United States Navy.
The last heavy cruiser to enter service was the USS Salem.
The USS Salem is a museum ship.
Museum ships are open to the public.
The USS Salem served in the Atlantic and Mediterranean.

[PREMISE (FOL)]:
HeavyCruiser(usssalem) ∧ BuiltFor(usssalem, unitedstatesnavy)
LastHeavyCruiserToEnterService(usssalem)
MuseumShip(usssalem)
∀x (MuseumShip(x) → OpenToPublic(x))
ServedIn(usssalem, atlantic) ∧ ServedIn(usssalem, mediterranean)

[PREMISE (GK)]:
HeavyCruiser(usssalem) & BuiltFor(usssalem, unitedstatesnavy).
LastHeavyCruiserToEnterService(usssalem).
MuseumShip(usssalem).
! [X] : (MuseumShip(X) => OpenToPublic(X)).
ServedIn(usssalem, atlantic) & ServedIn(usssalem, mediterranean).

[CONCLUSION]:
The USS Salem was not the last heavy cruiser to enter service.

[CONCLUSION (FOL)]:
¬LastHeavyCruiserToEnterService(usssalem)

[CONCLUSION (GK)]:
-LastHeavyCruiserToEnterService(usssalem).


===

['x']
['x']
[PREMISE]:
TS Leda was a good passenger and cargo vessel.
TS Leda was a Norwegian vessel that was built with stabilizers.
Stabilizers are mechanical devices found only on ships with powerful steam turbine engines.
To be a good passenger and cargo vessel, ships must be quiet and good at sea.
Some ships that are quiet and good at sea have powerful steam turbine engines.
Vessels are ships.

[PREMISE (FOL)]:
∀x (TSLeda(x) → ((Passenger(x) ∧ Vessel(x)) ∧ (Cargo(x) ∧ Vessel(x)))
∀x (TSLeda(x) → (Norweigian(x) ∧ Vessel(x) ∧ Stabilizers(x)))
∀x (Stabilizers(x) → MechanicalDevice(x) ∧ OnlyOnShips(x) ∧ PowerfulSteamTurbine(x))
∀x ((Passenger(x) ∧ Vessel(x)) ∧ (Cargo(x) ∧ Vessel(x)) → (Quiet(x) ∧ GoodAt(x, sea)))
∃x (Quiet(x) ∧ GoodAt(x, sea) ∧ PowerfulSteamTurbine(x))
∀x (Ship(x) → Vessel(x))

[PREMISE (GK)]:
! [X] : (TSLeda(X) => ((Passenger(X) & Vessel(X)) & (Cargo(X) & Vessel(X))).
! [X] : (TSLeda(X) => (Norweigian(X) & Vessel(X) & Stabilizers(X))).
! [X] : (Stabilizers(X) => MechanicalDevice(X) & OnlyOnShips(X) & PowerfulSteamTurbine(X)).
! [X] : ((Passenger(X) & Vessel(X)) & (Cargo(X) & Vessel(X)) => (Quiet(X) & GoodAt(X, sea))).
? [X] : (Quiet(X) & GoodAt(X, sea) & PowerfulSteamTurbine(X)).
! [X] : (Ship(X) => Vessel(X)).

[CONCLUSION]:
TS Leda was quiet and good at sea.

[CONCLUSION (FOL)]:
∀x (TSLeda(x) → Quiet(x) ∧ GoodAt(x, sea))

[CONCLUSION (GK)]:
! [X] : (TSLeda(X) => Quiet(X) & GoodAt(X, sea)).


===

['x']
['x']
[PREMISE]:
TS Leda was a good passenger and cargo vessel.
TS Leda was a Norwegian vessel that was built with stabilizers.
Stabilizers are mechanical devices found only on ships with powerful steam turbine engines.
To be a good passenger and cargo vessel, ships must be quiet and good at sea.
Some ships that are quiet and good at sea have powerful steam turbine engines.
Vessels are ships.

[PREMISE (FOL)]:
∀x (TSLeda(x) → ((Passenger(x) ∧ Vessel(x)) ∧ (Cargo(x) ∧ Vessel(x)))
∀x (TSLeda(x) → (Norweigian(x) ∧ Vessel(x) ∧ Stabilizers(x)))
∀x (Stabilizers(x) → MechanicalDevice(x) ∧ OnlyOnShips(x) ∧ PowerfulSteamTurbine(x))
∀x ((Passenger(x) ∧ Vessel(x)) ∧ (Cargo(x) ∧ Vessel(x)) → (Quiet(x) ∧ GoodAt(x, sea)))
∃x (Quiet(x) ∧ GoodAt(x, sea) ∧ PowerfulSteamTurbine(x))
∀x (Ship(x) → Vessel(x))

[PREMISE (GK)]:
! [X] : (TSLeda(X) => ((Passenger(X) & Vessel(X)) & (Cargo(X) & Vessel(X))).
! [X] : (TSLeda(X) => (Norweigian(X) & Vessel(X) & Stabilizers(X))).
! [X] : (Stabilizers(X) => MechanicalDevice(X) & OnlyOnShips(X) & PowerfulSteamTurbine(X)).
! [X] : ((Passenger(X) & Vessel(X)) & (Cargo(X) & Vessel(X)) => (Quiet(X) & GoodAt(X, sea))).
? [X] : (Quiet(X) & GoodAt(X, sea) & PowerfulSteamTurbine(X)).
! [X] : (Ship(X) => Vessel(X)).

[CONCLUSION]:
TS Leda had powerful steam turbine engines.

[CONCLUSION (FOL)]:
∀x (TSLeda(x) → PowerfulSteamTurbine(x))

[CONCLUSION (GK)]:
! [X] : (TSLeda(X) => PowerfulSteamTurbine(X)).


===

['x']
['x']
[PREMISE]:
TS Leda was a good passenger and cargo vessel.
TS Leda was a Norwegian vessel that was built with stabilizers.
Stabilizers are mechanical devices found only on ships with powerful steam turbine engines.
To be a good passenger and cargo vessel, ships must be quiet and good at sea.
Some ships that are quiet and good at sea have powerful steam turbine engines.
Vessels are ships.

[PREMISE (FOL)]:
∀x (TSLeda(x) → ((Passenger(x) ∧ Vessel(x)) ∧ (Cargo(x) ∧ Vessel(x)))
∀x (TSLeda(x) → (Norweigian(x) ∧ Vessel(x) ∧ Stabilizers(x)))
∀x (Stabilizers(x) → MechanicalDevice(x) ∧ OnlyOnShips(x) ∧ PowerfulSteamTurbine(x))
∀x ((Passenger(x) ∧ Vessel(x)) ∧ (Cargo(x) ∧ Vessel(x)) → (Quiet(x) ∧ GoodAt(x, sea)))
∃x (Quiet(x) ∧ GoodAt(x, sea) ∧ PowerfulSteamTurbine(x))
∀x (Ship(x) → Vessel(x))

[PREMISE (GK)]:
! [X] : (TSLeda(X) => ((Passenger(X) & Vessel(X)) & (Cargo(X) & Vessel(X))).
! [X] : (TSLeda(X) => (Norweigian(X) & Vessel(X) & Stabilizers(X))).
! [X] : (Stabilizers(X) => MechanicalDevice(X) & OnlyOnShips(X) & PowerfulSteamTurbine(X)).
! [X] : ((Passenger(X) & Vessel(X)) & (Cargo(X) & Vessel(X)) => (Quiet(X) & GoodAt(X, sea))).
? [X] : (Quiet(X) & GoodAt(X, sea) & PowerfulSteamTurbine(X)).
! [X] : (Ship(X) => Vessel(X)).

[CONCLUSION]:
TS Leda was not a Norwegian vessel.

[CONCLUSION (FOL)]:
∀x (TSLeda(x) → ¬(Norweigian(x) ∧ Vessel(x)))

[CONCLUSION (GK)]:
! [X] : (TSLeda(X) => -(Norweigian(X) & Vessel(X))).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Rosa was born in Santiago. 
Santiago is the capital and largest city of Chile.
Rosa is the daughter of a Catalan building contractor, Jose.
Jose has a Chilean wife, Carmen.
Carmen and Jose are Rosa's parents.
People from Catalan are not from Chile.
A building contractor is responsible for the day-to-day oversight of a construction site. 

[PREMISE (FOL)]:
BornIn(rosa, santiago)
CapitalOf(santiago, chile) ∧ LargestCityOf(santiago, chile)
DaughterOf(rosa, jose) ∧ BuildingContractor(jose) ∧ Catalan(jose)
WifeOf(jose, carmen) ∧ Chilean(carmen)
ParentOf(jose, rosa) ∧ ParentOf(carmen, rosa)
∀x (Catalan(x) → ¬Chilean(x))
∀x ∃y (BuildingContractor(x) → ConstructionSite(y) ∧ Oversee(x, y))

[PREMISE (GK)]:
BornIn(rosa, santiago).
CapitalOf(santiago, chile) & LargestCityOf(santiago, chile).
DaughterOf(rosa, jose) & BuildingContractor(jose) & Catalan(jose).
WifeOf(jose, carmen) & Chilean(carmen).
ParentOf(jose, rosa) & ParentOf(carmen, rosa).
! [X] : (Catalan(X) => -Chilean(X)).
! [X] : ? [Y] : (BuildingContractor(X) => ConstructionSite(Y) & Oversee(X, Y)).

[CONCLUSION]:
Rosa was born in the largest city of Chile.

[CONCLUSION (FOL)]:
∃x (BornIn(rosa, x) ∧ LargestCityOf(x, chile))

[CONCLUSION (GK)]:
? [X] : (BornIn(rosa, X) & LargestCityOf(X, chile)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Rosa was born in Santiago. 
Santiago is the capital and largest city of Chile.
Rosa is the daughter of a Catalan building contractor, Jose.
Jose has a Chilean wife, Carmen.
Carmen and Jose are Rosa's parents.
People from Catalan are not from Chile.
A building contractor is responsible for the day-to-day oversight of a construction site. 

[PREMISE (FOL)]:
BornIn(rosa, santiago)
CapitalOf(santiago, chile) ∧ LargestCityOf(santiago, chile)
DaughterOf(rosa, jose) ∧ BuildingContractor(jose) ∧ Catalan(jose)
WifeOf(jose, carmen) ∧ Chilean(carmen)
ParentOf(jose, rosa) ∧ ParentOf(carmen, rosa)
∀x (Catalan(x) → ¬Chilean(x))
∀x ∃y (BuildingContractor(x) → ConstructionSite(y) ∧ Oversee(x, y))

[PREMISE (GK)]:
BornIn(rosa, santiago).
CapitalOf(santiago, chile) & LargestCityOf(santiago, chile).
DaughterOf(rosa, jose) & BuildingContractor(jose) & Catalan(jose).
WifeOf(jose, carmen) & Chilean(carmen).
ParentOf(jose, rosa) & ParentOf(carmen, rosa).
! [X] : (Catalan(X) => -Chilean(X)).
! [X] : ? [Y] : (BuildingContractor(X) => ConstructionSite(Y) & Oversee(X, Y)).

[CONCLUSION]:
Neither of Rosa's parents is Chilean.

[CONCLUSION (FOL)]:
¬Chilean(jose) ∧ ¬Chilean(carmen)

[CONCLUSION (GK)]:
-Chilean(jose) & -Chilean(carmen).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Rosa was born in Santiago. 
Santiago is the capital and largest city of Chile.
Rosa is the daughter of a Catalan building contractor, Jose.
Jose has a Chilean wife, Carmen.
Carmen and Jose are Rosa's parents.
People from Catalan are not from Chile.
A building contractor is responsible for the day-to-day oversight of a construction site. 

[PREMISE (FOL)]:
BornIn(rosa, santiago)
CapitalOf(santiago, chile) ∧ LargestCityOf(santiago, chile)
DaughterOf(rosa, jose) ∧ BuildingContractor(jose) ∧ Catalan(jose)
WifeOf(jose, carmen) ∧ Chilean(carmen)
ParentOf(jose, rosa) ∧ ParentOf(carmen, rosa)
∀x (Catalan(x) → ¬Chilean(x))
∀x ∃y (BuildingContractor(x) → ConstructionSite(y) ∧ Oversee(x, y))

[PREMISE (GK)]:
BornIn(rosa, santiago).
CapitalOf(santiago, chile) & LargestCityOf(santiago, chile).
DaughterOf(rosa, jose) & BuildingContractor(jose) & Catalan(jose).
WifeOf(jose, carmen) & Chilean(carmen).
ParentOf(jose, rosa) & ParentOf(carmen, rosa).
! [X] : (Catalan(X) => -Chilean(X)).
! [X] : ? [Y] : (BuildingContractor(X) => ConstructionSite(Y) & Oversee(X, Y)).

[CONCLUSION]:
Rosa is the daughter of someone who is responsible for the oversight of traffic.

[CONCLUSION (FOL)]:
∃x (DaughterOf(rosa, x) ∧ Oversee(x, traffic))

[CONCLUSION (GK)]:
? [X] : (DaughterOf(rosa, X) & Oversee(X, traffic)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Tyga is a rapper.
Rappers release rap albums.
Tyga released the Well Done 3 album.
Rappers are not opera singers.

[PREMISE (FOL)]:
IsRapper(tyga)
∀x ∀y ((IsRapper(x) ∧ ReleasedAlbum(x, y)) → IsRapAlbum(y))
ReleasedAlbum(tyga, wellDone3)
∀x (IsRapper(x) → ¬IsOperaSinger(x))

[PREMISE (GK)]:
IsRapper(tyga).
! [X] : ! [Y] : ((IsRapper(X) & ReleasedAlbum(X, Y)) => IsRapAlbum(Y)).
ReleasedAlbum(tyga, wellDone3).
! [X] : (IsRapper(X) => -IsOperaSinger(X)).

[CONCLUSION]:
Well Done 3 is a rap album.

[CONCLUSION (FOL)]:
IsRapAlbum(wellDone3)

[CONCLUSION (GK)]:
IsRapAlbum(wellDone3).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Tyga is a rapper.
Rappers release rap albums.
Tyga released the Well Done 3 album.
Rappers are not opera singers.

[PREMISE (FOL)]:
IsRapper(tyga)
∀x ∀y ((IsRapper(x) ∧ ReleasedAlbum(x, y)) → IsRapAlbum(y))
ReleasedAlbum(tyga, wellDone3)
∀x (IsRapper(x) → ¬IsOperaSinger(x))

[PREMISE (GK)]:
IsRapper(tyga).
! [X] : ! [Y] : ((IsRapper(X) & ReleasedAlbum(X, Y)) => IsRapAlbum(Y)).
ReleasedAlbum(tyga, wellDone3).
! [X] : (IsRapper(X) => -IsOperaSinger(X)).

[CONCLUSION]:
Tyga is an opera singer.

[CONCLUSION (FOL)]:
IsOperaSinger(tyga)

[CONCLUSION (GK)]:
IsOperaSinger(tyga).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Tyga is a rapper.
Rappers release rap albums.
Tyga released the Well Done 3 album.
Rappers are not opera singers.

[PREMISE (FOL)]:
IsRapper(tyga)
∀x ∀y ((IsRapper(x) ∧ ReleasedAlbum(x, y)) → IsRapAlbum(y))
ReleasedAlbum(tyga, wellDone3)
∀x (IsRapper(x) → ¬IsOperaSinger(x))

[PREMISE (GK)]:
IsRapper(tyga).
! [X] : ! [Y] : ((IsRapper(X) & ReleasedAlbum(X, Y)) => IsRapAlbum(Y)).
ReleasedAlbum(tyga, wellDone3).
! [X] : (IsRapper(X) => -IsOperaSinger(X)).

[CONCLUSION]:
Well Done 3 is worth listening to.

[CONCLUSION (FOL)]:
IsWorthListening(wellDone3)

[CONCLUSION (GK)]:
IsWorthListening(wellDone3).


===

[]
['x']
[PREMISE]:
Deborah Wallace is a Scottish-born actress, playwright, and producer.
Psyche is a play based on the life of James Miranda Barry.
Homesick, Psyche and The Void are plays by Deborah Wallace.
Deborah Wallace co-produced Gasland.

[PREMISE (FOL)]:
BornIn(deborahWallace, scotland) ∧ Actress(deborahWallace) ∧ Playwright(deborahWallace) ∧ Producer(deborahWallace)
Play(psyche) ∧ BasedOn(psyche, lifeOfJamesMirandaBarry)
Play(homesick) ∧ WrittenBy(homesick, deborahWallace) ∧ Play(psyche) ∧ WrittenBy(psyche, deborahWallace) ∧ Play(theVoid) ∧ WrittenBy(theVoid, deborahWallace)
CoProduce(deborahWallace, gasland)

[PREMISE (GK)]:
BornIn(deborahWallace, scotland) & Actress(deborahWallace) & Playwright(deborahWallace) & Producer(deborahWallace).
Play(psyche) & BasedOn(psyche, lifeOfJamesMirandaBarry).
Play(homesick) & WrittenBy(homesick, deborahWallace) & Play(psyche) & WrittenBy(psyche, deborahWallace) & Play(theVoid) & WrittenBy(theVoid, deborahWallace).
CoProduce(deborahWallace, gasland).

[CONCLUSION]:
Gasland was coproduced by the same person Homesick was from.

[CONCLUSION (FOL)]:
∃x (CoProduces(x, gasland) ∧ WrittenBy(homesick, x))

[CONCLUSION (GK)]:
? [X] : (CoProduces(X, gasland) & WrittenBy(homesick, X)).


===

[]
['x']
[PREMISE]:
Deborah Wallace is a Scottish-born actress, playwright, and producer.
Psyche is a play based on the life of James Miranda Barry.
Homesick, Psyche and The Void are plays by Deborah Wallace.
Deborah Wallace co-produced Gasland.

[PREMISE (FOL)]:
BornIn(deborahWallace, scotland) ∧ Actress(deborahWallace) ∧ Playwright(deborahWallace) ∧ Producer(deborahWallace)
Play(psyche) ∧ BasedOn(psyche, lifeOfJamesMirandaBarry)
Play(homesick) ∧ WrittenBy(homesick, deborahWallace) ∧ Play(psyche) ∧ WrittenBy(psyche, deborahWallace) ∧ Play(theVoid) ∧ WrittenBy(theVoid, deborahWallace)
CoProduce(deborahWallace, gasland)

[PREMISE (GK)]:
BornIn(deborahWallace, scotland) & Actress(deborahWallace) & Playwright(deborahWallace) & Producer(deborahWallace).
Play(psyche) & BasedOn(psyche, lifeOfJamesMirandaBarry).
Play(homesick) & WrittenBy(homesick, deborahWallace) & Play(psyche) & WrittenBy(psyche, deborahWallace) & Play(theVoid) & WrittenBy(theVoid, deborahWallace).
CoProduce(deborahWallace, gasland).

[CONCLUSION]:
No plays by Deborah Wallace are based on the life of James Miranda Barry.

[CONCLUSION (FOL)]:
∀x (Play(x) ∧ WrittenBy(x, deborahwallace) → ¬BasedOn(x, lifeofjamesmirandabarry))

[CONCLUSION (GK)]:
! [X] : (Play(X) & WrittenBy(X, deborahwallace) => -BasedOn(X, lifeofjamesmirandabarry)).


===

[]
[]
[PREMISE]:
Deborah Wallace is a Scottish-born actress, playwright, and producer.
Psyche is a play based on the life of James Miranda Barry.
Homesick, Psyche and The Void are plays by Deborah Wallace.
Deborah Wallace co-produced Gasland.

[PREMISE (FOL)]:
BornIn(deborahWallace, scotland) ∧ Actress(deborahWallace) ∧ Playwright(deborahWallace) ∧ Producer(deborahWallace)
Play(psyche) ∧ BasedOn(psyche, lifeOfJamesMirandaBarry)
Play(homesick) ∧ WrittenBy(homesick, deborahWallace) ∧ Play(psyche) ∧ WrittenBy(psyche, deborahWallace) ∧ Play(theVoid) ∧ WrittenBy(theVoid, deborahWallace)
CoProduce(deborahWallace, gasland)

[PREMISE (GK)]:
BornIn(deborahWallace, scotland) & Actress(deborahWallace) & Playwright(deborahWallace) & Producer(deborahWallace).
Play(psyche) & BasedOn(psyche, lifeOfJamesMirandaBarry).
Play(homesick) & WrittenBy(homesick, deborahWallace) & Play(psyche) & WrittenBy(psyche, deborahWallace) & Play(theVoid) & WrittenBy(theVoid, deborahWallace).
CoProduce(deborahWallace, gasland).

[CONCLUSION]:
Gasland is a play.

[CONCLUSION (FOL)]:
Play(gasland)

[CONCLUSION (GK)]:
Play(gasland).


===

['x']
['x']
[PREMISE]:
Animals who need large territory travel far.
Every animal that eats a lot needs a large territory.
If something is a big animal, then it will eat a lot.
Bears are big animals.
Larry is a big animal.

[PREMISE (FOL)]:
∀x (Animal(x) ∧ Need(x, largeTerritory) → TravelFar(x))
∀x (EatALot(x) → Need(x, largeTerritory))
∀x (Big(x) ∧ Animal(x) → EatALot(x))
∀x (Bear(x) → Big(x) ∧ Animal(x))
Big(larry) ∧ Animal(larry)

[PREMISE (GK)]:
! [X] : (Animal(X) & Need(X, largeTerritory) => TravelFar(X)).
! [X] : (EatALot(X) => Need(X, largeTerritory)).
! [X] : (Big(X) & Animal(X) => EatALot(X)).
! [X] : (Bear(X) => Big(X) & Animal(X)).
Big(larry) & Animal(larry).

[CONCLUSION]:
Larry is a bear.

[CONCLUSION (FOL)]:
Bear(larry)

[CONCLUSION (GK)]:
Bear(larry).


===

['x']
['x']
[PREMISE]:
Animals who need large territory travel far.
Every animal that eats a lot needs a large territory.
If something is a big animal, then it will eat a lot.
Bears are big animals.
Larry is a big animal.

[PREMISE (FOL)]:
∀x (Animal(x) ∧ Need(x, largeTerritory) → TravelFar(x))
∀x (EatALot(x) → Need(x, largeTerritory))
∀x (Big(x) ∧ Animal(x) → EatALot(x))
∀x (Bear(x) → Big(x) ∧ Animal(x))
Big(larry) ∧ Animal(larry)

[PREMISE (GK)]:
! [X] : (Animal(X) & Need(X, largeTerritory) => TravelFar(X)).
! [X] : (EatALot(X) => Need(X, largeTerritory)).
! [X] : (Big(X) & Animal(X) => EatALot(X)).
! [X] : (Bear(X) => Big(X) & Animal(X)).
Big(larry) & Animal(larry).

[CONCLUSION]:
Larry is not a bear and does not travel far.

[CONCLUSION (FOL)]:
¬Bear(larry) ∧ ¬TravelFar(larry)

[CONCLUSION (GK)]:
-Bear(larry) & -TravelFar(larry).


===

['x']
['x']
[PREMISE]:
Animals who need large territory travel far.
Every animal that eats a lot needs a large territory.
If something is a big animal, then it will eat a lot.
Bears are big animals.
Larry is a big animal.

[PREMISE (FOL)]:
∀x (Animal(x) ∧ Need(x, largeTerritory) → TravelFar(x))
∀x (EatALot(x) → Need(x, largeTerritory))
∀x (Big(x) ∧ Animal(x) → EatALot(x))
∀x (Bear(x) → Big(x) ∧ Animal(x))
Big(larry) ∧ Animal(larry)

[PREMISE (GK)]:
! [X] : (Animal(X) & Need(X, largeTerritory) => TravelFar(X)).
! [X] : (EatALot(X) => Need(X, largeTerritory)).
! [X] : (Big(X) & Animal(X) => EatALot(X)).
! [X] : (Bear(X) => Big(X) & Animal(X)).
Big(larry) & Animal(larry).

[CONCLUSION]:
If Larry either travels far or needs a large territory, then Larry is a bear.

[CONCLUSION (FOL)]:
TravelFar(larry) ⊕ Need(larry, largeTerritory) → Bear(larry)

[CONCLUSION (GK)]:
TravelFar(larry) <~> Need(larry, largeTerritory) => Bear(larry).


===

['x']
['x']
[PREMISE]:
Any convicted criminal that is innocent is not truly guilty.
All convicted criminals who did not commit a crime are truly innocent.
All convicted criminals are truly guilty or found guilty.
If a convicted criminal is found guilty, then they are sentenced to a punishment.
If a convicted criminal is found guilty, then they can argue against their punishment.
Garry is a convicted criminal who not found guilty or is sentenced to punishment.

[PREMISE (FOL)]:
∀x (ConvictedCriminal(x) ∧ Innocent(x) → ¬TrulyGuilty(x))
∀x (ConvictedCriminal(x) ∧ ¬CommitCrime(x) → Innocent(x))
∀x (ConvictedCriminal(x) ∧ (TrulyGuilty(x) ∨ FoundGuilty(x)))
∀x (ConvictedCriminal(x) ∧ FoundGuilty(x) → SentencedToPunishment(x))
∀x (ConvictedCriminal(x) ∧ FoundGuilty(x) → CanArgueAgainst(x, punishment))
ConvictedCriminal(garry) ∧ (¬(FoundGuilty(garry) ∨ SentencedToPunishment(garry)))

[PREMISE (GK)]:
! [X] : (ConvictedCriminal(X) & Innocent(X) => -TrulyGuilty(X)).
! [X] : (ConvictedCriminal(X) & -CommitCrime(X) => Innocent(X)).
! [X] : (ConvictedCriminal(X) & (TrulyGuilty(X) | FoundGuilty(X))).
! [X] : (ConvictedCriminal(X) & FoundGuilty(X) => SentencedToPunishment(X)).
! [X] : (ConvictedCriminal(X) & FoundGuilty(X) => CanArgueAgainst(X, punishment)).
ConvictedCriminal(garry) & (-(FoundGuilty(garry) | SentencedToPunishment(garry))).

[CONCLUSION]:
Garry is sentenced to a punishment.

[CONCLUSION (FOL)]:
SentencedToPunishment(garry)

[CONCLUSION (GK)]:
SentencedToPunishment(garry).


===

['x']
['x']
[PREMISE]:
Any convicted criminal that is innocent is not truly guilty.
All convicted criminals who did not commit a crime are truly innocent.
All convicted criminals are truly guilty or found guilty.
If a convicted criminal is found guilty, then they are sentenced to a punishment.
If a convicted criminal is found guilty, then they can argue against their punishment.
Garry is a convicted criminal who not found guilty or is sentenced to punishment.

[PREMISE (FOL)]:
∀x (ConvictedCriminal(x) ∧ Innocent(x) → ¬TrulyGuilty(x))
∀x (ConvictedCriminal(x) ∧ ¬CommitCrime(x) → Innocent(x))
∀x (ConvictedCriminal(x) ∧ (TrulyGuilty(x) ∨ FoundGuilty(x)))
∀x (ConvictedCriminal(x) ∧ FoundGuilty(x) → SentencedToPunishment(x))
∀x (ConvictedCriminal(x) ∧ FoundGuilty(x) → CanArgueAgainst(x, punishment))
ConvictedCriminal(garry) ∧ (¬(FoundGuilty(garry) ∨ SentencedToPunishment(garry)))

[PREMISE (GK)]:
! [X] : (ConvictedCriminal(X) & Innocent(X) => -TrulyGuilty(X)).
! [X] : (ConvictedCriminal(X) & -CommitCrime(X) => Innocent(X)).
! [X] : (ConvictedCriminal(X) & (TrulyGuilty(X) | FoundGuilty(X))).
! [X] : (ConvictedCriminal(X) & FoundGuilty(X) => SentencedToPunishment(X)).
! [X] : (ConvictedCriminal(X) & FoundGuilty(X) => CanArgueAgainst(X, punishment)).
ConvictedCriminal(garry) & (-(FoundGuilty(garry) | SentencedToPunishment(garry))).

[CONCLUSION]:
Garry did not commit a crime and can argue against his punishment.

[CONCLUSION (FOL)]:
¬CommitCrime(garry) ∧ CanArgueAgainst(garry, punishment)

[CONCLUSION (GK)]:
-CommitCrime(garry) & CanArgueAgainst(garry, punishment).


===

['x']
['x']
[PREMISE]:
Any convicted criminal that is innocent is not truly guilty.
All convicted criminals who did not commit a crime are truly innocent.
All convicted criminals are truly guilty or found guilty.
If a convicted criminal is found guilty, then they are sentenced to a punishment.
If a convicted criminal is found guilty, then they can argue against their punishment.
Garry is a convicted criminal who not found guilty or is sentenced to punishment.

[PREMISE (FOL)]:
∀x (ConvictedCriminal(x) ∧ Innocent(x) → ¬TrulyGuilty(x))
∀x (ConvictedCriminal(x) ∧ ¬CommitCrime(x) → Innocent(x))
∀x (ConvictedCriminal(x) ∧ (TrulyGuilty(x) ∨ FoundGuilty(x)))
∀x (ConvictedCriminal(x) ∧ FoundGuilty(x) → SentencedToPunishment(x))
∀x (ConvictedCriminal(x) ∧ FoundGuilty(x) → CanArgueAgainst(x, punishment))
ConvictedCriminal(garry) ∧ (¬(FoundGuilty(garry) ∨ SentencedToPunishment(garry)))

[PREMISE (GK)]:
! [X] : (ConvictedCriminal(X) & Innocent(X) => -TrulyGuilty(X)).
! [X] : (ConvictedCriminal(X) & -CommitCrime(X) => Innocent(X)).
! [X] : (ConvictedCriminal(X) & (TrulyGuilty(X) | FoundGuilty(X))).
! [X] : (ConvictedCriminal(X) & FoundGuilty(X) => SentencedToPunishment(X)).
! [X] : (ConvictedCriminal(X) & FoundGuilty(X) => CanArgueAgainst(X, punishment)).
ConvictedCriminal(garry) & (-(FoundGuilty(garry) | SentencedToPunishment(garry))).

[CONCLUSION]:
Garry is not both innocent and someone who did not commit a crime.

[CONCLUSION (FOL)]:
¬(Innocent(garry) ∧ ¬CommitCrime(garry))

[CONCLUSION (GK)]:
-(Innocent(garry) & -CommitCrime(garry)).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Phoneix's music is classified under the indie pop genre.
Phoenix is a band from France.
French bands write songs in French or in English.
Aside from indie pop, pop rock and synth-pop are two other genres of music.
Phoenix has no songs in French.

[PREMISE (FOL)]:
IndiePop(phoenix)
Band(phoenix) ∧ From(phoenix, france)
∀x ∃y (Band(x) ∧ From(x, france) ∧ Write(x, y) ∧ Song(y) → InFrench(y) ⊕ InEnglish(y))
∀x (IndiePop(x) → ¬PopRock(x) ∧ ¬SynthPop(x))
∀x (Song(x) ∧ By(phoenix, x) → ¬InFrench(x))

[PREMISE (GK)]:
IndiePop(phoenix).
Band(phoenix) & From(phoenix, france).
! [X] : ? [Y] : (Band(X) & From(X, france) & Write(X, Y) & Song(Y) => InFrench(Y) <~> InEnglish(Y)).
! [X] : (IndiePop(X) => -PopRock(X) & -SynthPop(X)).
! [X] : (Song(X) & By(phoenix, X) => -InFrench(X)).

[CONCLUSION]:
Phoneix's music is classified under the pop rock genre.

[CONCLUSION (FOL)]:
PopRock(phoenix)

[CONCLUSION (GK)]:
PopRock(phoenix).


===

['x', 'y']
['x', 'y']
[PREMISE]:
Phoneix's music is classified under the indie pop genre.
Phoenix is a band from France.
French bands write songs in French or in English.
Aside from indie pop, pop rock and synth-pop are two other genres of music.
Phoenix has no songs in French.

[PREMISE (FOL)]:
IndiePop(phoenix)
Band(phoenix) ∧ From(phoenix, france)
∀x ∃y (Band(x) ∧ From(x, france) ∧ Write(x, y) ∧ Song(y) → InFrench(y) ⊕ InEnglish(y))
∀x (IndiePop(x) → ¬PopRock(x) ∧ ¬SynthPop(x))
∀x (Song(x) ∧ By(phoenix, x) → ¬InFrench(x))

[PREMISE (GK)]:
IndiePop(phoenix).
Band(phoenix) & From(phoenix, france).
! [X] : ? [Y] : (Band(X) & From(X, france) & Write(X, Y) & Song(Y) => InFrench(Y) <~> InEnglish(Y)).
! [X] : (IndiePop(X) => -PopRock(X) & -SynthPop(X)).
! [X] : (Song(X) & By(phoenix, X) => -InFrench(X)).

[CONCLUSION]:
Phoenix writes songs in French.

[CONCLUSION (FOL)]:
∃x (Write(phoenix, y) ∧ Song(x) → InFrench(x))

[CONCLUSION (GK)]:
? [X] : (Write(phoenix, Y) & Song(X) => InFrench(X)).


===

